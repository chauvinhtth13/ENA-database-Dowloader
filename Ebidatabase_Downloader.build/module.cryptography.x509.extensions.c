/* Generated code for Python source for module 'cryptography.x509.extensions'
 * created by Nuitka version 0.5.30
 *
 * This code is in part copyright 2018 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The _module_cryptography$x509$extensions is a Python object pointer of module type. */

/* Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_cryptography$x509$extensions;
PyDictObject *moduledict_cryptography$x509$extensions;

/* The module constants used, if any. */
static PyObject *const_str_plain__crl_issuer;
extern PyObject *const_str_plain_TLS_FEATURE;
static PyObject *const_str_plain__decipher_only;
extern PyObject *const_str_plain_data;
static PyObject *const_tuple_30cc927ede2fc9470dffcd81c25765bb_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_other_tuple;
extern PyObject *const_str_plain_SEQUENCE;
static PyObject *const_tuple_str_plain__policies_tuple;
extern PyObject *const_str_plain_get_values_for_type;
static PyObject *const_str_plain__indirect_crl;
extern PyObject *const_str_plain_CRLReason;
extern PyObject *const_str_digest_b9c4baf879ebd882d40843df3a4dead7;
static PyObject *const_str_digest_096877126149ba9ef6483d7f63c2f65e;
extern PyObject *const_str_plain_warn;
extern PyObject *const_str_plain_IPv6Network;
extern PyObject *const_str_plain_digital_signature;
extern PyObject *const_str_plain_KEY_USAGE;
static PyObject *const_tuple_str_plain_EllipticCurvePublicKey_tuple;
static PyObject *const_str_digest_e29a6013213dd6497cd7c55bc7864351;
static PyObject *const_str_digest_76d9dc3b971abafb272069e298f2eb0c;
extern PyObject *const_str_plain_UncompressedPoint;
static PyObject *const_tuple_828872b32a88e627e2f72e22e0a4680e_tuple;
static PyObject *const_str_plain__organization;
static PyObject *const_str_digest_a173082fd91f8794530005b1589bf6b2;
static PyObject *const_tuple_str_plain__notice_reference_tuple;
static PyObject *const_tuple_str_plain__key_encipherment_tuple;
extern PyObject *const_str_plain_warnings;
extern PyObject *const_str_plain_reason;
static PyObject *const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple;
extern PyObject *const_str_plain_read_only_property;
extern PyObject *const_str_plain___exit__;
extern PyObject *const_str_plain_ExtensionOID;
static PyObject *const_str_digest_a0744842c59ec0ec1342dee683ec7ac8;
extern PyObject *const_str_plain_text_type;
static PyObject *const_str_plain__access_location;
extern PyObject *const_str_plain_ca_compromise;
static PyObject *const_str_digest_91034dde8ef1b9b2896e23f094ab68ec;
extern PyObject *const_str_plain_abstractproperty;
extern PyObject *const_str_plain__extensions;
extern PyObject *const_str_digest_9db3cdd3cd765463b4eec6754eb8e087;
extern PyObject *const_str_plain_IssuerAlternativeName;
static PyObject *const_str_plain__only_contains_ca_certs;
extern PyObject *const_str_digest_97cd6fd5c8579a7068d86fbfd40e2f84;
static PyObject *const_str_digest_548641877ac6c51da15a8285d67846ee;
static PyObject *const_tuple_571ef8230a0f951e7e814a3a1b007a73_tuple;
extern PyObject *const_str_plain_x;
static PyObject *const_str_digest_e796fffc6f5e8d4c3d564875b854a9ed;
extern PyObject *const_str_plain_AccessDescription;
extern PyObject *const_str_plain_NoticeReference;
extern PyObject *const_str_plain_SubjectPublicKeyInfo;
extern PyObject *const_str_plain_relative_name;
extern PyObject *const_str_digest_d8b4cb10b00d6765b713cf768245d18d;
static PyObject *const_tuple_str_plain_self_str_plain_ca_str_plain_path_length_tuple;
extern PyObject *const_str_plain_IPAddress;
extern PyObject *const_str_plain_require_explicit_policy;
extern PyObject *const_str_plain_cls;
static PyObject *const_str_plain__key_encipherment;
extern PyObject *const_str_plain_UnrecognizedExtension;
extern PyObject *const_str_plain_remove_from_crl;
extern PyObject *const_str_plain_SUBJECT_ALTERNATIVE_NAME;
extern PyObject *const_str_plain_CRL_REASON;
extern PyObject *const_str_plain_SignedCertificateTimestamp;
extern PyObject *const_str_plain_RelativeDistinguishedName;
static PyObject *const_str_plain_serialized;
static PyObject *const_tuple_str_plain__extensions_tuple;
extern PyObject *const_str_plain_sha1;
extern PyObject *const_str_plain_OtherName;
extern PyObject *const_str_plain__nonce;
extern PyObject *const_str_plain___init__;
extern PyObject *const_str_plain_CRLEntryExtensionOID;
extern PyObject *const_str_plain_permitted_subtrees;
static PyObject *const_str_digest_aedab8e33f4a55e03d8255716673252f;
static PyObject *const_str_plain__only_contains_attribute_certs;
extern PyObject *const_str_plain_policy_identifier;
static PyObject *const_str_digest_de1714430c844d988a0d091fac0a73d4;
static PyObject *const_str_digest_f7714799e19abc5d09ccbaf8366649ea;
extern PyObject *const_str_plain_extensions;
extern PyObject *const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple;
extern PyObject *const_str_plain_is_empty;
static PyObject *const_str_digest_28228272e91a15a54ff010026fcf7af8;
static PyObject *const_str_digest_ba0ace4d3ab5fb435146fa7a7a8c5e76;
static PyObject *const_str_plain__data_encipherment;
extern PyObject *const_str_plain_crl_sign;
static PyObject *const_tuple_a73b8498e05ac6f54cfbc844a1aafead_tuple;
static PyObject *const_tuple_2a50e9eb562974724a6432490d012463_tuple;
static PyObject *const_tuple_str_plain__organization_tuple;
static PyObject *const_unicode_digest_91632884773c30442b9e2ac13e53950d;
static PyObject *const_tuple_str_plain__key_identifier_tuple;
extern PyObject *const_str_plain_content_commitment;
extern PyObject *const_str_plain_BIT_STRING;
extern PyObject *const_str_digest_0dcb6991fe0fe1dc113b1f3e65627e35;
extern PyObject *const_str_plain_crl_issuer;
extern PyObject *const_str_plain_ExtensionNotFound;
extern PyObject *const_str_plain_general_names;
extern PyObject *const_str_plain_DeltaCRLIndicator;
extern PyObject *const_str_plain_TLSFeature;
extern PyObject *const_str_plain_ski;
extern PyObject *const_str_plain_excluded_subtrees;
static PyObject *const_str_plain_policies;
extern PyObject *const_str_plain_key_identifier;
extern PyObject *const_str_plain_nonce;
static PyObject *const_str_digest_0c5b9c1eebf18567ca6eef13eba8418b;
static PyObject *const_tuple_str_plain_self_str_plain_distribution_points_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_field_name_tuple;
extern PyObject *const_str_plain_register_interface;
extern PyObject *const_str_plain_integer_types;
static PyObject *const_tuple_str_plain_RelativeDistinguishedName_tuple;
static PyObject *const_str_plain_aci;
static PyObject *const_tuple_str_plain_self_str_plain_aci_tuple;
extern PyObject *const_str_plain_AUTHORITY_INFORMATION_ACCESS;
extern PyObject *const_str_plain_GeneralNames;
extern PyObject *const_str_plain_cessation_of_operation;
extern PyObject *const_str_plain_PrecertPoison;
extern PyObject *const_str_plain_privilege_withdrawn;
extern PyObject *const_str_plain_indirect_crl;
static PyObject *const_str_plain_aACompromise;
static PyObject *const_str_plain_len_method;
static PyObject *const_tuple_str_plain_self_str_plain_invalidity_date_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_crl_issuer_str_plain_fn_tuple;
extern PyObject *const_str_plain_CERTIFICATE_POLICIES;
static PyObject *const_str_plain__policies;
extern PyObject *const_str_plain_INVALIDITY_DATE;
static PyObject *const_str_plain_from_public_key;
extern PyObject *const_str_plain_ISSUING_DISTRIBUTION_POINT;
extern PyObject *const_str_plain_DeprecatedIn27;
extern PyObject *const_str_plain_tree;
extern PyObject *const_str_digest_b311fd8ca9b218772fd89e927df64198;
static PyObject *const_tuple_str_plain__crl_number_tuple;
extern PyObject *const_str_plain_UserNotice;
static PyObject *const_str_plain__path_length;
static PyObject *const_tuple_str_plain_self_str_plain_oid_str_plain_value_tuple;
static PyObject *const_tuple_str_plain__key_cert_sign_tuple;
static PyObject *const_tuple_40c66ae610f06e095b8a28b392d109cb_tuple;
static PyObject *const_str_plain__critical;
extern PyObject *const_str_plain__TLS_FEATURE_TYPE_TO_ENUM;
static PyObject *const_tuple_str_plain__crl_issuer_tuple;
static PyObject *const_str_plain__policy_identifier;
static PyObject *const_tuple_str_plain__general_names_tuple;
static PyObject *const_str_digest_350fb76bfa2c81c3db35fe4ad0c5cc28;
static PyObject *const_str_digest_d3e161c72eca6237cebf732e747f2482;
static PyObject *const_tuple_str_plain_cls_str_plain_public_key_str_plain_digest_tuple;
extern PyObject *const_str_plain_policy_qualifiers;
extern PyObject *const_str_plain_ObjectIdentifier;
extern PyObject *const_str_plain_Encoding;
extern PyObject *const_str_plain_notice_numbers;
extern PyObject *const_str_plain_authority_cert_issuer;
static PyObject *const_str_digest_a4add4111fbe02d06da1613741f3d5ca;
extern PyObject *const_str_plain_NAME_CONSTRAINTS;
extern PyObject *const_str_plain_OCSPNoCheck;
static PyObject *const_str_plain__permitted_subtrees;
static PyObject *const_str_plain__key_cert_sign;
static PyObject *const_str_digest_98ddab5a38618a53af9688f12b4a5b05;
static PyObject *const_str_plain_removeFromCRL;
static PyObject *const_str_digest_3a0a1109b8c268ad95ea7f220c74ef61;
static PyObject *const_str_digest_1695020c9fca9629cae2bba3b13ed98d;
extern PyObject *const_str_plain_read_any_element;
static PyObject *const_tuple_str_plain_self_str_plain_ps_str_plain_es_tuple;
extern PyObject *const_str_plain_Enum;
extern PyObject *const_tuple_str_plain__value_tuple;
extern PyObject *const_tuple_str_plain_Enum_tuple;
static PyObject *const_str_digest_5576b3ba482b3c884e20c0f0f9889daf;
static PyObject *const_tuple_str_plain_self_str_plain_descriptions_tuple;
extern PyObject *const_str_plain___iter__;
static PyObject *const_str_plain__relative_name;
static PyObject *const_str_digest_bed5ff04fb0d04ecd22172c330a8e05a;
static PyObject *const_str_digest_171541ce3e17f273a42b3961194a7b72;
extern PyObject *const_tuple_str_plain_utils_tuple;
static PyObject *const_str_digest_acc45e336b0d5f3376f4867fb94a18e6;
static PyObject *const_str_digest_52903da339eb426b3d703a3f30ce3e10;
extern PyObject *const_str_plain__digest;
static PyObject *const_str_digest_f37468dd5629ccacfbc304506e5ed113;
static PyObject *const_str_digest_92ebfd7d825e182438411c24725c884a;
extern PyObject *const_str_plain_datetime;
extern PyObject *const_str_plain_digest;
static PyObject *const_str_digest_d0cacbb4febc1bdb60a26b048c7bb9b6;
extern PyObject *const_str_plain___file__;
static PyObject *const_str_digest_dbdc4cc574491d1286f5938d4480dec8;
static PyObject *const_tuple_str_plain__only_contains_attribute_certs_tuple;
extern PyObject *const_str_plain_path_length;
extern PyObject *const_str_plain_hashlib;
static PyObject *const_str_digest_908210834a8fb4c8eaca7a64e23a4bed;
static PyObject *const_tuple_str_plain__only_contains_ca_certs_tuple;
extern PyObject *const_str_plain___getitem__;
static PyObject *const_str_digest_ccd052a57d9b2466ec6174083baebf1e;
extern PyObject *const_str_plain___metaclass__;
extern PyObject *const_str_plain_skip_certs;
static PyObject *const_tuple_str_plain_cls_str_plain_public_key_tuple;
static PyObject *const_tuple_str_plain__relative_name_tuple;
static PyObject *const_tuple_b58c59c90f8b7ff71dbfd006f561c9fe_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_reason_tuple;
extern PyObject *const_str_plain_OBJECT_IDENTIFIER;
extern PyObject *const_str_plain_CRL_DISTRIBUTION_POINTS;
static PyObject *const_str_digest_f63518e696f94cef547d30428c9b8408;
static PyObject *const_tuple_str_plain__policy_qualifiers_tuple;
extern PyObject *const_str_plain_EXTENDED_KEY_USAGE;
extern PyObject *const_str_plain_PolicyInformation;
static PyObject *const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple;
extern PyObject *const_str_plain_read_byte;
extern PyObject *const_str_plain_InhibitAnyPolicy;
static PyObject *const_str_plain__require_explicit_policy;
static PyObject *const_str_digest_d04c4a4e63138db9ecc900ec9847717c;
extern PyObject *const_str_plain_CRL_NUMBER;
static PyObject *const_tuple_str_plain_self_str_plain_crl_number_tuple;
static PyObject *const_str_digest_da5560b5b28f3c84a1c556751340bb55;
static PyObject *const_str_digest_2fedee8d2e8553cc3a2acd1bc300acd1;
static PyObject *const_str_digest_f7d33cb69a7dc22294881ff5b1fe0ec9;
extern PyObject *const_str_plain_all;
static PyObject *const_str_digest_2615a61b30c6d1612864004a5b3409b1;
extern PyObject *const_str_plain_name;
static PyObject *const_tuple_str_plain__authority_cert_issuer_tuple;
extern PyObject *const_str_plain_authority_cert_serial_number;
static PyObject *const_tuple_str_plain__notice_numbers_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_features_tuple;
static PyObject *const_str_digest_11b049dd960f5e8f8d4550cdd9caf427;
static PyObject *const_str_digest_4896564d0ed5e6b06237436d00bf3cad;
static PyObject *const_str_digest_7689dc38f9edab5e0154168296ac4aa7;
extern PyObject *const_str_plain_sct;
extern PyObject *const_str_plain_msg;
static PyObject *const_str_plain_getitem_method;
extern PyObject *const_str_plain_CRLNumber;
extern PyObject *const_str_plain_DistributionPoint;
static PyObject *const_tuple_str_plain_self_str_plain_general_names_tuple;
static PyObject *const_str_plain_status_request_v2;
extern PyObject *const_str_plain_invalidity_date;
static PyObject *const_str_digest_f68da15c98dbc7b7660e8e5bee0179e6;
static PyObject *const_tuple_str_plain__distribution_points_tuple;
static PyObject *const_str_digest_ad140184cf2507dc997c5c6a9d0f3e94;
static PyObject *const_str_digest_a2ae3825a8b7f0237bc2c108542b8be9;
static PyObject *const_str_plain_signed_certificate_timestamps;
static PyObject *const_str_digest_114372ae17a491041cc1a4b677269f5b;
static PyObject *const_tuple_55f45cc1ebe66c7c9c0566ce5a780f3f_tuple;
static PyObject *const_str_digest_e7bc751982d7cd4fe2e9c78dbf3e6347;
static PyObject *const_str_plain__general_names;
extern PyObject *const_str_plain_ca;
static PyObject *const_str_plain_usages;
extern PyObject *const_str_plain_FRESHEST_CRL;
static PyObject *const_str_plain_crl_constraints;
static PyObject *const_tuple_str_plain_self_str_plain_policies_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_tree_tuple;
static PyObject *const_tuple_str_plain__key_agreement_tuple;
static PyObject *const_str_digest_2622a0002f5b5df69415ebf4bce9a343;
static PyObject *const_tuple_str_plain_self_str_plain_skip_certs_tuple;
extern PyObject *const_str_plain_AuthorityInformationAccess;
static PyObject *const_str_digest_73d50e8900e7f2ac40a53b664096aa15;
static PyObject *const_str_digest_9cc2c8377ce78bc1b198ac0906717d7f;
extern PyObject *const_str_plain_crl_number;
extern PyObject *const_str_plain_full_name;
extern PyObject *const_str_plain_InvalidityDate;
static PyObject *const_tuple_str_plain_SignedCertificateTimestamp_tuple;
static PyObject *const_str_plain__encipher_only;
extern PyObject *const_str_plain_SubjectKeyIdentifier;
extern PyObject *const_tuple_none_none_none_tuple;
static PyObject *const_str_digest_881d5fa81af108f32d6b1d8d2d35a638;
extern PyObject *const_str_plain_division;
extern PyObject *const_str_plain_only_contains_user_certs;
static PyObject *const_tuple_str_plain__explicit_text_tuple;
static PyObject *const_str_digest_c3da50fdd18d409ebf6fe1322cd35c5d;
extern PyObject *const_str_plain_public_bytes;
extern PyObject *const_str_plain_only_contains_ca_certs;
extern PyObject *const_str_plain_stacklevel;
static PyObject *const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_sct_tuple;
static PyObject *const_tuple_str_plain__skip_certs_tuple;
static PyObject *const_tuple_str_plain__descriptions_tuple;
extern PyObject *const_str_plain_IPv4Network;
static PyObject *const_tuple_str_plain__features_tuple;
static PyObject *const_tuple_str_plain__digital_signature_tuple;
static PyObject *const_tuple_str_plain__signed_certificate_timestamps_tuple;
extern PyObject *const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
static PyObject *const_str_digest_d2a030963ea7fa46a452128daffceb24;
extern PyObject *const_str_plain__value;
static PyObject *const_str_digest_ac8667798ba70bb109d3e3236473ab02;
extern PyObject *const_tuple_type_object_tuple;
static PyObject *const_tuple_str_plain__ca_tuple;
static PyObject *const_str_digest_2a0138f3ee2cd707fb386e46f1612821;
extern PyObject *const_str_plain_FreshestCRL;
extern PyObject *const_str_plain_type;
static PyObject *const_str_plain__notice_numbers;
static PyObject *const_tuple_str_plain__excluded_subtrees_tuple;
extern PyObject *const_str_plain_reader;
static PyObject *const_str_plain__key_agreement;
static PyObject *const_str_digest_c6c3dada1f7f971d20a3492ccb208681;
extern PyObject *const_str_plain_constant_time;
static PyObject *const_str_plain__reasons;
static PyObject *const_str_digest_35185795abbb3b5bbc0cab5aa03aab83;
static PyObject *const_str_digest_b436a97f38724e3583df19a1d449e278;
static PyObject *const_str_digest_d9e548ca3e36faa8011f3a82a40a2310;
extern PyObject *const_str_plain_ExtendedKeyUsage;
static PyObject *const_str_digest_fdf88dfad66dd7b1bb721469f9f06736;
static PyObject *const_tuple_str_plain__require_explicit_policy_tuple;
static PyObject *const_tuple_str_plain__inhibit_policy_mapping_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_nonce_tuple;
static PyObject *const_str_plain__validate_ip_name;
extern PyObject *const_str_plain___ne__;
static PyObject *const_tuple_str_plain_self_str_plain_pq_tuple;
extern PyObject *const_str_plain_PRECERT_SIGNED_CERTIFICATE_TIMESTAMPS;
static PyObject *const_tuple_str_plain_self_str_plain_usages_tuple;
extern PyObject *const_str_plain_self;
extern PyObject *const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_name_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_type_str_plain_objs_tuple;
extern PyObject *const_str_digest_bd71b5d9106eb6b876b65e57bcd30837;
static PyObject *const_str_plain__make_sequence_methods;
static PyObject *const_str_plain_status_request;
extern PyObject *const_str_plain_ISSUER_ALTERNATIVE_NAME;
extern PyObject *const_str_plain_DELTA_CRL_INDICATOR;
extern PyObject *const_str_plain_value;
extern PyObject *const_dict_f154c9a58c9419d7e391901d7b7fe49e;
extern PyObject *const_str_plain_certificateHold;
extern PyObject *const_str_plain_NameConstraints;
static PyObject *const_str_plain__key_identifier_from_public_key;
static PyObject *const_str_plain__notice_reference;
static PyObject *const_str_digest_15f4645c15394598b5ad3d887ad62f4a;
extern PyObject *const_str_plain_BasicConstraints;
static PyObject *const_str_plain__only_some_reasons;
static PyObject *const_str_digest_26a75172f55108334b01cdc8efcbab38;
static PyObject *const_str_digest_cb90e2fbaafbf44b381aafdbc54043e2;
static PyObject *const_int_pos_17;
static PyObject *const_tuple_0249ced4da5e72f251db066d967b15dd_tuple;
extern PyObject *const_str_digest_9c4dcd45c628f51f60b0e74617698ea7;
extern PyObject *const_tuple_str_plain_self_str_plain_digest_tuple;
extern PyObject *const_str_plain_aa_compromise;
extern PyObject *const_str_plain_CertificatePolicies;
extern PyObject *const_tuple_str_plain__reason_tuple;
static PyObject *const_str_plain__distribution_points;
static PyObject *const_tuple_str_plain__critical_tuple;
extern PyObject *const_int_pos_5;
extern PyObject *const_int_pos_2;
extern PyObject *const_str_plain_key_cert_sign;
extern PyObject *const_int_pos_1;
static PyObject *const_tuple_str_plain__reasons_tuple;
extern PyObject *const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_i_tuple;
extern PyObject *const_str_plain_KeyUsage;
extern PyObject *const_str_plain_CertificateIssuer;
static PyObject *const_str_digest_520475ee9f753bee090d1ecadd4c727e;
static PyObject *const_tuple_str_plain_constant_time_str_plain_serialization_tuple;
static PyObject *const_str_plain__features;
extern PyObject *const_str_plain_utils;
static PyObject *const_str_digest_de9abd61df15d9c64a5a616e9749f115;
extern PyObject *const_str_plain_bytes_eq;
extern PyObject *const_str_plain_serialization;
extern PyObject *const_str_plain_decipher_only;
extern PyObject *const_str_plain_read_single_element;
static PyObject *const_str_plain__full_name;
static PyObject *const_str_plain_objs;
extern PyObject *const_str_digest_becb7ddc5eba88bda421a9fc23a1539c;
extern PyObject *const_str_plain___hash__;
static PyObject *const_tuple_str_plain__data_encipherment_tuple;
static PyObject *const_str_plain_cACompromise;
static PyObject *const_str_plain__excluded_subtrees;
static PyObject *const_tuple_96332c2a391d63d358e15081c1debfb6_tuple;
extern PyObject *const_str_plain___eq__;
extern PyObject *const_str_plain_NONCE;
extern PyObject *const_str_plain___enter__;
extern PyObject *const_str_plain_inhibit_policy_mapping;
extern PyObject *const_str_plain_IssuingDistributionPoint;
extern PyObject *const_str_plain_fn;
extern PyObject *const_str_plain_ReasonFlags;
extern PyObject *const_str_plain_PublicFormat;
static PyObject *const_str_plain__crl_number;
static PyObject *const_str_plain__authority_cert_serial_number;
extern PyObject *const_str_plain_key_agreement;
static PyObject *const_tuple_9e442608387cffc806b1f25d569bdb89_tuple;
extern PyObject *const_str_plain_i;
extern PyObject *const_str_plain_only_contains_attribute_certs;
static PyObject *const_str_plain_features;
static PyObject *const_tuple_str_plain_self_str_plain_type_tuple;
extern PyObject *const_str_plain_public_key;
static PyObject *const_str_plain_get_extension_for_oid;
static PyObject *const_str_plain__invalidity_date;
extern PyObject *const_str_plain_INHIBIT_ANY_POLICY;
static PyObject *const_tuple_str_plain_RSAPublicKey_tuple;
static PyObject *const_tuple_f0b7c840b1a9fbe38f5c07adf2fdfe26_tuple;
static PyObject *const_str_digest_6e39999ae9fa2f733baa4157c3ce7ef9;
extern PyObject *const_str_plain_cryptography;
extern PyObject *const_str_plain_organization;
extern PyObject *const_str_plain_AUTHORITY_KEY_IDENTIFIER;
static PyObject *const_str_digest_1dfb7a6265a6e9db387c1d41869616b8;
static PyObject *const_str_digest_c47beb1c7d1e047c9170d20aad4fb97b;
static PyObject *const_str_digest_2a63548c17bc773344f27e5819855b7b;
extern PyObject *const_str_plain_superseded;
extern PyObject *const_int_0;
extern PyObject *const_str_plain__reason;
extern PyObject *const_str_plain_six;
extern PyObject *const_str_plain_idx;
static PyObject *const_tuple_str_plain__only_some_reasons_tuple;
extern PyObject *const_tuple_str_plain__oid_tuple;
extern PyObject *const_str_digest_957c81bc7a15c28c0c453fa3270dbc10;
extern PyObject *const_str_plain_data_encipherment;
static PyObject *const_str_plain__explicit_text;
static PyObject *const_str_plain__crl_sign;
static PyObject *const_tuple_str_plain__digest_tuple;
static PyObject *const_str_plain__descriptions;
static PyObject *const_str_plain__key_identifier;
static PyObject *const_tuple_str_plain__permitted_subtrees_tuple;
static PyObject *const_str_plain_pq;
static PyObject *const_str_digest_7d42ffe02af672349902ee30e189a05b;
static PyObject *const_str_plain_ps;
extern PyObject *const_str_plain_add_metaclass;
static PyObject *const_str_plain_descriptions;
extern PyObject *const_str_plain_read_element;
extern PyObject *const_str_plain_print_function;
extern PyObject *const_str_plain_ExtensionType;
extern PyObject *const_str_plain_ABCMeta;
static PyObject *const_tuple_79831141b0c54263bd4ba55a91ef27c4_tuple;
extern PyObject *const_tuple_str_plain__nonce_tuple;
static PyObject *const_str_plain_es;
static PyObject *const_str_plain__policy_qualifiers;
static PyObject *const_str_plain__only_contains_user_certs;
static PyObject *const_str_digest_8f0bd0cc388ffa652d2a12f682c27871;
static PyObject *const_str_plain__access_method;
static PyObject *const_str_digest_198893d8157c272d69767f46f86316c2;
extern PyObject *const_str_plain_X962;
extern PyObject *const_dict_empty;
extern PyObject *const_str_plain_access_method;
static PyObject *const_tuple_str_plain__access_location_tuple;
extern PyObject *const_tuple_empty;
extern PyObject *const_str_digest_97ac982b098bfd0facb64df38773c335;
extern PyObject *const_tuple_str_plain_self_tuple;
extern PyObject *const_str_plain_access_location;
extern PyObject *const_str_plain___repr__;
static PyObject *const_str_digest_de6ca45cc2c0d21b3ea9542eeb752d64;
static PyObject *const_tuple_str_plain__access_method_tuple;
static PyObject *const_str_plain_iter_method;
extern PyObject *const_str_plain_reasons;
extern PyObject *const_str_plain_ext;
extern PyObject *const_str_plain_affiliation_changed;
extern PyObject *const_str_plain_key_compromise;
static PyObject *const_str_plain_public_key_info;
extern PyObject *const_str_plain_Extensions;
extern PyObject *const_str_plain_algorithm;
static PyObject *const_tuple_6d08159ea13672603ee689286b27f535_tuple;
extern PyObject *const_str_plain_format;
extern PyObject *const_str_plain_EllipticCurvePublicKey;
extern PyObject *const_str_plain_BASIC_CONSTRAINTS;
static PyObject *const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple;
static PyObject *const_str_plain__authority_cert_issuer;
extern PyObject *const_str_plain_DuplicateExtension;
extern PyObject *const_str_plain_affiliationChanged;
static PyObject *const_str_plain_privilegeWithdrawn;
static PyObject *const_tuple_str_plain__full_name_tuple;
extern PyObject *const_str_plain_abc;
extern PyObject *const_str_plain_GeneralName;
static PyObject *const_str_plain_extclass;
static PyObject *const_str_plain_distribution_points;
static PyObject *const_str_plain__skip_certs;
extern PyObject *const_str_plain_Extension;
static PyObject *const_str_digest_afa42db89846e96e9cfc2ab56578058d;
extern PyObject *const_str_plain_unspecified;
extern PyObject *const_str_plain_encipher_only;
extern PyObject *const_str_plain___module__;
static PyObject *const_str_digest_1ea9692159fa7fd9f8e15a3506f4463c;
static PyObject *const_str_digest_421b43a5ec9f9f0f5f30b5a50ec3db96;
static PyObject *const_str_digest_d0363a16b2327897c21c9e61fd2edb1e;
extern PyObject *const_str_angle_genexpr;
static PyObject *const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple;
extern PyObject *const_str_plain_critical;
static PyObject *const_tuple_str_plain__content_commitment_tuple;
static PyObject *const_str_digest_87fc424e9112e6987e5fe8e83a94ae22;
extern PyObject *const_str_plain_enum;
extern PyObject *const_str_plain_PRECERT_POISON;
extern PyObject *const_str_plain_OCSPNonce;
extern PyObject *const_str_plain_SUBJECT_KEY_IDENTIFIER;
static PyObject *const_str_plain__digital_signature;
static PyObject *const_tuple_str_plain_self_str_plain_signed_certificate_timestamps_tuple;
extern PyObject *const_str_plain__oid;
static PyObject *const_str_digest_e41e00d6ec327bc9d8187afd927a45a2;
static PyObject *const_str_digest_449ea3887ada75d14dab0f566d0a778c;
static PyObject *const_str_digest_293839491199d08c5eee9ab993bbfcfe;
extern PyObject *const_str_plain_cessationOfOperation;
extern PyObject *const_str_plain_RSAPublicKey;
extern PyObject *const_str_plain_PKCS1;
static PyObject *const_str_digest_009ff6af115398b3dfb26f0926fdbea2;
static PyObject *const_unicode_digest_71b136bb2c4e9e2ce7c90a48ee86f246;
extern PyObject *const_str_plain_keyCompromise;
extern PyObject *const_str_plain_PolicyConstraints;
static PyObject *const_tuple_str_plain__usages_tuple;
extern PyObject *const_str_plain_explicit_text;
extern PyObject *const_str_plain_other;
extern PyObject *const_str_plain_notice_reference;
static PyObject *const_tuple_str_plain__path_length_tuple;
static PyObject *const_str_digest_837e2310df6009dd1b110accad73bb42;
extern PyObject *const_str_plain_CRLDistributionPoints;
static PyObject *const_str_plain_from_issuer_public_key;
extern PyObject *const_str_plain_ipaddress;
static PyObject *const_str_plain__content_commitment;
static PyObject *const_str_digest_37a5813a8df88d549fa10cdd6f24a9b9;
static PyObject *const_tuple_str_plain_self_str_plain_extclass_str_plain_ext_tuple;
static PyObject *const_str_digest_024b912fa6151b94263fc1d09ce49af2;
static PyObject *const_tuple_str_plain__authority_cert_serial_number_tuple;
static PyObject *const_str_digest_1961eae2d00689b393091e3fc681acbe;
extern PyObject *const_str_plain_CERTIFICATE_ISSUER;
static PyObject *const_str_digest_3611def0515b06c31df0f70307f767f3;
static PyObject *const_str_plain__usages;
extern PyObject *const_str_plain_oid;
static PyObject *const_str_plain_field_name;
extern PyObject *const_str_plain_AuthorityKeyIdentifier;
static PyObject *const_tuple_str_plain__indirect_crl_tuple;
extern PyObject *const_str_plain_key_encipherment;
static PyObject *const_tuple_str_plain_self_str_plain_extensions_tuple;
static PyObject *const_str_plain__signed_certificate_timestamps;
extern PyObject *const_str_plain_TLSFeatureType;
extern PyObject *const_str_plain_any;
extern PyObject *const_str_plain_absolute_import;
static PyObject *const_tuple_str_plain_self_str_plain_oid_str_plain_ext_tuple;
static PyObject *const_tuple_str_plain__only_contains_user_certs_tuple;
extern PyObject *const_str_plain_DERReader;
static PyObject *const_str_digest_42aaad2aaa6a1ee7d79f305ebfd1a58b;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_digest_2e6a7667e25628285e79573956cb938f;
static PyObject *const_str_plain_from_issuer_subject_key_identifier;
static PyObject *const_str_digest_56973e3a5f1a8b7f8ba81c36b603bcaa;
static PyObject *const_tuple_str_plain__crl_sign_tuple;
extern PyObject *const_str_plain_get_extension_for_class;
extern PyObject *const_str_plain___len__;
extern PyObject *const_str_plain_certificate_hold;
static PyObject *const_tuple_str_plain__invalidity_date_tuple;
extern PyObject *const_str_plain_OCSPExtensionOID;
static PyObject *const_str_plain__ca;
static PyObject *const_tuple_str_plain__policy_identifier_tuple;
extern PyObject *const_str_plain_SubjectAlternativeName;
static PyObject *const_tuple_9d6859e57abe5ce2ca107f61cc5077a0_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_idx_str_plain_field_name_tuple;
extern PyObject *const_str_plain_DER;
static PyObject *const_str_plain__inhibit_policy_mapping;
extern PyObject *const_str_plain_POLICY_CONSTRAINTS;
extern PyObject *const_str_plain_OCSP_NO_CHECK;
extern PyObject *const_str_plain_only_some_reasons;
static PyObject *const_tuple_str_plain_cls_str_plain_ski_str_plain_digest_tuple;
static PyObject *module_filename_obj;

static bool constants_created = false;

static void createModuleConstants( void )
{
    const_str_plain__crl_issuer = UNSTREAM_STRING( &constant_bin[ 697512 ], 11, 1 );
    const_str_plain__decipher_only = UNSTREAM_STRING( &constant_bin[ 697523 ], 14, 1 );
    const_tuple_30cc927ede2fc9470dffcd81c25765bb_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_30cc927ede2fc9470dffcd81c25765bb_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_30cc927ede2fc9470dffcd81c25765bb_tuple, 1, const_str_plain_notice_reference ); Py_INCREF( const_str_plain_notice_reference );
    PyTuple_SET_ITEM( const_tuple_30cc927ede2fc9470dffcd81c25765bb_tuple, 2, const_str_plain_explicit_text ); Py_INCREF( const_str_plain_explicit_text );
    const_tuple_str_plain__policies_tuple = PyTuple_New( 1 );
    const_str_plain__policies = UNSTREAM_STRING( &constant_bin[ 654976 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__policies_tuple, 0, const_str_plain__policies ); Py_INCREF( const_str_plain__policies );
    const_str_plain__indirect_crl = UNSTREAM_STRING( &constant_bin[ 697537 ], 13, 1 );
    const_str_digest_096877126149ba9ef6483d7f63c2f65e = UNSTREAM_STRING( &constant_bin[ 697550 ], 18, 0 );
    const_tuple_str_plain_EllipticCurvePublicKey_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_EllipticCurvePublicKey_tuple, 0, const_str_plain_EllipticCurvePublicKey ); Py_INCREF( const_str_plain_EllipticCurvePublicKey );
    const_str_digest_e29a6013213dd6497cd7c55bc7864351 = UNSTREAM_STRING( &constant_bin[ 697568 ], 16, 0 );
    const_str_digest_76d9dc3b971abafb272069e298f2eb0c = UNSTREAM_STRING( &constant_bin[ 697584 ], 86, 0 );
    const_tuple_828872b32a88e627e2f72e22e0a4680e_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_828872b32a88e627e2f72e22e0a4680e_tuple, 0, const_str_plain_public_key ); Py_INCREF( const_str_plain_public_key );
    PyTuple_SET_ITEM( const_tuple_828872b32a88e627e2f72e22e0a4680e_tuple, 1, const_str_plain_algorithm ); Py_INCREF( const_str_plain_algorithm );
    const_str_plain_serialized = UNSTREAM_STRING( &constant_bin[ 673551 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_828872b32a88e627e2f72e22e0a4680e_tuple, 2, const_str_plain_serialized ); Py_INCREF( const_str_plain_serialized );
    const_str_plain_public_key_info = UNSTREAM_STRING( &constant_bin[ 697670 ], 15, 1 );
    PyTuple_SET_ITEM( const_tuple_828872b32a88e627e2f72e22e0a4680e_tuple, 3, const_str_plain_public_key_info ); Py_INCREF( const_str_plain_public_key_info );
    PyTuple_SET_ITEM( const_tuple_828872b32a88e627e2f72e22e0a4680e_tuple, 4, const_str_plain_reader ); Py_INCREF( const_str_plain_reader );
    PyTuple_SET_ITEM( const_tuple_828872b32a88e627e2f72e22e0a4680e_tuple, 5, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    const_str_plain__organization = UNSTREAM_STRING( &constant_bin[ 697685 ], 13, 1 );
    const_str_digest_a173082fd91f8794530005b1589bf6b2 = UNSTREAM_STRING( &constant_bin[ 697698 ], 55, 0 );
    const_tuple_str_plain__notice_reference_tuple = PyTuple_New( 1 );
    const_str_plain__notice_reference = UNSTREAM_STRING( &constant_bin[ 661144 ], 17, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__notice_reference_tuple, 0, const_str_plain__notice_reference ); Py_INCREF( const_str_plain__notice_reference );
    const_tuple_str_plain__key_encipherment_tuple = PyTuple_New( 1 );
    const_str_plain__key_encipherment = UNSTREAM_STRING( &constant_bin[ 697753 ], 17, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__key_encipherment_tuple, 0, const_str_plain__key_encipherment ); Py_INCREF( const_str_plain__key_encipherment );
    const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple, 1, const_str_plain_key_identifier ); Py_INCREF( const_str_plain_key_identifier );
    PyTuple_SET_ITEM( const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple, 2, const_str_plain_authority_cert_issuer ); Py_INCREF( const_str_plain_authority_cert_issuer );
    PyTuple_SET_ITEM( const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple, 3, const_str_plain_authority_cert_serial_number ); Py_INCREF( const_str_plain_authority_cert_serial_number );
    const_str_digest_a0744842c59ec0ec1342dee683ec7ac8 = UNSTREAM_STRING( &constant_bin[ 697770 ], 63, 0 );
    const_str_plain__access_location = UNSTREAM_STRING( &constant_bin[ 697833 ], 16, 1 );
    const_str_digest_91034dde8ef1b9b2896e23f094ab68ec = UNSTREAM_STRING( &constant_bin[ 697849 ], 43, 0 );
    const_str_plain__only_contains_ca_certs = UNSTREAM_STRING( &constant_bin[ 697892 ], 23, 1 );
    const_str_digest_548641877ac6c51da15a8285d67846ee = UNSTREAM_STRING( &constant_bin[ 697915 ], 22, 0 );
    const_tuple_571ef8230a0f951e7e814a3a1b007a73_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_571ef8230a0f951e7e814a3a1b007a73_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_571ef8230a0f951e7e814a3a1b007a73_tuple, 1, const_str_plain_organization ); Py_INCREF( const_str_plain_organization );
    PyTuple_SET_ITEM( const_tuple_571ef8230a0f951e7e814a3a1b007a73_tuple, 2, const_str_plain_notice_numbers ); Py_INCREF( const_str_plain_notice_numbers );
    const_str_digest_e796fffc6f5e8d4c3d564875b854a9ed = UNSTREAM_STRING( &constant_bin[ 697937 ], 29, 0 );
    const_tuple_str_plain_self_str_plain_ca_str_plain_path_length_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ca_str_plain_path_length_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ca_str_plain_path_length_tuple, 1, const_str_plain_ca ); Py_INCREF( const_str_plain_ca );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ca_str_plain_path_length_tuple, 2, const_str_plain_path_length ); Py_INCREF( const_str_plain_path_length );
    const_tuple_str_plain__extensions_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__extensions_tuple, 0, const_str_plain__extensions ); Py_INCREF( const_str_plain__extensions );
    const_str_digest_aedab8e33f4a55e03d8255716673252f = UNSTREAM_STRING( &constant_bin[ 697966 ], 17, 0 );
    const_str_plain__only_contains_attribute_certs = UNSTREAM_STRING( &constant_bin[ 697983 ], 30, 1 );
    const_str_digest_de1714430c844d988a0d091fac0a73d4 = UNSTREAM_STRING( &constant_bin[ 698013 ], 15, 0 );
    const_str_digest_f7714799e19abc5d09ccbaf8366649ea = UNSTREAM_STRING( &constant_bin[ 698028 ], 29, 0 );
    const_str_digest_28228272e91a15a54ff010026fcf7af8 = UNSTREAM_STRING( &constant_bin[ 698057 ], 58, 0 );
    const_str_digest_ba0ace4d3ab5fb435146fa7a7a8c5e76 = UNSTREAM_STRING( &constant_bin[ 698115 ], 41, 0 );
    const_str_plain__data_encipherment = UNSTREAM_STRING( &constant_bin[ 698156 ], 18, 1 );
    const_tuple_a73b8498e05ac6f54cfbc844a1aafead_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_a73b8498e05ac6f54cfbc844a1aafead_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a73b8498e05ac6f54cfbc844a1aafead_tuple, 1, const_str_plain_permitted_subtrees ); Py_INCREF( const_str_plain_permitted_subtrees );
    PyTuple_SET_ITEM( const_tuple_a73b8498e05ac6f54cfbc844a1aafead_tuple, 2, const_str_plain_excluded_subtrees ); Py_INCREF( const_str_plain_excluded_subtrees );
    const_tuple_2a50e9eb562974724a6432490d012463_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_2a50e9eb562974724a6432490d012463_tuple, 0, const_str_plain_CRLEntryExtensionOID ); Py_INCREF( const_str_plain_CRLEntryExtensionOID );
    PyTuple_SET_ITEM( const_tuple_2a50e9eb562974724a6432490d012463_tuple, 1, const_str_plain_ExtensionOID ); Py_INCREF( const_str_plain_ExtensionOID );
    PyTuple_SET_ITEM( const_tuple_2a50e9eb562974724a6432490d012463_tuple, 2, const_str_plain_OCSPExtensionOID ); Py_INCREF( const_str_plain_OCSPExtensionOID );
    PyTuple_SET_ITEM( const_tuple_2a50e9eb562974724a6432490d012463_tuple, 3, const_str_plain_ObjectIdentifier ); Py_INCREF( const_str_plain_ObjectIdentifier );
    const_tuple_str_plain__organization_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__organization_tuple, 0, const_str_plain__organization ); Py_INCREF( const_str_plain__organization );
    const_unicode_digest_91632884773c30442b9e2ac13e53950d = UNSTREAM_UNICODE( &constant_bin[ 698174 ], 101 );
    const_tuple_str_plain__key_identifier_tuple = PyTuple_New( 1 );
    const_str_plain__key_identifier = UNSTREAM_STRING( &constant_bin[ 654897 ], 15, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__key_identifier_tuple, 0, const_str_plain__key_identifier ); Py_INCREF( const_str_plain__key_identifier );
    const_str_plain_policies = UNSTREAM_STRING( &constant_bin[ 654977 ], 8, 1 );
    const_str_digest_0c5b9c1eebf18567ca6eef13eba8418b = UNSTREAM_STRING( &constant_bin[ 698275 ], 49, 0 );
    const_tuple_str_plain_self_str_plain_distribution_points_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_distribution_points_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_distribution_points = UNSTREAM_STRING( &constant_bin[ 654823 ], 19, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_distribution_points_tuple, 1, const_str_plain_distribution_points ); Py_INCREF( const_str_plain_distribution_points );
    const_tuple_str_plain_self_str_plain_field_name_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_field_name_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_field_name = UNSTREAM_STRING( &constant_bin[ 698324 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_field_name_tuple, 1, const_str_plain_field_name ); Py_INCREF( const_str_plain_field_name );
    const_tuple_str_plain_RelativeDistinguishedName_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_RelativeDistinguishedName_tuple, 0, const_str_plain_RelativeDistinguishedName ); Py_INCREF( const_str_plain_RelativeDistinguishedName );
    const_str_plain_aci = UNSTREAM_STRING( &constant_bin[ 48265 ], 3, 1 );
    const_tuple_str_plain_self_str_plain_aci_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_aci_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_aci_tuple, 1, const_str_plain_aci ); Py_INCREF( const_str_plain_aci );
    const_str_plain_aACompromise = UNSTREAM_STRING( &constant_bin[ 698334 ], 12, 1 );
    const_str_plain_len_method = UNSTREAM_STRING( &constant_bin[ 698346 ], 10, 1 );
    const_tuple_str_plain_self_str_plain_invalidity_date_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_invalidity_date_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_invalidity_date_tuple, 1, const_str_plain_invalidity_date ); Py_INCREF( const_str_plain_invalidity_date );
    const_tuple_str_plain_self_str_plain_crl_issuer_str_plain_fn_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_crl_issuer_str_plain_fn_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_crl_issuer_str_plain_fn_tuple, 1, const_str_plain_crl_issuer ); Py_INCREF( const_str_plain_crl_issuer );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_crl_issuer_str_plain_fn_tuple, 2, const_str_plain_fn ); Py_INCREF( const_str_plain_fn );
    const_str_plain_from_public_key = UNSTREAM_STRING( &constant_bin[ 698356 ], 15, 1 );
    const_tuple_str_plain__crl_number_tuple = PyTuple_New( 1 );
    const_str_plain__crl_number = UNSTREAM_STRING( &constant_bin[ 656308 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__crl_number_tuple, 0, const_str_plain__crl_number ); Py_INCREF( const_str_plain__crl_number );
    const_str_plain__path_length = UNSTREAM_STRING( &constant_bin[ 698371 ], 12, 1 );
    const_tuple_str_plain_self_str_plain_oid_str_plain_value_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_oid_str_plain_value_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_oid_str_plain_value_tuple, 1, const_str_plain_oid ); Py_INCREF( const_str_plain_oid );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_oid_str_plain_value_tuple, 2, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    const_tuple_str_plain__key_cert_sign_tuple = PyTuple_New( 1 );
    const_str_plain__key_cert_sign = UNSTREAM_STRING( &constant_bin[ 698383 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__key_cert_sign_tuple, 0, const_str_plain__key_cert_sign ); Py_INCREF( const_str_plain__key_cert_sign );
    const_tuple_40c66ae610f06e095b8a28b392d109cb_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_40c66ae610f06e095b8a28b392d109cb_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_40c66ae610f06e095b8a28b392d109cb_tuple, 1, const_str_plain_encipher_only ); Py_INCREF( const_str_plain_encipher_only );
    PyTuple_SET_ITEM( const_tuple_40c66ae610f06e095b8a28b392d109cb_tuple, 2, const_str_plain_decipher_only ); Py_INCREF( const_str_plain_decipher_only );
    const_str_plain__critical = UNSTREAM_STRING( &constant_bin[ 80177 ], 9, 1 );
    const_tuple_str_plain__crl_issuer_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__crl_issuer_tuple, 0, const_str_plain__crl_issuer ); Py_INCREF( const_str_plain__crl_issuer );
    const_str_plain__policy_identifier = UNSTREAM_STRING( &constant_bin[ 698397 ], 18, 1 );
    const_tuple_str_plain__general_names_tuple = PyTuple_New( 1 );
    const_str_plain__general_names = UNSTREAM_STRING( &constant_bin[ 655162 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__general_names_tuple, 0, const_str_plain__general_names ); Py_INCREF( const_str_plain__general_names );
    const_str_digest_350fb76bfa2c81c3db35fe4ad0c5cc28 = UNSTREAM_STRING( &constant_bin[ 698415 ], 50, 0 );
    const_str_digest_d3e161c72eca6237cebf732e747f2482 = UNSTREAM_STRING( &constant_bin[ 698465 ], 89, 0 );
    const_tuple_str_plain_cls_str_plain_public_key_str_plain_digest_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_public_key_str_plain_digest_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_public_key_str_plain_digest_tuple, 1, const_str_plain_public_key ); Py_INCREF( const_str_plain_public_key );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_public_key_str_plain_digest_tuple, 2, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    const_str_digest_a4add4111fbe02d06da1613741f3d5ca = UNSTREAM_STRING( &constant_bin[ 698554 ], 59, 0 );
    const_str_plain__permitted_subtrees = UNSTREAM_STRING( &constant_bin[ 698613 ], 19, 1 );
    const_str_digest_98ddab5a38618a53af9688f12b4a5b05 = UNSTREAM_STRING( &constant_bin[ 698632 ], 25, 0 );
    const_str_plain_removeFromCRL = UNSTREAM_STRING( &constant_bin[ 698657 ], 13, 1 );
    const_str_digest_3a0a1109b8c268ad95ea7f220c74ef61 = UNSTREAM_STRING( &constant_bin[ 698670 ], 76, 0 );
    const_str_digest_1695020c9fca9629cae2bba3b13ed98d = UNSTREAM_STRING( &constant_bin[ 698746 ], 75, 0 );
    const_tuple_str_plain_self_str_plain_ps_str_plain_es_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ps_str_plain_es_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_ps = UNSTREAM_STRING( &constant_bin[ 6907 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ps_str_plain_es_tuple, 1, const_str_plain_ps ); Py_INCREF( const_str_plain_ps );
    const_str_plain_es = UNSTREAM_STRING( &constant_bin[ 400 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ps_str_plain_es_tuple, 2, const_str_plain_es ); Py_INCREF( const_str_plain_es );
    const_str_digest_5576b3ba482b3c884e20c0f0f9889daf = UNSTREAM_STRING( &constant_bin[ 698821 ], 89, 0 );
    const_tuple_str_plain_self_str_plain_descriptions_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_descriptions_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_descriptions = UNSTREAM_STRING( &constant_bin[ 655432 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_descriptions_tuple, 1, const_str_plain_descriptions ); Py_INCREF( const_str_plain_descriptions );
    const_str_plain__relative_name = UNSTREAM_STRING( &constant_bin[ 659711 ], 14, 1 );
    const_str_digest_bed5ff04fb0d04ecd22172c330a8e05a = UNSTREAM_STRING( &constant_bin[ 698910 ], 176, 0 );
    const_str_digest_171541ce3e17f273a42b3961194a7b72 = UNSTREAM_STRING( &constant_bin[ 699086 ], 47, 0 );
    const_str_digest_acc45e336b0d5f3376f4867fb94a18e6 = UNSTREAM_STRING( &constant_bin[ 699133 ], 61, 0 );
    const_str_digest_52903da339eb426b3d703a3f30ce3e10 = UNSTREAM_STRING( &constant_bin[ 699194 ], 64, 0 );
    const_str_digest_f37468dd5629ccacfbc304506e5ed113 = UNSTREAM_STRING( &constant_bin[ 699258 ], 19, 0 );
    const_str_digest_92ebfd7d825e182438411c24725c884a = UNSTREAM_STRING( &constant_bin[ 699277 ], 30, 0 );
    const_str_digest_d0cacbb4febc1bdb60a26b048c7bb9b6 = UNSTREAM_STRING( &constant_bin[ 699307 ], 27, 0 );
    const_str_digest_dbdc4cc574491d1286f5938d4480dec8 = UNSTREAM_STRING( &constant_bin[ 699334 ], 27, 0 );
    const_tuple_str_plain__only_contains_attribute_certs_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__only_contains_attribute_certs_tuple, 0, const_str_plain__only_contains_attribute_certs ); Py_INCREF( const_str_plain__only_contains_attribute_certs );
    const_str_digest_908210834a8fb4c8eaca7a64e23a4bed = UNSTREAM_STRING( &constant_bin[ 699361 ], 64, 0 );
    const_tuple_str_plain__only_contains_ca_certs_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__only_contains_ca_certs_tuple, 0, const_str_plain__only_contains_ca_certs ); Py_INCREF( const_str_plain__only_contains_ca_certs );
    const_str_digest_ccd052a57d9b2466ec6174083baebf1e = UNSTREAM_STRING( &constant_bin[ 699425 ], 73, 0 );
    const_tuple_str_plain_cls_str_plain_public_key_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_public_key_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_public_key_tuple, 1, const_str_plain_public_key ); Py_INCREF( const_str_plain_public_key );
    const_tuple_str_plain__relative_name_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__relative_name_tuple, 0, const_str_plain__relative_name ); Py_INCREF( const_str_plain__relative_name );
    const_tuple_b58c59c90f8b7ff71dbfd006f561c9fe_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_b58c59c90f8b7ff71dbfd006f561c9fe_tuple, 0, const_str_plain_GeneralName ); Py_INCREF( const_str_plain_GeneralName );
    PyTuple_SET_ITEM( const_tuple_b58c59c90f8b7ff71dbfd006f561c9fe_tuple, 1, const_str_plain_IPAddress ); Py_INCREF( const_str_plain_IPAddress );
    PyTuple_SET_ITEM( const_tuple_b58c59c90f8b7ff71dbfd006f561c9fe_tuple, 2, const_str_plain_OtherName ); Py_INCREF( const_str_plain_OtherName );
    const_tuple_str_plain_self_str_plain_reason_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_reason_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_reason_tuple, 1, const_str_plain_reason ); Py_INCREF( const_str_plain_reason );
    const_str_digest_f63518e696f94cef547d30428c9b8408 = UNSTREAM_STRING( &constant_bin[ 699498 ], 31, 0 );
    const_tuple_str_plain__policy_qualifiers_tuple = PyTuple_New( 1 );
    const_str_plain__policy_qualifiers = UNSTREAM_STRING( &constant_bin[ 699529 ], 18, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__policy_qualifiers_tuple, 0, const_str_plain__policy_qualifiers ); Py_INCREF( const_str_plain__policy_qualifiers );
    const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple, 1, const_str_plain_full_name ); Py_INCREF( const_str_plain_full_name );
    PyTuple_SET_ITEM( const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple, 2, const_str_plain_relative_name ); Py_INCREF( const_str_plain_relative_name );
    PyTuple_SET_ITEM( const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple, 3, const_str_plain_reasons ); Py_INCREF( const_str_plain_reasons );
    PyTuple_SET_ITEM( const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple, 4, const_str_plain_crl_issuer ); Py_INCREF( const_str_plain_crl_issuer );
    const_str_plain__require_explicit_policy = UNSTREAM_STRING( &constant_bin[ 699547 ], 24, 1 );
    const_str_digest_d04c4a4e63138db9ecc900ec9847717c = UNSTREAM_STRING( &constant_bin[ 699571 ], 42, 0 );
    const_tuple_str_plain_self_str_plain_crl_number_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_crl_number_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_crl_number_tuple, 1, const_str_plain_crl_number ); Py_INCREF( const_str_plain_crl_number );
    const_str_digest_da5560b5b28f3c84a1c556751340bb55 = UNSTREAM_STRING( &constant_bin[ 699613 ], 88, 0 );
    const_str_digest_2fedee8d2e8553cc3a2acd1bc300acd1 = UNSTREAM_STRING( &constant_bin[ 699701 ], 36, 0 );
    const_str_digest_f7d33cb69a7dc22294881ff5b1fe0ec9 = UNSTREAM_STRING( &constant_bin[ 699737 ], 124, 0 );
    const_str_digest_2615a61b30c6d1612864004a5b3409b1 = UNSTREAM_STRING( &constant_bin[ 698067 ], 48, 0 );
    const_tuple_str_plain__authority_cert_issuer_tuple = PyTuple_New( 1 );
    const_str_plain__authority_cert_issuer = UNSTREAM_STRING( &constant_bin[ 699861 ], 22, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__authority_cert_issuer_tuple, 0, const_str_plain__authority_cert_issuer ); Py_INCREF( const_str_plain__authority_cert_issuer );
    const_tuple_str_plain__notice_numbers_tuple = PyTuple_New( 1 );
    const_str_plain__notice_numbers = UNSTREAM_STRING( &constant_bin[ 699883 ], 15, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__notice_numbers_tuple, 0, const_str_plain__notice_numbers ); Py_INCREF( const_str_plain__notice_numbers );
    const_tuple_str_plain_self_str_plain_features_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_features_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_features = UNSTREAM_STRING( &constant_bin[ 655519 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_features_tuple, 1, const_str_plain_features ); Py_INCREF( const_str_plain_features );
    const_str_digest_11b049dd960f5e8f8d4550cdd9caf427 = UNSTREAM_STRING( &constant_bin[ 699898 ], 79, 0 );
    const_str_digest_4896564d0ed5e6b06237436d00bf3cad = UNSTREAM_STRING( &constant_bin[ 699977 ], 327, 0 );
    const_str_digest_7689dc38f9edab5e0154168296ac4aa7 = UNSTREAM_STRING( &constant_bin[ 700304 ], 50, 0 );
    const_str_plain_getitem_method = UNSTREAM_STRING( &constant_bin[ 700354 ], 14, 1 );
    const_tuple_str_plain_self_str_plain_general_names_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_general_names_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_general_names_tuple, 1, const_str_plain_general_names ); Py_INCREF( const_str_plain_general_names );
    const_str_plain_status_request_v2 = UNSTREAM_STRING( &constant_bin[ 700368 ], 17, 1 );
    const_str_digest_f68da15c98dbc7b7660e8e5bee0179e6 = UNSTREAM_STRING( &constant_bin[ 700385 ], 36, 0 );
    const_tuple_str_plain__distribution_points_tuple = PyTuple_New( 1 );
    const_str_plain__distribution_points = UNSTREAM_STRING( &constant_bin[ 654822 ], 20, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__distribution_points_tuple, 0, const_str_plain__distribution_points ); Py_INCREF( const_str_plain__distribution_points );
    const_str_digest_ad140184cf2507dc997c5c6a9d0f3e94 = UNSTREAM_STRING( &constant_bin[ 700421 ], 45, 0 );
    const_str_digest_a2ae3825a8b7f0237bc2c108542b8be9 = UNSTREAM_STRING( &constant_bin[ 700466 ], 57, 0 );
    const_str_plain_signed_certificate_timestamps = UNSTREAM_STRING( &constant_bin[ 657015 ], 29, 1 );
    const_str_digest_114372ae17a491041cc1a4b677269f5b = UNSTREAM_STRING( &constant_bin[ 700523 ], 85, 0 );
    const_tuple_55f45cc1ebe66c7c9c0566ce5a780f3f_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_55f45cc1ebe66c7c9c0566ce5a780f3f_tuple, 0, const_str_plain_BIT_STRING ); Py_INCREF( const_str_plain_BIT_STRING );
    PyTuple_SET_ITEM( const_tuple_55f45cc1ebe66c7c9c0566ce5a780f3f_tuple, 1, const_str_plain_DERReader ); Py_INCREF( const_str_plain_DERReader );
    PyTuple_SET_ITEM( const_tuple_55f45cc1ebe66c7c9c0566ce5a780f3f_tuple, 2, const_str_plain_OBJECT_IDENTIFIER ); Py_INCREF( const_str_plain_OBJECT_IDENTIFIER );
    PyTuple_SET_ITEM( const_tuple_55f45cc1ebe66c7c9c0566ce5a780f3f_tuple, 3, const_str_plain_SEQUENCE ); Py_INCREF( const_str_plain_SEQUENCE );
    const_str_digest_e7bc751982d7cd4fe2e9c78dbf3e6347 = UNSTREAM_STRING( &constant_bin[ 700608 ], 125, 0 );
    const_str_plain_usages = UNSTREAM_STRING( &constant_bin[ 700484 ], 6, 1 );
    const_str_plain_crl_constraints = UNSTREAM_STRING( &constant_bin[ 700733 ], 15, 1 );
    const_tuple_str_plain_self_str_plain_policies_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_policies_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_policies_tuple, 1, const_str_plain_policies ); Py_INCREF( const_str_plain_policies );
    const_tuple_str_plain_self_str_plain_tree_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_tree_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_tree_tuple, 1, const_str_plain_tree ); Py_INCREF( const_str_plain_tree );
    const_tuple_str_plain__key_agreement_tuple = PyTuple_New( 1 );
    const_str_plain__key_agreement = UNSTREAM_STRING( &constant_bin[ 700748 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__key_agreement_tuple, 0, const_str_plain__key_agreement ); Py_INCREF( const_str_plain__key_agreement );
    const_str_digest_2622a0002f5b5df69415ebf4bce9a343 = UNSTREAM_STRING( &constant_bin[ 700762 ], 94, 0 );
    const_tuple_str_plain_self_str_plain_skip_certs_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_skip_certs_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_skip_certs_tuple, 1, const_str_plain_skip_certs ); Py_INCREF( const_str_plain_skip_certs );
    const_str_digest_73d50e8900e7f2ac40a53b664096aa15 = UNSTREAM_STRING( &constant_bin[ 700856 ], 22, 0 );
    const_str_digest_9cc2c8377ce78bc1b198ac0906717d7f = UNSTREAM_STRING( &constant_bin[ 700878 ], 101, 0 );
    const_tuple_str_plain_SignedCertificateTimestamp_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_SignedCertificateTimestamp_tuple, 0, const_str_plain_SignedCertificateTimestamp ); Py_INCREF( const_str_plain_SignedCertificateTimestamp );
    const_str_plain__encipher_only = UNSTREAM_STRING( &constant_bin[ 700979 ], 14, 1 );
    const_str_digest_881d5fa81af108f32d6b1d8d2d35a638 = UNSTREAM_STRING( &constant_bin[ 700993 ], 64, 0 );
    const_tuple_str_plain__explicit_text_tuple = PyTuple_New( 1 );
    const_str_plain__explicit_text = UNSTREAM_STRING( &constant_bin[ 701057 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__explicit_text_tuple, 0, const_str_plain__explicit_text ); Py_INCREF( const_str_plain__explicit_text );
    const_str_digest_c3da50fdd18d409ebf6fe1322cd35c5d = UNSTREAM_STRING( &constant_bin[ 701071 ], 301, 0 );
    const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_sct_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_sct_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    PyTuple_SET_ITEM( const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_sct_tuple, 1, const_str_plain_sct ); Py_INCREF( const_str_plain_sct );
    const_tuple_str_plain__skip_certs_tuple = PyTuple_New( 1 );
    const_str_plain__skip_certs = UNSTREAM_STRING( &constant_bin[ 701372 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__skip_certs_tuple, 0, const_str_plain__skip_certs ); Py_INCREF( const_str_plain__skip_certs );
    const_tuple_str_plain__descriptions_tuple = PyTuple_New( 1 );
    const_str_plain__descriptions = UNSTREAM_STRING( &constant_bin[ 655431 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__descriptions_tuple, 0, const_str_plain__descriptions ); Py_INCREF( const_str_plain__descriptions );
    const_tuple_str_plain__features_tuple = PyTuple_New( 1 );
    const_str_plain__features = UNSTREAM_STRING( &constant_bin[ 700409 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__features_tuple, 0, const_str_plain__features ); Py_INCREF( const_str_plain__features );
    const_tuple_str_plain__digital_signature_tuple = PyTuple_New( 1 );
    const_str_plain__digital_signature = UNSTREAM_STRING( &constant_bin[ 701383 ], 18, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__digital_signature_tuple, 0, const_str_plain__digital_signature ); Py_INCREF( const_str_plain__digital_signature );
    const_tuple_str_plain__signed_certificate_timestamps_tuple = PyTuple_New( 1 );
    const_str_plain__signed_certificate_timestamps = UNSTREAM_STRING( &constant_bin[ 657014 ], 30, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__signed_certificate_timestamps_tuple, 0, const_str_plain__signed_certificate_timestamps ); Py_INCREF( const_str_plain__signed_certificate_timestamps );
    const_str_digest_d2a030963ea7fa46a452128daffceb24 = UNSTREAM_STRING( &constant_bin[ 701401 ], 41, 0 );
    const_str_digest_ac8667798ba70bb109d3e3236473ab02 = UNSTREAM_STRING( &constant_bin[ 701442 ], 62, 0 );
    const_tuple_str_plain__ca_tuple = PyTuple_New( 1 );
    const_str_plain__ca = UNSTREAM_STRING( &constant_bin[ 1410 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__ca_tuple, 0, const_str_plain__ca ); Py_INCREF( const_str_plain__ca );
    const_str_digest_2a0138f3ee2cd707fb386e46f1612821 = UNSTREAM_STRING( &constant_bin[ 701504 ], 23, 0 );
    const_tuple_str_plain__excluded_subtrees_tuple = PyTuple_New( 1 );
    const_str_plain__excluded_subtrees = UNSTREAM_STRING( &constant_bin[ 701527 ], 18, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__excluded_subtrees_tuple, 0, const_str_plain__excluded_subtrees ); Py_INCREF( const_str_plain__excluded_subtrees );
    const_str_digest_c6c3dada1f7f971d20a3492ccb208681 = UNSTREAM_STRING( &constant_bin[ 701545 ], 84, 0 );
    const_str_plain__reasons = UNSTREAM_STRING( &constant_bin[ 43819 ], 8, 1 );
    const_str_digest_35185795abbb3b5bbc0cab5aa03aab83 = UNSTREAM_STRING( &constant_bin[ 701629 ], 75, 0 );
    const_str_digest_b436a97f38724e3583df19a1d449e278 = UNSTREAM_STRING( &constant_bin[ 701704 ], 41, 0 );
    const_str_digest_d9e548ca3e36faa8011f3a82a40a2310 = UNSTREAM_STRING( &constant_bin[ 701745 ], 15, 0 );
    const_str_digest_fdf88dfad66dd7b1bb721469f9f06736 = UNSTREAM_STRING( &constant_bin[ 701760 ], 55, 0 );
    const_tuple_str_plain__require_explicit_policy_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__require_explicit_policy_tuple, 0, const_str_plain__require_explicit_policy ); Py_INCREF( const_str_plain__require_explicit_policy );
    const_tuple_str_plain__inhibit_policy_mapping_tuple = PyTuple_New( 1 );
    const_str_plain__inhibit_policy_mapping = UNSTREAM_STRING( &constant_bin[ 701815 ], 23, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__inhibit_policy_mapping_tuple, 0, const_str_plain__inhibit_policy_mapping ); Py_INCREF( const_str_plain__inhibit_policy_mapping );
    const_str_plain__validate_ip_name = UNSTREAM_STRING( &constant_bin[ 701838 ], 17, 1 );
    const_tuple_str_plain_self_str_plain_pq_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pq_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_pq = UNSTREAM_STRING( &constant_bin[ 653632 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pq_tuple, 1, const_str_plain_pq ); Py_INCREF( const_str_plain_pq );
    const_tuple_str_plain_self_str_plain_usages_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_usages_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_usages_tuple, 1, const_str_plain_usages ); Py_INCREF( const_str_plain_usages );
    const_tuple_str_plain_self_str_plain_type_str_plain_objs_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_type_str_plain_objs_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_type_str_plain_objs_tuple, 1, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    const_str_plain_objs = UNSTREAM_STRING( &constant_bin[ 1331 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_type_str_plain_objs_tuple, 2, const_str_plain_objs ); Py_INCREF( const_str_plain_objs );
    const_str_plain__make_sequence_methods = UNSTREAM_STRING( &constant_bin[ 701855 ], 22, 1 );
    const_str_plain_status_request = UNSTREAM_STRING( &constant_bin[ 700368 ], 14, 1 );
    const_str_plain__key_identifier_from_public_key = UNSTREAM_STRING( &constant_bin[ 701877 ], 31, 1 );
    const_str_digest_15f4645c15394598b5ad3d887ad62f4a = UNSTREAM_STRING( &constant_bin[ 701908 ], 64, 0 );
    const_str_plain__only_some_reasons = UNSTREAM_STRING( &constant_bin[ 701972 ], 18, 1 );
    const_str_digest_26a75172f55108334b01cdc8efcbab38 = UNSTREAM_STRING( &constant_bin[ 701990 ], 32, 0 );
    const_str_digest_cb90e2fbaafbf44b381aafdbc54043e2 = UNSTREAM_STRING( &constant_bin[ 702022 ], 77, 0 );
    const_int_pos_17 = PyInt_FromLong( 17l );
    const_tuple_0249ced4da5e72f251db066d967b15dd_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_0249ced4da5e72f251db066d967b15dd_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    PyTuple_SET_ITEM( const_tuple_0249ced4da5e72f251db066d967b15dd_tuple, 1, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_0249ced4da5e72f251db066d967b15dd_tuple, 2, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    const_tuple_str_plain__critical_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__critical_tuple, 0, const_str_plain__critical ); Py_INCREF( const_str_plain__critical );
    const_tuple_str_plain__reasons_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__reasons_tuple, 0, const_str_plain__reasons ); Py_INCREF( const_str_plain__reasons );
    const_str_digest_520475ee9f753bee090d1ecadd4c727e = UNSTREAM_STRING( &constant_bin[ 702099 ], 31, 0 );
    const_tuple_str_plain_constant_time_str_plain_serialization_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_constant_time_str_plain_serialization_tuple, 0, const_str_plain_constant_time ); Py_INCREF( const_str_plain_constant_time );
    PyTuple_SET_ITEM( const_tuple_str_plain_constant_time_str_plain_serialization_tuple, 1, const_str_plain_serialization ); Py_INCREF( const_str_plain_serialization );
    const_str_digest_de9abd61df15d9c64a5a616e9749f115 = UNSTREAM_STRING( &constant_bin[ 702130 ], 224, 0 );
    const_str_plain__full_name = UNSTREAM_STRING( &constant_bin[ 661478 ], 10, 1 );
    const_tuple_str_plain__data_encipherment_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__data_encipherment_tuple, 0, const_str_plain__data_encipherment ); Py_INCREF( const_str_plain__data_encipherment );
    const_str_plain_cACompromise = UNSTREAM_STRING( &constant_bin[ 702354 ], 12, 1 );
    const_tuple_96332c2a391d63d358e15081c1debfb6_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_96332c2a391d63d358e15081c1debfb6_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_96332c2a391d63d358e15081c1debfb6_tuple, 1, const_str_plain_oid ); Py_INCREF( const_str_plain_oid );
    PyTuple_SET_ITEM( const_tuple_96332c2a391d63d358e15081c1debfb6_tuple, 2, const_str_plain_critical ); Py_INCREF( const_str_plain_critical );
    PyTuple_SET_ITEM( const_tuple_96332c2a391d63d358e15081c1debfb6_tuple, 3, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    const_str_plain__authority_cert_serial_number = UNSTREAM_STRING( &constant_bin[ 702366 ], 29, 1 );
    const_tuple_9e442608387cffc806b1f25d569bdb89_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_9e442608387cffc806b1f25d569bdb89_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_9e442608387cffc806b1f25d569bdb89_tuple, 1, const_str_plain_access_method ); Py_INCREF( const_str_plain_access_method );
    PyTuple_SET_ITEM( const_tuple_9e442608387cffc806b1f25d569bdb89_tuple, 2, const_str_plain_access_location ); Py_INCREF( const_str_plain_access_location );
    const_tuple_str_plain_self_str_plain_type_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_type_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_type_tuple, 1, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    const_str_plain_get_extension_for_oid = UNSTREAM_STRING( &constant_bin[ 702395 ], 21, 1 );
    const_str_plain__invalidity_date = UNSTREAM_STRING( &constant_bin[ 655451 ], 16, 1 );
    const_tuple_str_plain_RSAPublicKey_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_RSAPublicKey_tuple, 0, const_str_plain_RSAPublicKey ); Py_INCREF( const_str_plain_RSAPublicKey );
    const_tuple_f0b7c840b1a9fbe38f5c07adf2fdfe26_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_f0b7c840b1a9fbe38f5c07adf2fdfe26_tuple, 0, const_str_plain_field_name ); Py_INCREF( const_str_plain_field_name );
    PyTuple_SET_ITEM( const_tuple_f0b7c840b1a9fbe38f5c07adf2fdfe26_tuple, 1, const_str_plain_len_method ); Py_INCREF( const_str_plain_len_method );
    const_str_plain_iter_method = UNSTREAM_STRING( &constant_bin[ 702416 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_f0b7c840b1a9fbe38f5c07adf2fdfe26_tuple, 2, const_str_plain_iter_method ); Py_INCREF( const_str_plain_iter_method );
    PyTuple_SET_ITEM( const_tuple_f0b7c840b1a9fbe38f5c07adf2fdfe26_tuple, 3, const_str_plain_getitem_method ); Py_INCREF( const_str_plain_getitem_method );
    const_str_digest_6e39999ae9fa2f733baa4157c3ce7ef9 = UNSTREAM_STRING( &constant_bin[ 702427 ], 25, 0 );
    const_str_digest_1dfb7a6265a6e9db387c1d41869616b8 = UNSTREAM_STRING( &constant_bin[ 702452 ], 37, 0 );
    const_str_digest_c47beb1c7d1e047c9170d20aad4fb97b = UNSTREAM_STRING( &constant_bin[ 702489 ], 117, 0 );
    const_str_digest_2a63548c17bc773344f27e5819855b7b = UNSTREAM_STRING( &constant_bin[ 702606 ], 45, 0 );
    const_tuple_str_plain__only_some_reasons_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__only_some_reasons_tuple, 0, const_str_plain__only_some_reasons ); Py_INCREF( const_str_plain__only_some_reasons );
    const_str_plain__crl_sign = UNSTREAM_STRING( &constant_bin[ 702651 ], 9, 1 );
    const_tuple_str_plain__digest_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__digest_tuple, 0, const_str_plain__digest ); Py_INCREF( const_str_plain__digest );
    const_tuple_str_plain__permitted_subtrees_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__permitted_subtrees_tuple, 0, const_str_plain__permitted_subtrees ); Py_INCREF( const_str_plain__permitted_subtrees );
    const_str_digest_7d42ffe02af672349902ee30e189a05b = UNSTREAM_STRING( &constant_bin[ 702660 ], 71, 0 );
    const_tuple_79831141b0c54263bd4ba55a91ef27c4_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_79831141b0c54263bd4ba55a91ef27c4_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_79831141b0c54263bd4ba55a91ef27c4_tuple, 1, const_str_plain_policy_identifier ); Py_INCREF( const_str_plain_policy_identifier );
    PyTuple_SET_ITEM( const_tuple_79831141b0c54263bd4ba55a91ef27c4_tuple, 2, const_str_plain_policy_qualifiers ); Py_INCREF( const_str_plain_policy_qualifiers );
    const_str_plain__only_contains_user_certs = UNSTREAM_STRING( &constant_bin[ 702731 ], 25, 1 );
    const_str_digest_8f0bd0cc388ffa652d2a12f682c27871 = UNSTREAM_STRING( &constant_bin[ 702756 ], 17, 0 );
    const_str_plain__access_method = UNSTREAM_STRING( &constant_bin[ 702773 ], 14, 1 );
    const_str_digest_198893d8157c272d69767f46f86316c2 = UNSTREAM_STRING( &constant_bin[ 702787 ], 80, 0 );
    const_tuple_str_plain__access_location_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__access_location_tuple, 0, const_str_plain__access_location ); Py_INCREF( const_str_plain__access_location );
    const_str_digest_de6ca45cc2c0d21b3ea9542eeb752d64 = UNSTREAM_STRING( &constant_bin[ 702867 ], 28, 0 );
    const_tuple_str_plain__access_method_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__access_method_tuple, 0, const_str_plain__access_method ); Py_INCREF( const_str_plain__access_method );
    const_tuple_6d08159ea13672603ee689286b27f535_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_6d08159ea13672603ee689286b27f535_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_6d08159ea13672603ee689286b27f535_tuple, 1, const_str_plain_digital_signature ); Py_INCREF( const_str_plain_digital_signature );
    PyTuple_SET_ITEM( const_tuple_6d08159ea13672603ee689286b27f535_tuple, 2, const_str_plain_content_commitment ); Py_INCREF( const_str_plain_content_commitment );
    PyTuple_SET_ITEM( const_tuple_6d08159ea13672603ee689286b27f535_tuple, 3, const_str_plain_key_encipherment ); Py_INCREF( const_str_plain_key_encipherment );
    PyTuple_SET_ITEM( const_tuple_6d08159ea13672603ee689286b27f535_tuple, 4, const_str_plain_data_encipherment ); Py_INCREF( const_str_plain_data_encipherment );
    PyTuple_SET_ITEM( const_tuple_6d08159ea13672603ee689286b27f535_tuple, 5, const_str_plain_key_agreement ); Py_INCREF( const_str_plain_key_agreement );
    PyTuple_SET_ITEM( const_tuple_6d08159ea13672603ee689286b27f535_tuple, 6, const_str_plain_key_cert_sign ); Py_INCREF( const_str_plain_key_cert_sign );
    PyTuple_SET_ITEM( const_tuple_6d08159ea13672603ee689286b27f535_tuple, 7, const_str_plain_crl_sign ); Py_INCREF( const_str_plain_crl_sign );
    PyTuple_SET_ITEM( const_tuple_6d08159ea13672603ee689286b27f535_tuple, 8, const_str_plain_encipher_only ); Py_INCREF( const_str_plain_encipher_only );
    PyTuple_SET_ITEM( const_tuple_6d08159ea13672603ee689286b27f535_tuple, 9, const_str_plain_decipher_only ); Py_INCREF( const_str_plain_decipher_only );
    const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 1, const_str_plain_full_name ); Py_INCREF( const_str_plain_full_name );
    PyTuple_SET_ITEM( const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 2, const_str_plain_relative_name ); Py_INCREF( const_str_plain_relative_name );
    PyTuple_SET_ITEM( const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 3, const_str_plain_only_contains_user_certs ); Py_INCREF( const_str_plain_only_contains_user_certs );
    PyTuple_SET_ITEM( const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 4, const_str_plain_only_contains_ca_certs ); Py_INCREF( const_str_plain_only_contains_ca_certs );
    PyTuple_SET_ITEM( const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 5, const_str_plain_only_some_reasons ); Py_INCREF( const_str_plain_only_some_reasons );
    PyTuple_SET_ITEM( const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 6, const_str_plain_indirect_crl ); Py_INCREF( const_str_plain_indirect_crl );
    PyTuple_SET_ITEM( const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 7, const_str_plain_only_contains_attribute_certs ); Py_INCREF( const_str_plain_only_contains_attribute_certs );
    PyTuple_SET_ITEM( const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 8, const_str_plain_crl_constraints ); Py_INCREF( const_str_plain_crl_constraints );
    PyTuple_SET_ITEM( const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 9, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    const_str_plain_privilegeWithdrawn = UNSTREAM_STRING( &constant_bin[ 702895 ], 18, 1 );
    const_tuple_str_plain__full_name_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__full_name_tuple, 0, const_str_plain__full_name ); Py_INCREF( const_str_plain__full_name );
    const_str_plain_extclass = UNSTREAM_STRING( &constant_bin[ 702913 ], 8, 1 );
    const_str_digest_afa42db89846e96e9cfc2ab56578058d = UNSTREAM_STRING( &constant_bin[ 702921 ], 27, 0 );
    const_str_digest_1ea9692159fa7fd9f8e15a3506f4463c = UNSTREAM_STRING( &constant_bin[ 702948 ], 139, 0 );
    const_str_digest_421b43a5ec9f9f0f5f30b5a50ec3db96 = UNSTREAM_STRING( &constant_bin[ 703087 ], 26, 0 );
    const_str_digest_d0363a16b2327897c21c9e61fd2edb1e = UNSTREAM_STRING( &constant_bin[ 703113 ], 58, 0 );
    const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple, 1, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple, 2, const_str_plain_oid ); Py_INCREF( const_str_plain_oid );
    const_tuple_str_plain__content_commitment_tuple = PyTuple_New( 1 );
    const_str_plain__content_commitment = UNSTREAM_STRING( &constant_bin[ 703171 ], 19, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__content_commitment_tuple, 0, const_str_plain__content_commitment ); Py_INCREF( const_str_plain__content_commitment );
    const_str_digest_87fc424e9112e6987e5fe8e83a94ae22 = UNSTREAM_STRING( &constant_bin[ 703190 ], 41, 0 );
    const_tuple_str_plain_self_str_plain_signed_certificate_timestamps_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_signed_certificate_timestamps_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_signed_certificate_timestamps_tuple, 1, const_str_plain_signed_certificate_timestamps ); Py_INCREF( const_str_plain_signed_certificate_timestamps );
    const_str_digest_e41e00d6ec327bc9d8187afd927a45a2 = UNSTREAM_STRING( &constant_bin[ 703231 ], 59, 0 );
    const_str_digest_449ea3887ada75d14dab0f566d0a778c = UNSTREAM_STRING( &constant_bin[ 703290 ], 47, 0 );
    const_str_digest_293839491199d08c5eee9ab993bbfcfe = UNSTREAM_STRING( &constant_bin[ 703337 ], 55, 0 );
    const_str_digest_009ff6af115398b3dfb26f0926fdbea2 = UNSTREAM_STRING( &constant_bin[ 703392 ], 46, 0 );
    const_unicode_digest_71b136bb2c4e9e2ce7c90a48ee86f246 = UNSTREAM_UNICODE( &constant_bin[ 703438 ], 123 );
    const_tuple_str_plain__usages_tuple = PyTuple_New( 1 );
    const_str_plain__usages = UNSTREAM_STRING( &constant_bin[ 703561 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__usages_tuple, 0, const_str_plain__usages ); Py_INCREF( const_str_plain__usages );
    const_tuple_str_plain__path_length_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__path_length_tuple, 0, const_str_plain__path_length ); Py_INCREF( const_str_plain__path_length );
    const_str_digest_837e2310df6009dd1b110accad73bb42 = UNSTREAM_STRING( &constant_bin[ 703568 ], 50, 0 );
    const_str_plain_from_issuer_public_key = UNSTREAM_STRING( &constant_bin[ 703618 ], 22, 1 );
    const_str_digest_37a5813a8df88d549fa10cdd6f24a9b9 = UNSTREAM_STRING( &constant_bin[ 703640 ], 63, 0 );
    const_tuple_str_plain_self_str_plain_extclass_str_plain_ext_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_extclass_str_plain_ext_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_extclass_str_plain_ext_tuple, 1, const_str_plain_extclass ); Py_INCREF( const_str_plain_extclass );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_extclass_str_plain_ext_tuple, 2, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    const_str_digest_024b912fa6151b94263fc1d09ce49af2 = UNSTREAM_STRING( &constant_bin[ 703703 ], 47, 0 );
    const_tuple_str_plain__authority_cert_serial_number_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__authority_cert_serial_number_tuple, 0, const_str_plain__authority_cert_serial_number ); Py_INCREF( const_str_plain__authority_cert_serial_number );
    const_str_digest_1961eae2d00689b393091e3fc681acbe = UNSTREAM_STRING( &constant_bin[ 703750 ], 32, 0 );
    const_str_digest_3611def0515b06c31df0f70307f767f3 = UNSTREAM_STRING( &constant_bin[ 703782 ], 83, 0 );
    const_tuple_str_plain__indirect_crl_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__indirect_crl_tuple, 0, const_str_plain__indirect_crl ); Py_INCREF( const_str_plain__indirect_crl );
    const_tuple_str_plain_self_str_plain_extensions_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_extensions_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_extensions_tuple, 1, const_str_plain_extensions ); Py_INCREF( const_str_plain_extensions );
    const_tuple_str_plain_self_str_plain_oid_str_plain_ext_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_oid_str_plain_ext_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_oid_str_plain_ext_tuple, 1, const_str_plain_oid ); Py_INCREF( const_str_plain_oid );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_oid_str_plain_ext_tuple, 2, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    const_tuple_str_plain__only_contains_user_certs_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__only_contains_user_certs_tuple, 0, const_str_plain__only_contains_user_certs ); Py_INCREF( const_str_plain__only_contains_user_certs );
    const_str_digest_42aaad2aaa6a1ee7d79f305ebfd1a58b = UNSTREAM_STRING( &constant_bin[ 703865 ], 173, 0 );
    const_str_digest_2e6a7667e25628285e79573956cb938f = UNSTREAM_STRING( &constant_bin[ 704038 ], 36, 0 );
    const_str_plain_from_issuer_subject_key_identifier = UNSTREAM_STRING( &constant_bin[ 698959 ], 34, 1 );
    const_str_digest_56973e3a5f1a8b7f8ba81c36b603bcaa = UNSTREAM_STRING( &constant_bin[ 704074 ], 37, 0 );
    const_tuple_str_plain__crl_sign_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__crl_sign_tuple, 0, const_str_plain__crl_sign ); Py_INCREF( const_str_plain__crl_sign );
    const_tuple_str_plain__invalidity_date_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__invalidity_date_tuple, 0, const_str_plain__invalidity_date ); Py_INCREF( const_str_plain__invalidity_date );
    const_tuple_str_plain__policy_identifier_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__policy_identifier_tuple, 0, const_str_plain__policy_identifier ); Py_INCREF( const_str_plain__policy_identifier );
    const_tuple_9d6859e57abe5ce2ca107f61cc5077a0_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_9d6859e57abe5ce2ca107f61cc5077a0_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_9d6859e57abe5ce2ca107f61cc5077a0_tuple, 1, const_str_plain_require_explicit_policy ); Py_INCREF( const_str_plain_require_explicit_policy );
    PyTuple_SET_ITEM( const_tuple_9d6859e57abe5ce2ca107f61cc5077a0_tuple, 2, const_str_plain_inhibit_policy_mapping ); Py_INCREF( const_str_plain_inhibit_policy_mapping );
    const_tuple_str_plain_self_str_plain_idx_str_plain_field_name_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_idx_str_plain_field_name_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_idx_str_plain_field_name_tuple, 1, const_str_plain_idx ); Py_INCREF( const_str_plain_idx );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_idx_str_plain_field_name_tuple, 2, const_str_plain_field_name ); Py_INCREF( const_str_plain_field_name );
    const_tuple_str_plain_cls_str_plain_ski_str_plain_digest_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_ski_str_plain_digest_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_ski_str_plain_digest_tuple, 1, const_str_plain_ski ); Py_INCREF( const_str_plain_ski );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_ski_str_plain_digest_tuple, 2, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );

    constants_created = true;
}

#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_cryptography$x509$extensions( void )
{
    // The module may not have been used at all.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_c7fe5f8e4c1b93586b4d8d29a0d60610;
static PyCodeObject *codeobj_8017e2f65ba06ea20e193d996eb1cfec;
static PyCodeObject *codeobj_3b42e089c008ee23c7f6e75389fecdbc;
static PyCodeObject *codeobj_8774b456ae1e62ad546755d82447ddb0;
static PyCodeObject *codeobj_96666e03f5705254b116c6bfc15976cf;
static PyCodeObject *codeobj_25020f81cac34ffc251ec44246a595c8;
static PyCodeObject *codeobj_93355c1f035919f49ba1c93c15fa1b26;
static PyCodeObject *codeobj_ff3fcdf462b06c1ccc8f762be3dca470;
static PyCodeObject *codeobj_288d18811543a4caa9a97723100a1438;
static PyCodeObject *codeobj_a093dfbb9eba017c77e90495ad84f46b;
static PyCodeObject *codeobj_32ca2991404875e1f23201079d1225b9;
static PyCodeObject *codeobj_70f950699a834ade1711fc8de5000741;
static PyCodeObject *codeobj_e3704f3371b37ff098d623844cfbee1e;
static PyCodeObject *codeobj_e68b59737d616b587e212e23bf9889ca;
static PyCodeObject *codeobj_a27de6359d8ab3d5836396a97af0dd56;
static PyCodeObject *codeobj_efa7c6c8ebb42411f84380efc042fa9b;
static PyCodeObject *codeobj_f4d9248322167b2ac77a2fb751c6795b;
static PyCodeObject *codeobj_781e6ff451377bc709ff6533ef34d0bb;
static PyCodeObject *codeobj_fa6f15834600be01ff30b260874e5673;
static PyCodeObject *codeobj_81a666e8d664204b6485ad520243bcb4;
static PyCodeObject *codeobj_68b0050ce85ef4a64f787e21fb011498;
static PyCodeObject *codeobj_80de6067447f8063ab4895e4ecf97af8;
static PyCodeObject *codeobj_4f772ca62aff292069d20685ea8ad5a3;
static PyCodeObject *codeobj_69802bcecece78bdea4189479571dd66;
static PyCodeObject *codeobj_9785c3bd15b32f86e88298ed70b78f98;
static PyCodeObject *codeobj_1b99be5f5125e520c5e83672fe393339;
static PyCodeObject *codeobj_46d9b8cdfe49abc480fe0ac59bfd4d0e;
static PyCodeObject *codeobj_0850861f8e53ba258cf8c812b5257de8;
static PyCodeObject *codeobj_a4a29737b836789d950c2cc5c6053ad4;
static PyCodeObject *codeobj_34264ca058405cbbc64ede36ef24ba67;
static PyCodeObject *codeobj_6086204b98cd7a3504a399bfa8318f89;
static PyCodeObject *codeobj_4bcdc3c1413ff63ddaed7210d6b7fcf6;
static PyCodeObject *codeobj_712d92b931f86762fe66868302371b42;
static PyCodeObject *codeobj_d61a1308ab34f09405007abf3d96513d;
static PyCodeObject *codeobj_cf753b2aac21c54581e397ad48de68ce;
static PyCodeObject *codeobj_cc2dd91dca578c1e2053b1e93066de1e;
static PyCodeObject *codeobj_ee3c270008e9c546283aead71bfc3864;
static PyCodeObject *codeobj_dce89ec5d6ba48c58dbdd43f0b34646a;
static PyCodeObject *codeobj_f6cb175ee3c5700aba57c91b105c56e0;
static PyCodeObject *codeobj_91766bb581ac47f3950cf4363ddf6101;
static PyCodeObject *codeobj_bd5df53feaf3918c5d9af33cf2bcef94;
static PyCodeObject *codeobj_729253a47ed1776955e8d27ecd2e7328;
static PyCodeObject *codeobj_2db8e09794d5a59d04ae35a3fa1b13f2;
static PyCodeObject *codeobj_d7dc6886ba34e40cd7ef252f6e349251;
static PyCodeObject *codeobj_d1c2e4d7460a8ac2798c7a347fc9360d;
static PyCodeObject *codeobj_35875bcb7c761051b162bab059cb2263;
static PyCodeObject *codeobj_47c73715590dd417125d0b31840d019d;
static PyCodeObject *codeobj_a0dcedc74a44194c715350024de9064f;
static PyCodeObject *codeobj_465314d58281e7cbbb03e4f8c9567305;
static PyCodeObject *codeobj_d28e44372df668104d77395650e260bf;
static PyCodeObject *codeobj_31d6ad167a415ca40a0d9b8ab50a7ba8;
static PyCodeObject *codeobj_223717f5f7d37ac0eeb879531047bfcf;
static PyCodeObject *codeobj_e048cd6d0ea6ce193f5d3d78a092fb7e;
static PyCodeObject *codeobj_08a1b65564a30b1f1e14109e0bae6149;
static PyCodeObject *codeobj_ee4b5c168c4ba5f7c4d2952f125f81bb;
static PyCodeObject *codeobj_97f6035c4dcab8dd27ed5558d571757a;
static PyCodeObject *codeobj_2098416324e0e575808c7fc7af839a8b;
static PyCodeObject *codeobj_3d456b8c68fc0d32404a21a843d53ce8;
static PyCodeObject *codeobj_cc7a4dc2c94b88b2c8cc7d6f77071a16;
static PyCodeObject *codeobj_57b878bd30a7b81e486b96e3c4401c0a;
static PyCodeObject *codeobj_cd463798241da98486e9c3fa55f5fc4d;
static PyCodeObject *codeobj_4e91e44c3bcc754dd269c486ee08327b;
static PyCodeObject *codeobj_dc0f15fbcff159e2a6f1050cb1735e72;
static PyCodeObject *codeobj_2a4cd2aacba5505bee324db73a85961b;
static PyCodeObject *codeobj_b18c87e2d8e243dd66ad82ea564ebd88;
static PyCodeObject *codeobj_967d20a02668c8df3b981c121e92390c;
static PyCodeObject *codeobj_b7fdc0353e23c582f08622537806bb7a;
static PyCodeObject *codeobj_235720495b109b09daf397b30088ca24;
static PyCodeObject *codeobj_9ee5e0eb8ddcfdfc231fceb269a57aa0;
static PyCodeObject *codeobj_3497c1c37e412baefa4af9a9a209b6ae;
static PyCodeObject *codeobj_8f3f5ca8f9dcd2eee7756b96f3f2bbe0;
static PyCodeObject *codeobj_69a9fb7c23f7735a4e94f6c7a371cd0d;
static PyCodeObject *codeobj_12a61a0f3bdbcdc560a8ea860e2877f1;
static PyCodeObject *codeobj_24eca4c72db0e65a6c34b09011c8543e;
static PyCodeObject *codeobj_48635dd8a2061be9a32ee8f29fed87cb;
static PyCodeObject *codeobj_269cb9bd17342eadc310b70cb566e7ca;
static PyCodeObject *codeobj_b9a64eab02561c7ba59bd763bc6ee1b4;
static PyCodeObject *codeobj_a90aeaeb6f8a3ed1eddebdacaf29192a;
static PyCodeObject *codeobj_d82593620f5895cf8bf3aba5f81ef7d9;
static PyCodeObject *codeobj_c8a574578584b58b662d6a22e972cb4a;
static PyCodeObject *codeobj_186cdc657e777afed82927af6bc4a1ac;
static PyCodeObject *codeobj_8bab69c94615c96edcfa248584419f98;
static PyCodeObject *codeobj_d785c5a91161828fe66a1f09a8282ede;
static PyCodeObject *codeobj_42aded348931584374c6be3e26f3a62e;
static PyCodeObject *codeobj_a4f747c1a224ef94ef7f9cf43f8c3230;
static PyCodeObject *codeobj_723e5289641b14306ae87c96d0c461c6;
static PyCodeObject *codeobj_7346d97a6acf28e8393536b873af6c89;
static PyCodeObject *codeobj_78212c4b4aab735709dfbff7b76cb570;
static PyCodeObject *codeobj_7f765b3590326b8670f2d2e63a18abd5;
static PyCodeObject *codeobj_52a71a816261aa20655054a6cf2cd004;
static PyCodeObject *codeobj_aeb0ee93788492df02f8efe63af9c8d6;
static PyCodeObject *codeobj_3507eef1aab655efc5eb282ddd6df11f;
static PyCodeObject *codeobj_659a0820a281f91b587826d06e5c7fee;
static PyCodeObject *codeobj_fb2d1e86479ac610614a07d93fea0f47;
static PyCodeObject *codeobj_6d5e1e6a7899503b88d3340b3792fdf9;
static PyCodeObject *codeobj_d4425f82b152e2d24c56b73e79a512b0;
static PyCodeObject *codeobj_a028e2d79c3f3de23eb6a9238178dcbb;
static PyCodeObject *codeobj_58ca4cf1e6f5ee2247eee7ab1590e625;
static PyCodeObject *codeobj_2426e68a1691573cdabc00868b370303;
static PyCodeObject *codeobj_eead1fd5104b0d4f8d1d4ffd849695ab;
static PyCodeObject *codeobj_2dbe05eea4e50ba135d849bf18bf240c;
static PyCodeObject *codeobj_5905ebf138e75fb05d5d095e8ff6e294;
static PyCodeObject *codeobj_51616706c0e3c52cf5160713d5617964;
static PyCodeObject *codeobj_8deead5e9a69c59660a72414a4a524b9;
static PyCodeObject *codeobj_a59e3470eb3314c071ae13b9d32dfac6;
static PyCodeObject *codeobj_0f9bf51bf63188a54bf9db4e12622b3b;
static PyCodeObject *codeobj_8fb9d15244005ec133e79705c05a61d3;
static PyCodeObject *codeobj_8e09650574ba24d0fac88dd7967ee8ec;
static PyCodeObject *codeobj_d34b80df37edbf7f7bad1484045d4000;
static PyCodeObject *codeobj_245ca46202f093d6d661d0cc31b2f7cc;
static PyCodeObject *codeobj_fb676fc0aa7f7213b586ead04828ec85;
static PyCodeObject *codeobj_5d6578b18c844fbf92e4e1cc396ff560;
static PyCodeObject *codeobj_595f73a82e458cba3cad4ec3ac173f24;
static PyCodeObject *codeobj_500e5c17bcdaddaa2217eaf4f19855d0;
static PyCodeObject *codeobj_99466dbcc845cc7abe2836db2cfbf366;
static PyCodeObject *codeobj_9bff6aba8635fc588ed756614cb17cb8;
static PyCodeObject *codeobj_05417fe8f5b9303ade0d507b76aed4e3;
static PyCodeObject *codeobj_8e0b8ffe2152f7bb061afe1b8cc2cf5b;
static PyCodeObject *codeobj_501ff7d581b05da1d05a86fe0ad85a96;
static PyCodeObject *codeobj_777c5f1cf0e58ad143e7d4d1541f3a9b;
static PyCodeObject *codeobj_89af66793f1fc61aa38227cde0214ec2;
static PyCodeObject *codeobj_8f969f316377d0f9b0caba40b49b8c02;
static PyCodeObject *codeobj_06ede4ab871537b61c08c580959fa458;
static PyCodeObject *codeobj_177dcec9eb5c8b0e02169c0f6f894e57;
static PyCodeObject *codeobj_551214abb8a6570be6ada69e6e1f5f07;
static PyCodeObject *codeobj_bd49e54fb09a1da0efb6cacab0b984e7;
static PyCodeObject *codeobj_ca7ebae402d55046675fc70d82ea120a;
static PyCodeObject *codeobj_9dc41cd1ae78f5934b45799a32540da0;
static PyCodeObject *codeobj_60b448e7e2dc606440735ac8e5d8691f;
static PyCodeObject *codeobj_40f213b6f11b241a43740142e00ab9ab;
static PyCodeObject *codeobj_9b119bc9e22a532e859a09afb821f8e4;
static PyCodeObject *codeobj_4ca18bfa12c3bc19559b0a1931a20efa;
static PyCodeObject *codeobj_c2b4b4eb68b8cda65212caee479d5c37;
static PyCodeObject *codeobj_7343becceae098df6e086719547e2f7e;
static PyCodeObject *codeobj_e83a154ae2975041ff88351280be1927;
static PyCodeObject *codeobj_fa2931ec8fdcd4814cb233f5a491f5a6;
static PyCodeObject *codeobj_593e248f319c1962ca90d8a41e9a9b37;
static PyCodeObject *codeobj_ceeefbfafb213371719a30a4754165d4;
static PyCodeObject *codeobj_b17d8bfe741848af9af0ee2a9bb1f68b;
static PyCodeObject *codeobj_a584e498103128fd6f0f75adcfa25ce5;
static PyCodeObject *codeobj_5d6754a9c513375f07c3b917f00663b8;
static PyCodeObject *codeobj_5a3287b9f9778171857e124b22ebfc17;
static PyCodeObject *codeobj_bd2f597ab578a8ca34dcbdb4451318c2;
static PyCodeObject *codeobj_5979b7dcae0cb17ab58172bc693ecfcc;
static PyCodeObject *codeobj_797af5f1fd77e5cc555a75349b5fe3c0;
static PyCodeObject *codeobj_27f3275a0ef40b25b2c2ac83a6e7e96d;
static PyCodeObject *codeobj_90f9dc917871442a40fd7dbb81775ea8;
static PyCodeObject *codeobj_2222a6dca432c7c5cdd7e181de61cc46;
static PyCodeObject *codeobj_67f775c2ac36778d8149bcd69067f7f5;
static PyCodeObject *codeobj_869ca61483dae9badd586b13a5a2c497;
static PyCodeObject *codeobj_41d2fca2c6d1a037a39bc7c2cae9471c;
static PyCodeObject *codeobj_f7221220b795ab66d7e03e36dcbe8593;
static PyCodeObject *codeobj_6f138dddb9068ed9deb97d66f8a4a0ad;
static PyCodeObject *codeobj_cdd83968b5926d20e2e7b9ca4d0b58f0;
static PyCodeObject *codeobj_c98d790ca6223d6a3644d33bd2467526;
static PyCodeObject *codeobj_c93644efbdbc7699d1558444ac6d1411;
static PyCodeObject *codeobj_e2a74a50be727bc49fb93340dd76c5a6;
static PyCodeObject *codeobj_275e644d3ba496e282a9a7e1ed6c862f;
static PyCodeObject *codeobj_98f0485697a13d329db62f025ca69055;
static PyCodeObject *codeobj_a832e1e599b4539b0c4897fe94eb7731;
static PyCodeObject *codeobj_1ad98fd393824af3d185d3a361c38cfa;
static PyCodeObject *codeobj_82367caa71540dce30cd160871f23994;
static PyCodeObject *codeobj_e7e78460243290e4e69f97e186caf46f;
static PyCodeObject *codeobj_2d3cca7ece0d16a2395b72a526be98a8;
static PyCodeObject *codeobj_a5a40d86b13e608d03513b23b4a76c2b;
static PyCodeObject *codeobj_75efb6deb95f95a6df103413ee1e48a9;
static PyCodeObject *codeobj_1911d24b26514a8ef43cc8a5f5185162;
static PyCodeObject *codeobj_5cb549ee87f94a874ff5835c02e8bf76;
static PyCodeObject *codeobj_32a5567534533d3fcb64d922d269cbb9;
static PyCodeObject *codeobj_412598eaeb7e5076c659e7571e1acadb;
static PyCodeObject *codeobj_c6ffc7f3b129e13eebcbcd394632062a;
static PyCodeObject *codeobj_2f56c60eb8999fc8e0ae18eca4bed6ea;
static PyCodeObject *codeobj_ff852a570e805f80242c9e3d5522b935;
static PyCodeObject *codeobj_a902b9ea7d61e52337a09f3bba2dcc2f;
static PyCodeObject *codeobj_d1ce443d1458827659a4c2d5d052464f;
static PyCodeObject *codeobj_207c446b384b5fff7b758b710ebcd306;
static PyCodeObject *codeobj_4b0d9409191589b3b8889a0e1a8beb39;
static PyCodeObject *codeobj_63793d5a1ced56f732c5a865370481f9;
static PyCodeObject *codeobj_8735c6c8ac5e6c3fd0af4da21d827208;
static PyCodeObject *codeobj_083fd7a326fcbb7a6d20eb602df89ced;
static PyCodeObject *codeobj_106adc7dbc7e53b3b99843320941121f;
static PyCodeObject *codeobj_2799c6e1c293d05ed77773714e41415f;
static PyCodeObject *codeobj_5ce4859f79d64aac185e077923698816;
static PyCodeObject *codeobj_4e01197d0e4e4c79cdf2d327dc689777;
static PyCodeObject *codeobj_8f443af4d4ccb5dbf9dc156cb2a6b3ee;
static PyCodeObject *codeobj_2546b3ff0691355f96b84825af8536c7;
static PyCodeObject *codeobj_3a5102eb577fb4372f9d34ba72a6e91e;
static PyCodeObject *codeobj_3b9e5fcacf56da1f761df47407c4b7d4;
static PyCodeObject *codeobj_9ba8ec00a538bc1740a345849883dfb7;
static PyCodeObject *codeobj_cea77827f2eac305a5259abe26384ad4;
static PyCodeObject *codeobj_64a6ae9ffc5aa8649774f127c5759ec5;
static PyCodeObject *codeobj_16033c495aaaac6c823cfe41921d5827;
static PyCodeObject *codeobj_24a659e0b5b173b5b0c0638bb94387a8;
static PyCodeObject *codeobj_c664490bf2cb1f2b87743a30375121be;
static PyCodeObject *codeobj_f799b95668610ebc24d3f07b237690e1;
static PyCodeObject *codeobj_d999c9f13b6b8303947563cefca3f80f;
static PyCodeObject *codeobj_b40e6da599a2c89c752888c535860a7a;
static PyCodeObject *codeobj_570758ffab42816481105f89d6aa8913;
static PyCodeObject *codeobj_6cf426505a8a71ab8f24c6f71a74b0cb;
static PyCodeObject *codeobj_7070792c3c3a6ccf6682eea55ee7c662;
static PyCodeObject *codeobj_548e0e17232c8f06b933389489c7d4f9;
static PyCodeObject *codeobj_3bafaa5dacbb94a3ec12b882c27fef71;
static PyCodeObject *codeobj_f9a53cd0e4d5f2dd63b517a6ab23b164;
static PyCodeObject *codeobj_b33015c9c8f142821188a53ad7ed0219;
static PyCodeObject *codeobj_a0de3733aff74e9bc6ad1271640bbb3a;
static PyCodeObject *codeobj_819e7ded813ebd3724f65aaa539d9d5c;
static PyCodeObject *codeobj_a9673f6324198b7604937ea246a4d5fb;
static PyCodeObject *codeobj_41293317db5a160a626e998b0bcaae37;
static PyCodeObject *codeobj_825cf7bc77cbec1bc71ec3174af38633;
static PyCodeObject *codeobj_9577bd5f33b7ffea2ef89eff32e0a9cf;
static PyCodeObject *codeobj_b664d78d6ebdc07d97666d986b9e557d;
static PyCodeObject *codeobj_a0f103b7065a35f97f5a35b2994585aa;
static PyCodeObject *codeobj_0c5f8fcaef9aafcfe368d2f302930746;
static PyCodeObject *codeobj_97bcd8a86a0e71a6d026a07d84b45ed7;
static PyCodeObject *codeobj_e076e7a305486e6abcaf1216659b6e19;
static PyCodeObject *codeobj_751849f6c514a7f7c9c0b68ae52b5141;
static PyCodeObject *codeobj_6e3008cfbd7ffcd179f9b62324e3d1b8;
static PyCodeObject *codeobj_c676f56e52e36e7b954928a8cf5ae824;
static PyCodeObject *codeobj_09be14c4282cabf6b9e19a783dec5f1b;
static PyCodeObject *codeobj_ed63b3fd75ae09f84d1ac8d724b0892b;
static PyCodeObject *codeobj_30db93ecd5f2bde29ae55c0d5f3ae202;
static PyCodeObject *codeobj_093eaa0e810751ddd673b7c5be612109;
static PyCodeObject *codeobj_1b541eeb081b95502e02af418188e21b;
static PyCodeObject *codeobj_e6076427abefcbfd63f41a0300f8f79c;
static PyCodeObject *codeobj_d43c3be20699fac34d3694aa86e1d73a;
static PyCodeObject *codeobj_d730e719f82fc7facbe4eb13d71303fc;
static PyCodeObject *codeobj_ab8ef2a24d0f1a790614f3268e20e185;
static PyCodeObject *codeobj_6cf8b2c589661b0ba098edf538ce526d;
static PyCodeObject *codeobj_8d7d29dbad9addbf58f92f1a4bc533d0;
static PyCodeObject *codeobj_7ff35117673a9277a1a56b314dcb491c;
static PyCodeObject *codeobj_73bb14bed3dfca8611c927e438dcc6d1;
static PyCodeObject *codeobj_022896bc33b4a7204d84fa2b6880e6cc;
static PyCodeObject *codeobj_1929fcfaa60d306de7136ca2141845f6;
static PyCodeObject *codeobj_acac3422c0e3d6f57a7c8462949c204c;
static PyCodeObject *codeobj_333cc1037c812d2229525293f8f2e028;
static PyCodeObject *codeobj_321d3d2d646eb033dd31542f84fb8ad7;
static PyCodeObject *codeobj_dfa357761ff8a2cf04a1e4591e6ba131;
static PyCodeObject *codeobj_6cf10bf052c6bf6b809820f2dbf45aec;
static PyCodeObject *codeobj_e5d51e6845904641cf548956df6959bf;
static PyCodeObject *codeobj_5b8d0f2a0e6c3090c7a94dd8ad77bf87;
static PyCodeObject *codeobj_64cba0da5a657c80e4c65b31e75f4900;
static PyCodeObject *codeobj_408986620bf31dc37b5b1cb7c3f1a6dc;

static void createModuleCodeObjects(void)
{
    module_filename_obj = MAKE_RELATIVE_PATH( const_str_digest_520475ee9f753bee090d1ecadd4c727e );
    codeobj_c7fe5f8e4c1b93586b4d8d29a0d60610 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 187, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8017e2f65ba06ea20e193d996eb1cfec = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 308, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_3b42e089c008ee23c7f6e75389fecdbc = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 447, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8774b456ae1e62ad546755d82447ddb0 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 483, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_96666e03f5705254b116c6bfc15976cf = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 522, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_25020f81cac34ffc251ec44246a595c8 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 535, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_93355c1f035919f49ba1c93c15fa1b26 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 541, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_ff3fcdf462b06c1ccc8f762be3dca470 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 685, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_288d18811543a4caa9a97723100a1438 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 721, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a093dfbb9eba017c77e90495ad84f46b = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 802, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_32ca2991404875e1f23201079d1225b9 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 840, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_70f950699a834ade1711fc8de5000741 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 912, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_e3704f3371b37ff098d623844cfbee1e = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 951, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_e68b59737d616b587e212e23bf9889ca = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 1088, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a27de6359d8ab3d5836396a97af0dd56 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 1100, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_efa7c6c8ebb42411f84380efc042fa9b = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 1131, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_name_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_f4d9248322167b2ac77a2fb751c6795b = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 1204, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_781e6ff451377bc709ff6533ef34d0bb = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 1217, const_tuple_0249ced4da5e72f251db066d967b15dd_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_fa6f15834600be01ff30b260874e5673 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 1219, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_i_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_81a666e8d664204b6485ad520243bcb4 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 1387, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_sct_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_68b0050ce85ef4a64f787e21fb011498 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 1461, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_80de6067447f8063ab4895e4ecf97af8 = MAKE_CODEOBJ( module_filename_obj, const_str_digest_56973e3a5f1a8b7f8ba81c36b603bcaa, 1, const_tuple_empty, 0, CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_4f772ca62aff292069d20685ea8ad5a3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_AccessDescription, 334, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_69802bcecece78bdea4189479571dd66 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_AuthorityInformationAccess, 303, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_9785c3bd15b32f86e88298ed70b78f98 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_AuthorityKeyIdentifier, 171, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_1b99be5f5125e520c5e83672fe393339 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_BasicConstraints, 371, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_46d9b8cdfe49abc480fe0ac59bfd4d0e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_CRLDistributionPoints, 441, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_0850861f8e53ba258cf8c812b5257de8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_CRLNumber, 143, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a4a29737b836789d950c2cc5c6053ad4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_CRLReason, 1323, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_34264ca058405cbbc64ede36ef24ba67 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_CertificateIssuer, 1295, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_6086204b98cd7a3504a399bfa8318f89 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_CertificatePolicies, 680, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_4bcdc3c1413ff63ddaed7210d6b7fcf6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_DeltaCRLIndicator, 413, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_712d92b931f86762fe66868302371b42 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_DistributionPoint, 512, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d61a1308ab34f09405007abf3d96513d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_ExtendedKeyUsage, 835, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_cf753b2aac21c54581e397ad48de68ce = MAKE_CODEOBJ( module_filename_obj, const_str_plain_Extension, 1162, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_cc2dd91dca578c1e2053b1e93066de1e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_ExtensionType, 99, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_ee3c270008e9c546283aead71bfc3864 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_Extensions, 107, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_dce89ec5d6ba48c58dbdd43f0b34646a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_FreshestCRL, 477, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_f6cb175ee3c5700aba57c91b105c56e0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_GeneralNames, 1201, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_91766bb581ac47f3950cf4363ddf6101 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_InhibitAnyPolicy, 955, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_bd5df53feaf3918c5d9af33cf2bcef94 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_InvalidityDate, 1351, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_729253a47ed1776955e8d27ecd2e7328 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_IssuerAlternativeName, 1267, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_2db8e09794d5a59d04ae35a3fa1b13f2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_IssuingDistributionPoint, 1452, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d7dc6886ba34e40cd7ef252f6e349251 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_KeyUsage, 986, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d1c2e4d7460a8ac2798c7a347fc9360d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_NameConstraints, 1081, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_35875bcb7c761051b162bab059cb2263 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_NoticeReference, 798, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_47c73715590dd417125d0b31840d019d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_OCSPNoCheck, 866, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a0dcedc74a44194c715350024de9064f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_OCSPNonce, 1424, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_465314d58281e7cbbb03e4f8c9567305 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PolicyConstraints, 619, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d28e44372df668104d77395650e260bf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PolicyInformation, 711, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_31d6ad167a415ca40a0d9b8ab50a7ba8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PrecertPoison, 886, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_223717f5f7d37ac0eeb879531047bfcf = MAKE_CODEOBJ( module_filename_obj, const_str_digest_97ac982b098bfd0facb64df38773c335, 1381, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_e048cd6d0ea6ce193f5d3d78a092fb7e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_SubjectAlternativeName, 1239, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_08a1b65564a30b1f1e14109e0bae6149 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_SubjectKeyIdentifier, 274, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_ee4b5c168c4ba5f7c4d2952f125f81bb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_TLSFeature, 906, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_97f6035c4dcab8dd27ed5558d571757a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_UnrecognizedExtension, 1582, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_2098416324e0e575808c7fc7af839a8b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_UserNotice, 761, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_3d456b8c68fc0d32404a21a843d53ce8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 152, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_cc7a4dc2c94b88b2c8cc7d6f77071a16 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 243, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_57b878bd30a7b81e486b96e3c4401c0a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 289, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_cd463798241da98486e9c3fa55f5fc4d = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 321, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_4e91e44c3bcc754dd269c486ee08327b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 351, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_dc0f15fbcff159e2a6f1050cb1735e72 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 399, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_2a4cd2aacba5505bee324db73a85961b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 424, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_b18c87e2d8e243dd66ad82ea564ebd88 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 463, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_967d20a02668c8df3b981c121e92390c = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 499, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_b7fdc0353e23c582f08622537806bb7a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 572, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_235720495b109b09daf397b30088ca24 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 654, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_9ee5e0eb8ddcfdfc231fceb269a57aa0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 698, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_3497c1c37e412baefa4af9a9a209b6ae = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 737, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8f3f5ca8f9dcd2eee7756b96f3f2bbe0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 779, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_69a9fb7c23f7735a4e94f6c7a371cd0d = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 815, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_12a61a0f3bdbcdc560a8ea860e2877f1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 852, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_24eca4c72db0e65a6c34b09011c8543e = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 869, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_48635dd8a2061be9a32ee8f29fed87cb = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 889, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_269cb9bd17342eadc310b70cb566e7ca = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 927, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_b9a64eab02561c7ba59bd763bc6ee1b4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 970, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a90aeaeb6f8a3ed1eddebdacaf29192a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1051, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d82593620f5895cf8bf3aba5f81ef7d9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1118, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_c8a574578584b58b662d6a22e972cb4a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1184, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_186cdc657e777afed82927af6bc4a1ac = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1225, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8bab69c94615c96edcfa248584419f98 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1253, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d785c5a91161828fe66a1f09a8282ede = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1281, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_42aded348931584374c6be3e26f3a62e = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1309, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a4f747c1a224ef94ef7f9cf43f8c3230 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1335, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_723e5289641b14306ae87c96d0c461c6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1365, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_7346d97a6acf28e8393536b873af6c89 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1410, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_78212c4b4aab735709dfbff7b76cb570 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1433, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_7f765b3590326b8670f2d2e63a18abd5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1537, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_52a71a816261aa20655054a6cf2cd004 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1599, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_aeb0ee93788492df02f8efe63af9c8d6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 161, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_3507eef1aab655efc5eb282ddd6df11f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 257, const_tuple_str_plain_self_str_plain_aci_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_659a0820a281f91b587826d06e5c7fee = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 298, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_fb2d1e86479ac610614a07d93fea0f47 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 330, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_6d5e1e6a7899503b88d3340b3792fdf9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 363, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d4425f82b152e2d24c56b73e79a512b0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 408, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a028e2d79c3f3de23eb6a9238178dcbb = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 433, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_58ca4cf1e6f5ee2247eee7ab1590e625 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 472, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_2426e68a1691573cdabc00868b370303 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 508, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_eead1fd5104b0d4f8d1d4ffd849695ab = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 586, const_tuple_str_plain_self_str_plain_crl_issuer_str_plain_fn_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_2dbe05eea4e50ba135d849bf18bf240c = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 666, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_5905ebf138e75fb05d5d095e8ff6e294 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 707, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_51616706c0e3c52cf5160713d5617964 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 749, const_tuple_str_plain_self_str_plain_pq_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8deead5e9a69c59660a72414a4a524b9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 791, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a59e3470eb3314c071ae13b9d32dfac6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 827, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_0f9bf51bf63188a54bf9db4e12622b3b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 861, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8fb9d15244005ec133e79705c05a61d3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 878, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8e09650574ba24d0fac88dd7967ee8ec = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 898, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d34b80df37edbf7f7bad1484045d4000 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 936, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_245ca46202f093d6d661d0cc31b2f7cc = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 979, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_fb676fc0aa7f7213b586ead04828ec85 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1070, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_5d6578b18c844fbf92e4e1cc396ff560 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1145, const_tuple_str_plain_self_str_plain_ps_str_plain_es_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_595f73a82e458cba3cad4ec3ac173f24 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1197, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_500e5c17bcdaddaa2217eaf4f19855d0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1234, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_99466dbcc845cc7abe2836db2cfbf366 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1262, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_9bff6aba8635fc588ed756614cb17cb8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1290, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_05417fe8f5b9303ade0d507b76aed4e3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1318, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8e0b8ffe2152f7bb061afe1b8cc2cf5b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1344, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_501ff7d581b05da1d05a86fe0ad85a96 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1374, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_777c5f1cf0e58ad143e7d4d1541f3a9b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1407, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_89af66793f1fc61aa38227cde0214ec2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1442, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8f969f316377d0f9b0caba40b49b8c02 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1555, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_06ede4ab871537b61c08c580959fa458 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1608, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_177dcec9eb5c8b0e02169c0f6f894e57 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 87, const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_551214abb8a6570be6ada69e6e1f5f07 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 93, const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_bd49e54fb09a1da0efb6cacab0b984e7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 108, const_tuple_str_plain_self_str_plain_extensions_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_ca7ebae402d55046675fc70d82ea120a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 146, const_tuple_str_plain_self_str_plain_crl_number_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_9dc41cd1ae78f5934b45799a32540da0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 174, const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_60b448e7e2dc606440735ac8e5d8691f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 277, const_tuple_str_plain_self_str_plain_digest_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_40f213b6f11b241a43740142e00ab9ab = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 306, const_tuple_str_plain_self_str_plain_descriptions_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_9b119bc9e22a532e859a09afb821f8e4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 335, const_tuple_9e442608387cffc806b1f25d569bdb89_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_4ca18bfa12c3bc19559b0a1931a20efa = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 374, const_tuple_str_plain_self_str_plain_ca_str_plain_path_length_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_c2b4b4eb68b8cda65212caee479d5c37 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 416, const_tuple_str_plain_self_str_plain_crl_number_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_7343becceae098df6e086719547e2f7e = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 444, const_tuple_str_plain_self_str_plain_distribution_points_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_e83a154ae2975041ff88351280be1927 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 480, const_tuple_str_plain_self_str_plain_distribution_points_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_fa2931ec8fdcd4814cb233f5a491f5a6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 513, const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_593e248f319c1962ca90d8a41e9a9b37 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 622, const_tuple_9d6859e57abe5ce2ca107f61cc5077a0_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_ceeefbfafb213371719a30a4754165d4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 683, const_tuple_str_plain_self_str_plain_policies_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_b17d8bfe741848af9af0ee2a9bb1f68b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 712, const_tuple_79831141b0c54263bd4ba55a91ef27c4_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a584e498103128fd6f0f75adcfa25ce5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 762, const_tuple_30cc927ede2fc9470dffcd81c25765bb_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_5d6754a9c513375f07c3b917f00663b8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 799, const_tuple_571ef8230a0f951e7e814a3a1b007a73_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_5a3287b9f9778171857e124b22ebfc17 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 838, const_tuple_str_plain_self_str_plain_usages_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_bd2f597ab578a8ca34dcbdb4451318c2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 909, const_tuple_str_plain_self_str_plain_features_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_5979b7dcae0cb17ab58172bc693ecfcc = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 958, const_tuple_str_plain_self_str_plain_skip_certs_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_797af5f1fd77e5cc555a75349b5fe3c0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 989, const_tuple_6d08159ea13672603ee689286b27f535_tuple, 10, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_27f3275a0ef40b25b2c2ac83a6e7e96d = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1084, const_tuple_a73b8498e05ac6f54cfbc844a1aafead_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_90f9dc917871442a40fd7dbb81775ea8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1163, const_tuple_96332c2a391d63d358e15081c1debfb6_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_2222a6dca432c7c5cdd7e181de61cc46 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1202, const_tuple_str_plain_self_str_plain_general_names_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_67f775c2ac36778d8149bcd69067f7f5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1242, const_tuple_str_plain_self_str_plain_general_names_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_869ca61483dae9badd586b13a5a2c497 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1270, const_tuple_str_plain_self_str_plain_general_names_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_41d2fca2c6d1a037a39bc7c2cae9471c = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1298, const_tuple_str_plain_self_str_plain_general_names_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_f7221220b795ab66d7e03e36dcbe8593 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1326, const_tuple_str_plain_self_str_plain_reason_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_6f138dddb9068ed9deb97d66f8a4a0ad = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1354, const_tuple_str_plain_self_str_plain_invalidity_date_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_cdd83968b5926d20e2e7b9ca4d0b58f0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1384, const_tuple_str_plain_self_str_plain_signed_certificate_timestamps_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_c98d790ca6223d6a3644d33bd2467526 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1427, const_tuple_str_plain_self_str_plain_nonce_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_c93644efbdbc7699d1558444ac6d1411 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1455, const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 8, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_e2a74a50be727bc49fb93340dd76c5a6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1583, const_tuple_str_plain_self_str_plain_oid_str_plain_value_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_275e644d3ba496e282a9a7e1ed6c862f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 158, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_98f0485697a13d329db62f025ca69055 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 254, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a832e1e599b4539b0c4897fe94eb7731 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 295, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_1ad98fd393824af3d185d3a361c38cfa = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 327, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_82367caa71540dce30cd160871f23994 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 360, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_e7e78460243290e4e69f97e186caf46f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 405, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_2d3cca7ece0d16a2395b72a526be98a8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 430, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a5a40d86b13e608d03513b23b4a76c2b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 469, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_75efb6deb95f95a6df103413ee1e48a9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 505, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_1911d24b26514a8ef43cc8a5f5185162 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 583, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_5cb549ee87f94a874ff5835c02e8bf76 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 663, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_32a5567534533d3fcb64d922d269cbb9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 704, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_412598eaeb7e5076c659e7571e1acadb = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 746, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_c6ffc7f3b129e13eebcbcd394632062a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 788, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_2f56c60eb8999fc8e0ae18eca4bed6ea = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 824, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_ff852a570e805f80242c9e3d5522b935 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 858, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a902b9ea7d61e52337a09f3bba2dcc2f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 875, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d1ce443d1458827659a4c2d5d052464f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 895, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_207c446b384b5fff7b758b710ebcd306 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 933, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_4b0d9409191589b3b8889a0e1a8beb39 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 976, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_63793d5a1ced56f732c5a865370481f9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1067, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8735c6c8ac5e6c3fd0af4da21d827208 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1127, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_083fd7a326fcbb7a6d20eb602df89ced = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1194, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_106adc7dbc7e53b3b99843320941121f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1231, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_2799c6e1c293d05ed77773714e41415f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1259, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_5ce4859f79d64aac185e077923698816 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1287, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_4e01197d0e4e4c79cdf2d327dc689777 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1315, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8f443af4d4ccb5dbf9dc156cb2a6b3ee = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1341, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_2546b3ff0691355f96b84825af8536c7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1371, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_3a5102eb577fb4372f9d34ba72a6e91e = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1419, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_3b9e5fcacf56da1f761df47407c4b7d4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1439, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_9ba8ec00a538bc1740a345849883dfb7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1552, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_cea77827f2eac305a5259abe26384ad4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1605, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_64a6ae9ffc5aa8649774f127c5759ec5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 136, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_16033c495aaaac6c823cfe41921d5827 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 164, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_24a659e0b5b173b5b0c0638bb94387a8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 235, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_c664490bf2cb1f2b87743a30375121be = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 286, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_f799b95668610ebc24d3f07b237690e1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 318, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d999c9f13b6b8303947563cefca3f80f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 345, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_b40e6da599a2c89c752888c535860a7a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 395, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_570758ffab42816481105f89d6aa8913 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 436, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_6cf426505a8a71ab8f24c6f71a74b0cb = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 460, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_7070792c3c3a6ccf6682eea55ee7c662 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 496, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_548e0e17232c8f06b933389489c7d4f9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 565, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_3bafaa5dacbb94a3ec12b882c27fef71 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 647, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_f9a53cd0e4d5f2dd63b517a6ab23b164 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 695, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_b33015c9c8f142821188a53ad7ed0219 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 731, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a0de3733aff74e9bc6ad1271640bbb3a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 773, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_819e7ded813ebd3724f65aaa539d9d5c = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 809, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a9673f6324198b7604937ea246a4d5fb = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 849, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_41293317db5a160a626e998b0bcaae37 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 881, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_825cf7bc77cbec1bc71ec3174af38633 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 901, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_9577bd5f33b7ffea2ef89eff32e0a9cf = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 924, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_b664d78d6ebdc07d97666d986b9e557d = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 967, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a0f103b7065a35f97f5a35b2994585aa = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1034, const_tuple_40c66ae610f06e095b8a28b392d109cb_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_0c5f8fcaef9aafcfe368d2f302930746 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1139, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_97bcd8a86a0e71a6d026a07d84b45ed7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1180, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_e076e7a305486e6abcaf1216659b6e19 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1222, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_751849f6c514a7f7c9c0b68ae52b5141 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1250, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_6e3008cfbd7ffcd179f9b62324e3d1b8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1278, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_c676f56e52e36e7b954928a8cf5ae824 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1306, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_09be14c4282cabf6b9e19a783dec5f1b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1332, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_ed63b3fd75ae09f84d1ac8d724b0892b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1360, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_30db93ecd5f2bde29ae55c0d5f3ae202 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1400, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_093eaa0e810751ddd673b7c5be612109 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1445, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_1b541eeb081b95502e02af418188e21b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1525, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_e6076427abefcbfd63f41a0300f8f79c = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1592, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d43c3be20699fac34d3694aa86e1d73a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__key_identifier_from_public_key, 33, const_tuple_828872b32a88e627e2f72e22e0a4680e_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d730e719f82fc7facbe4eb13d71303fc = MAKE_CODEOBJ( module_filename_obj, const_str_plain__make_sequence_methods, 73, const_tuple_f0b7c840b1a9fbe38f5c07adf2fdfe26_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_ab8ef2a24d0f1a790614f3268e20e185 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__validate_ip_name, 1130, const_tuple_str_plain_self_str_plain_tree_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_6cf8b2c589661b0ba098edf538ce526d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_decipher_only, 1025, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8d7d29dbad9addbf58f92f1a4bc533d0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_encipher_only, 1016, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_7ff35117673a9277a1a56b314dcb491c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_from_issuer_public_key, 205, const_tuple_str_plain_cls_str_plain_public_key_str_plain_digest_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_73bb14bed3dfca8611c927e438dcc6d1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_from_issuer_subject_key_identifier, 214, const_tuple_str_plain_cls_str_plain_ski_str_plain_digest_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_022896bc33b4a7204d84fa2b6880e6cc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_from_public_key, 280, const_tuple_str_plain_cls_str_plain_public_key_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_1929fcfaa60d306de7136ca2141845f6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_extension_for_class, 118, const_tuple_str_plain_self_str_plain_extclass_str_plain_ext_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_acac3422c0e3d6f57a7c8462949c204c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_extension_for_oid, 111, const_tuple_str_plain_self_str_plain_oid_str_plain_ext_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_333cc1037c812d2229525293f8f2e028 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_values_for_type, 1213, const_tuple_str_plain_self_str_plain_type_str_plain_objs_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_321d3d2d646eb033dd31542f84fb8ad7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_values_for_type, 1247, const_tuple_str_plain_self_str_plain_type_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_dfa357761ff8a2cf04a1e4591e6ba131 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_values_for_type, 1275, const_tuple_str_plain_self_str_plain_type_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_6cf10bf052c6bf6b809820f2dbf45aec = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_values_for_type, 1303, const_tuple_str_plain_self_str_plain_type_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_e5d51e6845904641cf548956df6959bf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getitem_method, 80, const_tuple_str_plain_self_str_plain_idx_str_plain_field_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_5b8d0f2a0e6c3090c7a94dd8ad77bf87 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_iter_method, 77, const_tuple_str_plain_self_str_plain_field_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_64cba0da5a657c80e4c65b31e75f4900 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_len_method, 74, const_tuple_str_plain_self_str_plain_field_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_408986620bf31dc37b5b1cb7c3f1a6dc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_oid, 100, const_tuple_str_plain_self_tuple, 1, CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
}

// The module function declarations.
#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_15___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_15___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_28___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_28___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_48___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_48___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_58___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_58___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_58___init__$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_58___init__$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_58___init__$$$genexpr_3_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_58___init__$$$genexpr_3_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_68___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_68___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_73___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_73___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_83___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_83___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_88___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_88___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_101___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_101___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_118___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_118___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_118___init__$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_118___init__$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_121__validate_ip_name$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_121__validate_ip_name$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_130_get_values_for_type$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_130_get_values_for_type$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_130_get_values_for_type$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_130_get_values_for_type$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_163___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_163___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_173___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void cryptography$x509$extensions$$$function_173___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_100___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_101___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_102___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_103___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_104___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_105___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_106___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_107___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_108___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_109___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_10___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_110___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_111___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_112_encipher_only(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_113_decipher_only(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_114___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_115___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_116___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_117___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_118___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_119___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_11___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_120___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_121__validate_ip_name(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_122___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_123___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_124___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_125___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_126___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_127___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_128___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_129___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_12___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_130_get_values_for_type(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_131___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_132___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_133___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_134___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_135___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_136_get_values_for_type(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_137___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_138___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_139___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_13___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_140___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_141___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_142_get_values_for_type(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_143___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_144___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_145___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_146___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_147___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_148_get_values_for_type(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_149___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_14___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_150___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_151___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_152___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_153___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_154___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_155___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_156___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_157___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_158___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_159___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_15___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_160___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_161___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_162___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_163___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_164___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_165___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_166___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_167___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_168___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_169___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_16_from_issuer_public_key(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_170___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_171___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_172___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_173___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_174___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_175___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_176___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_177___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_178___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_179___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_17_from_issuer_subject_key_identifier(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_180___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_181___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_182___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_18___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_19___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_1__key_identifier_from_public_key(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_20___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_21___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_22___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_23_from_public_key(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_24___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_25___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_26___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_27___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_28___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_29___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_2__make_sequence_methods(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_1_len_method( struct Nuitka_CellObject *closure_field_name );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_2_iter_method( struct Nuitka_CellObject *closure_field_name );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_3_getitem_method( struct Nuitka_CellObject *closure_field_name );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_30___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_31___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_32___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_33___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_34___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_35___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_36___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_37___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_38___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_39___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_3___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_40___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_41___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_42___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_43___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_44___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_45___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_46___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_47___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_48___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_49___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_4___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_50___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_51___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_52___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_53___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_54___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_55___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_56___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_57___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_58___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_59___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_5_oid(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_60___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_61___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_62___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_63___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_64___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_65___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_66___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_67___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_68___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_69___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_6___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_70___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_71___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_72___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_73___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_74___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_75___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_76___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_77___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_78___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_79___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_7_get_extension_for_oid(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_80___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_81___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_82___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_83___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_84___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_85___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_86___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_87___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_88___init__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_89___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_8_get_extension_for_class(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_90___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_91___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_92___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_93___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_94___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_95___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_96___repr__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_97___eq__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_98___ne__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_99___hash__(  );


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_9___repr__(  );


// The module function definitions.
static PyObject *impl_cryptography$x509$extensions$$$function_1__key_identifier_from_public_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_public_key = python_pars[ 0 ];
    PyObject *var_algorithm = NULL;
    PyObject *var_serialized = NULL;
    PyObject *var_public_key_info = NULL;
    PyObject *var_reader = NULL;
    PyObject *var_data = NULL;
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__exit = NULL;
    PyObject *tmp_with_1__indicator = NULL;
    PyObject *tmp_with_1__source = NULL;
    PyObject *tmp_with_2__enter = NULL;
    PyObject *tmp_with_2__exit = NULL;
    PyObject *tmp_with_2__indicator = NULL;
    PyObject *tmp_with_2__source = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    bool tmp_is_1;
    bool tmp_is_2;
    bool tmp_is_3;
    bool tmp_is_4;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    PyObject *tmp_source_name_19;
    PyObject *tmp_source_name_20;
    PyObject *tmp_source_name_21;
    PyObject *tmp_source_name_22;
    PyObject *tmp_source_name_23;
    PyObject *tmp_source_name_24;
    PyObject *tmp_source_name_25;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_d43c3be20699fac34d3694aa86e1d73a = NULL;

    struct Nuitka_FrameObject *frame_d43c3be20699fac34d3694aa86e1d73a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d43c3be20699fac34d3694aa86e1d73a, codeobj_d43c3be20699fac34d3694aa86e1d73a, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d43c3be20699fac34d3694aa86e1d73a = cache_frame_d43c3be20699fac34d3694aa86e1d73a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d43c3be20699fac34d3694aa86e1d73a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d43c3be20699fac34d3694aa86e1d73a ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_public_key;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_RSAPublicKey );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_RSAPublicKey );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "RSAPublicKey" );
        exception_tb = NULL;

        exception_lineno = 34;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 34;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = par_public_key;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_public_bytes );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 35;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_serialization );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "serialization" );
        exception_tb = NULL;

        exception_lineno = 36;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_Encoding );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 36;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_DER );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 36;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_serialization );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "serialization" );
        exception_tb = NULL;

        exception_lineno = 37;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_PublicFormat );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 37;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_PKCS1 );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 37;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 35;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 35;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_data == NULL );
    var_data = tmp_assign_source_1;

    goto branch_end_1;
    branch_no_1:;
    tmp_isinstance_inst_2 = par_public_key;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_isinstance_cls_2 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_EllipticCurvePublicKey );

    if (unlikely( tmp_isinstance_cls_2 == NULL ))
    {
        tmp_isinstance_cls_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_EllipticCurvePublicKey );
    }

    if ( tmp_isinstance_cls_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "EllipticCurvePublicKey" );
        exception_tb = NULL;

        exception_lineno = 39;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_6 = par_public_key;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_public_bytes );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 40;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_serialization );
    }

    if ( tmp_source_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "serialization" );
        exception_tb = NULL;

        exception_lineno = 41;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_Encoding );
    if ( tmp_source_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 41;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_X962 );
    Py_DECREF( tmp_source_name_7 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 41;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_serialization );
    }

    if ( tmp_source_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "serialization" );
        exception_tb = NULL;

        exception_lineno = 42;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_PublicFormat );
    if ( tmp_source_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 42;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_UncompressedPoint );
    Py_DECREF( tmp_source_name_9 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 42;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 40;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 40;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_data == NULL );
    var_data = tmp_assign_source_2;

    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_11 = par_public_key;

    CHECK_OBJECT( tmp_source_name_11 );
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_public_bytes );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 46;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_13 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization );

    if (unlikely( tmp_source_name_13 == NULL ))
    {
        tmp_source_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_serialization );
    }

    if ( tmp_source_name_13 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "serialization" );
        exception_tb = NULL;

        exception_lineno = 47;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_Encoding );
    if ( tmp_source_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 47;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_DER );
    Py_DECREF( tmp_source_name_12 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 47;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_15 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization );

    if (unlikely( tmp_source_name_15 == NULL ))
    {
        tmp_source_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_serialization );
    }

    if ( tmp_source_name_15 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "serialization" );
        exception_tb = NULL;

        exception_lineno = 48;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_PublicFormat );
    if ( tmp_source_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 48;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_SubjectPublicKeyInfo );
    Py_DECREF( tmp_source_name_14 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 48;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 46;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 46;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_serialized == NULL );
    var_serialized = tmp_assign_source_3;

    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DERReader );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DERReader );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "DERReader" );
        exception_tb = NULL;

        exception_lineno = 51;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = var_serialized;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 51;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 51;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_reader == NULL );
    var_reader = tmp_assign_source_4;

    // Tried code:
    tmp_source_name_16 = var_reader;

    CHECK_OBJECT( tmp_source_name_16 );
    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_read_single_element );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 52;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_8 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SEQUENCE );

    if (unlikely( tmp_args_element_name_8 == NULL ))
    {
        tmp_args_element_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SEQUENCE );
    }

    if ( tmp_args_element_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "SEQUENCE" );
        exception_tb = NULL;

        exception_lineno = 52;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 52;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 52;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    assert( tmp_with_1__source == NULL );
    tmp_with_1__source = tmp_assign_source_5;

    tmp_source_name_17 = tmp_with_1__source;

    CHECK_OBJECT( tmp_source_name_17 );
    tmp_assign_source_6 = LOOKUP_SPECIAL( tmp_source_name_17, const_str_plain___exit__ );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 52;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    assert( tmp_with_1__exit == NULL );
    tmp_with_1__exit = tmp_assign_source_6;

    tmp_source_name_18 = tmp_with_1__source;

    CHECK_OBJECT( tmp_source_name_18 );
    tmp_called_name_6 = LOOKUP_SPECIAL( tmp_source_name_18, const_str_plain___enter__ );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 52;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 52;
    tmp_assign_source_7 = CALL_FUNCTION_NO_ARGS( tmp_called_name_6 );
    Py_DECREF( tmp_called_name_6 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 52;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    assert( tmp_with_1__enter == NULL );
    tmp_with_1__enter = tmp_assign_source_7;

    tmp_assign_source_8 = Py_True;
    assert( tmp_with_1__indicator == NULL );
    Py_INCREF( tmp_assign_source_8 );
    tmp_with_1__indicator = tmp_assign_source_8;

    tmp_assign_source_9 = tmp_with_1__enter;

    CHECK_OBJECT( tmp_assign_source_9 );
    assert( var_public_key_info == NULL );
    Py_INCREF( tmp_assign_source_9 );
    var_public_key_info = tmp_assign_source_9;

    // Tried code:
    // Tried code:
    tmp_source_name_19 = var_public_key_info;

    CHECK_OBJECT( tmp_source_name_19 );
    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_read_element );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 53;
        type_description_1 = "oooooo";
        goto try_except_handler_4;
    }
    tmp_args_element_name_9 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SEQUENCE );

    if (unlikely( tmp_args_element_name_9 == NULL ))
    {
        tmp_args_element_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SEQUENCE );
    }

    if ( tmp_args_element_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "SEQUENCE" );
        exception_tb = NULL;

        exception_lineno = 53;
        type_description_1 = "oooooo";
        goto try_except_handler_4;
    }

    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 53;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_assign_source_10 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 53;
        type_description_1 = "oooooo";
        goto try_except_handler_4;
    }
    assert( var_algorithm == NULL );
    var_algorithm = tmp_assign_source_10;

    tmp_source_name_20 = var_public_key_info;

    CHECK_OBJECT( tmp_source_name_20 );
    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_read_element );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;
        type_description_1 = "oooooo";
        goto try_except_handler_4;
    }
    tmp_args_element_name_10 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_BIT_STRING );

    if (unlikely( tmp_args_element_name_10 == NULL ))
    {
        tmp_args_element_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_BIT_STRING );
    }

    if ( tmp_args_element_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_8 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "BIT_STRING" );
        exception_tb = NULL;

        exception_lineno = 54;
        type_description_1 = "oooooo";
        goto try_except_handler_4;
    }

    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 54;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_assign_source_11 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_called_name_8 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;
        type_description_1 = "oooooo";
        goto try_except_handler_4;
    }
    {
        PyObject *old = par_public_key;
        assert( old != NULL );
        par_public_key = tmp_assign_source_11;
        Py_DECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_d43c3be20699fac34d3694aa86e1d73a );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_d43c3be20699fac34d3694aa86e1d73a, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_d43c3be20699fac34d3694aa86e1d73a, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = PyExc_BaseException;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 52;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_assign_source_12 = Py_False;
    {
        PyObject *old = tmp_with_1__indicator;
        assert( old != NULL );
        tmp_with_1__indicator = tmp_assign_source_12;
        Py_INCREF( tmp_with_1__indicator );
        Py_DECREF( old );
    }

    tmp_called_name_9 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_9 );
    tmp_args_element_name_11 = PyThreadState_GET()->exc_type;
    tmp_args_element_name_12 = PyThreadState_GET()->exc_value;
    tmp_args_element_name_13 = PyThreadState_GET()->exc_traceback;
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 52;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12, tmp_args_element_name_13 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_9, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 52;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 52;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 52;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_d43c3be20699fac34d3694aa86e1d73a->m_frame) frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooooo";
    goto try_except_handler_3;
    branch_no_4:;
    goto branch_end_3;
    branch_no_3:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 52;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_d43c3be20699fac34d3694aa86e1d73a->m_frame) frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooooo";
    goto try_except_handler_3;
    branch_end_3:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_1__key_identifier_from_public_key );
    return NULL;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_2 = tmp_with_1__indicator;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = Py_True;
    tmp_is_1 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    if ( tmp_is_1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_10 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_10 );
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 52;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_10, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 52;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    tmp_compare_left_3 = tmp_with_1__indicator;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = Py_True;
    tmp_is_2 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_2 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_called_name_11 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_11 );
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 52;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_11, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 52;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_6:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    Py_XDECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    Py_XDECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    // Tried code:
    tmp_assign_source_13 = var_algorithm;

    if ( tmp_assign_source_13 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "algorithm" );
        exception_tb = NULL;

        exception_lineno = 57;
        type_description_1 = "oooooo";
        goto try_except_handler_5;
    }

    assert( tmp_with_2__source == NULL );
    Py_INCREF( tmp_assign_source_13 );
    tmp_with_2__source = tmp_assign_source_13;

    tmp_source_name_21 = tmp_with_2__source;

    CHECK_OBJECT( tmp_source_name_21 );
    tmp_assign_source_14 = LOOKUP_SPECIAL( tmp_source_name_21, const_str_plain___exit__ );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 57;
        type_description_1 = "oooooo";
        goto try_except_handler_5;
    }
    assert( tmp_with_2__exit == NULL );
    tmp_with_2__exit = tmp_assign_source_14;

    tmp_source_name_22 = tmp_with_2__source;

    CHECK_OBJECT( tmp_source_name_22 );
    tmp_called_name_12 = LOOKUP_SPECIAL( tmp_source_name_22, const_str_plain___enter__ );
    if ( tmp_called_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 57;
        type_description_1 = "oooooo";
        goto try_except_handler_5;
    }
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 57;
    tmp_assign_source_15 = CALL_FUNCTION_NO_ARGS( tmp_called_name_12 );
    Py_DECREF( tmp_called_name_12 );
    if ( tmp_assign_source_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 57;
        type_description_1 = "oooooo";
        goto try_except_handler_5;
    }
    assert( tmp_with_2__enter == NULL );
    tmp_with_2__enter = tmp_assign_source_15;

    tmp_assign_source_16 = Py_True;
    assert( tmp_with_2__indicator == NULL );
    Py_INCREF( tmp_assign_source_16 );
    tmp_with_2__indicator = tmp_assign_source_16;

    // Tried code:
    // Tried code:
    tmp_source_name_23 = var_algorithm;

    if ( tmp_source_name_23 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "algorithm" );
        exception_tb = NULL;

        exception_lineno = 58;
        type_description_1 = "oooooo";
        goto try_except_handler_7;
    }

    tmp_called_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain_read_element );
    if ( tmp_called_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 58;
        type_description_1 = "oooooo";
        goto try_except_handler_7;
    }
    tmp_args_element_name_14 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OBJECT_IDENTIFIER );

    if (unlikely( tmp_args_element_name_14 == NULL ))
    {
        tmp_args_element_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OBJECT_IDENTIFIER );
    }

    if ( tmp_args_element_name_14 == NULL )
    {
        Py_DECREF( tmp_called_name_13 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "OBJECT_IDENTIFIER" );
        exception_tb = NULL;

        exception_lineno = 58;
        type_description_1 = "oooooo";
        goto try_except_handler_7;
    }

    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 58;
    {
        PyObject *call_args[] = { tmp_args_element_name_14 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
    }

    Py_DECREF( tmp_called_name_13 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 58;
        type_description_1 = "oooooo";
        goto try_except_handler_7;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_1 = var_algorithm;

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "algorithm" );
        exception_tb = NULL;

        exception_lineno = 59;
        type_description_1 = "oooooo";
        goto try_except_handler_7;
    }

    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 59;
    tmp_cond_value_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_is_empty );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 59;
        type_description_1 = "oooooo";
        goto try_except_handler_7;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 59;
        type_description_1 = "oooooo";
        goto try_except_handler_7;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_7;
    }
    else
    {
        goto branch_yes_7;
    }
    branch_yes_7:;
    tmp_called_instance_2 = var_algorithm;

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "algorithm" );
        exception_tb = NULL;

        exception_lineno = 61;
        type_description_1 = "oooooo";
        goto try_except_handler_7;
    }

    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 61;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_read_any_element );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 61;
        type_description_1 = "oooooo";
        goto try_except_handler_7;
    }
    Py_DECREF( tmp_unused );
    branch_no_7:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_d43c3be20699fac34d3694aa86e1d73a );
    if ( exception_keeper_tb_4 == NULL )
    {
        exception_keeper_tb_4 = MAKE_TRACEBACK( frame_d43c3be20699fac34d3694aa86e1d73a, exception_keeper_lineno_4 );
    }
    else if ( exception_keeper_lineno_4 != 0 )
    {
        exception_keeper_tb_4 = ADD_TRACEBACK( exception_keeper_tb_4, frame_d43c3be20699fac34d3694aa86e1d73a, exception_keeper_lineno_4 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_4, &exception_keeper_value_4, &exception_keeper_tb_4 );
    PUBLISH_EXCEPTION( &exception_keeper_type_4, &exception_keeper_value_4, &exception_keeper_tb_4 );
    tmp_compare_left_4 = PyThreadState_GET()->exc_type;
    tmp_compare_right_4 = PyExc_BaseException;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_4, tmp_compare_right_4 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 57;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_assign_source_17 = Py_False;
    {
        PyObject *old = tmp_with_2__indicator;
        assert( old != NULL );
        tmp_with_2__indicator = tmp_assign_source_17;
        Py_INCREF( tmp_with_2__indicator );
        Py_DECREF( old );
    }

    tmp_called_name_14 = tmp_with_2__exit;

    CHECK_OBJECT( tmp_called_name_14 );
    tmp_args_element_name_15 = PyThreadState_GET()->exc_type;
    tmp_args_element_name_16 = PyThreadState_GET()->exc_value;
    tmp_args_element_name_17 = PyThreadState_GET()->exc_traceback;
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 57;
    {
        PyObject *call_args[] = { tmp_args_element_name_15, tmp_args_element_name_16, tmp_args_element_name_17 };
        tmp_cond_value_3 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_14, call_args );
    }

    if ( tmp_cond_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 57;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 57;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_no_9;
    }
    else
    {
        goto branch_yes_9;
    }
    branch_yes_9:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 57;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_d43c3be20699fac34d3694aa86e1d73a->m_frame) frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooooo";
    goto try_except_handler_6;
    branch_no_9:;
    goto branch_end_8;
    branch_no_8:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 57;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_d43c3be20699fac34d3694aa86e1d73a->m_frame) frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooooo";
    goto try_except_handler_6;
    branch_end_8:;
    goto try_end_4;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_1__key_identifier_from_public_key );
    return NULL;
    // End of try:
    try_end_4:;
    goto try_end_5;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_5 = tmp_with_2__indicator;

    CHECK_OBJECT( tmp_compare_left_5 );
    tmp_compare_right_5 = Py_True;
    tmp_is_3 = ( tmp_compare_left_5 == tmp_compare_right_5 );
    if ( tmp_is_3 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    tmp_called_name_15 = tmp_with_2__exit;

    CHECK_OBJECT( tmp_called_name_15 );
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 57;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_15, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_5 );
        Py_XDECREF( exception_keeper_value_5 );
        Py_XDECREF( exception_keeper_tb_5 );

        exception_lineno = 57;
        type_description_1 = "oooooo";
        goto try_except_handler_5;
    }
    Py_DECREF( tmp_unused );
    branch_no_10:;
    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto try_except_handler_5;
    // End of try:
    try_end_5:;
    tmp_compare_left_6 = tmp_with_2__indicator;

    CHECK_OBJECT( tmp_compare_left_6 );
    tmp_compare_right_6 = Py_True;
    tmp_is_4 = ( tmp_compare_left_6 == tmp_compare_right_6 );
    if ( tmp_is_4 )
    {
        goto branch_yes_11;
    }
    else
    {
        goto branch_no_11;
    }
    branch_yes_11:;
    tmp_called_name_16 = tmp_with_2__exit;

    CHECK_OBJECT( tmp_called_name_16 );
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 57;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_16, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 57;
        type_description_1 = "oooooo";
        goto try_except_handler_5;
    }
    Py_DECREF( tmp_unused );
    branch_no_11:;
    goto try_end_6;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_with_2__source );
    tmp_with_2__source = NULL;

    Py_XDECREF( tmp_with_2__enter );
    tmp_with_2__enter = NULL;

    Py_XDECREF( tmp_with_2__exit );
    tmp_with_2__exit = NULL;

    Py_XDECREF( tmp_with_2__indicator );
    tmp_with_2__indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    CHECK_OBJECT( (PyObject *)tmp_with_2__source );
    Py_DECREF( tmp_with_2__source );
    tmp_with_2__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_2__enter );
    Py_DECREF( tmp_with_2__enter );
    tmp_with_2__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_2__exit );
    Py_DECREF( tmp_with_2__exit );
    tmp_with_2__exit = NULL;

    Py_XDECREF( tmp_with_2__indicator );
    tmp_with_2__indicator = NULL;

    tmp_called_instance_3 = par_public_key;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 65;
    tmp_compare_left_7 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_read_byte );
    if ( tmp_compare_left_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 65;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_7 = const_int_0;
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_7, tmp_compare_right_7 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_7 );

        exception_lineno = 65;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_7 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_12;
    }
    else
    {
        goto branch_no_12;
    }
    branch_yes_12:;
    tmp_make_exception_arg_1 = const_str_digest_dbdc4cc574491d1286f5938d4480dec8;
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 66;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 66;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooo";
    goto frame_exception_exit_1;
    branch_no_12:;
    tmp_source_name_24 = par_public_key;

    CHECK_OBJECT( tmp_source_name_24 );
    tmp_assign_source_18 = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain_data );
    if ( tmp_assign_source_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 68;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_data == NULL );
    var_data = tmp_assign_source_18;

    branch_end_2:;
    branch_end_1:;
    tmp_source_name_25 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_hashlib );

    if (unlikely( tmp_source_name_25 == NULL ))
    {
        tmp_source_name_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_hashlib );
    }

    if ( tmp_source_name_25 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "hashlib" );
        exception_tb = NULL;

        exception_lineno = 70;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_25, const_str_plain_sha1 );
    if ( tmp_called_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 70;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_18 = var_data;

    if ( tmp_args_element_name_18 == NULL )
    {
        Py_DECREF( tmp_called_name_17 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "data" );
        exception_tb = NULL;

        exception_lineno = 70;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 70;
    {
        PyObject *call_args[] = { tmp_args_element_name_18 };
        tmp_called_instance_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_17, call_args );
    }

    Py_DECREF( tmp_called_name_17 );
    if ( tmp_called_instance_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 70;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_d43c3be20699fac34d3694aa86e1d73a->m_frame.f_lineno = 70;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_digest );
    Py_DECREF( tmp_called_instance_4 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 70;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_d43c3be20699fac34d3694aa86e1d73a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_d43c3be20699fac34d3694aa86e1d73a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_d43c3be20699fac34d3694aa86e1d73a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d43c3be20699fac34d3694aa86e1d73a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d43c3be20699fac34d3694aa86e1d73a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d43c3be20699fac34d3694aa86e1d73a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d43c3be20699fac34d3694aa86e1d73a,
        type_description_1,
        par_public_key,
        var_algorithm,
        var_serialized,
        var_public_key_info,
        var_reader,
        var_data
    );


    // Release cached frame.
    if ( frame_d43c3be20699fac34d3694aa86e1d73a == cache_frame_d43c3be20699fac34d3694aa86e1d73a )
    {
        Py_DECREF( frame_d43c3be20699fac34d3694aa86e1d73a );
    }
    cache_frame_d43c3be20699fac34d3694aa86e1d73a = NULL;

    assertFrameObject( frame_d43c3be20699fac34d3694aa86e1d73a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_1__key_identifier_from_public_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_public_key );
    par_public_key = NULL;

    Py_XDECREF( var_algorithm );
    var_algorithm = NULL;

    Py_XDECREF( var_serialized );
    var_serialized = NULL;

    Py_XDECREF( var_public_key_info );
    var_public_key_info = NULL;

    Py_XDECREF( var_reader );
    var_reader = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_public_key );
    par_public_key = NULL;

    Py_XDECREF( var_algorithm );
    var_algorithm = NULL;

    Py_XDECREF( var_serialized );
    var_serialized = NULL;

    Py_XDECREF( var_public_key_info );
    var_public_key_info = NULL;

    Py_XDECREF( var_reader );
    var_reader = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_1__key_identifier_from_public_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_2__make_sequence_methods( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_field_name = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *var_len_method = NULL;
    PyObject *var_iter_method = NULL;
    PyObject *var_getitem_method = NULL;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_return_value;
    PyObject *tmp_tuple_element_1;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_1_len_method( par_field_name );
    assert( var_len_method == NULL );
    var_len_method = tmp_assign_source_1;

    tmp_assign_source_2 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_2_iter_method( par_field_name );
    assert( var_iter_method == NULL );
    var_iter_method = tmp_assign_source_2;

    tmp_assign_source_3 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_3_getitem_method( par_field_name );
    assert( var_getitem_method == NULL );
    var_getitem_method = tmp_assign_source_3;

    // Tried code:
    tmp_return_value = PyTuple_New( 3 );
    tmp_tuple_element_1 = var_len_method;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_return_value, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_iter_method;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_return_value, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_getitem_method;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_return_value, 2, tmp_tuple_element_1 );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_2__make_sequence_methods );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_len_method );
    Py_DECREF( var_len_method );
    var_len_method = NULL;

    CHECK_OBJECT( (PyObject *)par_field_name );
    Py_DECREF( par_field_name );
    par_field_name = NULL;

    CHECK_OBJECT( (PyObject *)var_iter_method );
    Py_DECREF( var_iter_method );
    var_iter_method = NULL;

    CHECK_OBJECT( (PyObject *)var_getitem_method );
    Py_DECREF( var_getitem_method );
    var_getitem_method = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_2__make_sequence_methods );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_1_len_method( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_getattr_attr_1;
    PyObject *tmp_getattr_target_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_64cba0da5a657c80e4c65b31e75f4900 = NULL;

    struct Nuitka_FrameObject *frame_64cba0da5a657c80e4c65b31e75f4900;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_64cba0da5a657c80e4c65b31e75f4900, codeobj_64cba0da5a657c80e4c65b31e75f4900, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_64cba0da5a657c80e4c65b31e75f4900 = cache_frame_64cba0da5a657c80e4c65b31e75f4900;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_64cba0da5a657c80e4c65b31e75f4900 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_64cba0da5a657c80e4c65b31e75f4900 ) == 2 ); // Frame stack

    // Framed code:
    tmp_getattr_target_1 = par_self;

    CHECK_OBJECT( tmp_getattr_target_1 );
    if ( self->m_closure[0] == NULL )
    {
        tmp_getattr_attr_1 = NULL;
    }
    else
    {
        tmp_getattr_attr_1 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_getattr_attr_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "field_name" );
        exception_tb = NULL;

        exception_lineno = 75;
        type_description_1 = "oc";
        goto frame_exception_exit_1;
    }

    tmp_len_arg_1 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, NULL );
    if ( tmp_len_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 75;
        type_description_1 = "oc";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_LEN( tmp_len_arg_1 );
    Py_DECREF( tmp_len_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 75;
        type_description_1 = "oc";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_64cba0da5a657c80e4c65b31e75f4900 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_64cba0da5a657c80e4c65b31e75f4900 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_64cba0da5a657c80e4c65b31e75f4900 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_64cba0da5a657c80e4c65b31e75f4900, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_64cba0da5a657c80e4c65b31e75f4900->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_64cba0da5a657c80e4c65b31e75f4900, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_64cba0da5a657c80e4c65b31e75f4900,
        type_description_1,
        par_self,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_64cba0da5a657c80e4c65b31e75f4900 == cache_frame_64cba0da5a657c80e4c65b31e75f4900 )
    {
        Py_DECREF( frame_64cba0da5a657c80e4c65b31e75f4900 );
    }
    cache_frame_64cba0da5a657c80e4c65b31e75f4900 = NULL;

    assertFrameObject( frame_64cba0da5a657c80e4c65b31e75f4900 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_1_len_method );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_1_len_method );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_2_iter_method( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_getattr_attr_1;
    PyObject *tmp_getattr_target_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87 = NULL;

    struct Nuitka_FrameObject *frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87, codeobj_5b8d0f2a0e6c3090c7a94dd8ad77bf87, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87 = cache_frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87 ) == 2 ); // Frame stack

    // Framed code:
    tmp_getattr_target_1 = par_self;

    CHECK_OBJECT( tmp_getattr_target_1 );
    if ( self->m_closure[0] == NULL )
    {
        tmp_getattr_attr_1 = NULL;
    }
    else
    {
        tmp_getattr_attr_1 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_getattr_attr_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "field_name" );
        exception_tb = NULL;

        exception_lineno = 78;
        type_description_1 = "oc";
        goto frame_exception_exit_1;
    }

    tmp_iter_arg_1 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, NULL );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 78;
        type_description_1 = "oc";
        goto frame_exception_exit_1;
    }
    tmp_return_value = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 78;
        type_description_1 = "oc";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87,
        type_description_1,
        par_self,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87 == cache_frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87 )
    {
        Py_DECREF( frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87 );
    }
    cache_frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87 = NULL;

    assertFrameObject( frame_5b8d0f2a0e6c3090c7a94dd8ad77bf87 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_2_iter_method );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_2_iter_method );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_3_getitem_method( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_idx = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_getattr_attr_1;
    PyObject *tmp_getattr_target_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_e5d51e6845904641cf548956df6959bf = NULL;

    struct Nuitka_FrameObject *frame_e5d51e6845904641cf548956df6959bf;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e5d51e6845904641cf548956df6959bf, codeobj_e5d51e6845904641cf548956df6959bf, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e5d51e6845904641cf548956df6959bf = cache_frame_e5d51e6845904641cf548956df6959bf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e5d51e6845904641cf548956df6959bf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e5d51e6845904641cf548956df6959bf ) == 2 ); // Frame stack

    // Framed code:
    tmp_getattr_target_1 = par_self;

    CHECK_OBJECT( tmp_getattr_target_1 );
    if ( self->m_closure[0] == NULL )
    {
        tmp_getattr_attr_1 = NULL;
    }
    else
    {
        tmp_getattr_attr_1 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_getattr_attr_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "field_name" );
        exception_tb = NULL;

        exception_lineno = 81;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_1 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, NULL );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 81;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = par_idx;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_return_value = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 81;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e5d51e6845904641cf548956df6959bf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e5d51e6845904641cf548956df6959bf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e5d51e6845904641cf548956df6959bf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e5d51e6845904641cf548956df6959bf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e5d51e6845904641cf548956df6959bf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e5d51e6845904641cf548956df6959bf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e5d51e6845904641cf548956df6959bf,
        type_description_1,
        par_self,
        par_idx,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_e5d51e6845904641cf548956df6959bf == cache_frame_e5d51e6845904641cf548956df6959bf )
    {
        Py_DECREF( frame_e5d51e6845904641cf548956df6959bf );
    }
    cache_frame_e5d51e6845904641cf548956df6959bf = NULL;

    assertFrameObject( frame_e5d51e6845904641cf548956df6959bf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_3_getitem_method );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_idx );
    Py_DECREF( par_idx );
    par_idx = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_idx );
    Py_DECREF( par_idx );
    par_idx = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_3_getitem_method );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_3___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_msg = python_pars[ 1 ];
    PyObject *par_oid = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_object_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_type_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_177dcec9eb5c8b0e02169c0f6f894e57 = NULL;

    struct Nuitka_FrameObject *frame_177dcec9eb5c8b0e02169c0f6f894e57;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_177dcec9eb5c8b0e02169c0f6f894e57, codeobj_177dcec9eb5c8b0e02169c0f6f894e57, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_177dcec9eb5c8b0e02169c0f6f894e57 = cache_frame_177dcec9eb5c8b0e02169c0f6f894e57;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_177dcec9eb5c8b0e02169c0f6f894e57 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_177dcec9eb5c8b0e02169c0f6f894e57 ) == 2 ); // Frame stack

    // Framed code:
    tmp_type_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DuplicateExtension );

    if (unlikely( tmp_type_name_1 == NULL ))
    {
        tmp_type_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DuplicateExtension );
    }

    if ( tmp_type_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "DuplicateExtension" );
        exception_tb = NULL;

        exception_lineno = 88;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_object_name_1 = par_self;

    CHECK_OBJECT( tmp_object_name_1 );
    tmp_called_instance_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 88;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_msg;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_177dcec9eb5c8b0e02169c0f6f894e57->m_frame.f_lineno = 88;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 88;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_1 = par_oid;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_oid, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 89;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_177dcec9eb5c8b0e02169c0f6f894e57 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_177dcec9eb5c8b0e02169c0f6f894e57 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_177dcec9eb5c8b0e02169c0f6f894e57, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_177dcec9eb5c8b0e02169c0f6f894e57->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_177dcec9eb5c8b0e02169c0f6f894e57, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_177dcec9eb5c8b0e02169c0f6f894e57,
        type_description_1,
        par_self,
        par_msg,
        par_oid
    );


    // Release cached frame.
    if ( frame_177dcec9eb5c8b0e02169c0f6f894e57 == cache_frame_177dcec9eb5c8b0e02169c0f6f894e57 )
    {
        Py_DECREF( frame_177dcec9eb5c8b0e02169c0f6f894e57 );
    }
    cache_frame_177dcec9eb5c8b0e02169c0f6f894e57 = NULL;

    assertFrameObject( frame_177dcec9eb5c8b0e02169c0f6f894e57 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_3___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_msg );
    Py_DECREF( par_msg );
    par_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_oid );
    Py_DECREF( par_oid );
    par_oid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_msg );
    Py_DECREF( par_msg );
    par_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_oid );
    Py_DECREF( par_oid );
    par_oid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_3___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_4___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_msg = python_pars[ 1 ];
    PyObject *par_oid = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_object_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_type_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_551214abb8a6570be6ada69e6e1f5f07 = NULL;

    struct Nuitka_FrameObject *frame_551214abb8a6570be6ada69e6e1f5f07;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_551214abb8a6570be6ada69e6e1f5f07, codeobj_551214abb8a6570be6ada69e6e1f5f07, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_551214abb8a6570be6ada69e6e1f5f07 = cache_frame_551214abb8a6570be6ada69e6e1f5f07;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_551214abb8a6570be6ada69e6e1f5f07 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_551214abb8a6570be6ada69e6e1f5f07 ) == 2 ); // Frame stack

    // Framed code:
    tmp_type_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound );

    if (unlikely( tmp_type_name_1 == NULL ))
    {
        tmp_type_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound );
    }

    if ( tmp_type_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ExtensionNotFound" );
        exception_tb = NULL;

        exception_lineno = 94;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_object_name_1 = par_self;

    CHECK_OBJECT( tmp_object_name_1 );
    tmp_called_instance_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 94;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_msg;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_551214abb8a6570be6ada69e6e1f5f07->m_frame.f_lineno = 94;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 94;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_1 = par_oid;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_oid, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 95;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_551214abb8a6570be6ada69e6e1f5f07 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_551214abb8a6570be6ada69e6e1f5f07 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_551214abb8a6570be6ada69e6e1f5f07, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_551214abb8a6570be6ada69e6e1f5f07->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_551214abb8a6570be6ada69e6e1f5f07, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_551214abb8a6570be6ada69e6e1f5f07,
        type_description_1,
        par_self,
        par_msg,
        par_oid
    );


    // Release cached frame.
    if ( frame_551214abb8a6570be6ada69e6e1f5f07 == cache_frame_551214abb8a6570be6ada69e6e1f5f07 )
    {
        Py_DECREF( frame_551214abb8a6570be6ada69e6e1f5f07 );
    }
    cache_frame_551214abb8a6570be6ada69e6e1f5f07 = NULL;

    assertFrameObject( frame_551214abb8a6570be6ada69e6e1f5f07 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_4___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_msg );
    Py_DECREF( par_msg );
    par_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_oid );
    Py_DECREF( par_oid );
    par_oid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_msg );
    Py_DECREF( par_msg );
    par_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_oid );
    Py_DECREF( par_oid );
    par_oid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_4___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_5_oid( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_5_oid );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_5_oid );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_6___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_extensions = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_bd49e54fb09a1da0efb6cacab0b984e7 = NULL;

    struct Nuitka_FrameObject *frame_bd49e54fb09a1da0efb6cacab0b984e7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bd49e54fb09a1da0efb6cacab0b984e7, codeobj_bd49e54fb09a1da0efb6cacab0b984e7, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_bd49e54fb09a1da0efb6cacab0b984e7 = cache_frame_bd49e54fb09a1da0efb6cacab0b984e7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bd49e54fb09a1da0efb6cacab0b984e7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bd49e54fb09a1da0efb6cacab0b984e7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = par_extensions;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__extensions, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 109;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bd49e54fb09a1da0efb6cacab0b984e7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bd49e54fb09a1da0efb6cacab0b984e7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bd49e54fb09a1da0efb6cacab0b984e7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bd49e54fb09a1da0efb6cacab0b984e7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bd49e54fb09a1da0efb6cacab0b984e7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bd49e54fb09a1da0efb6cacab0b984e7,
        type_description_1,
        par_self,
        par_extensions
    );


    // Release cached frame.
    if ( frame_bd49e54fb09a1da0efb6cacab0b984e7 == cache_frame_bd49e54fb09a1da0efb6cacab0b984e7 )
    {
        Py_DECREF( frame_bd49e54fb09a1da0efb6cacab0b984e7 );
    }
    cache_frame_bd49e54fb09a1da0efb6cacab0b984e7 = NULL;

    assertFrameObject( frame_bd49e54fb09a1da0efb6cacab0b984e7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_6___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_extensions );
    Py_DECREF( par_extensions );
    par_extensions = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_extensions );
    Py_DECREF( par_extensions );
    par_extensions = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_6___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_7_get_extension_for_oid( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_oid = python_pars[ 1 ];
    PyObject *var_ext = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_acac3422c0e3d6f57a7c8462949c204c = NULL;

    struct Nuitka_FrameObject *frame_acac3422c0e3d6f57a7c8462949c204c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_acac3422c0e3d6f57a7c8462949c204c, codeobj_acac3422c0e3d6f57a7c8462949c204c, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_acac3422c0e3d6f57a7c8462949c204c = cache_frame_acac3422c0e3d6f57a7c8462949c204c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_acac3422c0e3d6f57a7c8462949c204c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_acac3422c0e3d6f57a7c8462949c204c ) == 2 ); // Frame stack

    // Framed code:
    tmp_iter_arg_1 = par_self;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 112;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooo";
        exception_lineno = 112;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 112;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_ext;
        var_ext = tmp_assign_source_3;
        Py_INCREF( var_ext );
        Py_XDECREF( old );
    }

    tmp_source_name_1 = var_ext;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_oid );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 113;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    tmp_compare_right_2 = par_oid;

    CHECK_OBJECT( tmp_compare_right_2 );
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 113;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_return_value = var_ext;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_2;
    branch_no_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 112;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__iter_value );
    Py_DECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ExtensionNotFound" );
        exception_tb = NULL;

        exception_lineno = 116;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_1 = const_str_digest_6e39999ae9fa2f733baa4157c3ce7ef9;
    tmp_args_element_name_2 = par_oid;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_acac3422c0e3d6f57a7c8462949c204c->m_frame.f_lineno = 116;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 116;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_oid;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_acac3422c0e3d6f57a7c8462949c204c->m_frame.f_lineno = 116;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_3 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_raise_type_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 116;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_1;
    exception_lineno = 116;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_acac3422c0e3d6f57a7c8462949c204c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_acac3422c0e3d6f57a7c8462949c204c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_acac3422c0e3d6f57a7c8462949c204c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_acac3422c0e3d6f57a7c8462949c204c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_acac3422c0e3d6f57a7c8462949c204c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_acac3422c0e3d6f57a7c8462949c204c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_acac3422c0e3d6f57a7c8462949c204c,
        type_description_1,
        par_self,
        par_oid,
        var_ext
    );


    // Release cached frame.
    if ( frame_acac3422c0e3d6f57a7c8462949c204c == cache_frame_acac3422c0e3d6f57a7c8462949c204c )
    {
        Py_DECREF( frame_acac3422c0e3d6f57a7c8462949c204c );
    }
    cache_frame_acac3422c0e3d6f57a7c8462949c204c = NULL;

    assertFrameObject( frame_acac3422c0e3d6f57a7c8462949c204c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_7_get_extension_for_oid );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_oid );
    Py_DECREF( par_oid );
    par_oid = NULL;

    CHECK_OBJECT( (PyObject *)var_ext );
    Py_DECREF( var_ext );
    var_ext = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_oid );
    Py_DECREF( par_oid );
    par_oid = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_7_get_extension_for_oid );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_8_get_extension_for_class( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_extclass = python_pars[ 1 ];
    PyObject *var_ext = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_exc_match_exception_match_1;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_1929fcfaa60d306de7136ca2141845f6 = NULL;

    struct Nuitka_FrameObject *frame_1929fcfaa60d306de7136ca2141845f6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1929fcfaa60d306de7136ca2141845f6, codeobj_1929fcfaa60d306de7136ca2141845f6, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1929fcfaa60d306de7136ca2141845f6 = cache_frame_1929fcfaa60d306de7136ca2141845f6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1929fcfaa60d306de7136ca2141845f6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1929fcfaa60d306de7136ca2141845f6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_extclass;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_UnrecognizedExtension );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_UnrecognizedExtension );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "UnrecognizedExtension" );
        exception_tb = NULL;

        exception_lineno = 119;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_f7d33cb69a7dc22294881ff5b1fe0ec9;
    frame_1929fcfaa60d306de7136ca2141845f6->m_frame.f_lineno = 120;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 120;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_iter_arg_1 = par_self;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 126;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooo";
        exception_lineno = 126;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_2 = exception_keeper_type_1;
    tmp_compare_right_2 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 126;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_2;
    branch_no_2:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_2:;
    // End of try:
    try_end_1:;
    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_ext;
        var_ext = tmp_assign_source_3;
        Py_INCREF( var_ext );
        Py_XDECREF( old );
    }

    tmp_source_name_1 = var_ext;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_isinstance_inst_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_value );
    if ( tmp_isinstance_inst_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 127;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    tmp_isinstance_cls_1 = par_extclass;

    CHECK_OBJECT( tmp_isinstance_cls_1 );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_inst_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 127;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_return_value = var_ext;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_2;
    branch_no_3:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 126;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__iter_value );
    Py_DECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ExtensionNotFound" );
        exception_tb = NULL;

        exception_lineno = 130;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_1 = const_str_digest_6e39999ae9fa2f733baa4157c3ce7ef9;
    tmp_args_element_name_2 = par_extclass;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_1929fcfaa60d306de7136ca2141845f6->m_frame.f_lineno = 131;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 131;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_extclass;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_oid );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 131;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_1929fcfaa60d306de7136ca2141845f6->m_frame.f_lineno = 130;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_3 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_raise_type_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 130;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_2;
    exception_lineno = 130;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1929fcfaa60d306de7136ca2141845f6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1929fcfaa60d306de7136ca2141845f6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1929fcfaa60d306de7136ca2141845f6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1929fcfaa60d306de7136ca2141845f6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1929fcfaa60d306de7136ca2141845f6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1929fcfaa60d306de7136ca2141845f6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1929fcfaa60d306de7136ca2141845f6,
        type_description_1,
        par_self,
        par_extclass,
        var_ext
    );


    // Release cached frame.
    if ( frame_1929fcfaa60d306de7136ca2141845f6 == cache_frame_1929fcfaa60d306de7136ca2141845f6 )
    {
        Py_DECREF( frame_1929fcfaa60d306de7136ca2141845f6 );
    }
    cache_frame_1929fcfaa60d306de7136ca2141845f6 = NULL;

    assertFrameObject( frame_1929fcfaa60d306de7136ca2141845f6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_8_get_extension_for_class );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ext );
    Py_DECREF( var_ext );
    var_ext = NULL;

    CHECK_OBJECT( (PyObject *)par_extclass );
    Py_DECREF( par_extclass );
    par_extclass = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    CHECK_OBJECT( (PyObject *)par_extclass );
    Py_DECREF( par_extclass );
    par_extclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_8_get_extension_for_class );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_9___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_64a6ae9ffc5aa8649774f127c5759ec5 = NULL;

    struct Nuitka_FrameObject *frame_64a6ae9ffc5aa8649774f127c5759ec5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_64a6ae9ffc5aa8649774f127c5759ec5, codeobj_64a6ae9ffc5aa8649774f127c5759ec5, module_cryptography$x509$extensions, sizeof(void *) );
    frame_64a6ae9ffc5aa8649774f127c5759ec5 = cache_frame_64a6ae9ffc5aa8649774f127c5759ec5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_64a6ae9ffc5aa8649774f127c5759ec5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_64a6ae9ffc5aa8649774f127c5759ec5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_e29a6013213dd6497cd7c55bc7864351;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__extensions );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 138;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_64a6ae9ffc5aa8649774f127c5759ec5->m_frame.f_lineno = 138;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 138;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_64a6ae9ffc5aa8649774f127c5759ec5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_64a6ae9ffc5aa8649774f127c5759ec5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_64a6ae9ffc5aa8649774f127c5759ec5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_64a6ae9ffc5aa8649774f127c5759ec5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_64a6ae9ffc5aa8649774f127c5759ec5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_64a6ae9ffc5aa8649774f127c5759ec5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_64a6ae9ffc5aa8649774f127c5759ec5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_64a6ae9ffc5aa8649774f127c5759ec5 == cache_frame_64a6ae9ffc5aa8649774f127c5759ec5 )
    {
        Py_DECREF( frame_64a6ae9ffc5aa8649774f127c5759ec5 );
    }
    cache_frame_64a6ae9ffc5aa8649774f127c5759ec5 = NULL;

    assertFrameObject( frame_64a6ae9ffc5aa8649774f127c5759ec5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_9___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_9___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_10___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_crl_number = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_ca7ebae402d55046675fc70d82ea120a = NULL;

    struct Nuitka_FrameObject *frame_ca7ebae402d55046675fc70d82ea120a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ca7ebae402d55046675fc70d82ea120a, codeobj_ca7ebae402d55046675fc70d82ea120a, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_ca7ebae402d55046675fc70d82ea120a = cache_frame_ca7ebae402d55046675fc70d82ea120a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ca7ebae402d55046675fc70d82ea120a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ca7ebae402d55046675fc70d82ea120a ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_crl_number;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_six );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "six" );
        exception_tb = NULL;

        exception_lineno = 147;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_integer_types );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 147;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 147;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_f7714799e19abc5d09ccbaf8366649ea;
    frame_ca7ebae402d55046675fc70d82ea120a->m_frame.f_lineno = 148;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 148;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_crl_number;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__crl_number, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 150;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ca7ebae402d55046675fc70d82ea120a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ca7ebae402d55046675fc70d82ea120a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ca7ebae402d55046675fc70d82ea120a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ca7ebae402d55046675fc70d82ea120a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ca7ebae402d55046675fc70d82ea120a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ca7ebae402d55046675fc70d82ea120a,
        type_description_1,
        par_self,
        par_crl_number
    );


    // Release cached frame.
    if ( frame_ca7ebae402d55046675fc70d82ea120a == cache_frame_ca7ebae402d55046675fc70d82ea120a )
    {
        Py_DECREF( frame_ca7ebae402d55046675fc70d82ea120a );
    }
    cache_frame_ca7ebae402d55046675fc70d82ea120a = NULL;

    assertFrameObject( frame_ca7ebae402d55046675fc70d82ea120a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_10___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_crl_number );
    Py_DECREF( par_crl_number );
    par_crl_number = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_crl_number );
    Py_DECREF( par_crl_number );
    par_crl_number = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_10___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_11___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_3d456b8c68fc0d32404a21a843d53ce8 = NULL;

    struct Nuitka_FrameObject *frame_3d456b8c68fc0d32404a21a843d53ce8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3d456b8c68fc0d32404a21a843d53ce8, codeobj_3d456b8c68fc0d32404a21a843d53ce8, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_3d456b8c68fc0d32404a21a843d53ce8 = cache_frame_3d456b8c68fc0d32404a21a843d53ce8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3d456b8c68fc0d32404a21a843d53ce8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3d456b8c68fc0d32404a21a843d53ce8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLNumber );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CRLNumber );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "CRLNumber" );
        exception_tb = NULL;

        exception_lineno = 153;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 153;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_crl_number );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 156;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_crl_number );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 156;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 156;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d456b8c68fc0d32404a21a843d53ce8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d456b8c68fc0d32404a21a843d53ce8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d456b8c68fc0d32404a21a843d53ce8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3d456b8c68fc0d32404a21a843d53ce8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3d456b8c68fc0d32404a21a843d53ce8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3d456b8c68fc0d32404a21a843d53ce8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3d456b8c68fc0d32404a21a843d53ce8,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_3d456b8c68fc0d32404a21a843d53ce8 == cache_frame_3d456b8c68fc0d32404a21a843d53ce8 )
    {
        Py_DECREF( frame_3d456b8c68fc0d32404a21a843d53ce8 );
    }
    cache_frame_3d456b8c68fc0d32404a21a843d53ce8 = NULL;

    assertFrameObject( frame_3d456b8c68fc0d32404a21a843d53ce8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_11___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_11___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_12___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_275e644d3ba496e282a9a7e1ed6c862f = NULL;

    struct Nuitka_FrameObject *frame_275e644d3ba496e282a9a7e1ed6c862f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_275e644d3ba496e282a9a7e1ed6c862f, codeobj_275e644d3ba496e282a9a7e1ed6c862f, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_275e644d3ba496e282a9a7e1ed6c862f = cache_frame_275e644d3ba496e282a9a7e1ed6c862f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_275e644d3ba496e282a9a7e1ed6c862f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_275e644d3ba496e282a9a7e1ed6c862f ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 159;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 159;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_275e644d3ba496e282a9a7e1ed6c862f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_275e644d3ba496e282a9a7e1ed6c862f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_275e644d3ba496e282a9a7e1ed6c862f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_275e644d3ba496e282a9a7e1ed6c862f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_275e644d3ba496e282a9a7e1ed6c862f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_275e644d3ba496e282a9a7e1ed6c862f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_275e644d3ba496e282a9a7e1ed6c862f,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_275e644d3ba496e282a9a7e1ed6c862f == cache_frame_275e644d3ba496e282a9a7e1ed6c862f )
    {
        Py_DECREF( frame_275e644d3ba496e282a9a7e1ed6c862f );
    }
    cache_frame_275e644d3ba496e282a9a7e1ed6c862f = NULL;

    assertFrameObject( frame_275e644d3ba496e282a9a7e1ed6c862f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_12___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_12___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_13___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_aeb0ee93788492df02f8efe63af9c8d6 = NULL;

    struct Nuitka_FrameObject *frame_aeb0ee93788492df02f8efe63af9c8d6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_aeb0ee93788492df02f8efe63af9c8d6, codeobj_aeb0ee93788492df02f8efe63af9c8d6, module_cryptography$x509$extensions, sizeof(void *) );
    frame_aeb0ee93788492df02f8efe63af9c8d6 = cache_frame_aeb0ee93788492df02f8efe63af9c8d6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_aeb0ee93788492df02f8efe63af9c8d6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_aeb0ee93788492df02f8efe63af9c8d6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_hash_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_crl_number );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 162;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 162;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aeb0ee93788492df02f8efe63af9c8d6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_aeb0ee93788492df02f8efe63af9c8d6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aeb0ee93788492df02f8efe63af9c8d6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_aeb0ee93788492df02f8efe63af9c8d6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_aeb0ee93788492df02f8efe63af9c8d6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_aeb0ee93788492df02f8efe63af9c8d6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_aeb0ee93788492df02f8efe63af9c8d6,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_aeb0ee93788492df02f8efe63af9c8d6 == cache_frame_aeb0ee93788492df02f8efe63af9c8d6 )
    {
        Py_DECREF( frame_aeb0ee93788492df02f8efe63af9c8d6 );
    }
    cache_frame_aeb0ee93788492df02f8efe63af9c8d6 = NULL;

    assertFrameObject( frame_aeb0ee93788492df02f8efe63af9c8d6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_13___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_13___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_14___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_16033c495aaaac6c823cfe41921d5827 = NULL;

    struct Nuitka_FrameObject *frame_16033c495aaaac6c823cfe41921d5827;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_16033c495aaaac6c823cfe41921d5827, codeobj_16033c495aaaac6c823cfe41921d5827, module_cryptography$x509$extensions, sizeof(void *) );
    frame_16033c495aaaac6c823cfe41921d5827 = cache_frame_16033c495aaaac6c823cfe41921d5827;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_16033c495aaaac6c823cfe41921d5827 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_16033c495aaaac6c823cfe41921d5827 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_de1714430c844d988a0d091fac0a73d4;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_crl_number );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 165;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_16033c495aaaac6c823cfe41921d5827->m_frame.f_lineno = 165;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 165;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_16033c495aaaac6c823cfe41921d5827 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_16033c495aaaac6c823cfe41921d5827 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_16033c495aaaac6c823cfe41921d5827 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_16033c495aaaac6c823cfe41921d5827, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_16033c495aaaac6c823cfe41921d5827->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_16033c495aaaac6c823cfe41921d5827, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_16033c495aaaac6c823cfe41921d5827,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_16033c495aaaac6c823cfe41921d5827 == cache_frame_16033c495aaaac6c823cfe41921d5827 )
    {
        Py_DECREF( frame_16033c495aaaac6c823cfe41921d5827 );
    }
    cache_frame_16033c495aaaac6c823cfe41921d5827 = NULL;

    assertFrameObject( frame_16033c495aaaac6c823cfe41921d5827 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_14___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_14___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_15___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key_identifier = python_pars[ 1 ];
    PyObject *par_authority_cert_issuer = python_pars[ 2 ];
    PyObject *par_authority_cert_serial_number = python_pars[ 3 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    bool tmp_isnot_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_9dc41cd1ae78f5934b45799a32540da0 = NULL;

    struct Nuitka_FrameObject *frame_9dc41cd1ae78f5934b45799a32540da0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9dc41cd1ae78f5934b45799a32540da0, codeobj_9dc41cd1ae78f5934b45799a32540da0, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9dc41cd1ae78f5934b45799a32540da0 = cache_frame_9dc41cd1ae78f5934b45799a32540da0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9dc41cd1ae78f5934b45799a32540da0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9dc41cd1ae78f5934b45799a32540da0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_authority_cert_issuer;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = Py_None;
    tmp_compare_left_1 = BOOL_FROM( tmp_compexpr_left_1 == tmp_compexpr_right_1 );
    tmp_compexpr_left_2 = par_authority_cert_serial_number;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = Py_None;
    tmp_compare_right_1 = BOOL_FROM( tmp_compexpr_left_2 == tmp_compexpr_right_2 );
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 176;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_da5560b5b28f3c84a1c556751340bb55;
    frame_9dc41cd1ae78f5934b45799a32540da0->m_frame.f_lineno = 179;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 179;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_compare_left_2 = par_authority_cert_issuer;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_2 != tmp_compare_right_2 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_list_arg_1 = par_authority_cert_issuer;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 185;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_authority_cert_issuer;
        assert( old != NULL );
        par_authority_cert_issuer = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_authority_cert_issuer;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 187;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_15___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_c7fe5f8e4c1b93586b4d8d29a0d60610,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_15___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_15___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_9dc41cd1ae78f5934b45799a32540da0->m_frame.f_lineno = 186;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 186;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 186;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_2 = const_str_digest_e41e00d6ec327bc9d8187afd927a45a2;
    frame_9dc41cd1ae78f5934b45799a32540da0->m_frame.f_lineno = 189;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 189;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    branch_no_2:;
    tmp_compexpr_left_3 = par_authority_cert_serial_number;

    CHECK_OBJECT( tmp_compexpr_left_3 );
    tmp_compexpr_right_3 = Py_None;
    tmp_and_left_value_1 = BOOL_FROM( tmp_compexpr_left_3 != tmp_compexpr_right_3 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    assert( !(tmp_and_left_truth_1 == -1) );
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_isinstance_inst_1 = par_authority_cert_serial_number;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_six );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "six" );
        exception_tb = NULL;

        exception_lineno = 195;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_integer_types );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 195;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_operand_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 194;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 194;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_2 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_2 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 194;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_make_exception_arg_3 = const_str_digest_024b912fa6151b94263fc1d09ce49af2;
    frame_9dc41cd1ae78f5934b45799a32540da0->m_frame.f_lineno = 197;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 197;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_4:;
    tmp_assattr_name_1 = par_key_identifier;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__key_identifier, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 201;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_authority_cert_issuer;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__authority_cert_issuer, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 202;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = par_authority_cert_serial_number;

    CHECK_OBJECT( tmp_assattr_name_3 );
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__authority_cert_serial_number, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 203;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9dc41cd1ae78f5934b45799a32540da0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9dc41cd1ae78f5934b45799a32540da0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9dc41cd1ae78f5934b45799a32540da0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9dc41cd1ae78f5934b45799a32540da0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9dc41cd1ae78f5934b45799a32540da0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9dc41cd1ae78f5934b45799a32540da0,
        type_description_1,
        par_self,
        par_key_identifier,
        par_authority_cert_issuer,
        par_authority_cert_serial_number
    );


    // Release cached frame.
    if ( frame_9dc41cd1ae78f5934b45799a32540da0 == cache_frame_9dc41cd1ae78f5934b45799a32540da0 )
    {
        Py_DECREF( frame_9dc41cd1ae78f5934b45799a32540da0 );
    }
    cache_frame_9dc41cd1ae78f5934b45799a32540da0 = NULL;

    assertFrameObject( frame_9dc41cd1ae78f5934b45799a32540da0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_15___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_authority_cert_serial_number );
    Py_DECREF( par_authority_cert_serial_number );
    par_authority_cert_serial_number = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_authority_cert_issuer );
    Py_DECREF( par_authority_cert_issuer );
    par_authority_cert_issuer = NULL;

    CHECK_OBJECT( (PyObject *)par_key_identifier );
    Py_DECREF( par_key_identifier );
    par_key_identifier = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_authority_cert_serial_number );
    Py_DECREF( par_authority_cert_serial_number );
    par_authority_cert_serial_number = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_authority_cert_issuer );
    par_authority_cert_issuer = NULL;

    CHECK_OBJECT( (PyObject *)par_key_identifier );
    Py_DECREF( par_key_identifier );
    par_key_identifier = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_15___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_15___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_15___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_15___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_c7fe5f8e4c1b93586b4d8d29a0d60610, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 187;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 187;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GeneralName" );
        exception_tb = NULL;

        exception_lineno = 187;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 187;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 187;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 187;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_16_from_issuer_public_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_public_key = python_pars[ 1 ];
    PyObject *var_digest = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_7ff35117673a9277a1a56b314dcb491c = NULL;

    struct Nuitka_FrameObject *frame_7ff35117673a9277a1a56b314dcb491c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7ff35117673a9277a1a56b314dcb491c, codeobj_7ff35117673a9277a1a56b314dcb491c, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7ff35117673a9277a1a56b314dcb491c = cache_frame_7ff35117673a9277a1a56b314dcb491c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7ff35117673a9277a1a56b314dcb491c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7ff35117673a9277a1a56b314dcb491c ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__key_identifier_from_public_key );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__key_identifier_from_public_key );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_key_identifier_from_public_key" );
        exception_tb = NULL;

        exception_lineno = 207;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_public_key;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_7ff35117673a9277a1a56b314dcb491c->m_frame.f_lineno = 207;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 207;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_digest == NULL );
    var_digest = tmp_assign_source_1;

    tmp_called_name_2 = par_cls;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_value_1 = var_digest;

    CHECK_OBJECT( tmp_dict_value_1 );
    tmp_dict_key_1 = const_str_plain_key_identifier;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_value_2 = Py_None;
    tmp_dict_key_2 = const_str_plain_authority_cert_issuer;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_value_3 = Py_None;
    tmp_dict_key_3 = const_str_plain_authority_cert_serial_number;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    frame_7ff35117673a9277a1a56b314dcb491c->m_frame.f_lineno = 208;
    tmp_return_value = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 208;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ff35117673a9277a1a56b314dcb491c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ff35117673a9277a1a56b314dcb491c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ff35117673a9277a1a56b314dcb491c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7ff35117673a9277a1a56b314dcb491c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7ff35117673a9277a1a56b314dcb491c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7ff35117673a9277a1a56b314dcb491c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7ff35117673a9277a1a56b314dcb491c,
        type_description_1,
        par_cls,
        par_public_key,
        var_digest
    );


    // Release cached frame.
    if ( frame_7ff35117673a9277a1a56b314dcb491c == cache_frame_7ff35117673a9277a1a56b314dcb491c )
    {
        Py_DECREF( frame_7ff35117673a9277a1a56b314dcb491c );
    }
    cache_frame_7ff35117673a9277a1a56b314dcb491c = NULL;

    assertFrameObject( frame_7ff35117673a9277a1a56b314dcb491c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_16_from_issuer_public_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_public_key );
    Py_DECREF( par_public_key );
    par_public_key = NULL;

    CHECK_OBJECT( (PyObject *)var_digest );
    Py_DECREF( var_digest );
    var_digest = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_public_key );
    Py_DECREF( par_public_key );
    par_public_key = NULL;

    Py_XDECREF( var_digest );
    var_digest = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_16_from_issuer_public_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_17_from_issuer_subject_key_identifier( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_ski = python_pars[ 1 ];
    PyObject *var_digest = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_73bb14bed3dfca8611c927e438dcc6d1 = NULL;

    struct Nuitka_FrameObject *frame_73bb14bed3dfca8611c927e438dcc6d1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_73bb14bed3dfca8611c927e438dcc6d1, codeobj_73bb14bed3dfca8611c927e438dcc6d1, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_73bb14bed3dfca8611c927e438dcc6d1 = cache_frame_73bb14bed3dfca8611c927e438dcc6d1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_73bb14bed3dfca8611c927e438dcc6d1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_73bb14bed3dfca8611c927e438dcc6d1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_ski;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SubjectKeyIdentifier );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SubjectKeyIdentifier );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "SubjectKeyIdentifier" );
        exception_tb = NULL;

        exception_lineno = 216;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 216;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = par_ski;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_digest );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 217;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_digest == NULL );
    var_digest = tmp_assign_source_1;

    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_3 = par_ski;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_value );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 219;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_digest );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 219;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_digest == NULL );
    var_digest = tmp_assign_source_2;

    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_warnings );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "warnings" );
        exception_tb = NULL;

        exception_lineno = 220;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_warn );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 220;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 2 );
    tmp_tuple_element_1 = const_str_digest_bed5ff04fb0d04ecd22172c330a8e05a;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 225;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_DeprecatedIn27 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 225;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_kw_name_1 = PyDict_Copy( const_dict_f154c9a58c9419d7e391901d7b7fe49e );
    frame_73bb14bed3dfca8611c927e438dcc6d1->m_frame.f_lineno = 220;
    tmp_unused = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 220;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_1:;
    tmp_called_name_2 = par_cls;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_kw_name_2 = _PyDict_NewPresized( 3 );
    tmp_dict_value_1 = var_digest;

    CHECK_OBJECT( tmp_dict_value_1 );
    tmp_dict_key_1 = const_str_plain_key_identifier;
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_value_2 = Py_None;
    tmp_dict_key_2 = const_str_plain_authority_cert_issuer;
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_value_3 = Py_None;
    tmp_dict_key_3 = const_str_plain_authority_cert_serial_number;
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_3, tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    frame_73bb14bed3dfca8611c927e438dcc6d1->m_frame.f_lineno = 229;
    tmp_return_value = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 229;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_73bb14bed3dfca8611c927e438dcc6d1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_73bb14bed3dfca8611c927e438dcc6d1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_73bb14bed3dfca8611c927e438dcc6d1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_73bb14bed3dfca8611c927e438dcc6d1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_73bb14bed3dfca8611c927e438dcc6d1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_73bb14bed3dfca8611c927e438dcc6d1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_73bb14bed3dfca8611c927e438dcc6d1,
        type_description_1,
        par_cls,
        par_ski,
        var_digest
    );


    // Release cached frame.
    if ( frame_73bb14bed3dfca8611c927e438dcc6d1 == cache_frame_73bb14bed3dfca8611c927e438dcc6d1 )
    {
        Py_DECREF( frame_73bb14bed3dfca8611c927e438dcc6d1 );
    }
    cache_frame_73bb14bed3dfca8611c927e438dcc6d1 = NULL;

    assertFrameObject( frame_73bb14bed3dfca8611c927e438dcc6d1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_17_from_issuer_subject_key_identifier );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ski );
    Py_DECREF( par_ski );
    par_ski = NULL;

    CHECK_OBJECT( (PyObject *)var_digest );
    Py_DECREF( var_digest );
    var_digest = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ski );
    Py_DECREF( par_ski );
    par_ski = NULL;

    Py_XDECREF( var_digest );
    var_digest = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_17_from_issuer_subject_key_identifier );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_18___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_24a659e0b5b173b5b0c0638bb94387a8 = NULL;

    struct Nuitka_FrameObject *frame_24a659e0b5b173b5b0c0638bb94387a8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_24a659e0b5b173b5b0c0638bb94387a8, codeobj_24a659e0b5b173b5b0c0638bb94387a8, module_cryptography$x509$extensions, sizeof(void *) );
    frame_24a659e0b5b173b5b0c0638bb94387a8 = cache_frame_24a659e0b5b173b5b0c0638bb94387a8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_24a659e0b5b173b5b0c0638bb94387a8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_24a659e0b5b173b5b0c0638bb94387a8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_42aaad2aaa6a1ee7d79f305ebfd1a58b;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_24a659e0b5b173b5b0c0638bb94387a8->m_frame.f_lineno = 237;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 237;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_24a659e0b5b173b5b0c0638bb94387a8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_24a659e0b5b173b5b0c0638bb94387a8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_24a659e0b5b173b5b0c0638bb94387a8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_24a659e0b5b173b5b0c0638bb94387a8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_24a659e0b5b173b5b0c0638bb94387a8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_24a659e0b5b173b5b0c0638bb94387a8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_24a659e0b5b173b5b0c0638bb94387a8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_24a659e0b5b173b5b0c0638bb94387a8 == cache_frame_24a659e0b5b173b5b0c0638bb94387a8 )
    {
        Py_DECREF( frame_24a659e0b5b173b5b0c0638bb94387a8 );
    }
    cache_frame_24a659e0b5b173b5b0c0638bb94387a8 = NULL;

    assertFrameObject( frame_24a659e0b5b173b5b0c0638bb94387a8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_18___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_18___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_19___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    static struct Nuitka_FrameObject *cache_frame_cc7a4dc2c94b88b2c8cc7d6f77071a16 = NULL;

    struct Nuitka_FrameObject *frame_cc7a4dc2c94b88b2c8cc7d6f77071a16;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cc7a4dc2c94b88b2c8cc7d6f77071a16, codeobj_cc7a4dc2c94b88b2c8cc7d6f77071a16, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_cc7a4dc2c94b88b2c8cc7d6f77071a16 = cache_frame_cc7a4dc2c94b88b2c8cc7d6f77071a16;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cc7a4dc2c94b88b2c8cc7d6f77071a16 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cc7a4dc2c94b88b2c8cc7d6f77071a16 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AuthorityKeyIdentifier );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AuthorityKeyIdentifier );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "AuthorityKeyIdentifier" );
        exception_tb = NULL;

        exception_lineno = 244;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 244;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_key_identifier );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 248;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_key_identifier );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 248;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 248;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 250;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_authority_cert_issuer );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_other;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_authority_cert_issuer );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 249;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_2 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    if ( tmp_and_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_2 );

        exception_lineno = 250;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    Py_DECREF( tmp_and_left_value_2 );
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_authority_cert_serial_number );
    if ( tmp_compexpr_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 250;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_other;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_authority_cert_serial_number );
    if ( tmp_compexpr_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_3 );

        exception_lineno = 251;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_2 = RICH_COMPARE_EQ( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    Py_DECREF( tmp_compexpr_left_3 );
    Py_DECREF( tmp_compexpr_right_3 );
    if ( tmp_and_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 250;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_and_right_value_1 = tmp_and_left_value_2;
    and_end_2:;
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cc7a4dc2c94b88b2c8cc7d6f77071a16 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cc7a4dc2c94b88b2c8cc7d6f77071a16 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cc7a4dc2c94b88b2c8cc7d6f77071a16 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cc7a4dc2c94b88b2c8cc7d6f77071a16, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cc7a4dc2c94b88b2c8cc7d6f77071a16->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cc7a4dc2c94b88b2c8cc7d6f77071a16, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cc7a4dc2c94b88b2c8cc7d6f77071a16,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_cc7a4dc2c94b88b2c8cc7d6f77071a16 == cache_frame_cc7a4dc2c94b88b2c8cc7d6f77071a16 )
    {
        Py_DECREF( frame_cc7a4dc2c94b88b2c8cc7d6f77071a16 );
    }
    cache_frame_cc7a4dc2c94b88b2c8cc7d6f77071a16 = NULL;

    assertFrameObject( frame_cc7a4dc2c94b88b2c8cc7d6f77071a16 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_19___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_19___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_20___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_98f0485697a13d329db62f025ca69055 = NULL;

    struct Nuitka_FrameObject *frame_98f0485697a13d329db62f025ca69055;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_98f0485697a13d329db62f025ca69055, codeobj_98f0485697a13d329db62f025ca69055, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_98f0485697a13d329db62f025ca69055 = cache_frame_98f0485697a13d329db62f025ca69055;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_98f0485697a13d329db62f025ca69055 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_98f0485697a13d329db62f025ca69055 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 255;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 255;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_98f0485697a13d329db62f025ca69055 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_98f0485697a13d329db62f025ca69055 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_98f0485697a13d329db62f025ca69055 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_98f0485697a13d329db62f025ca69055, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_98f0485697a13d329db62f025ca69055->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_98f0485697a13d329db62f025ca69055, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_98f0485697a13d329db62f025ca69055,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_98f0485697a13d329db62f025ca69055 == cache_frame_98f0485697a13d329db62f025ca69055 )
    {
        Py_DECREF( frame_98f0485697a13d329db62f025ca69055 );
    }
    cache_frame_98f0485697a13d329db62f025ca69055 = NULL;

    assertFrameObject( frame_98f0485697a13d329db62f025ca69055 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_20___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_20___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_21___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_aci = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_hash_arg_1;
    bool tmp_is_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_tuple_arg_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_3507eef1aab655efc5eb282ddd6df11f = NULL;

    struct Nuitka_FrameObject *frame_3507eef1aab655efc5eb282ddd6df11f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3507eef1aab655efc5eb282ddd6df11f, codeobj_3507eef1aab655efc5eb282ddd6df11f, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_3507eef1aab655efc5eb282ddd6df11f = cache_frame_3507eef1aab655efc5eb282ddd6df11f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3507eef1aab655efc5eb282ddd6df11f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3507eef1aab655efc5eb282ddd6df11f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_authority_cert_issuer );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 258;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_1 = Py_None;
    assert( var_aci == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var_aci = tmp_assign_source_1;

    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_authority_cert_issuer );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 261;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 261;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_aci == NULL );
    var_aci = tmp_assign_source_2;

    branch_end_1:;
    tmp_hash_arg_1 = PyTuple_New( 3 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_key_identifier );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 263;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_aci;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_hash_arg_1, 1, tmp_tuple_element_1 );
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_authority_cert_serial_number );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 263;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 2, tmp_tuple_element_1 );
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 262;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3507eef1aab655efc5eb282ddd6df11f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3507eef1aab655efc5eb282ddd6df11f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3507eef1aab655efc5eb282ddd6df11f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3507eef1aab655efc5eb282ddd6df11f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3507eef1aab655efc5eb282ddd6df11f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3507eef1aab655efc5eb282ddd6df11f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3507eef1aab655efc5eb282ddd6df11f,
        type_description_1,
        par_self,
        var_aci
    );


    // Release cached frame.
    if ( frame_3507eef1aab655efc5eb282ddd6df11f == cache_frame_3507eef1aab655efc5eb282ddd6df11f )
    {
        Py_DECREF( frame_3507eef1aab655efc5eb282ddd6df11f );
    }
    cache_frame_3507eef1aab655efc5eb282ddd6df11f = NULL;

    assertFrameObject( frame_3507eef1aab655efc5eb282ddd6df11f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_21___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_aci );
    Py_DECREF( var_aci );
    var_aci = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_aci );
    var_aci = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_21___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_22___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_digest = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_60b448e7e2dc606440735ac8e5d8691f = NULL;

    struct Nuitka_FrameObject *frame_60b448e7e2dc606440735ac8e5d8691f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_60b448e7e2dc606440735ac8e5d8691f, codeobj_60b448e7e2dc606440735ac8e5d8691f, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_60b448e7e2dc606440735ac8e5d8691f = cache_frame_60b448e7e2dc606440735ac8e5d8691f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_60b448e7e2dc606440735ac8e5d8691f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_60b448e7e2dc606440735ac8e5d8691f ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = par_digest;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__digest, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 278;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_60b448e7e2dc606440735ac8e5d8691f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_60b448e7e2dc606440735ac8e5d8691f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_60b448e7e2dc606440735ac8e5d8691f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_60b448e7e2dc606440735ac8e5d8691f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_60b448e7e2dc606440735ac8e5d8691f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_60b448e7e2dc606440735ac8e5d8691f,
        type_description_1,
        par_self,
        par_digest
    );


    // Release cached frame.
    if ( frame_60b448e7e2dc606440735ac8e5d8691f == cache_frame_60b448e7e2dc606440735ac8e5d8691f )
    {
        Py_DECREF( frame_60b448e7e2dc606440735ac8e5d8691f );
    }
    cache_frame_60b448e7e2dc606440735ac8e5d8691f = NULL;

    assertFrameObject( frame_60b448e7e2dc606440735ac8e5d8691f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_22___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_22___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_23_from_public_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_public_key = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_022896bc33b4a7204d84fa2b6880e6cc = NULL;

    struct Nuitka_FrameObject *frame_022896bc33b4a7204d84fa2b6880e6cc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_022896bc33b4a7204d84fa2b6880e6cc, codeobj_022896bc33b4a7204d84fa2b6880e6cc, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_022896bc33b4a7204d84fa2b6880e6cc = cache_frame_022896bc33b4a7204d84fa2b6880e6cc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_022896bc33b4a7204d84fa2b6880e6cc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_022896bc33b4a7204d84fa2b6880e6cc ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = par_cls;

    CHECK_OBJECT( tmp_called_name_1 );
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__key_identifier_from_public_key );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__key_identifier_from_public_key );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_key_identifier_from_public_key" );
        exception_tb = NULL;

        exception_lineno = 282;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_public_key;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_022896bc33b4a7204d84fa2b6880e6cc->m_frame.f_lineno = 282;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 282;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_022896bc33b4a7204d84fa2b6880e6cc->m_frame.f_lineno = 282;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 282;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_022896bc33b4a7204d84fa2b6880e6cc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_022896bc33b4a7204d84fa2b6880e6cc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_022896bc33b4a7204d84fa2b6880e6cc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_022896bc33b4a7204d84fa2b6880e6cc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_022896bc33b4a7204d84fa2b6880e6cc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_022896bc33b4a7204d84fa2b6880e6cc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_022896bc33b4a7204d84fa2b6880e6cc,
        type_description_1,
        par_cls,
        par_public_key
    );


    // Release cached frame.
    if ( frame_022896bc33b4a7204d84fa2b6880e6cc == cache_frame_022896bc33b4a7204d84fa2b6880e6cc )
    {
        Py_DECREF( frame_022896bc33b4a7204d84fa2b6880e6cc );
    }
    cache_frame_022896bc33b4a7204d84fa2b6880e6cc = NULL;

    assertFrameObject( frame_022896bc33b4a7204d84fa2b6880e6cc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_23_from_public_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_public_key );
    Py_DECREF( par_public_key );
    par_public_key = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_public_key );
    Py_DECREF( par_public_key );
    par_public_key = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_23_from_public_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_24___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_c664490bf2cb1f2b87743a30375121be = NULL;

    struct Nuitka_FrameObject *frame_c664490bf2cb1f2b87743a30375121be;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c664490bf2cb1f2b87743a30375121be, codeobj_c664490bf2cb1f2b87743a30375121be, module_cryptography$x509$extensions, sizeof(void *) );
    frame_c664490bf2cb1f2b87743a30375121be = cache_frame_c664490bf2cb1f2b87743a30375121be;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c664490bf2cb1f2b87743a30375121be );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c664490bf2cb1f2b87743a30375121be ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_2fedee8d2e8553cc3a2acd1bc300acd1;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_digest );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 287;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_c664490bf2cb1f2b87743a30375121be->m_frame.f_lineno = 287;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 287;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c664490bf2cb1f2b87743a30375121be );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c664490bf2cb1f2b87743a30375121be );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c664490bf2cb1f2b87743a30375121be );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c664490bf2cb1f2b87743a30375121be, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c664490bf2cb1f2b87743a30375121be->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c664490bf2cb1f2b87743a30375121be, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c664490bf2cb1f2b87743a30375121be,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_c664490bf2cb1f2b87743a30375121be == cache_frame_c664490bf2cb1f2b87743a30375121be )
    {
        Py_DECREF( frame_c664490bf2cb1f2b87743a30375121be );
    }
    cache_frame_c664490bf2cb1f2b87743a30375121be = NULL;

    assertFrameObject( frame_c664490bf2cb1f2b87743a30375121be );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_24___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_24___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_25___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_57b878bd30a7b81e486b96e3c4401c0a = NULL;

    struct Nuitka_FrameObject *frame_57b878bd30a7b81e486b96e3c4401c0a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_57b878bd30a7b81e486b96e3c4401c0a, codeobj_57b878bd30a7b81e486b96e3c4401c0a, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_57b878bd30a7b81e486b96e3c4401c0a = cache_frame_57b878bd30a7b81e486b96e3c4401c0a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_57b878bd30a7b81e486b96e3c4401c0a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_57b878bd30a7b81e486b96e3c4401c0a ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SubjectKeyIdentifier );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SubjectKeyIdentifier );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "SubjectKeyIdentifier" );
        exception_tb = NULL;

        exception_lineno = 290;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 290;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_constant_time );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_constant_time );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "constant_time" );
        exception_tb = NULL;

        exception_lineno = 293;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_bytes_eq );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_digest );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 293;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_other;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_digest );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 293;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_57b878bd30a7b81e486b96e3c4401c0a->m_frame.f_lineno = 293;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_57b878bd30a7b81e486b96e3c4401c0a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_57b878bd30a7b81e486b96e3c4401c0a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_57b878bd30a7b81e486b96e3c4401c0a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_57b878bd30a7b81e486b96e3c4401c0a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_57b878bd30a7b81e486b96e3c4401c0a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_57b878bd30a7b81e486b96e3c4401c0a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_57b878bd30a7b81e486b96e3c4401c0a,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_57b878bd30a7b81e486b96e3c4401c0a == cache_frame_57b878bd30a7b81e486b96e3c4401c0a )
    {
        Py_DECREF( frame_57b878bd30a7b81e486b96e3c4401c0a );
    }
    cache_frame_57b878bd30a7b81e486b96e3c4401c0a = NULL;

    assertFrameObject( frame_57b878bd30a7b81e486b96e3c4401c0a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_25___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_25___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_26___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_a832e1e599b4539b0c4897fe94eb7731 = NULL;

    struct Nuitka_FrameObject *frame_a832e1e599b4539b0c4897fe94eb7731;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a832e1e599b4539b0c4897fe94eb7731, codeobj_a832e1e599b4539b0c4897fe94eb7731, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_a832e1e599b4539b0c4897fe94eb7731 = cache_frame_a832e1e599b4539b0c4897fe94eb7731;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a832e1e599b4539b0c4897fe94eb7731 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a832e1e599b4539b0c4897fe94eb7731 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 296;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 296;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a832e1e599b4539b0c4897fe94eb7731 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a832e1e599b4539b0c4897fe94eb7731 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a832e1e599b4539b0c4897fe94eb7731 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a832e1e599b4539b0c4897fe94eb7731, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a832e1e599b4539b0c4897fe94eb7731->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a832e1e599b4539b0c4897fe94eb7731, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a832e1e599b4539b0c4897fe94eb7731,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_a832e1e599b4539b0c4897fe94eb7731 == cache_frame_a832e1e599b4539b0c4897fe94eb7731 )
    {
        Py_DECREF( frame_a832e1e599b4539b0c4897fe94eb7731 );
    }
    cache_frame_a832e1e599b4539b0c4897fe94eb7731 = NULL;

    assertFrameObject( frame_a832e1e599b4539b0c4897fe94eb7731 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_26___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_26___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_27___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_659a0820a281f91b587826d06e5c7fee = NULL;

    struct Nuitka_FrameObject *frame_659a0820a281f91b587826d06e5c7fee;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_659a0820a281f91b587826d06e5c7fee, codeobj_659a0820a281f91b587826d06e5c7fee, module_cryptography$x509$extensions, sizeof(void *) );
    frame_659a0820a281f91b587826d06e5c7fee = cache_frame_659a0820a281f91b587826d06e5c7fee;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_659a0820a281f91b587826d06e5c7fee );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_659a0820a281f91b587826d06e5c7fee ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_hash_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_digest );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 299;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 299;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_659a0820a281f91b587826d06e5c7fee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_659a0820a281f91b587826d06e5c7fee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_659a0820a281f91b587826d06e5c7fee );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_659a0820a281f91b587826d06e5c7fee, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_659a0820a281f91b587826d06e5c7fee->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_659a0820a281f91b587826d06e5c7fee, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_659a0820a281f91b587826d06e5c7fee,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_659a0820a281f91b587826d06e5c7fee == cache_frame_659a0820a281f91b587826d06e5c7fee )
    {
        Py_DECREF( frame_659a0820a281f91b587826d06e5c7fee );
    }
    cache_frame_659a0820a281f91b587826d06e5c7fee = NULL;

    assertFrameObject( frame_659a0820a281f91b587826d06e5c7fee );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_27___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_27___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_28___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_descriptions = python_pars[ 1 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_40f213b6f11b241a43740142e00ab9ab = NULL;

    struct Nuitka_FrameObject *frame_40f213b6f11b241a43740142e00ab9ab;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_40f213b6f11b241a43740142e00ab9ab, codeobj_40f213b6f11b241a43740142e00ab9ab, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_40f213b6f11b241a43740142e00ab9ab = cache_frame_40f213b6f11b241a43740142e00ab9ab;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_40f213b6f11b241a43740142e00ab9ab );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_40f213b6f11b241a43740142e00ab9ab ) == 2 ); // Frame stack

    // Framed code:
    tmp_list_arg_1 = par_descriptions;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 307;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_descriptions;
        assert( old != NULL );
        par_descriptions = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_descriptions;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 308;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_28___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_8017e2f65ba06ea20e193d996eb1cfec,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_28___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_28___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_40f213b6f11b241a43740142e00ab9ab->m_frame.f_lineno = 308;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 308;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 308;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_52903da339eb426b3d703a3f30ce3e10;
    frame_40f213b6f11b241a43740142e00ab9ab->m_frame.f_lineno = 309;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 309;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_descriptions;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__descriptions, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 314;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40f213b6f11b241a43740142e00ab9ab );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40f213b6f11b241a43740142e00ab9ab );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_40f213b6f11b241a43740142e00ab9ab, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_40f213b6f11b241a43740142e00ab9ab->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_40f213b6f11b241a43740142e00ab9ab, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_40f213b6f11b241a43740142e00ab9ab,
        type_description_1,
        par_self,
        par_descriptions
    );


    // Release cached frame.
    if ( frame_40f213b6f11b241a43740142e00ab9ab == cache_frame_40f213b6f11b241a43740142e00ab9ab )
    {
        Py_DECREF( frame_40f213b6f11b241a43740142e00ab9ab );
    }
    cache_frame_40f213b6f11b241a43740142e00ab9ab = NULL;

    assertFrameObject( frame_40f213b6f11b241a43740142e00ab9ab );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_28___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_descriptions );
    Py_DECREF( par_descriptions );
    par_descriptions = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_descriptions );
    Py_DECREF( par_descriptions );
    par_descriptions = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_28___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_28___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_28___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_28___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_8017e2f65ba06ea20e193d996eb1cfec, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 308;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 308;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AccessDescription );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AccessDescription );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "AccessDescription" );
        exception_tb = NULL;

        exception_lineno = 308;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 308;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 308;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 308;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_29___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_f799b95668610ebc24d3f07b237690e1 = NULL;

    struct Nuitka_FrameObject *frame_f799b95668610ebc24d3f07b237690e1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f799b95668610ebc24d3f07b237690e1, codeobj_f799b95668610ebc24d3f07b237690e1, module_cryptography$x509$extensions, sizeof(void *) );
    frame_f799b95668610ebc24d3f07b237690e1 = cache_frame_f799b95668610ebc24d3f07b237690e1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f799b95668610ebc24d3f07b237690e1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f799b95668610ebc24d3f07b237690e1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_26a75172f55108334b01cdc8efcbab38;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__descriptions );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 319;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_f799b95668610ebc24d3f07b237690e1->m_frame.f_lineno = 319;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 319;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f799b95668610ebc24d3f07b237690e1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f799b95668610ebc24d3f07b237690e1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f799b95668610ebc24d3f07b237690e1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f799b95668610ebc24d3f07b237690e1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f799b95668610ebc24d3f07b237690e1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f799b95668610ebc24d3f07b237690e1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f799b95668610ebc24d3f07b237690e1,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f799b95668610ebc24d3f07b237690e1 == cache_frame_f799b95668610ebc24d3f07b237690e1 )
    {
        Py_DECREF( frame_f799b95668610ebc24d3f07b237690e1 );
    }
    cache_frame_f799b95668610ebc24d3f07b237690e1 = NULL;

    assertFrameObject( frame_f799b95668610ebc24d3f07b237690e1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_29___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_29___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_30___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_cd463798241da98486e9c3fa55f5fc4d = NULL;

    struct Nuitka_FrameObject *frame_cd463798241da98486e9c3fa55f5fc4d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cd463798241da98486e9c3fa55f5fc4d, codeobj_cd463798241da98486e9c3fa55f5fc4d, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_cd463798241da98486e9c3fa55f5fc4d = cache_frame_cd463798241da98486e9c3fa55f5fc4d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cd463798241da98486e9c3fa55f5fc4d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cd463798241da98486e9c3fa55f5fc4d ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AuthorityInformationAccess );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AuthorityInformationAccess );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "AuthorityInformationAccess" );
        exception_tb = NULL;

        exception_lineno = 322;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 322;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__descriptions );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 325;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__descriptions );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 325;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 325;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd463798241da98486e9c3fa55f5fc4d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd463798241da98486e9c3fa55f5fc4d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd463798241da98486e9c3fa55f5fc4d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cd463798241da98486e9c3fa55f5fc4d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cd463798241da98486e9c3fa55f5fc4d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cd463798241da98486e9c3fa55f5fc4d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cd463798241da98486e9c3fa55f5fc4d,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_cd463798241da98486e9c3fa55f5fc4d == cache_frame_cd463798241da98486e9c3fa55f5fc4d )
    {
        Py_DECREF( frame_cd463798241da98486e9c3fa55f5fc4d );
    }
    cache_frame_cd463798241da98486e9c3fa55f5fc4d = NULL;

    assertFrameObject( frame_cd463798241da98486e9c3fa55f5fc4d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_30___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_30___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_31___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_1ad98fd393824af3d185d3a361c38cfa = NULL;

    struct Nuitka_FrameObject *frame_1ad98fd393824af3d185d3a361c38cfa;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1ad98fd393824af3d185d3a361c38cfa, codeobj_1ad98fd393824af3d185d3a361c38cfa, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_1ad98fd393824af3d185d3a361c38cfa = cache_frame_1ad98fd393824af3d185d3a361c38cfa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1ad98fd393824af3d185d3a361c38cfa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1ad98fd393824af3d185d3a361c38cfa ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 328;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 328;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1ad98fd393824af3d185d3a361c38cfa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1ad98fd393824af3d185d3a361c38cfa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1ad98fd393824af3d185d3a361c38cfa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1ad98fd393824af3d185d3a361c38cfa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1ad98fd393824af3d185d3a361c38cfa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1ad98fd393824af3d185d3a361c38cfa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1ad98fd393824af3d185d3a361c38cfa,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_1ad98fd393824af3d185d3a361c38cfa == cache_frame_1ad98fd393824af3d185d3a361c38cfa )
    {
        Py_DECREF( frame_1ad98fd393824af3d185d3a361c38cfa );
    }
    cache_frame_1ad98fd393824af3d185d3a361c38cfa = NULL;

    assertFrameObject( frame_1ad98fd393824af3d185d3a361c38cfa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_31___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_31___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_32___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_arg_1;
    static struct Nuitka_FrameObject *cache_frame_fb2d1e86479ac610614a07d93fea0f47 = NULL;

    struct Nuitka_FrameObject *frame_fb2d1e86479ac610614a07d93fea0f47;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fb2d1e86479ac610614a07d93fea0f47, codeobj_fb2d1e86479ac610614a07d93fea0f47, module_cryptography$x509$extensions, sizeof(void *) );
    frame_fb2d1e86479ac610614a07d93fea0f47 = cache_frame_fb2d1e86479ac610614a07d93fea0f47;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fb2d1e86479ac610614a07d93fea0f47 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fb2d1e86479ac610614a07d93fea0f47 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__descriptions );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 331;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_hash_arg_1 = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 331;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 331;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fb2d1e86479ac610614a07d93fea0f47 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fb2d1e86479ac610614a07d93fea0f47 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fb2d1e86479ac610614a07d93fea0f47 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fb2d1e86479ac610614a07d93fea0f47, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fb2d1e86479ac610614a07d93fea0f47->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fb2d1e86479ac610614a07d93fea0f47, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fb2d1e86479ac610614a07d93fea0f47,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_fb2d1e86479ac610614a07d93fea0f47 == cache_frame_fb2d1e86479ac610614a07d93fea0f47 )
    {
        Py_DECREF( frame_fb2d1e86479ac610614a07d93fea0f47 );
    }
    cache_frame_fb2d1e86479ac610614a07d93fea0f47 = NULL;

    assertFrameObject( frame_fb2d1e86479ac610614a07d93fea0f47 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_32___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_32___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_33___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_access_method = python_pars[ 1 ];
    PyObject *par_access_location = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_9b119bc9e22a532e859a09afb821f8e4 = NULL;

    struct Nuitka_FrameObject *frame_9b119bc9e22a532e859a09afb821f8e4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9b119bc9e22a532e859a09afb821f8e4, codeobj_9b119bc9e22a532e859a09afb821f8e4, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9b119bc9e22a532e859a09afb821f8e4 = cache_frame_9b119bc9e22a532e859a09afb821f8e4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9b119bc9e22a532e859a09afb821f8e4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9b119bc9e22a532e859a09afb821f8e4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_access_method;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ObjectIdentifier" );
        exception_tb = NULL;

        exception_lineno = 336;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 336;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_b436a97f38724e3583df19a1d449e278;
    frame_9b119bc9e22a532e859a09afb821f8e4->m_frame.f_lineno = 337;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 337;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_isinstance_inst_2 = par_access_location;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_isinstance_cls_2 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName );

    if (unlikely( tmp_isinstance_cls_2 == NULL ))
    {
        tmp_isinstance_cls_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName );
    }

    if ( tmp_isinstance_cls_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GeneralName" );
        exception_tb = NULL;

        exception_lineno = 339;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 339;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_1dfb7a6265a6e9db387c1d41869616b8;
    frame_9b119bc9e22a532e859a09afb821f8e4->m_frame.f_lineno = 340;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 340;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_assattr_name_1 = par_access_method;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__access_method, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 342;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_access_location;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__access_location, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 343;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9b119bc9e22a532e859a09afb821f8e4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9b119bc9e22a532e859a09afb821f8e4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9b119bc9e22a532e859a09afb821f8e4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9b119bc9e22a532e859a09afb821f8e4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9b119bc9e22a532e859a09afb821f8e4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9b119bc9e22a532e859a09afb821f8e4,
        type_description_1,
        par_self,
        par_access_method,
        par_access_location
    );


    // Release cached frame.
    if ( frame_9b119bc9e22a532e859a09afb821f8e4 == cache_frame_9b119bc9e22a532e859a09afb821f8e4 )
    {
        Py_DECREF( frame_9b119bc9e22a532e859a09afb821f8e4 );
    }
    cache_frame_9b119bc9e22a532e859a09afb821f8e4 = NULL;

    assertFrameObject( frame_9b119bc9e22a532e859a09afb821f8e4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_33___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_access_location );
    Py_DECREF( par_access_location );
    par_access_location = NULL;

    CHECK_OBJECT( (PyObject *)par_access_method );
    Py_DECREF( par_access_method );
    par_access_method = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_access_location );
    Py_DECREF( par_access_location );
    par_access_location = NULL;

    CHECK_OBJECT( (PyObject *)par_access_method );
    Py_DECREF( par_access_method );
    par_access_method = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_33___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_34___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_d999c9f13b6b8303947563cefca3f80f = NULL;

    struct Nuitka_FrameObject *frame_d999c9f13b6b8303947563cefca3f80f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d999c9f13b6b8303947563cefca3f80f, codeobj_d999c9f13b6b8303947563cefca3f80f, module_cryptography$x509$extensions, sizeof(void *) );
    frame_d999c9f13b6b8303947563cefca3f80f = cache_frame_d999c9f13b6b8303947563cefca3f80f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d999c9f13b6b8303947563cefca3f80f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d999c9f13b6b8303947563cefca3f80f ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_5576b3ba482b3c884e20c0f0f9889daf;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_d999c9f13b6b8303947563cefca3f80f->m_frame.f_lineno = 347;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 347;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d999c9f13b6b8303947563cefca3f80f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d999c9f13b6b8303947563cefca3f80f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d999c9f13b6b8303947563cefca3f80f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d999c9f13b6b8303947563cefca3f80f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d999c9f13b6b8303947563cefca3f80f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d999c9f13b6b8303947563cefca3f80f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d999c9f13b6b8303947563cefca3f80f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d999c9f13b6b8303947563cefca3f80f == cache_frame_d999c9f13b6b8303947563cefca3f80f )
    {
        Py_DECREF( frame_d999c9f13b6b8303947563cefca3f80f );
    }
    cache_frame_d999c9f13b6b8303947563cefca3f80f = NULL;

    assertFrameObject( frame_d999c9f13b6b8303947563cefca3f80f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_34___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_34___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_35___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_4e91e44c3bcc754dd269c486ee08327b = NULL;

    struct Nuitka_FrameObject *frame_4e91e44c3bcc754dd269c486ee08327b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4e91e44c3bcc754dd269c486ee08327b, codeobj_4e91e44c3bcc754dd269c486ee08327b, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_4e91e44c3bcc754dd269c486ee08327b = cache_frame_4e91e44c3bcc754dd269c486ee08327b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4e91e44c3bcc754dd269c486ee08327b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4e91e44c3bcc754dd269c486ee08327b ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AccessDescription );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AccessDescription );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "AccessDescription" );
        exception_tb = NULL;

        exception_lineno = 352;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 352;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_access_method );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 356;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_access_method );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 356;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 356;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 357;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_access_location );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 357;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_other;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_access_location );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 357;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 357;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4e91e44c3bcc754dd269c486ee08327b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4e91e44c3bcc754dd269c486ee08327b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4e91e44c3bcc754dd269c486ee08327b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4e91e44c3bcc754dd269c486ee08327b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4e91e44c3bcc754dd269c486ee08327b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4e91e44c3bcc754dd269c486ee08327b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4e91e44c3bcc754dd269c486ee08327b,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_4e91e44c3bcc754dd269c486ee08327b == cache_frame_4e91e44c3bcc754dd269c486ee08327b )
    {
        Py_DECREF( frame_4e91e44c3bcc754dd269c486ee08327b );
    }
    cache_frame_4e91e44c3bcc754dd269c486ee08327b = NULL;

    assertFrameObject( frame_4e91e44c3bcc754dd269c486ee08327b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_35___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_35___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_36___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_82367caa71540dce30cd160871f23994 = NULL;

    struct Nuitka_FrameObject *frame_82367caa71540dce30cd160871f23994;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_82367caa71540dce30cd160871f23994, codeobj_82367caa71540dce30cd160871f23994, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_82367caa71540dce30cd160871f23994 = cache_frame_82367caa71540dce30cd160871f23994;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_82367caa71540dce30cd160871f23994 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_82367caa71540dce30cd160871f23994 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 361;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 361;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_82367caa71540dce30cd160871f23994 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_82367caa71540dce30cd160871f23994 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_82367caa71540dce30cd160871f23994 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_82367caa71540dce30cd160871f23994, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_82367caa71540dce30cd160871f23994->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_82367caa71540dce30cd160871f23994, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_82367caa71540dce30cd160871f23994,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_82367caa71540dce30cd160871f23994 == cache_frame_82367caa71540dce30cd160871f23994 )
    {
        Py_DECREF( frame_82367caa71540dce30cd160871f23994 );
    }
    cache_frame_82367caa71540dce30cd160871f23994 = NULL;

    assertFrameObject( frame_82367caa71540dce30cd160871f23994 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_36___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_36___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_37___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_6d5e1e6a7899503b88d3340b3792fdf9 = NULL;

    struct Nuitka_FrameObject *frame_6d5e1e6a7899503b88d3340b3792fdf9;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6d5e1e6a7899503b88d3340b3792fdf9, codeobj_6d5e1e6a7899503b88d3340b3792fdf9, module_cryptography$x509$extensions, sizeof(void *) );
    frame_6d5e1e6a7899503b88d3340b3792fdf9 = cache_frame_6d5e1e6a7899503b88d3340b3792fdf9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6d5e1e6a7899503b88d3340b3792fdf9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6d5e1e6a7899503b88d3340b3792fdf9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_hash_arg_1 = PyTuple_New( 2 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_access_method );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 364;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_access_location );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 364;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 1, tmp_tuple_element_1 );
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 364;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6d5e1e6a7899503b88d3340b3792fdf9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6d5e1e6a7899503b88d3340b3792fdf9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6d5e1e6a7899503b88d3340b3792fdf9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6d5e1e6a7899503b88d3340b3792fdf9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6d5e1e6a7899503b88d3340b3792fdf9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6d5e1e6a7899503b88d3340b3792fdf9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6d5e1e6a7899503b88d3340b3792fdf9,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6d5e1e6a7899503b88d3340b3792fdf9 == cache_frame_6d5e1e6a7899503b88d3340b3792fdf9 )
    {
        Py_DECREF( frame_6d5e1e6a7899503b88d3340b3792fdf9 );
    }
    cache_frame_6d5e1e6a7899503b88d3340b3792fdf9 = NULL;

    assertFrameObject( frame_6d5e1e6a7899503b88d3340b3792fdf9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_37___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_37___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_38___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_ca = python_pars[ 1 ];
    PyObject *par_path_length = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_operand_name_2;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_4ca18bfa12c3bc19559b0a1931a20efa = NULL;

    struct Nuitka_FrameObject *frame_4ca18bfa12c3bc19559b0a1931a20efa;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4ca18bfa12c3bc19559b0a1931a20efa, codeobj_4ca18bfa12c3bc19559b0a1931a20efa, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_4ca18bfa12c3bc19559b0a1931a20efa = cache_frame_4ca18bfa12c3bc19559b0a1931a20efa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4ca18bfa12c3bc19559b0a1931a20efa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4ca18bfa12c3bc19559b0a1931a20efa ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_ca;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyBool_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 375;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_421b43a5ec9f9f0f5f30b5a50ec3db96;
    frame_4ca18bfa12c3bc19559b0a1931a20efa->m_frame.f_lineno = 376;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 376;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_compexpr_left_1 = par_path_length;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = Py_None;
    tmp_and_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 != tmp_compexpr_right_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    assert( !(tmp_and_left_truth_1 == -1) );
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_operand_name_1 = par_ca;

    CHECK_OBJECT( tmp_operand_name_1 );
    tmp_and_right_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 378;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 378;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_ba0ace4d3ab5fb435146fa7a7a8c5e76;
    frame_4ca18bfa12c3bc19559b0a1931a20efa->m_frame.f_lineno = 379;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 379;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_compexpr_left_2 = par_path_length;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = Py_None;
    tmp_and_left_value_2 = BOOL_FROM( tmp_compexpr_left_2 != tmp_compexpr_right_2 );
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    assert( !(tmp_and_left_truth_2 == -1) );
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    tmp_isinstance_inst_2 = par_path_length;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_six );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "six" );
        exception_tb = NULL;

        exception_lineno = 383;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_integer_types );
    if ( tmp_isinstance_cls_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 383;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_operand_name_2 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    Py_DECREF( tmp_isinstance_cls_2 );
    if ( tmp_operand_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 383;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_2 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 383;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 383;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    tmp_compexpr_left_3 = par_path_length;

    CHECK_OBJECT( tmp_compexpr_left_3 );
    tmp_compexpr_right_3 = const_int_0;
    tmp_or_right_value_1 = RICH_COMPARE_LT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 383;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_2 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    Py_INCREF( tmp_or_left_value_1 );
    tmp_and_right_value_2 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_value_2 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    Py_INCREF( tmp_and_left_value_2 );
    tmp_cond_value_2 = tmp_and_left_value_2;
    and_end_2:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 383;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_3 = const_str_digest_350fb76bfa2c81c3db35fe4ad0c5cc28;
    frame_4ca18bfa12c3bc19559b0a1931a20efa->m_frame.f_lineno = 385;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 385;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    tmp_assattr_name_1 = par_ca;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__ca, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 389;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_path_length;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__path_length, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 390;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4ca18bfa12c3bc19559b0a1931a20efa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4ca18bfa12c3bc19559b0a1931a20efa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4ca18bfa12c3bc19559b0a1931a20efa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4ca18bfa12c3bc19559b0a1931a20efa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4ca18bfa12c3bc19559b0a1931a20efa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4ca18bfa12c3bc19559b0a1931a20efa,
        type_description_1,
        par_self,
        par_ca,
        par_path_length
    );


    // Release cached frame.
    if ( frame_4ca18bfa12c3bc19559b0a1931a20efa == cache_frame_4ca18bfa12c3bc19559b0a1931a20efa )
    {
        Py_DECREF( frame_4ca18bfa12c3bc19559b0a1931a20efa );
    }
    cache_frame_4ca18bfa12c3bc19559b0a1931a20efa = NULL;

    assertFrameObject( frame_4ca18bfa12c3bc19559b0a1931a20efa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_38___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_ca );
    Py_DECREF( par_ca );
    par_ca = NULL;

    CHECK_OBJECT( (PyObject *)par_path_length );
    Py_DECREF( par_path_length );
    par_path_length = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_ca );
    Py_DECREF( par_ca );
    par_ca = NULL;

    CHECK_OBJECT( (PyObject *)par_path_length );
    Py_DECREF( par_path_length );
    par_path_length = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_38___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_39___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_b40e6da599a2c89c752888c535860a7a = NULL;

    struct Nuitka_FrameObject *frame_b40e6da599a2c89c752888c535860a7a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b40e6da599a2c89c752888c535860a7a, codeobj_b40e6da599a2c89c752888c535860a7a, module_cryptography$x509$extensions, sizeof(void *) );
    frame_b40e6da599a2c89c752888c535860a7a = cache_frame_b40e6da599a2c89c752888c535860a7a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b40e6da599a2c89c752888c535860a7a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b40e6da599a2c89c752888c535860a7a ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_d0363a16b2327897c21c9e61fd2edb1e;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_b40e6da599a2c89c752888c535860a7a->m_frame.f_lineno = 396;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 396;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b40e6da599a2c89c752888c535860a7a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b40e6da599a2c89c752888c535860a7a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b40e6da599a2c89c752888c535860a7a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b40e6da599a2c89c752888c535860a7a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b40e6da599a2c89c752888c535860a7a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b40e6da599a2c89c752888c535860a7a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b40e6da599a2c89c752888c535860a7a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b40e6da599a2c89c752888c535860a7a == cache_frame_b40e6da599a2c89c752888c535860a7a )
    {
        Py_DECREF( frame_b40e6da599a2c89c752888c535860a7a );
    }
    cache_frame_b40e6da599a2c89c752888c535860a7a = NULL;

    assertFrameObject( frame_b40e6da599a2c89c752888c535860a7a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_39___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_39___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_40___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_dc0f15fbcff159e2a6f1050cb1735e72 = NULL;

    struct Nuitka_FrameObject *frame_dc0f15fbcff159e2a6f1050cb1735e72;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dc0f15fbcff159e2a6f1050cb1735e72, codeobj_dc0f15fbcff159e2a6f1050cb1735e72, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_dc0f15fbcff159e2a6f1050cb1735e72 = cache_frame_dc0f15fbcff159e2a6f1050cb1735e72;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dc0f15fbcff159e2a6f1050cb1735e72 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dc0f15fbcff159e2a6f1050cb1735e72 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_BasicConstraints );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_BasicConstraints );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "BasicConstraints" );
        exception_tb = NULL;

        exception_lineno = 400;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 400;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ca );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 403;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_ca );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 403;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 403;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 403;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_path_length );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 403;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_other;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_path_length );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 403;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 403;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dc0f15fbcff159e2a6f1050cb1735e72 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_dc0f15fbcff159e2a6f1050cb1735e72 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dc0f15fbcff159e2a6f1050cb1735e72 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dc0f15fbcff159e2a6f1050cb1735e72, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dc0f15fbcff159e2a6f1050cb1735e72->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dc0f15fbcff159e2a6f1050cb1735e72, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dc0f15fbcff159e2a6f1050cb1735e72,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_dc0f15fbcff159e2a6f1050cb1735e72 == cache_frame_dc0f15fbcff159e2a6f1050cb1735e72 )
    {
        Py_DECREF( frame_dc0f15fbcff159e2a6f1050cb1735e72 );
    }
    cache_frame_dc0f15fbcff159e2a6f1050cb1735e72 = NULL;

    assertFrameObject( frame_dc0f15fbcff159e2a6f1050cb1735e72 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_40___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_40___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_41___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_e7e78460243290e4e69f97e186caf46f = NULL;

    struct Nuitka_FrameObject *frame_e7e78460243290e4e69f97e186caf46f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e7e78460243290e4e69f97e186caf46f, codeobj_e7e78460243290e4e69f97e186caf46f, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_e7e78460243290e4e69f97e186caf46f = cache_frame_e7e78460243290e4e69f97e186caf46f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e7e78460243290e4e69f97e186caf46f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e7e78460243290e4e69f97e186caf46f ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 406;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 406;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e7e78460243290e4e69f97e186caf46f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e7e78460243290e4e69f97e186caf46f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e7e78460243290e4e69f97e186caf46f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e7e78460243290e4e69f97e186caf46f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e7e78460243290e4e69f97e186caf46f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e7e78460243290e4e69f97e186caf46f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e7e78460243290e4e69f97e186caf46f,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_e7e78460243290e4e69f97e186caf46f == cache_frame_e7e78460243290e4e69f97e186caf46f )
    {
        Py_DECREF( frame_e7e78460243290e4e69f97e186caf46f );
    }
    cache_frame_e7e78460243290e4e69f97e186caf46f = NULL;

    assertFrameObject( frame_e7e78460243290e4e69f97e186caf46f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_41___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_41___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_42___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_d4425f82b152e2d24c56b73e79a512b0 = NULL;

    struct Nuitka_FrameObject *frame_d4425f82b152e2d24c56b73e79a512b0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d4425f82b152e2d24c56b73e79a512b0, codeobj_d4425f82b152e2d24c56b73e79a512b0, module_cryptography$x509$extensions, sizeof(void *) );
    frame_d4425f82b152e2d24c56b73e79a512b0 = cache_frame_d4425f82b152e2d24c56b73e79a512b0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d4425f82b152e2d24c56b73e79a512b0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d4425f82b152e2d24c56b73e79a512b0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_hash_arg_1 = PyTuple_New( 2 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ca );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 409;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_path_length );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 409;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 1, tmp_tuple_element_1 );
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 409;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4425f82b152e2d24c56b73e79a512b0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4425f82b152e2d24c56b73e79a512b0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4425f82b152e2d24c56b73e79a512b0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d4425f82b152e2d24c56b73e79a512b0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d4425f82b152e2d24c56b73e79a512b0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d4425f82b152e2d24c56b73e79a512b0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d4425f82b152e2d24c56b73e79a512b0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d4425f82b152e2d24c56b73e79a512b0 == cache_frame_d4425f82b152e2d24c56b73e79a512b0 )
    {
        Py_DECREF( frame_d4425f82b152e2d24c56b73e79a512b0 );
    }
    cache_frame_d4425f82b152e2d24c56b73e79a512b0 = NULL;

    assertFrameObject( frame_d4425f82b152e2d24c56b73e79a512b0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_42___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_42___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_43___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_crl_number = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_c2b4b4eb68b8cda65212caee479d5c37 = NULL;

    struct Nuitka_FrameObject *frame_c2b4b4eb68b8cda65212caee479d5c37;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c2b4b4eb68b8cda65212caee479d5c37, codeobj_c2b4b4eb68b8cda65212caee479d5c37, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_c2b4b4eb68b8cda65212caee479d5c37 = cache_frame_c2b4b4eb68b8cda65212caee479d5c37;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c2b4b4eb68b8cda65212caee479d5c37 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c2b4b4eb68b8cda65212caee479d5c37 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_crl_number;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_six );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "six" );
        exception_tb = NULL;

        exception_lineno = 417;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_integer_types );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 417;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 417;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_f7714799e19abc5d09ccbaf8366649ea;
    frame_c2b4b4eb68b8cda65212caee479d5c37->m_frame.f_lineno = 418;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 418;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_crl_number;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__crl_number, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 420;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c2b4b4eb68b8cda65212caee479d5c37 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c2b4b4eb68b8cda65212caee479d5c37 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c2b4b4eb68b8cda65212caee479d5c37, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c2b4b4eb68b8cda65212caee479d5c37->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c2b4b4eb68b8cda65212caee479d5c37, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c2b4b4eb68b8cda65212caee479d5c37,
        type_description_1,
        par_self,
        par_crl_number
    );


    // Release cached frame.
    if ( frame_c2b4b4eb68b8cda65212caee479d5c37 == cache_frame_c2b4b4eb68b8cda65212caee479d5c37 )
    {
        Py_DECREF( frame_c2b4b4eb68b8cda65212caee479d5c37 );
    }
    cache_frame_c2b4b4eb68b8cda65212caee479d5c37 = NULL;

    assertFrameObject( frame_c2b4b4eb68b8cda65212caee479d5c37 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_43___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_crl_number );
    Py_DECREF( par_crl_number );
    par_crl_number = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_crl_number );
    Py_DECREF( par_crl_number );
    par_crl_number = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_43___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_44___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_2a4cd2aacba5505bee324db73a85961b = NULL;

    struct Nuitka_FrameObject *frame_2a4cd2aacba5505bee324db73a85961b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2a4cd2aacba5505bee324db73a85961b, codeobj_2a4cd2aacba5505bee324db73a85961b, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_2a4cd2aacba5505bee324db73a85961b = cache_frame_2a4cd2aacba5505bee324db73a85961b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2a4cd2aacba5505bee324db73a85961b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2a4cd2aacba5505bee324db73a85961b ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DeltaCRLIndicator );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeltaCRLIndicator );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "DeltaCRLIndicator" );
        exception_tb = NULL;

        exception_lineno = 425;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 425;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_crl_number );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 428;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_crl_number );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 428;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 428;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2a4cd2aacba5505bee324db73a85961b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2a4cd2aacba5505bee324db73a85961b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2a4cd2aacba5505bee324db73a85961b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2a4cd2aacba5505bee324db73a85961b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2a4cd2aacba5505bee324db73a85961b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2a4cd2aacba5505bee324db73a85961b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2a4cd2aacba5505bee324db73a85961b,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_2a4cd2aacba5505bee324db73a85961b == cache_frame_2a4cd2aacba5505bee324db73a85961b )
    {
        Py_DECREF( frame_2a4cd2aacba5505bee324db73a85961b );
    }
    cache_frame_2a4cd2aacba5505bee324db73a85961b = NULL;

    assertFrameObject( frame_2a4cd2aacba5505bee324db73a85961b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_44___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_44___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_45___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_2d3cca7ece0d16a2395b72a526be98a8 = NULL;

    struct Nuitka_FrameObject *frame_2d3cca7ece0d16a2395b72a526be98a8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2d3cca7ece0d16a2395b72a526be98a8, codeobj_2d3cca7ece0d16a2395b72a526be98a8, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_2d3cca7ece0d16a2395b72a526be98a8 = cache_frame_2d3cca7ece0d16a2395b72a526be98a8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2d3cca7ece0d16a2395b72a526be98a8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2d3cca7ece0d16a2395b72a526be98a8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 431;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 431;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2d3cca7ece0d16a2395b72a526be98a8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2d3cca7ece0d16a2395b72a526be98a8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2d3cca7ece0d16a2395b72a526be98a8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2d3cca7ece0d16a2395b72a526be98a8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2d3cca7ece0d16a2395b72a526be98a8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2d3cca7ece0d16a2395b72a526be98a8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2d3cca7ece0d16a2395b72a526be98a8,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_2d3cca7ece0d16a2395b72a526be98a8 == cache_frame_2d3cca7ece0d16a2395b72a526be98a8 )
    {
        Py_DECREF( frame_2d3cca7ece0d16a2395b72a526be98a8 );
    }
    cache_frame_2d3cca7ece0d16a2395b72a526be98a8 = NULL;

    assertFrameObject( frame_2d3cca7ece0d16a2395b72a526be98a8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_45___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_45___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_46___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_a028e2d79c3f3de23eb6a9238178dcbb = NULL;

    struct Nuitka_FrameObject *frame_a028e2d79c3f3de23eb6a9238178dcbb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a028e2d79c3f3de23eb6a9238178dcbb, codeobj_a028e2d79c3f3de23eb6a9238178dcbb, module_cryptography$x509$extensions, sizeof(void *) );
    frame_a028e2d79c3f3de23eb6a9238178dcbb = cache_frame_a028e2d79c3f3de23eb6a9238178dcbb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a028e2d79c3f3de23eb6a9238178dcbb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a028e2d79c3f3de23eb6a9238178dcbb ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_hash_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_crl_number );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 434;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 434;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a028e2d79c3f3de23eb6a9238178dcbb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a028e2d79c3f3de23eb6a9238178dcbb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a028e2d79c3f3de23eb6a9238178dcbb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a028e2d79c3f3de23eb6a9238178dcbb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a028e2d79c3f3de23eb6a9238178dcbb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a028e2d79c3f3de23eb6a9238178dcbb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a028e2d79c3f3de23eb6a9238178dcbb,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_a028e2d79c3f3de23eb6a9238178dcbb == cache_frame_a028e2d79c3f3de23eb6a9238178dcbb )
    {
        Py_DECREF( frame_a028e2d79c3f3de23eb6a9238178dcbb );
    }
    cache_frame_a028e2d79c3f3de23eb6a9238178dcbb = NULL;

    assertFrameObject( frame_a028e2d79c3f3de23eb6a9238178dcbb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_46___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_46___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_47___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_570758ffab42816481105f89d6aa8913 = NULL;

    struct Nuitka_FrameObject *frame_570758ffab42816481105f89d6aa8913;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_570758ffab42816481105f89d6aa8913, codeobj_570758ffab42816481105f89d6aa8913, module_cryptography$x509$extensions, sizeof(void *) );
    frame_570758ffab42816481105f89d6aa8913 = cache_frame_570758ffab42816481105f89d6aa8913;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_570758ffab42816481105f89d6aa8913 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_570758ffab42816481105f89d6aa8913 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_009ff6af115398b3dfb26f0926fdbea2;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_570758ffab42816481105f89d6aa8913->m_frame.f_lineno = 437;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 437;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_570758ffab42816481105f89d6aa8913 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_570758ffab42816481105f89d6aa8913 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_570758ffab42816481105f89d6aa8913 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_570758ffab42816481105f89d6aa8913, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_570758ffab42816481105f89d6aa8913->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_570758ffab42816481105f89d6aa8913, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_570758ffab42816481105f89d6aa8913,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_570758ffab42816481105f89d6aa8913 == cache_frame_570758ffab42816481105f89d6aa8913 )
    {
        Py_DECREF( frame_570758ffab42816481105f89d6aa8913 );
    }
    cache_frame_570758ffab42816481105f89d6aa8913 = NULL;

    assertFrameObject( frame_570758ffab42816481105f89d6aa8913 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_47___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_47___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_48___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_distribution_points = python_pars[ 1 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_7343becceae098df6e086719547e2f7e = NULL;

    struct Nuitka_FrameObject *frame_7343becceae098df6e086719547e2f7e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7343becceae098df6e086719547e2f7e, codeobj_7343becceae098df6e086719547e2f7e, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_7343becceae098df6e086719547e2f7e = cache_frame_7343becceae098df6e086719547e2f7e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7343becceae098df6e086719547e2f7e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7343becceae098df6e086719547e2f7e ) == 2 ); // Frame stack

    // Framed code:
    tmp_list_arg_1 = par_distribution_points;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 445;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_distribution_points;
        assert( old != NULL );
        par_distribution_points = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_distribution_points;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 447;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_48___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_3b42e089c008ee23c7f6e75389fecdbc,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_48___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_48___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_7343becceae098df6e086719547e2f7e->m_frame.f_lineno = 446;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 446;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 446;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_37a5813a8df88d549fa10cdd6f24a9b9;
    frame_7343becceae098df6e086719547e2f7e->m_frame.f_lineno = 449;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 449;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_distribution_points;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__distribution_points, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 454;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7343becceae098df6e086719547e2f7e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7343becceae098df6e086719547e2f7e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7343becceae098df6e086719547e2f7e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7343becceae098df6e086719547e2f7e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7343becceae098df6e086719547e2f7e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7343becceae098df6e086719547e2f7e,
        type_description_1,
        par_self,
        par_distribution_points
    );


    // Release cached frame.
    if ( frame_7343becceae098df6e086719547e2f7e == cache_frame_7343becceae098df6e086719547e2f7e )
    {
        Py_DECREF( frame_7343becceae098df6e086719547e2f7e );
    }
    cache_frame_7343becceae098df6e086719547e2f7e = NULL;

    assertFrameObject( frame_7343becceae098df6e086719547e2f7e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_48___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_distribution_points );
    Py_DECREF( par_distribution_points );
    par_distribution_points = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_distribution_points );
    Py_DECREF( par_distribution_points );
    par_distribution_points = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_48___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_48___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_48___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_48___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_3b42e089c008ee23c7f6e75389fecdbc, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 447;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 447;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DistributionPoint );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DistributionPoint );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "DistributionPoint" );
        exception_tb = NULL;

        exception_lineno = 447;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 447;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 447;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 447;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_49___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_6cf426505a8a71ab8f24c6f71a74b0cb = NULL;

    struct Nuitka_FrameObject *frame_6cf426505a8a71ab8f24c6f71a74b0cb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6cf426505a8a71ab8f24c6f71a74b0cb, codeobj_6cf426505a8a71ab8f24c6f71a74b0cb, module_cryptography$x509$extensions, sizeof(void *) );
    frame_6cf426505a8a71ab8f24c6f71a74b0cb = cache_frame_6cf426505a8a71ab8f24c6f71a74b0cb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6cf426505a8a71ab8f24c6f71a74b0cb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6cf426505a8a71ab8f24c6f71a74b0cb ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_d0cacbb4febc1bdb60a26b048c7bb9b6;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__distribution_points );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 461;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_6cf426505a8a71ab8f24c6f71a74b0cb->m_frame.f_lineno = 461;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 461;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6cf426505a8a71ab8f24c6f71a74b0cb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6cf426505a8a71ab8f24c6f71a74b0cb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6cf426505a8a71ab8f24c6f71a74b0cb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6cf426505a8a71ab8f24c6f71a74b0cb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6cf426505a8a71ab8f24c6f71a74b0cb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6cf426505a8a71ab8f24c6f71a74b0cb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6cf426505a8a71ab8f24c6f71a74b0cb,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6cf426505a8a71ab8f24c6f71a74b0cb == cache_frame_6cf426505a8a71ab8f24c6f71a74b0cb )
    {
        Py_DECREF( frame_6cf426505a8a71ab8f24c6f71a74b0cb );
    }
    cache_frame_6cf426505a8a71ab8f24c6f71a74b0cb = NULL;

    assertFrameObject( frame_6cf426505a8a71ab8f24c6f71a74b0cb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_49___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_49___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_50___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_b18c87e2d8e243dd66ad82ea564ebd88 = NULL;

    struct Nuitka_FrameObject *frame_b18c87e2d8e243dd66ad82ea564ebd88;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b18c87e2d8e243dd66ad82ea564ebd88, codeobj_b18c87e2d8e243dd66ad82ea564ebd88, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_b18c87e2d8e243dd66ad82ea564ebd88 = cache_frame_b18c87e2d8e243dd66ad82ea564ebd88;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b18c87e2d8e243dd66ad82ea564ebd88 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b18c87e2d8e243dd66ad82ea564ebd88 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLDistributionPoints );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CRLDistributionPoints );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "CRLDistributionPoints" );
        exception_tb = NULL;

        exception_lineno = 464;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 464;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__distribution_points );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__distribution_points );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 467;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b18c87e2d8e243dd66ad82ea564ebd88 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b18c87e2d8e243dd66ad82ea564ebd88 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b18c87e2d8e243dd66ad82ea564ebd88 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b18c87e2d8e243dd66ad82ea564ebd88, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b18c87e2d8e243dd66ad82ea564ebd88->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b18c87e2d8e243dd66ad82ea564ebd88, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b18c87e2d8e243dd66ad82ea564ebd88,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_b18c87e2d8e243dd66ad82ea564ebd88 == cache_frame_b18c87e2d8e243dd66ad82ea564ebd88 )
    {
        Py_DECREF( frame_b18c87e2d8e243dd66ad82ea564ebd88 );
    }
    cache_frame_b18c87e2d8e243dd66ad82ea564ebd88 = NULL;

    assertFrameObject( frame_b18c87e2d8e243dd66ad82ea564ebd88 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_50___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_50___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_51___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_a5a40d86b13e608d03513b23b4a76c2b = NULL;

    struct Nuitka_FrameObject *frame_a5a40d86b13e608d03513b23b4a76c2b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a5a40d86b13e608d03513b23b4a76c2b, codeobj_a5a40d86b13e608d03513b23b4a76c2b, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_a5a40d86b13e608d03513b23b4a76c2b = cache_frame_a5a40d86b13e608d03513b23b4a76c2b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a5a40d86b13e608d03513b23b4a76c2b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a5a40d86b13e608d03513b23b4a76c2b ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 470;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 470;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a5a40d86b13e608d03513b23b4a76c2b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a5a40d86b13e608d03513b23b4a76c2b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a5a40d86b13e608d03513b23b4a76c2b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a5a40d86b13e608d03513b23b4a76c2b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a5a40d86b13e608d03513b23b4a76c2b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a5a40d86b13e608d03513b23b4a76c2b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a5a40d86b13e608d03513b23b4a76c2b,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_a5a40d86b13e608d03513b23b4a76c2b == cache_frame_a5a40d86b13e608d03513b23b4a76c2b )
    {
        Py_DECREF( frame_a5a40d86b13e608d03513b23b4a76c2b );
    }
    cache_frame_a5a40d86b13e608d03513b23b4a76c2b = NULL;

    assertFrameObject( frame_a5a40d86b13e608d03513b23b4a76c2b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_51___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_51___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_52___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_arg_1;
    static struct Nuitka_FrameObject *cache_frame_58ca4cf1e6f5ee2247eee7ab1590e625 = NULL;

    struct Nuitka_FrameObject *frame_58ca4cf1e6f5ee2247eee7ab1590e625;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_58ca4cf1e6f5ee2247eee7ab1590e625, codeobj_58ca4cf1e6f5ee2247eee7ab1590e625, module_cryptography$x509$extensions, sizeof(void *) );
    frame_58ca4cf1e6f5ee2247eee7ab1590e625 = cache_frame_58ca4cf1e6f5ee2247eee7ab1590e625;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_58ca4cf1e6f5ee2247eee7ab1590e625 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_58ca4cf1e6f5ee2247eee7ab1590e625 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__distribution_points );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 473;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_hash_arg_1 = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 473;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 473;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_58ca4cf1e6f5ee2247eee7ab1590e625 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_58ca4cf1e6f5ee2247eee7ab1590e625 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_58ca4cf1e6f5ee2247eee7ab1590e625 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_58ca4cf1e6f5ee2247eee7ab1590e625, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_58ca4cf1e6f5ee2247eee7ab1590e625->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_58ca4cf1e6f5ee2247eee7ab1590e625, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_58ca4cf1e6f5ee2247eee7ab1590e625,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_58ca4cf1e6f5ee2247eee7ab1590e625 == cache_frame_58ca4cf1e6f5ee2247eee7ab1590e625 )
    {
        Py_DECREF( frame_58ca4cf1e6f5ee2247eee7ab1590e625 );
    }
    cache_frame_58ca4cf1e6f5ee2247eee7ab1590e625 = NULL;

    assertFrameObject( frame_58ca4cf1e6f5ee2247eee7ab1590e625 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_52___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_52___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_53___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_distribution_points = python_pars[ 1 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_e83a154ae2975041ff88351280be1927 = NULL;

    struct Nuitka_FrameObject *frame_e83a154ae2975041ff88351280be1927;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e83a154ae2975041ff88351280be1927, codeobj_e83a154ae2975041ff88351280be1927, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_e83a154ae2975041ff88351280be1927 = cache_frame_e83a154ae2975041ff88351280be1927;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e83a154ae2975041ff88351280be1927 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e83a154ae2975041ff88351280be1927 ) == 2 ); // Frame stack

    // Framed code:
    tmp_list_arg_1 = par_distribution_points;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 481;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_distribution_points;
        assert( old != NULL );
        par_distribution_points = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_distribution_points;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 483;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_8774b456ae1e62ad546755d82447ddb0,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_53___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_53___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_e83a154ae2975041ff88351280be1927->m_frame.f_lineno = 482;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 482;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 482;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_37a5813a8df88d549fa10cdd6f24a9b9;
    frame_e83a154ae2975041ff88351280be1927->m_frame.f_lineno = 485;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 485;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_distribution_points;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__distribution_points, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 490;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e83a154ae2975041ff88351280be1927 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e83a154ae2975041ff88351280be1927 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e83a154ae2975041ff88351280be1927, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e83a154ae2975041ff88351280be1927->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e83a154ae2975041ff88351280be1927, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e83a154ae2975041ff88351280be1927,
        type_description_1,
        par_self,
        par_distribution_points
    );


    // Release cached frame.
    if ( frame_e83a154ae2975041ff88351280be1927 == cache_frame_e83a154ae2975041ff88351280be1927 )
    {
        Py_DECREF( frame_e83a154ae2975041ff88351280be1927 );
    }
    cache_frame_e83a154ae2975041ff88351280be1927 = NULL;

    assertFrameObject( frame_e83a154ae2975041ff88351280be1927 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_53___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_distribution_points );
    Py_DECREF( par_distribution_points );
    par_distribution_points = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_distribution_points );
    Py_DECREF( par_distribution_points );
    par_distribution_points = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_53___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_8774b456ae1e62ad546755d82447ddb0, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 483;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 483;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DistributionPoint );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DistributionPoint );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "DistributionPoint" );
        exception_tb = NULL;

        exception_lineno = 483;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 483;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 483;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 483;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_54___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_7070792c3c3a6ccf6682eea55ee7c662 = NULL;

    struct Nuitka_FrameObject *frame_7070792c3c3a6ccf6682eea55ee7c662;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7070792c3c3a6ccf6682eea55ee7c662, codeobj_7070792c3c3a6ccf6682eea55ee7c662, module_cryptography$x509$extensions, sizeof(void *) );
    frame_7070792c3c3a6ccf6682eea55ee7c662 = cache_frame_7070792c3c3a6ccf6682eea55ee7c662;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7070792c3c3a6ccf6682eea55ee7c662 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7070792c3c3a6ccf6682eea55ee7c662 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_aedab8e33f4a55e03d8255716673252f;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__distribution_points );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 497;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_7070792c3c3a6ccf6682eea55ee7c662->m_frame.f_lineno = 497;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 497;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7070792c3c3a6ccf6682eea55ee7c662 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7070792c3c3a6ccf6682eea55ee7c662 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7070792c3c3a6ccf6682eea55ee7c662 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7070792c3c3a6ccf6682eea55ee7c662, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7070792c3c3a6ccf6682eea55ee7c662->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7070792c3c3a6ccf6682eea55ee7c662, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7070792c3c3a6ccf6682eea55ee7c662,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_7070792c3c3a6ccf6682eea55ee7c662 == cache_frame_7070792c3c3a6ccf6682eea55ee7c662 )
    {
        Py_DECREF( frame_7070792c3c3a6ccf6682eea55ee7c662 );
    }
    cache_frame_7070792c3c3a6ccf6682eea55ee7c662 = NULL;

    assertFrameObject( frame_7070792c3c3a6ccf6682eea55ee7c662 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_54___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_54___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_55___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_967d20a02668c8df3b981c121e92390c = NULL;

    struct Nuitka_FrameObject *frame_967d20a02668c8df3b981c121e92390c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_967d20a02668c8df3b981c121e92390c, codeobj_967d20a02668c8df3b981c121e92390c, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_967d20a02668c8df3b981c121e92390c = cache_frame_967d20a02668c8df3b981c121e92390c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_967d20a02668c8df3b981c121e92390c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_967d20a02668c8df3b981c121e92390c ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_FreshestCRL );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FreshestCRL );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FreshestCRL" );
        exception_tb = NULL;

        exception_lineno = 500;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 500;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__distribution_points );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 503;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__distribution_points );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 503;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 503;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_967d20a02668c8df3b981c121e92390c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_967d20a02668c8df3b981c121e92390c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_967d20a02668c8df3b981c121e92390c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_967d20a02668c8df3b981c121e92390c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_967d20a02668c8df3b981c121e92390c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_967d20a02668c8df3b981c121e92390c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_967d20a02668c8df3b981c121e92390c,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_967d20a02668c8df3b981c121e92390c == cache_frame_967d20a02668c8df3b981c121e92390c )
    {
        Py_DECREF( frame_967d20a02668c8df3b981c121e92390c );
    }
    cache_frame_967d20a02668c8df3b981c121e92390c = NULL;

    assertFrameObject( frame_967d20a02668c8df3b981c121e92390c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_55___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_55___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_56___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_75efb6deb95f95a6df103413ee1e48a9 = NULL;

    struct Nuitka_FrameObject *frame_75efb6deb95f95a6df103413ee1e48a9;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_75efb6deb95f95a6df103413ee1e48a9, codeobj_75efb6deb95f95a6df103413ee1e48a9, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_75efb6deb95f95a6df103413ee1e48a9 = cache_frame_75efb6deb95f95a6df103413ee1e48a9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_75efb6deb95f95a6df103413ee1e48a9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_75efb6deb95f95a6df103413ee1e48a9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 506;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 506;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_75efb6deb95f95a6df103413ee1e48a9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_75efb6deb95f95a6df103413ee1e48a9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_75efb6deb95f95a6df103413ee1e48a9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_75efb6deb95f95a6df103413ee1e48a9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_75efb6deb95f95a6df103413ee1e48a9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_75efb6deb95f95a6df103413ee1e48a9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_75efb6deb95f95a6df103413ee1e48a9,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_75efb6deb95f95a6df103413ee1e48a9 == cache_frame_75efb6deb95f95a6df103413ee1e48a9 )
    {
        Py_DECREF( frame_75efb6deb95f95a6df103413ee1e48a9 );
    }
    cache_frame_75efb6deb95f95a6df103413ee1e48a9 = NULL;

    assertFrameObject( frame_75efb6deb95f95a6df103413ee1e48a9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_56___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_56___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_57___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_arg_1;
    static struct Nuitka_FrameObject *cache_frame_2426e68a1691573cdabc00868b370303 = NULL;

    struct Nuitka_FrameObject *frame_2426e68a1691573cdabc00868b370303;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2426e68a1691573cdabc00868b370303, codeobj_2426e68a1691573cdabc00868b370303, module_cryptography$x509$extensions, sizeof(void *) );
    frame_2426e68a1691573cdabc00868b370303 = cache_frame_2426e68a1691573cdabc00868b370303;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2426e68a1691573cdabc00868b370303 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2426e68a1691573cdabc00868b370303 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__distribution_points );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 509;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_hash_arg_1 = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 509;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 509;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2426e68a1691573cdabc00868b370303 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2426e68a1691573cdabc00868b370303 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2426e68a1691573cdabc00868b370303 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2426e68a1691573cdabc00868b370303, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2426e68a1691573cdabc00868b370303->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2426e68a1691573cdabc00868b370303, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2426e68a1691573cdabc00868b370303,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_2426e68a1691573cdabc00868b370303 == cache_frame_2426e68a1691573cdabc00868b370303 )
    {
        Py_DECREF( frame_2426e68a1691573cdabc00868b370303 );
    }
    cache_frame_2426e68a1691573cdabc00868b370303 = NULL;

    assertFrameObject( frame_2426e68a1691573cdabc00868b370303 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_57___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_57___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_58___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_full_name = python_pars[ 1 ];
    PyObject *par_relative_name = python_pars[ 2 ];
    PyObject *par_reasons = python_pars[ 3 ];
    PyObject *par_crl_issuer = python_pars[ 4 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *tmp_genexpr_2__$0 = NULL;
    PyObject *tmp_genexpr_3__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    int tmp_and_left_truth_3;
    int tmp_and_left_truth_4;
    int tmp_and_left_truth_5;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_left_value_3;
    PyObject *tmp_and_left_value_4;
    PyObject *tmp_and_left_value_5;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_and_right_value_3;
    PyObject *tmp_and_right_value_4;
    PyObject *tmp_and_right_value_5;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    int tmp_cond_truth_5;
    int tmp_cond_truth_6;
    int tmp_cond_truth_7;
    int tmp_cond_truth_8;
    int tmp_cond_truth_9;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_cond_value_5;
    PyObject *tmp_cond_value_6;
    PyObject *tmp_cond_value_7;
    PyObject *tmp_cond_value_8;
    PyObject *tmp_cond_value_9;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_iter_arg_3;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_list_arg_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_make_exception_arg_4;
    PyObject *tmp_make_exception_arg_5;
    PyObject *tmp_make_exception_arg_6;
    PyObject *tmp_make_exception_arg_7;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_operand_name_2;
    PyObject *tmp_operand_name_3;
    PyObject *tmp_operand_name_4;
    int tmp_or_left_truth_1;
    int tmp_or_left_truth_2;
    int tmp_or_left_truth_3;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_left_value_2;
    PyObject *tmp_or_left_value_3;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_or_right_value_2;
    PyObject *tmp_or_right_value_3;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_outline_return_value_2;
    PyObject *tmp_outline_return_value_3;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_raise_type_4;
    PyObject *tmp_raise_type_5;
    PyObject *tmp_raise_type_6;
    PyObject *tmp_raise_type_7;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_fa2931ec8fdcd4814cb233f5a491f5a6 = NULL;

    struct Nuitka_FrameObject *frame_fa2931ec8fdcd4814cb233f5a491f5a6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;
    tmp_outline_return_value_2 = NULL;
    tmp_outline_return_value_3 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fa2931ec8fdcd4814cb233f5a491f5a6, codeobj_fa2931ec8fdcd4814cb233f5a491f5a6, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_fa2931ec8fdcd4814cb233f5a491f5a6 = cache_frame_fa2931ec8fdcd4814cb233f5a491f5a6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fa2931ec8fdcd4814cb233f5a491f5a6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fa2931ec8fdcd4814cb233f5a491f5a6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_and_left_value_1 = par_full_name;

    CHECK_OBJECT( tmp_and_left_value_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 514;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_and_right_value_1 = par_relative_name;

    CHECK_OBJECT( tmp_and_right_value_1 );
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 514;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_11b049dd960f5e8f8d4550cdd9caf427;
    frame_fa2931ec8fdcd4814cb233f5a491f5a6->m_frame.f_lineno = 515;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 515;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_cond_value_2 = par_full_name;

    CHECK_OBJECT( tmp_cond_value_2 );
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 520;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_list_arg_1 = par_full_name;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 521;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_full_name;
        assert( old != NULL );
        par_full_name = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_full_name;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 522;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_58___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_96666e03f5705254b116c6bfc15976cf,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_58___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_58___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_fa2931ec8fdcd4814cb233f5a491f5a6->m_frame.f_lineno = 522;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 522;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 522;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_2 = const_str_digest_449ea3887ada75d14dab0f566d0a778c;
    frame_fa2931ec8fdcd4814cb233f5a491f5a6->m_frame.f_lineno = 523;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 523;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    branch_no_2:;
    tmp_cond_value_4 = par_relative_name;

    CHECK_OBJECT( tmp_cond_value_4 );
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 527;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_isinstance_inst_1 = par_relative_name;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_RelativeDistinguishedName );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_RelativeDistinguishedName );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "RelativeDistinguishedName" );
        exception_tb = NULL;

        exception_lineno = 528;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 528;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_5;
    }
    else
    {
        goto branch_yes_5;
    }
    branch_yes_5:;
    tmp_make_exception_arg_3 = const_str_digest_0c5b9c1eebf18567ca6eef13eba8418b;
    frame_fa2931ec8fdcd4814cb233f5a491f5a6->m_frame.f_lineno = 529;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 529;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_5:;
    branch_no_4:;
    tmp_cond_value_5 = par_crl_issuer;

    CHECK_OBJECT( tmp_cond_value_5 );
    tmp_cond_truth_5 = CHECK_IF_TRUE( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 533;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_5 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_list_arg_2 = par_crl_issuer;

    CHECK_OBJECT( tmp_list_arg_2 );
    tmp_assign_source_3 = PySequence_List( tmp_list_arg_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 534;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_crl_issuer;
        assert( old != NULL );
        par_crl_issuer = tmp_assign_source_3;
        Py_DECREF( old );
    }

    tmp_called_name_2 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_2 != NULL );
    tmp_iter_arg_2 = par_crl_issuer;

    CHECK_OBJECT( tmp_iter_arg_2 );
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 535;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_2__$0 == NULL );
    tmp_genexpr_2__$0 = tmp_assign_source_4;

    // Tried code:
    tmp_outline_return_value_2 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_58___init__$$$genexpr_2_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_25020f81cac34ffc251ec44246a595c8,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_2)->m_closure[0] = PyCell_NEW0( tmp_genexpr_2__$0 );
    assert( Py_SIZE( tmp_outline_return_value_2 ) >= 1 ); 


    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_58___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_3:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_2__$0 );
    Py_DECREF( tmp_genexpr_2__$0 );
    tmp_genexpr_2__$0 = NULL;

    goto outline_result_2;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_2__$0 );
    Py_DECREF( tmp_genexpr_2__$0 );
    tmp_genexpr_2__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_58___init__ );
    return NULL;
    outline_result_2:;
    tmp_args_element_name_2 = tmp_outline_return_value_2;
    frame_fa2931ec8fdcd4814cb233f5a491f5a6->m_frame.f_lineno = 535;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_cond_value_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_cond_value_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 535;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_6 = CHECK_IF_TRUE( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_6 );

        exception_lineno = 535;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == 1 )
    {
        goto branch_no_7;
    }
    else
    {
        goto branch_yes_7;
    }
    branch_yes_7:;
    tmp_make_exception_arg_4 = const_str_digest_837e2310df6009dd1b110accad73bb42;
    frame_fa2931ec8fdcd4814cb233f5a491f5a6->m_frame.f_lineno = 536;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_4 };
        tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_4 != NULL );
    exception_type = tmp_raise_type_4;
    exception_lineno = 536;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_7:;
    branch_no_6:;
    tmp_and_left_value_2 = par_reasons;

    CHECK_OBJECT( tmp_and_left_value_2 );
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    if ( tmp_and_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 540;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    tmp_isinstance_inst_2 = par_reasons;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_isinstance_cls_2 = (PyObject *)&PyFrozenSet_Type;
    tmp_operand_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 540;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 540;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 540;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    tmp_called_name_3 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_3 != NULL );
    tmp_iter_arg_3 = par_reasons;

    CHECK_OBJECT( tmp_iter_arg_3 );
    tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_3 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 541;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_3__$0 == NULL );
    tmp_genexpr_3__$0 = tmp_assign_source_5;

    // Tried code:
    tmp_outline_return_value_3 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_58___init__$$$genexpr_3_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_93355c1f035919f49ba1c93c15fa1b26,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_3)->m_closure[0] = PyCell_NEW0( tmp_genexpr_3__$0 );
    assert( Py_SIZE( tmp_outline_return_value_3 ) >= 1 ); 


    goto try_return_handler_4;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_58___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_4:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_3__$0 );
    Py_DECREF( tmp_genexpr_3__$0 );
    tmp_genexpr_3__$0 = NULL;

    goto outline_result_3;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_3__$0 );
    Py_DECREF( tmp_genexpr_3__$0 );
    tmp_genexpr_3__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_58___init__ );
    return NULL;
    outline_result_3:;
    tmp_args_element_name_3 = tmp_outline_return_value_3;
    frame_fa2931ec8fdcd4814cb233f5a491f5a6->m_frame.f_lineno = 540;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_operand_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_operand_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 540;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_right_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_2 );
    Py_DECREF( tmp_operand_name_2 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 540;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_2 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_and_right_value_2 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_value_7 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_cond_value_7 = tmp_and_left_value_2;
    and_end_2:;
    tmp_cond_truth_7 = CHECK_IF_TRUE( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 540;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_7 == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_make_exception_arg_5 = const_str_digest_2615a61b30c6d1612864004a5b3409b1;
    frame_fa2931ec8fdcd4814cb233f5a491f5a6->m_frame.f_lineno = 543;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_5 };
        tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_5 != NULL );
    exception_type = tmp_raise_type_5;
    exception_lineno = 543;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_8:;
    tmp_and_left_value_3 = par_reasons;

    CHECK_OBJECT( tmp_and_left_value_3 );
    tmp_and_left_truth_3 = CHECK_IF_TRUE( tmp_and_left_value_3 );
    if ( tmp_and_left_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 547;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_3 == 1 )
    {
        goto and_right_3;
    }
    else
    {
        goto and_left_3;
    }
    and_right_3:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ReasonFlags" );
        exception_tb = NULL;

        exception_lineno = 546;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_unspecified );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 546;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = par_reasons;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_or_left_value_2 = SEQUENCE_CONTAINS( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_or_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 546;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_2 = CHECK_IF_TRUE( tmp_or_left_value_2 );
    assert( !(tmp_or_left_truth_2 == -1) );
    if ( tmp_or_left_truth_2 == 1 )
    {
        goto or_left_2;
    }
    else
    {
        goto or_right_2;
    }
    or_right_2:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ReasonFlags" );
        exception_tb = NULL;

        exception_lineno = 547;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_remove_from_crl );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 547;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_2 = par_reasons;

    CHECK_OBJECT( tmp_compexpr_right_2 );
    tmp_or_right_value_2 = SEQUENCE_CONTAINS( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    if ( tmp_or_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 547;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_3 = tmp_or_right_value_2;
    goto or_end_2;
    or_left_2:;
    tmp_and_right_value_3 = tmp_or_left_value_2;
    or_end_2:;
    tmp_cond_value_8 = tmp_and_right_value_3;
    goto and_end_3;
    and_left_3:;
    tmp_cond_value_8 = tmp_and_left_value_3;
    and_end_3:;
    tmp_cond_truth_8 = CHECK_IF_TRUE( tmp_cond_value_8 );
    if ( tmp_cond_truth_8 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 547;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_8 == 1 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_make_exception_arg_6 = const_str_digest_3a0a1109b8c268ad95ea7f220c74ef61;
    frame_fa2931ec8fdcd4814cb233f5a491f5a6->m_frame.f_lineno = 549;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_6 };
        tmp_raise_type_6 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_6 != NULL );
    exception_type = tmp_raise_type_6;
    exception_lineno = 549;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_9:;
    tmp_and_left_value_4 = par_reasons;

    CHECK_OBJECT( tmp_and_left_value_4 );
    tmp_and_left_truth_4 = CHECK_IF_TRUE( tmp_and_left_value_4 );
    if ( tmp_and_left_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 554;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_4 == 1 )
    {
        goto and_right_4;
    }
    else
    {
        goto and_left_4;
    }
    and_right_4:;
    tmp_operand_name_3 = par_crl_issuer;

    CHECK_OBJECT( tmp_operand_name_3 );
    tmp_and_left_value_5 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_3 );
    if ( tmp_and_left_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 554;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_5 = CHECK_IF_TRUE( tmp_and_left_value_5 );
    if ( tmp_and_left_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 554;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_5 == 1 )
    {
        goto and_right_5;
    }
    else
    {
        goto and_left_5;
    }
    and_right_5:;
    tmp_or_left_value_3 = par_full_name;

    CHECK_OBJECT( tmp_or_left_value_3 );
    tmp_or_left_truth_3 = CHECK_IF_TRUE( tmp_or_left_value_3 );
    if ( tmp_or_left_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 554;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_3 == 1 )
    {
        goto or_left_3;
    }
    else
    {
        goto or_right_3;
    }
    or_right_3:;
    tmp_or_right_value_3 = par_relative_name;

    CHECK_OBJECT( tmp_or_right_value_3 );
    tmp_operand_name_4 = tmp_or_right_value_3;
    goto or_end_3;
    or_left_3:;
    tmp_operand_name_4 = tmp_or_left_value_3;
    or_end_3:;
    tmp_and_right_value_5 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_4 );
    if ( tmp_and_right_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 554;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_4 = tmp_and_right_value_5;
    goto and_end_5;
    and_left_5:;
    tmp_and_right_value_4 = tmp_and_left_value_5;
    and_end_5:;
    tmp_cond_value_9 = tmp_and_right_value_4;
    goto and_end_4;
    and_left_4:;
    tmp_cond_value_9 = tmp_and_left_value_4;
    and_end_4:;
    tmp_cond_truth_9 = CHECK_IF_TRUE( tmp_cond_value_9 );
    if ( tmp_cond_truth_9 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 554;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_9 == 1 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    tmp_make_exception_arg_7 = const_str_digest_198893d8157c272d69767f46f86316c2;
    frame_fa2931ec8fdcd4814cb233f5a491f5a6->m_frame.f_lineno = 555;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_7 };
        tmp_raise_type_7 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_7 != NULL );
    exception_type = tmp_raise_type_7;
    exception_lineno = 555;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_10:;
    tmp_assattr_name_1 = par_full_name;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__full_name, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 560;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_relative_name;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__relative_name, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 561;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = par_reasons;

    CHECK_OBJECT( tmp_assattr_name_3 );
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__reasons, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 562;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_4 = par_crl_issuer;

    CHECK_OBJECT( tmp_assattr_name_4 );
    tmp_assattr_target_4 = par_self;

    CHECK_OBJECT( tmp_assattr_target_4 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__crl_issuer, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 563;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fa2931ec8fdcd4814cb233f5a491f5a6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fa2931ec8fdcd4814cb233f5a491f5a6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fa2931ec8fdcd4814cb233f5a491f5a6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fa2931ec8fdcd4814cb233f5a491f5a6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fa2931ec8fdcd4814cb233f5a491f5a6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fa2931ec8fdcd4814cb233f5a491f5a6,
        type_description_1,
        par_self,
        par_full_name,
        par_relative_name,
        par_reasons,
        par_crl_issuer
    );


    // Release cached frame.
    if ( frame_fa2931ec8fdcd4814cb233f5a491f5a6 == cache_frame_fa2931ec8fdcd4814cb233f5a491f5a6 )
    {
        Py_DECREF( frame_fa2931ec8fdcd4814cb233f5a491f5a6 );
    }
    cache_frame_fa2931ec8fdcd4814cb233f5a491f5a6 = NULL;

    assertFrameObject( frame_fa2931ec8fdcd4814cb233f5a491f5a6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_58___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_reasons );
    Py_DECREF( par_reasons );
    par_reasons = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_crl_issuer );
    Py_DECREF( par_crl_issuer );
    par_crl_issuer = NULL;

    CHECK_OBJECT( (PyObject *)par_full_name );
    Py_DECREF( par_full_name );
    par_full_name = NULL;

    CHECK_OBJECT( (PyObject *)par_relative_name );
    Py_DECREF( par_relative_name );
    par_relative_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_reasons );
    Py_DECREF( par_reasons );
    par_reasons = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_crl_issuer );
    par_crl_issuer = NULL;

    Py_XDECREF( par_full_name );
    par_full_name = NULL;

    CHECK_OBJECT( (PyObject *)par_relative_name );
    Py_DECREF( par_relative_name );
    par_relative_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_58___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_58___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_58___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_58___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_96666e03f5705254b116c6bfc15976cf, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 522;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 522;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GeneralName" );
        exception_tb = NULL;

        exception_lineno = 522;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 522;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 522;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 522;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_58___init__$$$genexpr_2_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_58___init__$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_58___init__$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_25020f81cac34ffc251ec44246a595c8, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 535;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 535;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GeneralName" );
        exception_tb = NULL;

        exception_lineno = 535;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 535;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 535;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 535;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_58___init__$$$genexpr_3_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_58___init__$$$genexpr_3_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_58___init__$$$genexpr_3_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_93355c1f035919f49ba1c93c15fa1b26, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 541;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 541;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ReasonFlags" );
        exception_tb = NULL;

        exception_lineno = 541;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 541;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 541;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 541;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_59___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_548e0e17232c8f06b933389489c7d4f9 = NULL;

    struct Nuitka_FrameObject *frame_548e0e17232c8f06b933389489c7d4f9;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_548e0e17232c8f06b933389489c7d4f9, codeobj_548e0e17232c8f06b933389489c7d4f9, module_cryptography$x509$extensions, sizeof(void *) );
    frame_548e0e17232c8f06b933389489c7d4f9 = cache_frame_548e0e17232c8f06b933389489c7d4f9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_548e0e17232c8f06b933389489c7d4f9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_548e0e17232c8f06b933389489c7d4f9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_e7bc751982d7cd4fe2e9c78dbf3e6347;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_548e0e17232c8f06b933389489c7d4f9->m_frame.f_lineno = 567;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 567;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_548e0e17232c8f06b933389489c7d4f9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_548e0e17232c8f06b933389489c7d4f9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_548e0e17232c8f06b933389489c7d4f9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_548e0e17232c8f06b933389489c7d4f9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_548e0e17232c8f06b933389489c7d4f9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_548e0e17232c8f06b933389489c7d4f9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_548e0e17232c8f06b933389489c7d4f9,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_548e0e17232c8f06b933389489c7d4f9 == cache_frame_548e0e17232c8f06b933389489c7d4f9 )
    {
        Py_DECREF( frame_548e0e17232c8f06b933389489c7d4f9 );
    }
    cache_frame_548e0e17232c8f06b933389489c7d4f9 = NULL;

    assertFrameObject( frame_548e0e17232c8f06b933389489c7d4f9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_59___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_59___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_60___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    int tmp_and_left_truth_3;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_left_value_3;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_and_right_value_3;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_left_4;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    PyObject *tmp_compexpr_right_4;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    static struct Nuitka_FrameObject *cache_frame_b7fdc0353e23c582f08622537806bb7a = NULL;

    struct Nuitka_FrameObject *frame_b7fdc0353e23c582f08622537806bb7a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b7fdc0353e23c582f08622537806bb7a, codeobj_b7fdc0353e23c582f08622537806bb7a, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_b7fdc0353e23c582f08622537806bb7a = cache_frame_b7fdc0353e23c582f08622537806bb7a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b7fdc0353e23c582f08622537806bb7a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b7fdc0353e23c582f08622537806bb7a ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DistributionPoint );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DistributionPoint );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "DistributionPoint" );
        exception_tb = NULL;

        exception_lineno = 573;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 573;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_full_name );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 577;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_full_name );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 577;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 577;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 580;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_relative_name );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 578;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_other;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_relative_name );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 578;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_2 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 578;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    if ( tmp_and_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_2 );

        exception_lineno = 580;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    Py_DECREF( tmp_and_left_value_2 );
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_reasons );
    if ( tmp_compexpr_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 579;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_other;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_reasons );
    if ( tmp_compexpr_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_3 );

        exception_lineno = 579;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_3 = RICH_COMPARE_EQ( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    Py_DECREF( tmp_compexpr_left_3 );
    Py_DECREF( tmp_compexpr_right_3 );
    if ( tmp_and_left_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 579;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_3 = CHECK_IF_TRUE( tmp_and_left_value_3 );
    if ( tmp_and_left_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_3 );

        exception_lineno = 580;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_3 == 1 )
    {
        goto and_right_3;
    }
    else
    {
        goto and_left_3;
    }
    and_right_3:;
    Py_DECREF( tmp_and_left_value_3 );
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_crl_issuer );
    if ( tmp_compexpr_left_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 580;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = par_other;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_crl_issuer );
    if ( tmp_compexpr_right_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_4 );

        exception_lineno = 580;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_3 = RICH_COMPARE_EQ( tmp_compexpr_left_4, tmp_compexpr_right_4 );
    Py_DECREF( tmp_compexpr_left_4 );
    Py_DECREF( tmp_compexpr_right_4 );
    if ( tmp_and_right_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 580;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_2 = tmp_and_right_value_3;
    goto and_end_3;
    and_left_3:;
    tmp_and_right_value_2 = tmp_and_left_value_3;
    and_end_3:;
    tmp_and_right_value_1 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_and_right_value_1 = tmp_and_left_value_2;
    and_end_2:;
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b7fdc0353e23c582f08622537806bb7a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b7fdc0353e23c582f08622537806bb7a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b7fdc0353e23c582f08622537806bb7a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b7fdc0353e23c582f08622537806bb7a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b7fdc0353e23c582f08622537806bb7a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b7fdc0353e23c582f08622537806bb7a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b7fdc0353e23c582f08622537806bb7a,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_b7fdc0353e23c582f08622537806bb7a == cache_frame_b7fdc0353e23c582f08622537806bb7a )
    {
        Py_DECREF( frame_b7fdc0353e23c582f08622537806bb7a );
    }
    cache_frame_b7fdc0353e23c582f08622537806bb7a = NULL;

    assertFrameObject( frame_b7fdc0353e23c582f08622537806bb7a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_60___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_60___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_61___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_1911d24b26514a8ef43cc8a5f5185162 = NULL;

    struct Nuitka_FrameObject *frame_1911d24b26514a8ef43cc8a5f5185162;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1911d24b26514a8ef43cc8a5f5185162, codeobj_1911d24b26514a8ef43cc8a5f5185162, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_1911d24b26514a8ef43cc8a5f5185162 = cache_frame_1911d24b26514a8ef43cc8a5f5185162;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1911d24b26514a8ef43cc8a5f5185162 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1911d24b26514a8ef43cc8a5f5185162 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 584;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 584;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1911d24b26514a8ef43cc8a5f5185162 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1911d24b26514a8ef43cc8a5f5185162 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1911d24b26514a8ef43cc8a5f5185162 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1911d24b26514a8ef43cc8a5f5185162, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1911d24b26514a8ef43cc8a5f5185162->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1911d24b26514a8ef43cc8a5f5185162, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1911d24b26514a8ef43cc8a5f5185162,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_1911d24b26514a8ef43cc8a5f5185162 == cache_frame_1911d24b26514a8ef43cc8a5f5185162 )
    {
        Py_DECREF( frame_1911d24b26514a8ef43cc8a5f5185162 );
    }
    cache_frame_1911d24b26514a8ef43cc8a5f5185162 = NULL;

    assertFrameObject( frame_1911d24b26514a8ef43cc8a5f5185162 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_61___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_61___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_62___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_crl_issuer = NULL;
    PyObject *var_fn = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_hash_arg_1;
    bool tmp_isnot_1;
    bool tmp_isnot_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_tuple_arg_1;
    PyObject *tmp_tuple_arg_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_eead1fd5104b0d4f8d1d4ffd849695ab = NULL;

    struct Nuitka_FrameObject *frame_eead1fd5104b0d4f8d1d4ffd849695ab;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_eead1fd5104b0d4f8d1d4ffd849695ab, codeobj_eead1fd5104b0d4f8d1d4ffd849695ab, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_eead1fd5104b0d4f8d1d4ffd849695ab = cache_frame_eead1fd5104b0d4f8d1d4ffd849695ab;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_eead1fd5104b0d4f8d1d4ffd849695ab );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_eead1fd5104b0d4f8d1d4ffd849695ab ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_full_name );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 587;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_full_name );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 588;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 588;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_fn == NULL );
    var_fn = tmp_assign_source_1;

    goto branch_end_1;
    branch_no_1:;
    tmp_assign_source_2 = Py_None;
    assert( var_fn == NULL );
    Py_INCREF( tmp_assign_source_2 );
    var_fn = tmp_assign_source_2;

    branch_end_1:;
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_crl_issuer );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 592;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = Py_None;
    tmp_isnot_2 = ( tmp_compare_left_2 != tmp_compare_right_2 );
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_isnot_2 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_tuple_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_crl_issuer );
    if ( tmp_tuple_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 593;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_3 = PySequence_Tuple( tmp_tuple_arg_2 );
    Py_DECREF( tmp_tuple_arg_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 593;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_crl_issuer == NULL );
    var_crl_issuer = tmp_assign_source_3;

    goto branch_end_2;
    branch_no_2:;
    tmp_assign_source_4 = Py_None;
    assert( var_crl_issuer == NULL );
    Py_INCREF( tmp_assign_source_4 );
    var_crl_issuer = tmp_assign_source_4;

    branch_end_2:;
    tmp_hash_arg_1 = PyTuple_New( 4 );
    tmp_tuple_element_1 = var_fn;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_hash_arg_1, 0, tmp_tuple_element_1 );
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_relative_name );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 597;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 1, tmp_tuple_element_1 );
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_reasons );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 597;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 2, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_crl_issuer;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_hash_arg_1, 3, tmp_tuple_element_1 );
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 597;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eead1fd5104b0d4f8d1d4ffd849695ab );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_eead1fd5104b0d4f8d1d4ffd849695ab );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eead1fd5104b0d4f8d1d4ffd849695ab );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_eead1fd5104b0d4f8d1d4ffd849695ab, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_eead1fd5104b0d4f8d1d4ffd849695ab->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_eead1fd5104b0d4f8d1d4ffd849695ab, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_eead1fd5104b0d4f8d1d4ffd849695ab,
        type_description_1,
        par_self,
        var_crl_issuer,
        var_fn
    );


    // Release cached frame.
    if ( frame_eead1fd5104b0d4f8d1d4ffd849695ab == cache_frame_eead1fd5104b0d4f8d1d4ffd849695ab )
    {
        Py_DECREF( frame_eead1fd5104b0d4f8d1d4ffd849695ab );
    }
    cache_frame_eead1fd5104b0d4f8d1d4ffd849695ab = NULL;

    assertFrameObject( frame_eead1fd5104b0d4f8d1d4ffd849695ab );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_62___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_crl_issuer );
    Py_DECREF( var_crl_issuer );
    var_crl_issuer = NULL;

    CHECK_OBJECT( (PyObject *)var_fn );
    Py_DECREF( var_fn );
    var_fn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_crl_issuer );
    var_crl_issuer = NULL;

    Py_XDECREF( var_fn );
    var_fn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_62___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_63___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_require_explicit_policy = python_pars[ 1 ];
    PyObject *par_inhibit_policy_mapping = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    int tmp_and_left_truth_3;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_left_value_3;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_and_right_value_3;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_left_4;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    PyObject *tmp_compexpr_right_4;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_operand_name_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_593e248f319c1962ca90d8a41e9a9b37 = NULL;

    struct Nuitka_FrameObject *frame_593e248f319c1962ca90d8a41e9a9b37;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_593e248f319c1962ca90d8a41e9a9b37, codeobj_593e248f319c1962ca90d8a41e9a9b37, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_593e248f319c1962ca90d8a41e9a9b37 = cache_frame_593e248f319c1962ca90d8a41e9a9b37;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_593e248f319c1962ca90d8a41e9a9b37 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_593e248f319c1962ca90d8a41e9a9b37 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_require_explicit_policy;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = Py_None;
    tmp_and_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 != tmp_compexpr_right_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    assert( !(tmp_and_left_truth_1 == -1) );
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_isinstance_inst_1 = par_require_explicit_policy;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_six );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "six" );
        exception_tb = NULL;

        exception_lineno = 624;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_integer_types );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 624;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_operand_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 623;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 623;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 623;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_ac8667798ba70bb109d3e3236473ab02;
    frame_593e248f319c1962ca90d8a41e9a9b37->m_frame.f_lineno = 626;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 626;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_compexpr_left_2 = par_inhibit_policy_mapping;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = Py_None;
    tmp_and_left_value_2 = BOOL_FROM( tmp_compexpr_left_2 != tmp_compexpr_right_2 );
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    assert( !(tmp_and_left_truth_2 == -1) );
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    tmp_isinstance_inst_2 = par_inhibit_policy_mapping;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_six );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "six" );
        exception_tb = NULL;

        exception_lineno = 632;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_integer_types );
    if ( tmp_isinstance_cls_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 632;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_operand_name_2 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    Py_DECREF( tmp_isinstance_cls_2 );
    if ( tmp_operand_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 631;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_2 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_2 );
    if ( tmp_and_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 631;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_2 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_cond_value_2 = tmp_and_left_value_2;
    and_end_2:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 631;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_acc45e336b0d5f3376f4867fb94a18e6;
    frame_593e248f319c1962ca90d8a41e9a9b37->m_frame.f_lineno = 634;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 634;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_compexpr_left_3 = par_inhibit_policy_mapping;

    CHECK_OBJECT( tmp_compexpr_left_3 );
    tmp_compexpr_right_3 = Py_None;
    tmp_and_left_value_3 = BOOL_FROM( tmp_compexpr_left_3 == tmp_compexpr_right_3 );
    tmp_and_left_truth_3 = CHECK_IF_TRUE( tmp_and_left_value_3 );
    assert( !(tmp_and_left_truth_3 == -1) );
    if ( tmp_and_left_truth_3 == 1 )
    {
        goto and_right_3;
    }
    else
    {
        goto and_left_3;
    }
    and_right_3:;
    tmp_compexpr_left_4 = par_require_explicit_policy;

    CHECK_OBJECT( tmp_compexpr_left_4 );
    tmp_compexpr_right_4 = Py_None;
    tmp_and_right_value_3 = BOOL_FROM( tmp_compexpr_left_4 == tmp_compexpr_right_4 );
    tmp_cond_value_3 = tmp_and_right_value_3;
    goto and_end_3;
    and_left_3:;
    tmp_cond_value_3 = tmp_and_left_value_3;
    and_end_3:;
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    assert( !(tmp_cond_truth_3 == -1) );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_3 = const_str_digest_3611def0515b06c31df0f70307f767f3;
    frame_593e248f319c1962ca90d8a41e9a9b37->m_frame.f_lineno = 639;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 639;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    tmp_assattr_name_1 = par_require_explicit_policy;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__require_explicit_policy, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 644;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_inhibit_policy_mapping;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__inhibit_policy_mapping, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 645;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_593e248f319c1962ca90d8a41e9a9b37 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_593e248f319c1962ca90d8a41e9a9b37 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_593e248f319c1962ca90d8a41e9a9b37, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_593e248f319c1962ca90d8a41e9a9b37->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_593e248f319c1962ca90d8a41e9a9b37, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_593e248f319c1962ca90d8a41e9a9b37,
        type_description_1,
        par_self,
        par_require_explicit_policy,
        par_inhibit_policy_mapping
    );


    // Release cached frame.
    if ( frame_593e248f319c1962ca90d8a41e9a9b37 == cache_frame_593e248f319c1962ca90d8a41e9a9b37 )
    {
        Py_DECREF( frame_593e248f319c1962ca90d8a41e9a9b37 );
    }
    cache_frame_593e248f319c1962ca90d8a41e9a9b37 = NULL;

    assertFrameObject( frame_593e248f319c1962ca90d8a41e9a9b37 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_63___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_require_explicit_policy );
    Py_DECREF( par_require_explicit_policy );
    par_require_explicit_policy = NULL;

    CHECK_OBJECT( (PyObject *)par_inhibit_policy_mapping );
    Py_DECREF( par_inhibit_policy_mapping );
    par_inhibit_policy_mapping = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_require_explicit_policy );
    Py_DECREF( par_require_explicit_policy );
    par_require_explicit_policy = NULL;

    CHECK_OBJECT( (PyObject *)par_inhibit_policy_mapping );
    Py_DECREF( par_inhibit_policy_mapping );
    par_inhibit_policy_mapping = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_63___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_64___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_3bafaa5dacbb94a3ec12b882c27fef71 = NULL;

    struct Nuitka_FrameObject *frame_3bafaa5dacbb94a3ec12b882c27fef71;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3bafaa5dacbb94a3ec12b882c27fef71, codeobj_3bafaa5dacbb94a3ec12b882c27fef71, module_cryptography$x509$extensions, sizeof(void *) );
    frame_3bafaa5dacbb94a3ec12b882c27fef71 = cache_frame_3bafaa5dacbb94a3ec12b882c27fef71;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3bafaa5dacbb94a3ec12b882c27fef71 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3bafaa5dacbb94a3ec12b882c27fef71 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_unicode_digest_71b136bb2c4e9e2ce7c90a48ee86f246;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_3bafaa5dacbb94a3ec12b882c27fef71->m_frame.f_lineno = 649;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 649;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3bafaa5dacbb94a3ec12b882c27fef71 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3bafaa5dacbb94a3ec12b882c27fef71 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3bafaa5dacbb94a3ec12b882c27fef71 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3bafaa5dacbb94a3ec12b882c27fef71, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3bafaa5dacbb94a3ec12b882c27fef71->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3bafaa5dacbb94a3ec12b882c27fef71, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3bafaa5dacbb94a3ec12b882c27fef71,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_3bafaa5dacbb94a3ec12b882c27fef71 == cache_frame_3bafaa5dacbb94a3ec12b882c27fef71 )
    {
        Py_DECREF( frame_3bafaa5dacbb94a3ec12b882c27fef71 );
    }
    cache_frame_3bafaa5dacbb94a3ec12b882c27fef71 = NULL;

    assertFrameObject( frame_3bafaa5dacbb94a3ec12b882c27fef71 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_64___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_64___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_65___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_235720495b109b09daf397b30088ca24 = NULL;

    struct Nuitka_FrameObject *frame_235720495b109b09daf397b30088ca24;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_235720495b109b09daf397b30088ca24, codeobj_235720495b109b09daf397b30088ca24, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_235720495b109b09daf397b30088ca24 = cache_frame_235720495b109b09daf397b30088ca24;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_235720495b109b09daf397b30088ca24 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_235720495b109b09daf397b30088ca24 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PolicyConstraints );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PolicyConstraints );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PolicyConstraints" );
        exception_tb = NULL;

        exception_lineno = 655;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 655;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_require_explicit_policy );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 659;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_require_explicit_policy );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 659;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 659;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 660;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_inhibit_policy_mapping );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 660;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_other;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_inhibit_policy_mapping );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 660;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 660;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_235720495b109b09daf397b30088ca24 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_235720495b109b09daf397b30088ca24 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_235720495b109b09daf397b30088ca24 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_235720495b109b09daf397b30088ca24, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_235720495b109b09daf397b30088ca24->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_235720495b109b09daf397b30088ca24, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_235720495b109b09daf397b30088ca24,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_235720495b109b09daf397b30088ca24 == cache_frame_235720495b109b09daf397b30088ca24 )
    {
        Py_DECREF( frame_235720495b109b09daf397b30088ca24 );
    }
    cache_frame_235720495b109b09daf397b30088ca24 = NULL;

    assertFrameObject( frame_235720495b109b09daf397b30088ca24 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_65___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_65___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_66___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_5cb549ee87f94a874ff5835c02e8bf76 = NULL;

    struct Nuitka_FrameObject *frame_5cb549ee87f94a874ff5835c02e8bf76;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5cb549ee87f94a874ff5835c02e8bf76, codeobj_5cb549ee87f94a874ff5835c02e8bf76, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_5cb549ee87f94a874ff5835c02e8bf76 = cache_frame_5cb549ee87f94a874ff5835c02e8bf76;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5cb549ee87f94a874ff5835c02e8bf76 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5cb549ee87f94a874ff5835c02e8bf76 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 664;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 664;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cb549ee87f94a874ff5835c02e8bf76 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cb549ee87f94a874ff5835c02e8bf76 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cb549ee87f94a874ff5835c02e8bf76 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5cb549ee87f94a874ff5835c02e8bf76, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5cb549ee87f94a874ff5835c02e8bf76->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5cb549ee87f94a874ff5835c02e8bf76, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5cb549ee87f94a874ff5835c02e8bf76,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_5cb549ee87f94a874ff5835c02e8bf76 == cache_frame_5cb549ee87f94a874ff5835c02e8bf76 )
    {
        Py_DECREF( frame_5cb549ee87f94a874ff5835c02e8bf76 );
    }
    cache_frame_5cb549ee87f94a874ff5835c02e8bf76 = NULL;

    assertFrameObject( frame_5cb549ee87f94a874ff5835c02e8bf76 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_66___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_66___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_67___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_2dbe05eea4e50ba135d849bf18bf240c = NULL;

    struct Nuitka_FrameObject *frame_2dbe05eea4e50ba135d849bf18bf240c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2dbe05eea4e50ba135d849bf18bf240c, codeobj_2dbe05eea4e50ba135d849bf18bf240c, module_cryptography$x509$extensions, sizeof(void *) );
    frame_2dbe05eea4e50ba135d849bf18bf240c = cache_frame_2dbe05eea4e50ba135d849bf18bf240c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2dbe05eea4e50ba135d849bf18bf240c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2dbe05eea4e50ba135d849bf18bf240c ) == 2 ); // Frame stack

    // Framed code:
    tmp_hash_arg_1 = PyTuple_New( 2 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_require_explicit_policy );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 668;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_inhibit_policy_mapping );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 668;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 1, tmp_tuple_element_1 );
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 667;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2dbe05eea4e50ba135d849bf18bf240c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2dbe05eea4e50ba135d849bf18bf240c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2dbe05eea4e50ba135d849bf18bf240c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2dbe05eea4e50ba135d849bf18bf240c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2dbe05eea4e50ba135d849bf18bf240c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2dbe05eea4e50ba135d849bf18bf240c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2dbe05eea4e50ba135d849bf18bf240c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_2dbe05eea4e50ba135d849bf18bf240c == cache_frame_2dbe05eea4e50ba135d849bf18bf240c )
    {
        Py_DECREF( frame_2dbe05eea4e50ba135d849bf18bf240c );
    }
    cache_frame_2dbe05eea4e50ba135d849bf18bf240c = NULL;

    assertFrameObject( frame_2dbe05eea4e50ba135d849bf18bf240c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_67___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_67___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_68___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_policies = python_pars[ 1 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_ceeefbfafb213371719a30a4754165d4 = NULL;

    struct Nuitka_FrameObject *frame_ceeefbfafb213371719a30a4754165d4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ceeefbfafb213371719a30a4754165d4, codeobj_ceeefbfafb213371719a30a4754165d4, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_ceeefbfafb213371719a30a4754165d4 = cache_frame_ceeefbfafb213371719a30a4754165d4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ceeefbfafb213371719a30a4754165d4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ceeefbfafb213371719a30a4754165d4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_list_arg_1 = par_policies;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 684;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_policies;
        assert( old != NULL );
        par_policies = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_policies;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 685;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_68___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_ff3fcdf462b06c1ccc8f762be3dca470,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_68___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_68___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_ceeefbfafb213371719a30a4754165d4->m_frame.f_lineno = 685;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 685;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 685;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_a4add4111fbe02d06da1613741f3d5ca;
    frame_ceeefbfafb213371719a30a4754165d4->m_frame.f_lineno = 686;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 686;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_policies;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__policies, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 691;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ceeefbfafb213371719a30a4754165d4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ceeefbfafb213371719a30a4754165d4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ceeefbfafb213371719a30a4754165d4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ceeefbfafb213371719a30a4754165d4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ceeefbfafb213371719a30a4754165d4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ceeefbfafb213371719a30a4754165d4,
        type_description_1,
        par_self,
        par_policies
    );


    // Release cached frame.
    if ( frame_ceeefbfafb213371719a30a4754165d4 == cache_frame_ceeefbfafb213371719a30a4754165d4 )
    {
        Py_DECREF( frame_ceeefbfafb213371719a30a4754165d4 );
    }
    cache_frame_ceeefbfafb213371719a30a4754165d4 = NULL;

    assertFrameObject( frame_ceeefbfafb213371719a30a4754165d4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_68___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_policies );
    Py_DECREF( par_policies );
    par_policies = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_policies );
    Py_DECREF( par_policies );
    par_policies = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_68___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_68___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_68___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_68___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_ff3fcdf462b06c1ccc8f762be3dca470, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 685;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 685;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PolicyInformation );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PolicyInformation );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PolicyInformation" );
        exception_tb = NULL;

        exception_lineno = 685;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 685;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 685;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 685;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_69___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_f9a53cd0e4d5f2dd63b517a6ab23b164 = NULL;

    struct Nuitka_FrameObject *frame_f9a53cd0e4d5f2dd63b517a6ab23b164;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f9a53cd0e4d5f2dd63b517a6ab23b164, codeobj_f9a53cd0e4d5f2dd63b517a6ab23b164, module_cryptography$x509$extensions, sizeof(void *) );
    frame_f9a53cd0e4d5f2dd63b517a6ab23b164 = cache_frame_f9a53cd0e4d5f2dd63b517a6ab23b164;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f9a53cd0e4d5f2dd63b517a6ab23b164 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f9a53cd0e4d5f2dd63b517a6ab23b164 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_98ddab5a38618a53af9688f12b4a5b05;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__policies );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 696;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_f9a53cd0e4d5f2dd63b517a6ab23b164->m_frame.f_lineno = 696;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 696;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f9a53cd0e4d5f2dd63b517a6ab23b164 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f9a53cd0e4d5f2dd63b517a6ab23b164 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f9a53cd0e4d5f2dd63b517a6ab23b164 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f9a53cd0e4d5f2dd63b517a6ab23b164, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f9a53cd0e4d5f2dd63b517a6ab23b164->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f9a53cd0e4d5f2dd63b517a6ab23b164, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f9a53cd0e4d5f2dd63b517a6ab23b164,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f9a53cd0e4d5f2dd63b517a6ab23b164 == cache_frame_f9a53cd0e4d5f2dd63b517a6ab23b164 )
    {
        Py_DECREF( frame_f9a53cd0e4d5f2dd63b517a6ab23b164 );
    }
    cache_frame_f9a53cd0e4d5f2dd63b517a6ab23b164 = NULL;

    assertFrameObject( frame_f9a53cd0e4d5f2dd63b517a6ab23b164 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_69___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_69___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_70___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_9ee5e0eb8ddcfdfc231fceb269a57aa0 = NULL;

    struct Nuitka_FrameObject *frame_9ee5e0eb8ddcfdfc231fceb269a57aa0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9ee5e0eb8ddcfdfc231fceb269a57aa0, codeobj_9ee5e0eb8ddcfdfc231fceb269a57aa0, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_9ee5e0eb8ddcfdfc231fceb269a57aa0 = cache_frame_9ee5e0eb8ddcfdfc231fceb269a57aa0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9ee5e0eb8ddcfdfc231fceb269a57aa0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9ee5e0eb8ddcfdfc231fceb269a57aa0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CertificatePolicies );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CertificatePolicies );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "CertificatePolicies" );
        exception_tb = NULL;

        exception_lineno = 699;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 699;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__policies );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 702;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__policies );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 702;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 702;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9ee5e0eb8ddcfdfc231fceb269a57aa0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9ee5e0eb8ddcfdfc231fceb269a57aa0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9ee5e0eb8ddcfdfc231fceb269a57aa0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9ee5e0eb8ddcfdfc231fceb269a57aa0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9ee5e0eb8ddcfdfc231fceb269a57aa0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9ee5e0eb8ddcfdfc231fceb269a57aa0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9ee5e0eb8ddcfdfc231fceb269a57aa0,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_9ee5e0eb8ddcfdfc231fceb269a57aa0 == cache_frame_9ee5e0eb8ddcfdfc231fceb269a57aa0 )
    {
        Py_DECREF( frame_9ee5e0eb8ddcfdfc231fceb269a57aa0 );
    }
    cache_frame_9ee5e0eb8ddcfdfc231fceb269a57aa0 = NULL;

    assertFrameObject( frame_9ee5e0eb8ddcfdfc231fceb269a57aa0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_70___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_70___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_71___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_32a5567534533d3fcb64d922d269cbb9 = NULL;

    struct Nuitka_FrameObject *frame_32a5567534533d3fcb64d922d269cbb9;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_32a5567534533d3fcb64d922d269cbb9, codeobj_32a5567534533d3fcb64d922d269cbb9, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_32a5567534533d3fcb64d922d269cbb9 = cache_frame_32a5567534533d3fcb64d922d269cbb9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_32a5567534533d3fcb64d922d269cbb9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_32a5567534533d3fcb64d922d269cbb9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 705;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 705;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_32a5567534533d3fcb64d922d269cbb9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_32a5567534533d3fcb64d922d269cbb9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_32a5567534533d3fcb64d922d269cbb9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_32a5567534533d3fcb64d922d269cbb9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_32a5567534533d3fcb64d922d269cbb9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_32a5567534533d3fcb64d922d269cbb9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_32a5567534533d3fcb64d922d269cbb9,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_32a5567534533d3fcb64d922d269cbb9 == cache_frame_32a5567534533d3fcb64d922d269cbb9 )
    {
        Py_DECREF( frame_32a5567534533d3fcb64d922d269cbb9 );
    }
    cache_frame_32a5567534533d3fcb64d922d269cbb9 = NULL;

    assertFrameObject( frame_32a5567534533d3fcb64d922d269cbb9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_71___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_71___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_72___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_arg_1;
    static struct Nuitka_FrameObject *cache_frame_5905ebf138e75fb05d5d095e8ff6e294 = NULL;

    struct Nuitka_FrameObject *frame_5905ebf138e75fb05d5d095e8ff6e294;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5905ebf138e75fb05d5d095e8ff6e294, codeobj_5905ebf138e75fb05d5d095e8ff6e294, module_cryptography$x509$extensions, sizeof(void *) );
    frame_5905ebf138e75fb05d5d095e8ff6e294 = cache_frame_5905ebf138e75fb05d5d095e8ff6e294;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5905ebf138e75fb05d5d095e8ff6e294 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5905ebf138e75fb05d5d095e8ff6e294 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__policies );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 708;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_hash_arg_1 = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 708;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 708;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5905ebf138e75fb05d5d095e8ff6e294 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5905ebf138e75fb05d5d095e8ff6e294 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5905ebf138e75fb05d5d095e8ff6e294 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5905ebf138e75fb05d5d095e8ff6e294, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5905ebf138e75fb05d5d095e8ff6e294->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5905ebf138e75fb05d5d095e8ff6e294, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5905ebf138e75fb05d5d095e8ff6e294,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_5905ebf138e75fb05d5d095e8ff6e294 == cache_frame_5905ebf138e75fb05d5d095e8ff6e294 )
    {
        Py_DECREF( frame_5905ebf138e75fb05d5d095e8ff6e294 );
    }
    cache_frame_5905ebf138e75fb05d5d095e8ff6e294 = NULL;

    assertFrameObject( frame_5905ebf138e75fb05d5d095e8ff6e294 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_72___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_72___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_73___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_policy_identifier = python_pars[ 1 ];
    PyObject *par_policy_qualifiers = python_pars[ 2 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_b17d8bfe741848af9af0ee2a9bb1f68b = NULL;

    struct Nuitka_FrameObject *frame_b17d8bfe741848af9af0ee2a9bb1f68b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b17d8bfe741848af9af0ee2a9bb1f68b, codeobj_b17d8bfe741848af9af0ee2a9bb1f68b, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b17d8bfe741848af9af0ee2a9bb1f68b = cache_frame_b17d8bfe741848af9af0ee2a9bb1f68b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b17d8bfe741848af9af0ee2a9bb1f68b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b17d8bfe741848af9af0ee2a9bb1f68b ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_policy_identifier;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ObjectIdentifier" );
        exception_tb = NULL;

        exception_lineno = 713;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 713;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_ad140184cf2507dc997c5c6a9d0f3e94;
    frame_b17d8bfe741848af9af0ee2a9bb1f68b->m_frame.f_lineno = 714;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 714;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_policy_identifier;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__policy_identifier, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 716;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = par_policy_qualifiers;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 718;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_list_arg_1 = par_policy_qualifiers;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 719;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_policy_qualifiers;
        assert( old != NULL );
        par_policy_qualifiers = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_policy_qualifiers;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 721;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_73___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_288d18811543a4caa9a97723100a1438,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_73___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_73___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_b17d8bfe741848af9af0ee2a9bb1f68b->m_frame.f_lineno = 720;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 720;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 720;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_2 = const_str_digest_cb90e2fbaafbf44b381aafdbc54043e2;
    frame_b17d8bfe741848af9af0ee2a9bb1f68b->m_frame.f_lineno = 724;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 724;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    branch_no_2:;
    tmp_assattr_name_2 = par_policy_qualifiers;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__policy_qualifiers, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 729;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b17d8bfe741848af9af0ee2a9bb1f68b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b17d8bfe741848af9af0ee2a9bb1f68b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b17d8bfe741848af9af0ee2a9bb1f68b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b17d8bfe741848af9af0ee2a9bb1f68b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b17d8bfe741848af9af0ee2a9bb1f68b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b17d8bfe741848af9af0ee2a9bb1f68b,
        type_description_1,
        par_self,
        par_policy_identifier,
        par_policy_qualifiers
    );


    // Release cached frame.
    if ( frame_b17d8bfe741848af9af0ee2a9bb1f68b == cache_frame_b17d8bfe741848af9af0ee2a9bb1f68b )
    {
        Py_DECREF( frame_b17d8bfe741848af9af0ee2a9bb1f68b );
    }
    cache_frame_b17d8bfe741848af9af0ee2a9bb1f68b = NULL;

    assertFrameObject( frame_b17d8bfe741848af9af0ee2a9bb1f68b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_73___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_policy_identifier );
    Py_DECREF( par_policy_identifier );
    par_policy_identifier = NULL;

    CHECK_OBJECT( (PyObject *)par_policy_qualifiers );
    Py_DECREF( par_policy_qualifiers );
    par_policy_qualifiers = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_policy_identifier );
    Py_DECREF( par_policy_identifier );
    par_policy_identifier = NULL;

    Py_XDECREF( par_policy_qualifiers );
    par_policy_qualifiers = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_73___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_73___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_73___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_73___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_288d18811543a4caa9a97723100a1438, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 721;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 721;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = PyTuple_New( 2 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_six );
    }

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_isinstance_cls_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "six" );
        exception_tb = NULL;

        exception_lineno = 721;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_text_type );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_cls_1 );

        exception_lineno = 721;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_UserNotice );

    if (unlikely( tmp_tuple_element_1 == NULL ))
    {
        tmp_tuple_element_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_UserNotice );
    }

    if ( tmp_tuple_element_1 == NULL )
    {
        Py_DECREF( tmp_isinstance_cls_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "UserNotice" );
        exception_tb = NULL;

        exception_lineno = 721;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_isinstance_cls_1, 1, tmp_tuple_element_1 );
    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 721;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 721;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 721;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_74___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_b33015c9c8f142821188a53ad7ed0219 = NULL;

    struct Nuitka_FrameObject *frame_b33015c9c8f142821188a53ad7ed0219;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b33015c9c8f142821188a53ad7ed0219, codeobj_b33015c9c8f142821188a53ad7ed0219, module_cryptography$x509$extensions, sizeof(void *) );
    frame_b33015c9c8f142821188a53ad7ed0219 = cache_frame_b33015c9c8f142821188a53ad7ed0219;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b33015c9c8f142821188a53ad7ed0219 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b33015c9c8f142821188a53ad7ed0219 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_9cc2c8377ce78bc1b198ac0906717d7f;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_b33015c9c8f142821188a53ad7ed0219->m_frame.f_lineno = 733;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 733;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b33015c9c8f142821188a53ad7ed0219 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b33015c9c8f142821188a53ad7ed0219 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b33015c9c8f142821188a53ad7ed0219 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b33015c9c8f142821188a53ad7ed0219, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b33015c9c8f142821188a53ad7ed0219->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b33015c9c8f142821188a53ad7ed0219, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b33015c9c8f142821188a53ad7ed0219,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b33015c9c8f142821188a53ad7ed0219 == cache_frame_b33015c9c8f142821188a53ad7ed0219 )
    {
        Py_DECREF( frame_b33015c9c8f142821188a53ad7ed0219 );
    }
    cache_frame_b33015c9c8f142821188a53ad7ed0219 = NULL;

    assertFrameObject( frame_b33015c9c8f142821188a53ad7ed0219 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_74___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_74___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_75___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_3497c1c37e412baefa4af9a9a209b6ae = NULL;

    struct Nuitka_FrameObject *frame_3497c1c37e412baefa4af9a9a209b6ae;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3497c1c37e412baefa4af9a9a209b6ae, codeobj_3497c1c37e412baefa4af9a9a209b6ae, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_3497c1c37e412baefa4af9a9a209b6ae = cache_frame_3497c1c37e412baefa4af9a9a209b6ae;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3497c1c37e412baefa4af9a9a209b6ae );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3497c1c37e412baefa4af9a9a209b6ae ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PolicyInformation );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PolicyInformation );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PolicyInformation" );
        exception_tb = NULL;

        exception_lineno = 738;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_policy_identifier );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 742;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_policy_identifier );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 742;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 742;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 743;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_policy_qualifiers );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 743;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_other;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_policy_qualifiers );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 743;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 743;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3497c1c37e412baefa4af9a9a209b6ae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3497c1c37e412baefa4af9a9a209b6ae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3497c1c37e412baefa4af9a9a209b6ae );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3497c1c37e412baefa4af9a9a209b6ae, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3497c1c37e412baefa4af9a9a209b6ae->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3497c1c37e412baefa4af9a9a209b6ae, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3497c1c37e412baefa4af9a9a209b6ae,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_3497c1c37e412baefa4af9a9a209b6ae == cache_frame_3497c1c37e412baefa4af9a9a209b6ae )
    {
        Py_DECREF( frame_3497c1c37e412baefa4af9a9a209b6ae );
    }
    cache_frame_3497c1c37e412baefa4af9a9a209b6ae = NULL;

    assertFrameObject( frame_3497c1c37e412baefa4af9a9a209b6ae );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_75___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_75___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_76___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_412598eaeb7e5076c659e7571e1acadb = NULL;

    struct Nuitka_FrameObject *frame_412598eaeb7e5076c659e7571e1acadb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_412598eaeb7e5076c659e7571e1acadb, codeobj_412598eaeb7e5076c659e7571e1acadb, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_412598eaeb7e5076c659e7571e1acadb = cache_frame_412598eaeb7e5076c659e7571e1acadb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_412598eaeb7e5076c659e7571e1acadb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_412598eaeb7e5076c659e7571e1acadb ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 747;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 747;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_412598eaeb7e5076c659e7571e1acadb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_412598eaeb7e5076c659e7571e1acadb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_412598eaeb7e5076c659e7571e1acadb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_412598eaeb7e5076c659e7571e1acadb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_412598eaeb7e5076c659e7571e1acadb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_412598eaeb7e5076c659e7571e1acadb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_412598eaeb7e5076c659e7571e1acadb,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_412598eaeb7e5076c659e7571e1acadb == cache_frame_412598eaeb7e5076c659e7571e1acadb )
    {
        Py_DECREF( frame_412598eaeb7e5076c659e7571e1acadb );
    }
    cache_frame_412598eaeb7e5076c659e7571e1acadb = NULL;

    assertFrameObject( frame_412598eaeb7e5076c659e7571e1acadb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_76___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_76___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_77___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_pq = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_hash_arg_1;
    bool tmp_isnot_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_tuple_arg_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_51616706c0e3c52cf5160713d5617964 = NULL;

    struct Nuitka_FrameObject *frame_51616706c0e3c52cf5160713d5617964;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_51616706c0e3c52cf5160713d5617964, codeobj_51616706c0e3c52cf5160713d5617964, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_51616706c0e3c52cf5160713d5617964 = cache_frame_51616706c0e3c52cf5160713d5617964;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_51616706c0e3c52cf5160713d5617964 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_51616706c0e3c52cf5160713d5617964 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_policy_qualifiers );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 750;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_policy_qualifiers );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 751;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 751;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_pq == NULL );
    var_pq = tmp_assign_source_1;

    goto branch_end_1;
    branch_no_1:;
    tmp_assign_source_2 = Py_None;
    assert( var_pq == NULL );
    Py_INCREF( tmp_assign_source_2 );
    var_pq = tmp_assign_source_2;

    branch_end_1:;
    tmp_hash_arg_1 = PyTuple_New( 2 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_policy_identifier );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 755;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_pq;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_hash_arg_1, 1, tmp_tuple_element_1 );
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 755;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_51616706c0e3c52cf5160713d5617964 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_51616706c0e3c52cf5160713d5617964 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_51616706c0e3c52cf5160713d5617964 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_51616706c0e3c52cf5160713d5617964, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_51616706c0e3c52cf5160713d5617964->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_51616706c0e3c52cf5160713d5617964, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_51616706c0e3c52cf5160713d5617964,
        type_description_1,
        par_self,
        var_pq
    );


    // Release cached frame.
    if ( frame_51616706c0e3c52cf5160713d5617964 == cache_frame_51616706c0e3c52cf5160713d5617964 )
    {
        Py_DECREF( frame_51616706c0e3c52cf5160713d5617964 );
    }
    cache_frame_51616706c0e3c52cf5160713d5617964 = NULL;

    assertFrameObject( frame_51616706c0e3c52cf5160713d5617964 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_77___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_pq );
    Py_DECREF( var_pq );
    var_pq = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_pq );
    var_pq = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_77___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_78___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_notice_reference = python_pars[ 1 ];
    PyObject *par_explicit_text = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_a584e498103128fd6f0f75adcfa25ce5 = NULL;

    struct Nuitka_FrameObject *frame_a584e498103128fd6f0f75adcfa25ce5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a584e498103128fd6f0f75adcfa25ce5, codeobj_a584e498103128fd6f0f75adcfa25ce5, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a584e498103128fd6f0f75adcfa25ce5 = cache_frame_a584e498103128fd6f0f75adcfa25ce5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a584e498103128fd6f0f75adcfa25ce5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a584e498103128fd6f0f75adcfa25ce5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_and_left_value_1 = par_notice_reference;

    CHECK_OBJECT( tmp_and_left_value_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 763;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_isinstance_inst_1 = par_notice_reference;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_NoticeReference );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NoticeReference );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "NoticeReference" );
        exception_tb = NULL;

        exception_lineno = 764;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_operand_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 763;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 763;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 763;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_7689dc38f9edab5e0154168296ac4aa7;
    frame_a584e498103128fd6f0f75adcfa25ce5->m_frame.f_lineno = 766;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 766;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_notice_reference;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__notice_reference, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 770;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_explicit_text;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__explicit_text, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 771;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a584e498103128fd6f0f75adcfa25ce5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a584e498103128fd6f0f75adcfa25ce5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a584e498103128fd6f0f75adcfa25ce5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a584e498103128fd6f0f75adcfa25ce5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a584e498103128fd6f0f75adcfa25ce5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a584e498103128fd6f0f75adcfa25ce5,
        type_description_1,
        par_self,
        par_notice_reference,
        par_explicit_text
    );


    // Release cached frame.
    if ( frame_a584e498103128fd6f0f75adcfa25ce5 == cache_frame_a584e498103128fd6f0f75adcfa25ce5 )
    {
        Py_DECREF( frame_a584e498103128fd6f0f75adcfa25ce5 );
    }
    cache_frame_a584e498103128fd6f0f75adcfa25ce5 = NULL;

    assertFrameObject( frame_a584e498103128fd6f0f75adcfa25ce5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_78___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_explicit_text );
    Py_DECREF( par_explicit_text );
    par_explicit_text = NULL;

    CHECK_OBJECT( (PyObject *)par_notice_reference );
    Py_DECREF( par_notice_reference );
    par_notice_reference = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_explicit_text );
    Py_DECREF( par_explicit_text );
    par_explicit_text = NULL;

    CHECK_OBJECT( (PyObject *)par_notice_reference );
    Py_DECREF( par_notice_reference );
    par_notice_reference = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_78___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_79___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_a0de3733aff74e9bc6ad1271640bbb3a = NULL;

    struct Nuitka_FrameObject *frame_a0de3733aff74e9bc6ad1271640bbb3a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a0de3733aff74e9bc6ad1271640bbb3a, codeobj_a0de3733aff74e9bc6ad1271640bbb3a, module_cryptography$x509$extensions, sizeof(void *) );
    frame_a0de3733aff74e9bc6ad1271640bbb3a = cache_frame_a0de3733aff74e9bc6ad1271640bbb3a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a0de3733aff74e9bc6ad1271640bbb3a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a0de3733aff74e9bc6ad1271640bbb3a ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_76d9dc3b971abafb272069e298f2eb0c;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_a0de3733aff74e9bc6ad1271640bbb3a->m_frame.f_lineno = 775;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 775;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0de3733aff74e9bc6ad1271640bbb3a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0de3733aff74e9bc6ad1271640bbb3a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0de3733aff74e9bc6ad1271640bbb3a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a0de3733aff74e9bc6ad1271640bbb3a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a0de3733aff74e9bc6ad1271640bbb3a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a0de3733aff74e9bc6ad1271640bbb3a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a0de3733aff74e9bc6ad1271640bbb3a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_a0de3733aff74e9bc6ad1271640bbb3a == cache_frame_a0de3733aff74e9bc6ad1271640bbb3a )
    {
        Py_DECREF( frame_a0de3733aff74e9bc6ad1271640bbb3a );
    }
    cache_frame_a0de3733aff74e9bc6ad1271640bbb3a = NULL;

    assertFrameObject( frame_a0de3733aff74e9bc6ad1271640bbb3a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_79___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_79___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_80___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0 = NULL;

    struct Nuitka_FrameObject *frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0, codeobj_8f3f5ca8f9dcd2eee7756b96f3f2bbe0, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0 = cache_frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_UserNotice );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_UserNotice );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "UserNotice" );
        exception_tb = NULL;

        exception_lineno = 780;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 780;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_notice_reference );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 784;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_notice_reference );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 784;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 784;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 785;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_explicit_text );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 785;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_other;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_explicit_text );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 785;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 785;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0 == cache_frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0 )
    {
        Py_DECREF( frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0 );
    }
    cache_frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0 = NULL;

    assertFrameObject( frame_8f3f5ca8f9dcd2eee7756b96f3f2bbe0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_80___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_80___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_81___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_c6ffc7f3b129e13eebcbcd394632062a = NULL;

    struct Nuitka_FrameObject *frame_c6ffc7f3b129e13eebcbcd394632062a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c6ffc7f3b129e13eebcbcd394632062a, codeobj_c6ffc7f3b129e13eebcbcd394632062a, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_c6ffc7f3b129e13eebcbcd394632062a = cache_frame_c6ffc7f3b129e13eebcbcd394632062a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c6ffc7f3b129e13eebcbcd394632062a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c6ffc7f3b129e13eebcbcd394632062a ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 789;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 789;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c6ffc7f3b129e13eebcbcd394632062a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c6ffc7f3b129e13eebcbcd394632062a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c6ffc7f3b129e13eebcbcd394632062a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c6ffc7f3b129e13eebcbcd394632062a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c6ffc7f3b129e13eebcbcd394632062a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c6ffc7f3b129e13eebcbcd394632062a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c6ffc7f3b129e13eebcbcd394632062a,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_c6ffc7f3b129e13eebcbcd394632062a == cache_frame_c6ffc7f3b129e13eebcbcd394632062a )
    {
        Py_DECREF( frame_c6ffc7f3b129e13eebcbcd394632062a );
    }
    cache_frame_c6ffc7f3b129e13eebcbcd394632062a = NULL;

    assertFrameObject( frame_c6ffc7f3b129e13eebcbcd394632062a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_81___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_81___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_82___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_8deead5e9a69c59660a72414a4a524b9 = NULL;

    struct Nuitka_FrameObject *frame_8deead5e9a69c59660a72414a4a524b9;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8deead5e9a69c59660a72414a4a524b9, codeobj_8deead5e9a69c59660a72414a4a524b9, module_cryptography$x509$extensions, sizeof(void *) );
    frame_8deead5e9a69c59660a72414a4a524b9 = cache_frame_8deead5e9a69c59660a72414a4a524b9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8deead5e9a69c59660a72414a4a524b9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8deead5e9a69c59660a72414a4a524b9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_hash_arg_1 = PyTuple_New( 2 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_notice_reference );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 792;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_explicit_text );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 792;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 1, tmp_tuple_element_1 );
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 792;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8deead5e9a69c59660a72414a4a524b9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8deead5e9a69c59660a72414a4a524b9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8deead5e9a69c59660a72414a4a524b9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8deead5e9a69c59660a72414a4a524b9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8deead5e9a69c59660a72414a4a524b9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8deead5e9a69c59660a72414a4a524b9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8deead5e9a69c59660a72414a4a524b9,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8deead5e9a69c59660a72414a4a524b9 == cache_frame_8deead5e9a69c59660a72414a4a524b9 )
    {
        Py_DECREF( frame_8deead5e9a69c59660a72414a4a524b9 );
    }
    cache_frame_8deead5e9a69c59660a72414a4a524b9 = NULL;

    assertFrameObject( frame_8deead5e9a69c59660a72414a4a524b9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_82___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_82___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_83___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_organization = python_pars[ 1 ];
    PyObject *par_notice_numbers = python_pars[ 2 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_5d6754a9c513375f07c3b917f00663b8 = NULL;

    struct Nuitka_FrameObject *frame_5d6754a9c513375f07c3b917f00663b8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5d6754a9c513375f07c3b917f00663b8, codeobj_5d6754a9c513375f07c3b917f00663b8, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5d6754a9c513375f07c3b917f00663b8 = cache_frame_5d6754a9c513375f07c3b917f00663b8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5d6754a9c513375f07c3b917f00663b8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5d6754a9c513375f07c3b917f00663b8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = par_organization;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__organization, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 800;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_list_arg_1 = par_notice_numbers;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 801;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_notice_numbers;
        assert( old != NULL );
        par_notice_numbers = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_notice_numbers;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 802;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_83___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_a093dfbb9eba017c77e90495ad84f46b,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_83___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_83___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_5d6754a9c513375f07c3b917f00663b8->m_frame.f_lineno = 802;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 802;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 802;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_d2a030963ea7fa46a452128daffceb24;
    frame_5d6754a9c513375f07c3b917f00663b8->m_frame.f_lineno = 803;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 803;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_2 = par_notice_numbers;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__notice_numbers, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 807;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d6754a9c513375f07c3b917f00663b8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d6754a9c513375f07c3b917f00663b8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5d6754a9c513375f07c3b917f00663b8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5d6754a9c513375f07c3b917f00663b8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5d6754a9c513375f07c3b917f00663b8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5d6754a9c513375f07c3b917f00663b8,
        type_description_1,
        par_self,
        par_organization,
        par_notice_numbers
    );


    // Release cached frame.
    if ( frame_5d6754a9c513375f07c3b917f00663b8 == cache_frame_5d6754a9c513375f07c3b917f00663b8 )
    {
        Py_DECREF( frame_5d6754a9c513375f07c3b917f00663b8 );
    }
    cache_frame_5d6754a9c513375f07c3b917f00663b8 = NULL;

    assertFrameObject( frame_5d6754a9c513375f07c3b917f00663b8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_83___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_organization );
    Py_DECREF( par_organization );
    par_organization = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_notice_numbers );
    Py_DECREF( par_notice_numbers );
    par_notice_numbers = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_organization );
    Py_DECREF( par_organization );
    par_organization = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_notice_numbers );
    Py_DECREF( par_notice_numbers );
    par_notice_numbers = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_83___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_83___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_83___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_83___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_a093dfbb9eba017c77e90495ad84f46b, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 802;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 802;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 802;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 802;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 802;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_84___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_819e7ded813ebd3724f65aaa539d9d5c = NULL;

    struct Nuitka_FrameObject *frame_819e7ded813ebd3724f65aaa539d9d5c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_819e7ded813ebd3724f65aaa539d9d5c, codeobj_819e7ded813ebd3724f65aaa539d9d5c, module_cryptography$x509$extensions, sizeof(void *) );
    frame_819e7ded813ebd3724f65aaa539d9d5c = cache_frame_819e7ded813ebd3724f65aaa539d9d5c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_819e7ded813ebd3724f65aaa539d9d5c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_819e7ded813ebd3724f65aaa539d9d5c ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_114372ae17a491041cc1a4b677269f5b;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_819e7ded813ebd3724f65aaa539d9d5c->m_frame.f_lineno = 811;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 811;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_819e7ded813ebd3724f65aaa539d9d5c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_819e7ded813ebd3724f65aaa539d9d5c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_819e7ded813ebd3724f65aaa539d9d5c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_819e7ded813ebd3724f65aaa539d9d5c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_819e7ded813ebd3724f65aaa539d9d5c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_819e7ded813ebd3724f65aaa539d9d5c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_819e7ded813ebd3724f65aaa539d9d5c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_819e7ded813ebd3724f65aaa539d9d5c == cache_frame_819e7ded813ebd3724f65aaa539d9d5c )
    {
        Py_DECREF( frame_819e7ded813ebd3724f65aaa539d9d5c );
    }
    cache_frame_819e7ded813ebd3724f65aaa539d9d5c = NULL;

    assertFrameObject( frame_819e7ded813ebd3724f65aaa539d9d5c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_84___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_84___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_85___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_69a9fb7c23f7735a4e94f6c7a371cd0d = NULL;

    struct Nuitka_FrameObject *frame_69a9fb7c23f7735a4e94f6c7a371cd0d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_69a9fb7c23f7735a4e94f6c7a371cd0d, codeobj_69a9fb7c23f7735a4e94f6c7a371cd0d, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_69a9fb7c23f7735a4e94f6c7a371cd0d = cache_frame_69a9fb7c23f7735a4e94f6c7a371cd0d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_69a9fb7c23f7735a4e94f6c7a371cd0d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_69a9fb7c23f7735a4e94f6c7a371cd0d ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_NoticeReference );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NoticeReference );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "NoticeReference" );
        exception_tb = NULL;

        exception_lineno = 816;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 816;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_organization );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 820;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_organization );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 820;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 820;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 821;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_notice_numbers );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 821;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_other;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_notice_numbers );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 821;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 821;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_69a9fb7c23f7735a4e94f6c7a371cd0d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_69a9fb7c23f7735a4e94f6c7a371cd0d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_69a9fb7c23f7735a4e94f6c7a371cd0d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_69a9fb7c23f7735a4e94f6c7a371cd0d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_69a9fb7c23f7735a4e94f6c7a371cd0d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_69a9fb7c23f7735a4e94f6c7a371cd0d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_69a9fb7c23f7735a4e94f6c7a371cd0d,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_69a9fb7c23f7735a4e94f6c7a371cd0d == cache_frame_69a9fb7c23f7735a4e94f6c7a371cd0d )
    {
        Py_DECREF( frame_69a9fb7c23f7735a4e94f6c7a371cd0d );
    }
    cache_frame_69a9fb7c23f7735a4e94f6c7a371cd0d = NULL;

    assertFrameObject( frame_69a9fb7c23f7735a4e94f6c7a371cd0d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_85___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_85___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_86___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_2f56c60eb8999fc8e0ae18eca4bed6ea = NULL;

    struct Nuitka_FrameObject *frame_2f56c60eb8999fc8e0ae18eca4bed6ea;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2f56c60eb8999fc8e0ae18eca4bed6ea, codeobj_2f56c60eb8999fc8e0ae18eca4bed6ea, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_2f56c60eb8999fc8e0ae18eca4bed6ea = cache_frame_2f56c60eb8999fc8e0ae18eca4bed6ea;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2f56c60eb8999fc8e0ae18eca4bed6ea );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2f56c60eb8999fc8e0ae18eca4bed6ea ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 825;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 825;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f56c60eb8999fc8e0ae18eca4bed6ea );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f56c60eb8999fc8e0ae18eca4bed6ea );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f56c60eb8999fc8e0ae18eca4bed6ea );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2f56c60eb8999fc8e0ae18eca4bed6ea, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2f56c60eb8999fc8e0ae18eca4bed6ea->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2f56c60eb8999fc8e0ae18eca4bed6ea, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f56c60eb8999fc8e0ae18eca4bed6ea,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_2f56c60eb8999fc8e0ae18eca4bed6ea == cache_frame_2f56c60eb8999fc8e0ae18eca4bed6ea )
    {
        Py_DECREF( frame_2f56c60eb8999fc8e0ae18eca4bed6ea );
    }
    cache_frame_2f56c60eb8999fc8e0ae18eca4bed6ea = NULL;

    assertFrameObject( frame_2f56c60eb8999fc8e0ae18eca4bed6ea );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_86___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_86___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_87___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_tuple_arg_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_a59e3470eb3314c071ae13b9d32dfac6 = NULL;

    struct Nuitka_FrameObject *frame_a59e3470eb3314c071ae13b9d32dfac6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a59e3470eb3314c071ae13b9d32dfac6, codeobj_a59e3470eb3314c071ae13b9d32dfac6, module_cryptography$x509$extensions, sizeof(void *) );
    frame_a59e3470eb3314c071ae13b9d32dfac6 = cache_frame_a59e3470eb3314c071ae13b9d32dfac6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a59e3470eb3314c071ae13b9d32dfac6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a59e3470eb3314c071ae13b9d32dfac6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_hash_arg_1 = PyTuple_New( 2 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_organization );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 828;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_notice_numbers );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 828;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_tuple_element_1 = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 828;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 1, tmp_tuple_element_1 );
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 828;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a59e3470eb3314c071ae13b9d32dfac6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a59e3470eb3314c071ae13b9d32dfac6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a59e3470eb3314c071ae13b9d32dfac6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a59e3470eb3314c071ae13b9d32dfac6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a59e3470eb3314c071ae13b9d32dfac6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a59e3470eb3314c071ae13b9d32dfac6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a59e3470eb3314c071ae13b9d32dfac6,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_a59e3470eb3314c071ae13b9d32dfac6 == cache_frame_a59e3470eb3314c071ae13b9d32dfac6 )
    {
        Py_DECREF( frame_a59e3470eb3314c071ae13b9d32dfac6 );
    }
    cache_frame_a59e3470eb3314c071ae13b9d32dfac6 = NULL;

    assertFrameObject( frame_a59e3470eb3314c071ae13b9d32dfac6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_87___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_87___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_88___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_usages = python_pars[ 1 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_5a3287b9f9778171857e124b22ebfc17 = NULL;

    struct Nuitka_FrameObject *frame_5a3287b9f9778171857e124b22ebfc17;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5a3287b9f9778171857e124b22ebfc17, codeobj_5a3287b9f9778171857e124b22ebfc17, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_5a3287b9f9778171857e124b22ebfc17 = cache_frame_5a3287b9f9778171857e124b22ebfc17;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5a3287b9f9778171857e124b22ebfc17 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5a3287b9f9778171857e124b22ebfc17 ) == 2 ); // Frame stack

    // Framed code:
    tmp_list_arg_1 = par_usages;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 839;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_usages;
        assert( old != NULL );
        par_usages = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_usages;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 840;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_88___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_32ca2991404875e1f23201079d1225b9,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_88___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_88___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_5a3287b9f9778171857e124b22ebfc17->m_frame.f_lineno = 840;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 840;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 840;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_a2ae3825a8b7f0237bc2c108542b8be9;
    frame_5a3287b9f9778171857e124b22ebfc17->m_frame.f_lineno = 841;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 841;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_usages;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__usages, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 845;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5a3287b9f9778171857e124b22ebfc17 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5a3287b9f9778171857e124b22ebfc17 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5a3287b9f9778171857e124b22ebfc17, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5a3287b9f9778171857e124b22ebfc17->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5a3287b9f9778171857e124b22ebfc17, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5a3287b9f9778171857e124b22ebfc17,
        type_description_1,
        par_self,
        par_usages
    );


    // Release cached frame.
    if ( frame_5a3287b9f9778171857e124b22ebfc17 == cache_frame_5a3287b9f9778171857e124b22ebfc17 )
    {
        Py_DECREF( frame_5a3287b9f9778171857e124b22ebfc17 );
    }
    cache_frame_5a3287b9f9778171857e124b22ebfc17 = NULL;

    assertFrameObject( frame_5a3287b9f9778171857e124b22ebfc17 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_88___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_usages );
    Py_DECREF( par_usages );
    par_usages = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_usages );
    Py_DECREF( par_usages );
    par_usages = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_88___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_88___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_88___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_88___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_32ca2991404875e1f23201079d1225b9, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 840;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 840;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ObjectIdentifier" );
        exception_tb = NULL;

        exception_lineno = 840;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 840;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 840;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 840;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_89___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_a9673f6324198b7604937ea246a4d5fb = NULL;

    struct Nuitka_FrameObject *frame_a9673f6324198b7604937ea246a4d5fb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a9673f6324198b7604937ea246a4d5fb, codeobj_a9673f6324198b7604937ea246a4d5fb, module_cryptography$x509$extensions, sizeof(void *) );
    frame_a9673f6324198b7604937ea246a4d5fb = cache_frame_a9673f6324198b7604937ea246a4d5fb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a9673f6324198b7604937ea246a4d5fb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a9673f6324198b7604937ea246a4d5fb ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_548641877ac6c51da15a8285d67846ee;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__usages );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 850;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_a9673f6324198b7604937ea246a4d5fb->m_frame.f_lineno = 850;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 850;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a9673f6324198b7604937ea246a4d5fb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a9673f6324198b7604937ea246a4d5fb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a9673f6324198b7604937ea246a4d5fb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a9673f6324198b7604937ea246a4d5fb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a9673f6324198b7604937ea246a4d5fb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a9673f6324198b7604937ea246a4d5fb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a9673f6324198b7604937ea246a4d5fb,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_a9673f6324198b7604937ea246a4d5fb == cache_frame_a9673f6324198b7604937ea246a4d5fb )
    {
        Py_DECREF( frame_a9673f6324198b7604937ea246a4d5fb );
    }
    cache_frame_a9673f6324198b7604937ea246a4d5fb = NULL;

    assertFrameObject( frame_a9673f6324198b7604937ea246a4d5fb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_89___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_89___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_90___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_12a61a0f3bdbcdc560a8ea860e2877f1 = NULL;

    struct Nuitka_FrameObject *frame_12a61a0f3bdbcdc560a8ea860e2877f1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_12a61a0f3bdbcdc560a8ea860e2877f1, codeobj_12a61a0f3bdbcdc560a8ea860e2877f1, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_12a61a0f3bdbcdc560a8ea860e2877f1 = cache_frame_12a61a0f3bdbcdc560a8ea860e2877f1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_12a61a0f3bdbcdc560a8ea860e2877f1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_12a61a0f3bdbcdc560a8ea860e2877f1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtendedKeyUsage );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtendedKeyUsage );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ExtendedKeyUsage" );
        exception_tb = NULL;

        exception_lineno = 853;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 853;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__usages );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 856;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__usages );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 856;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 856;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_12a61a0f3bdbcdc560a8ea860e2877f1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_12a61a0f3bdbcdc560a8ea860e2877f1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_12a61a0f3bdbcdc560a8ea860e2877f1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_12a61a0f3bdbcdc560a8ea860e2877f1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_12a61a0f3bdbcdc560a8ea860e2877f1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_12a61a0f3bdbcdc560a8ea860e2877f1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_12a61a0f3bdbcdc560a8ea860e2877f1,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_12a61a0f3bdbcdc560a8ea860e2877f1 == cache_frame_12a61a0f3bdbcdc560a8ea860e2877f1 )
    {
        Py_DECREF( frame_12a61a0f3bdbcdc560a8ea860e2877f1 );
    }
    cache_frame_12a61a0f3bdbcdc560a8ea860e2877f1 = NULL;

    assertFrameObject( frame_12a61a0f3bdbcdc560a8ea860e2877f1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_90___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_90___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_91___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_ff852a570e805f80242c9e3d5522b935 = NULL;

    struct Nuitka_FrameObject *frame_ff852a570e805f80242c9e3d5522b935;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ff852a570e805f80242c9e3d5522b935, codeobj_ff852a570e805f80242c9e3d5522b935, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_ff852a570e805f80242c9e3d5522b935 = cache_frame_ff852a570e805f80242c9e3d5522b935;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ff852a570e805f80242c9e3d5522b935 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ff852a570e805f80242c9e3d5522b935 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 859;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 859;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff852a570e805f80242c9e3d5522b935 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff852a570e805f80242c9e3d5522b935 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff852a570e805f80242c9e3d5522b935 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ff852a570e805f80242c9e3d5522b935, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ff852a570e805f80242c9e3d5522b935->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ff852a570e805f80242c9e3d5522b935, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ff852a570e805f80242c9e3d5522b935,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_ff852a570e805f80242c9e3d5522b935 == cache_frame_ff852a570e805f80242c9e3d5522b935 )
    {
        Py_DECREF( frame_ff852a570e805f80242c9e3d5522b935 );
    }
    cache_frame_ff852a570e805f80242c9e3d5522b935 = NULL;

    assertFrameObject( frame_ff852a570e805f80242c9e3d5522b935 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_91___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_91___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_92___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_arg_1;
    static struct Nuitka_FrameObject *cache_frame_0f9bf51bf63188a54bf9db4e12622b3b = NULL;

    struct Nuitka_FrameObject *frame_0f9bf51bf63188a54bf9db4e12622b3b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0f9bf51bf63188a54bf9db4e12622b3b, codeobj_0f9bf51bf63188a54bf9db4e12622b3b, module_cryptography$x509$extensions, sizeof(void *) );
    frame_0f9bf51bf63188a54bf9db4e12622b3b = cache_frame_0f9bf51bf63188a54bf9db4e12622b3b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0f9bf51bf63188a54bf9db4e12622b3b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0f9bf51bf63188a54bf9db4e12622b3b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__usages );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 862;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_hash_arg_1 = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 862;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 862;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0f9bf51bf63188a54bf9db4e12622b3b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0f9bf51bf63188a54bf9db4e12622b3b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0f9bf51bf63188a54bf9db4e12622b3b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0f9bf51bf63188a54bf9db4e12622b3b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0f9bf51bf63188a54bf9db4e12622b3b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0f9bf51bf63188a54bf9db4e12622b3b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0f9bf51bf63188a54bf9db4e12622b3b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_0f9bf51bf63188a54bf9db4e12622b3b == cache_frame_0f9bf51bf63188a54bf9db4e12622b3b )
    {
        Py_DECREF( frame_0f9bf51bf63188a54bf9db4e12622b3b );
    }
    cache_frame_0f9bf51bf63188a54bf9db4e12622b3b = NULL;

    assertFrameObject( frame_0f9bf51bf63188a54bf9db4e12622b3b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_92___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_92___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_93___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_24eca4c72db0e65a6c34b09011c8543e = NULL;

    struct Nuitka_FrameObject *frame_24eca4c72db0e65a6c34b09011c8543e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_24eca4c72db0e65a6c34b09011c8543e, codeobj_24eca4c72db0e65a6c34b09011c8543e, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_24eca4c72db0e65a6c34b09011c8543e = cache_frame_24eca4c72db0e65a6c34b09011c8543e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_24eca4c72db0e65a6c34b09011c8543e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_24eca4c72db0e65a6c34b09011c8543e ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OCSPNoCheck );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OCSPNoCheck );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "OCSPNoCheck" );
        exception_tb = NULL;

        exception_lineno = 870;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 870;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_24eca4c72db0e65a6c34b09011c8543e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_24eca4c72db0e65a6c34b09011c8543e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_24eca4c72db0e65a6c34b09011c8543e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_24eca4c72db0e65a6c34b09011c8543e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_24eca4c72db0e65a6c34b09011c8543e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_24eca4c72db0e65a6c34b09011c8543e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_24eca4c72db0e65a6c34b09011c8543e,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_24eca4c72db0e65a6c34b09011c8543e == cache_frame_24eca4c72db0e65a6c34b09011c8543e )
    {
        Py_DECREF( frame_24eca4c72db0e65a6c34b09011c8543e );
    }
    cache_frame_24eca4c72db0e65a6c34b09011c8543e = NULL;

    assertFrameObject( frame_24eca4c72db0e65a6c34b09011c8543e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_93___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_93___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_94___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_a902b9ea7d61e52337a09f3bba2dcc2f = NULL;

    struct Nuitka_FrameObject *frame_a902b9ea7d61e52337a09f3bba2dcc2f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a902b9ea7d61e52337a09f3bba2dcc2f, codeobj_a902b9ea7d61e52337a09f3bba2dcc2f, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_a902b9ea7d61e52337a09f3bba2dcc2f = cache_frame_a902b9ea7d61e52337a09f3bba2dcc2f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a902b9ea7d61e52337a09f3bba2dcc2f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a902b9ea7d61e52337a09f3bba2dcc2f ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 876;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 876;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a902b9ea7d61e52337a09f3bba2dcc2f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a902b9ea7d61e52337a09f3bba2dcc2f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a902b9ea7d61e52337a09f3bba2dcc2f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a902b9ea7d61e52337a09f3bba2dcc2f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a902b9ea7d61e52337a09f3bba2dcc2f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a902b9ea7d61e52337a09f3bba2dcc2f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a902b9ea7d61e52337a09f3bba2dcc2f,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_a902b9ea7d61e52337a09f3bba2dcc2f == cache_frame_a902b9ea7d61e52337a09f3bba2dcc2f )
    {
        Py_DECREF( frame_a902b9ea7d61e52337a09f3bba2dcc2f );
    }
    cache_frame_a902b9ea7d61e52337a09f3bba2dcc2f = NULL;

    assertFrameObject( frame_a902b9ea7d61e52337a09f3bba2dcc2f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_94___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_94___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_95___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_8fb9d15244005ec133e79705c05a61d3 = NULL;

    struct Nuitka_FrameObject *frame_8fb9d15244005ec133e79705c05a61d3;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8fb9d15244005ec133e79705c05a61d3, codeobj_8fb9d15244005ec133e79705c05a61d3, module_cryptography$x509$extensions, sizeof(void *) );
    frame_8fb9d15244005ec133e79705c05a61d3 = cache_frame_8fb9d15244005ec133e79705c05a61d3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8fb9d15244005ec133e79705c05a61d3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8fb9d15244005ec133e79705c05a61d3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_hash_arg_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OCSPNoCheck );

    if (unlikely( tmp_hash_arg_1 == NULL ))
    {
        tmp_hash_arg_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OCSPNoCheck );
    }

    if ( tmp_hash_arg_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "OCSPNoCheck" );
        exception_tb = NULL;

        exception_lineno = 879;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 879;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8fb9d15244005ec133e79705c05a61d3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8fb9d15244005ec133e79705c05a61d3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8fb9d15244005ec133e79705c05a61d3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8fb9d15244005ec133e79705c05a61d3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8fb9d15244005ec133e79705c05a61d3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8fb9d15244005ec133e79705c05a61d3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8fb9d15244005ec133e79705c05a61d3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8fb9d15244005ec133e79705c05a61d3 == cache_frame_8fb9d15244005ec133e79705c05a61d3 )
    {
        Py_DECREF( frame_8fb9d15244005ec133e79705c05a61d3 );
    }
    cache_frame_8fb9d15244005ec133e79705c05a61d3 = NULL;

    assertFrameObject( frame_8fb9d15244005ec133e79705c05a61d3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_95___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_95___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_96___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = const_str_digest_d9e548ca3e36faa8011f3a82a40a2310;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_96___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_96___repr__ );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_97___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_48635dd8a2061be9a32ee8f29fed87cb = NULL;

    struct Nuitka_FrameObject *frame_48635dd8a2061be9a32ee8f29fed87cb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_48635dd8a2061be9a32ee8f29fed87cb, codeobj_48635dd8a2061be9a32ee8f29fed87cb, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_48635dd8a2061be9a32ee8f29fed87cb = cache_frame_48635dd8a2061be9a32ee8f29fed87cb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_48635dd8a2061be9a32ee8f29fed87cb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_48635dd8a2061be9a32ee8f29fed87cb ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PrecertPoison );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PrecertPoison );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PrecertPoison" );
        exception_tb = NULL;

        exception_lineno = 890;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 890;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_48635dd8a2061be9a32ee8f29fed87cb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_48635dd8a2061be9a32ee8f29fed87cb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_48635dd8a2061be9a32ee8f29fed87cb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_48635dd8a2061be9a32ee8f29fed87cb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_48635dd8a2061be9a32ee8f29fed87cb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_48635dd8a2061be9a32ee8f29fed87cb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_48635dd8a2061be9a32ee8f29fed87cb,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_48635dd8a2061be9a32ee8f29fed87cb == cache_frame_48635dd8a2061be9a32ee8f29fed87cb )
    {
        Py_DECREF( frame_48635dd8a2061be9a32ee8f29fed87cb );
    }
    cache_frame_48635dd8a2061be9a32ee8f29fed87cb = NULL;

    assertFrameObject( frame_48635dd8a2061be9a32ee8f29fed87cb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_97___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_97___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_98___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_d1ce443d1458827659a4c2d5d052464f = NULL;

    struct Nuitka_FrameObject *frame_d1ce443d1458827659a4c2d5d052464f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d1ce443d1458827659a4c2d5d052464f, codeobj_d1ce443d1458827659a4c2d5d052464f, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_d1ce443d1458827659a4c2d5d052464f = cache_frame_d1ce443d1458827659a4c2d5d052464f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d1ce443d1458827659a4c2d5d052464f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d1ce443d1458827659a4c2d5d052464f ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 896;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 896;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d1ce443d1458827659a4c2d5d052464f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d1ce443d1458827659a4c2d5d052464f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d1ce443d1458827659a4c2d5d052464f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d1ce443d1458827659a4c2d5d052464f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d1ce443d1458827659a4c2d5d052464f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d1ce443d1458827659a4c2d5d052464f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d1ce443d1458827659a4c2d5d052464f,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_d1ce443d1458827659a4c2d5d052464f == cache_frame_d1ce443d1458827659a4c2d5d052464f )
    {
        Py_DECREF( frame_d1ce443d1458827659a4c2d5d052464f );
    }
    cache_frame_d1ce443d1458827659a4c2d5d052464f = NULL;

    assertFrameObject( frame_d1ce443d1458827659a4c2d5d052464f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_98___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_98___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_99___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_8e09650574ba24d0fac88dd7967ee8ec = NULL;

    struct Nuitka_FrameObject *frame_8e09650574ba24d0fac88dd7967ee8ec;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8e09650574ba24d0fac88dd7967ee8ec, codeobj_8e09650574ba24d0fac88dd7967ee8ec, module_cryptography$x509$extensions, sizeof(void *) );
    frame_8e09650574ba24d0fac88dd7967ee8ec = cache_frame_8e09650574ba24d0fac88dd7967ee8ec;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8e09650574ba24d0fac88dd7967ee8ec );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8e09650574ba24d0fac88dd7967ee8ec ) == 2 ); // Frame stack

    // Framed code:
    tmp_hash_arg_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PrecertPoison );

    if (unlikely( tmp_hash_arg_1 == NULL ))
    {
        tmp_hash_arg_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PrecertPoison );
    }

    if ( tmp_hash_arg_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PrecertPoison" );
        exception_tb = NULL;

        exception_lineno = 899;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 899;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8e09650574ba24d0fac88dd7967ee8ec );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8e09650574ba24d0fac88dd7967ee8ec );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8e09650574ba24d0fac88dd7967ee8ec );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8e09650574ba24d0fac88dd7967ee8ec, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8e09650574ba24d0fac88dd7967ee8ec->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8e09650574ba24d0fac88dd7967ee8ec, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8e09650574ba24d0fac88dd7967ee8ec,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8e09650574ba24d0fac88dd7967ee8ec == cache_frame_8e09650574ba24d0fac88dd7967ee8ec )
    {
        Py_DECREF( frame_8e09650574ba24d0fac88dd7967ee8ec );
    }
    cache_frame_8e09650574ba24d0fac88dd7967ee8ec = NULL;

    assertFrameObject( frame_8e09650574ba24d0fac88dd7967ee8ec );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_99___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_99___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_100___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = const_str_digest_8f0bd0cc388ffa652d2a12f682c27871;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_100___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_100___repr__ );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_101___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_features = python_pars[ 1 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_operand_name_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_bd2f597ab578a8ca34dcbdb4451318c2 = NULL;

    struct Nuitka_FrameObject *frame_bd2f597ab578a8ca34dcbdb4451318c2;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bd2f597ab578a8ca34dcbdb4451318c2, codeobj_bd2f597ab578a8ca34dcbdb4451318c2, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_bd2f597ab578a8ca34dcbdb4451318c2 = cache_frame_bd2f597ab578a8ca34dcbdb4451318c2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bd2f597ab578a8ca34dcbdb4451318c2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bd2f597ab578a8ca34dcbdb4451318c2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_list_arg_1 = par_features;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 910;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_features;
        assert( old != NULL );
        par_features = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_features;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 912;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_101___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_70f950699a834ade1711fc8de5000741,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_101___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_101___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_bd2f597ab578a8ca34dcbdb4451318c2->m_frame.f_lineno = 912;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_operand_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 912;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 912;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 913;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    tmp_len_arg_1 = par_features;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 913;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_0;
    tmp_or_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 913;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    Py_INCREF( tmp_or_left_value_1 );
    tmp_cond_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 913;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_908210834a8fb4c8eaca7a64e23a4bed;
    frame_bd2f597ab578a8ca34dcbdb4451318c2->m_frame.f_lineno = 915;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 915;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_features;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__features, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 920;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bd2f597ab578a8ca34dcbdb4451318c2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bd2f597ab578a8ca34dcbdb4451318c2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bd2f597ab578a8ca34dcbdb4451318c2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bd2f597ab578a8ca34dcbdb4451318c2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bd2f597ab578a8ca34dcbdb4451318c2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bd2f597ab578a8ca34dcbdb4451318c2,
        type_description_1,
        par_self,
        par_features
    );


    // Release cached frame.
    if ( frame_bd2f597ab578a8ca34dcbdb4451318c2 == cache_frame_bd2f597ab578a8ca34dcbdb4451318c2 )
    {
        Py_DECREF( frame_bd2f597ab578a8ca34dcbdb4451318c2 );
    }
    cache_frame_bd2f597ab578a8ca34dcbdb4451318c2 = NULL;

    assertFrameObject( frame_bd2f597ab578a8ca34dcbdb4451318c2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_101___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_features );
    Py_DECREF( par_features );
    par_features = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_features );
    Py_DECREF( par_features );
    par_features = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_101___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_101___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_101___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_101___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_70f950699a834ade1711fc8de5000741, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 912;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 912;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_TLSFeatureType );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSFeatureType );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "TLSFeatureType" );
        exception_tb = NULL;

        exception_lineno = 912;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 912;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 912;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 912;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_102___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_9577bd5f33b7ffea2ef89eff32e0a9cf = NULL;

    struct Nuitka_FrameObject *frame_9577bd5f33b7ffea2ef89eff32e0a9cf;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9577bd5f33b7ffea2ef89eff32e0a9cf, codeobj_9577bd5f33b7ffea2ef89eff32e0a9cf, module_cryptography$x509$extensions, sizeof(void *) );
    frame_9577bd5f33b7ffea2ef89eff32e0a9cf = cache_frame_9577bd5f33b7ffea2ef89eff32e0a9cf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9577bd5f33b7ffea2ef89eff32e0a9cf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9577bd5f33b7ffea2ef89eff32e0a9cf ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_f68da15c98dbc7b7660e8e5bee0179e6;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_9577bd5f33b7ffea2ef89eff32e0a9cf->m_frame.f_lineno = 925;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 925;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9577bd5f33b7ffea2ef89eff32e0a9cf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9577bd5f33b7ffea2ef89eff32e0a9cf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9577bd5f33b7ffea2ef89eff32e0a9cf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9577bd5f33b7ffea2ef89eff32e0a9cf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9577bd5f33b7ffea2ef89eff32e0a9cf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9577bd5f33b7ffea2ef89eff32e0a9cf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9577bd5f33b7ffea2ef89eff32e0a9cf,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_9577bd5f33b7ffea2ef89eff32e0a9cf == cache_frame_9577bd5f33b7ffea2ef89eff32e0a9cf )
    {
        Py_DECREF( frame_9577bd5f33b7ffea2ef89eff32e0a9cf );
    }
    cache_frame_9577bd5f33b7ffea2ef89eff32e0a9cf = NULL;

    assertFrameObject( frame_9577bd5f33b7ffea2ef89eff32e0a9cf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_102___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_102___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_103___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_269cb9bd17342eadc310b70cb566e7ca = NULL;

    struct Nuitka_FrameObject *frame_269cb9bd17342eadc310b70cb566e7ca;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_269cb9bd17342eadc310b70cb566e7ca, codeobj_269cb9bd17342eadc310b70cb566e7ca, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_269cb9bd17342eadc310b70cb566e7ca = cache_frame_269cb9bd17342eadc310b70cb566e7ca;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_269cb9bd17342eadc310b70cb566e7ca );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_269cb9bd17342eadc310b70cb566e7ca ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_TLSFeature );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSFeature );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "TLSFeature" );
        exception_tb = NULL;

        exception_lineno = 928;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 928;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__features );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 931;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__features );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 931;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 931;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_269cb9bd17342eadc310b70cb566e7ca );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_269cb9bd17342eadc310b70cb566e7ca );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_269cb9bd17342eadc310b70cb566e7ca );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_269cb9bd17342eadc310b70cb566e7ca, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_269cb9bd17342eadc310b70cb566e7ca->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_269cb9bd17342eadc310b70cb566e7ca, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_269cb9bd17342eadc310b70cb566e7ca,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_269cb9bd17342eadc310b70cb566e7ca == cache_frame_269cb9bd17342eadc310b70cb566e7ca )
    {
        Py_DECREF( frame_269cb9bd17342eadc310b70cb566e7ca );
    }
    cache_frame_269cb9bd17342eadc310b70cb566e7ca = NULL;

    assertFrameObject( frame_269cb9bd17342eadc310b70cb566e7ca );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_103___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_103___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_104___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_207c446b384b5fff7b758b710ebcd306 = NULL;

    struct Nuitka_FrameObject *frame_207c446b384b5fff7b758b710ebcd306;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_207c446b384b5fff7b758b710ebcd306, codeobj_207c446b384b5fff7b758b710ebcd306, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_207c446b384b5fff7b758b710ebcd306 = cache_frame_207c446b384b5fff7b758b710ebcd306;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_207c446b384b5fff7b758b710ebcd306 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_207c446b384b5fff7b758b710ebcd306 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 934;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 934;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_207c446b384b5fff7b758b710ebcd306 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_207c446b384b5fff7b758b710ebcd306 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_207c446b384b5fff7b758b710ebcd306 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_207c446b384b5fff7b758b710ebcd306, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_207c446b384b5fff7b758b710ebcd306->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_207c446b384b5fff7b758b710ebcd306, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_207c446b384b5fff7b758b710ebcd306,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_207c446b384b5fff7b758b710ebcd306 == cache_frame_207c446b384b5fff7b758b710ebcd306 )
    {
        Py_DECREF( frame_207c446b384b5fff7b758b710ebcd306 );
    }
    cache_frame_207c446b384b5fff7b758b710ebcd306 = NULL;

    assertFrameObject( frame_207c446b384b5fff7b758b710ebcd306 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_104___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_104___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_105___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_arg_1;
    static struct Nuitka_FrameObject *cache_frame_d34b80df37edbf7f7bad1484045d4000 = NULL;

    struct Nuitka_FrameObject *frame_d34b80df37edbf7f7bad1484045d4000;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d34b80df37edbf7f7bad1484045d4000, codeobj_d34b80df37edbf7f7bad1484045d4000, module_cryptography$x509$extensions, sizeof(void *) );
    frame_d34b80df37edbf7f7bad1484045d4000 = cache_frame_d34b80df37edbf7f7bad1484045d4000;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d34b80df37edbf7f7bad1484045d4000 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d34b80df37edbf7f7bad1484045d4000 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__features );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 937;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_hash_arg_1 = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 937;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 937;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d34b80df37edbf7f7bad1484045d4000 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d34b80df37edbf7f7bad1484045d4000 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d34b80df37edbf7f7bad1484045d4000 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d34b80df37edbf7f7bad1484045d4000, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d34b80df37edbf7f7bad1484045d4000->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d34b80df37edbf7f7bad1484045d4000, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d34b80df37edbf7f7bad1484045d4000,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d34b80df37edbf7f7bad1484045d4000 == cache_frame_d34b80df37edbf7f7bad1484045d4000 )
    {
        Py_DECREF( frame_d34b80df37edbf7f7bad1484045d4000 );
    }
    cache_frame_d34b80df37edbf7f7bad1484045d4000 = NULL;

    assertFrameObject( frame_d34b80df37edbf7f7bad1484045d4000 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_105___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_105___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_e3704f3371b37ff098d623844cfbee1e, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 951;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 951;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_expression_name_1 = PyTuple_New( 2 );
    tmp_source_name_1 = var_x;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_value );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_1 );

        exception_lineno = 951;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_expression_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_x;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_expression_name_1, 1, tmp_tuple_element_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 951;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 951;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_106___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_skip_certs = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    int tmp_cmp_Lt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_5979b7dcae0cb17ab58172bc693ecfcc = NULL;

    struct Nuitka_FrameObject *frame_5979b7dcae0cb17ab58172bc693ecfcc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5979b7dcae0cb17ab58172bc693ecfcc, codeobj_5979b7dcae0cb17ab58172bc693ecfcc, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_5979b7dcae0cb17ab58172bc693ecfcc = cache_frame_5979b7dcae0cb17ab58172bc693ecfcc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5979b7dcae0cb17ab58172bc693ecfcc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5979b7dcae0cb17ab58172bc693ecfcc ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_skip_certs;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_six );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "six" );
        exception_tb = NULL;

        exception_lineno = 959;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_integer_types );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 959;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 959;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_e796fffc6f5e8d4c3d564875b854a9ed;
    frame_5979b7dcae0cb17ab58172bc693ecfcc->m_frame.f_lineno = 960;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 960;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_compare_left_1 = par_skip_certs;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_Lt_1 = RICH_COMPARE_BOOL_LT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Lt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 962;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Lt_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_87fc424e9112e6987e5fe8e83a94ae22;
    frame_5979b7dcae0cb17ab58172bc693ecfcc->m_frame.f_lineno = 963;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 963;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_assattr_name_1 = par_skip_certs;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__skip_certs, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 965;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5979b7dcae0cb17ab58172bc693ecfcc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5979b7dcae0cb17ab58172bc693ecfcc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5979b7dcae0cb17ab58172bc693ecfcc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5979b7dcae0cb17ab58172bc693ecfcc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5979b7dcae0cb17ab58172bc693ecfcc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5979b7dcae0cb17ab58172bc693ecfcc,
        type_description_1,
        par_self,
        par_skip_certs
    );


    // Release cached frame.
    if ( frame_5979b7dcae0cb17ab58172bc693ecfcc == cache_frame_5979b7dcae0cb17ab58172bc693ecfcc )
    {
        Py_DECREF( frame_5979b7dcae0cb17ab58172bc693ecfcc );
    }
    cache_frame_5979b7dcae0cb17ab58172bc693ecfcc = NULL;

    assertFrameObject( frame_5979b7dcae0cb17ab58172bc693ecfcc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_106___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_skip_certs );
    Py_DECREF( par_skip_certs );
    par_skip_certs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_skip_certs );
    Py_DECREF( par_skip_certs );
    par_skip_certs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_106___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_107___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_b664d78d6ebdc07d97666d986b9e557d = NULL;

    struct Nuitka_FrameObject *frame_b664d78d6ebdc07d97666d986b9e557d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b664d78d6ebdc07d97666d986b9e557d, codeobj_b664d78d6ebdc07d97666d986b9e557d, module_cryptography$x509$extensions, sizeof(void *) );
    frame_b664d78d6ebdc07d97666d986b9e557d = cache_frame_b664d78d6ebdc07d97666d986b9e557d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b664d78d6ebdc07d97666d986b9e557d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b664d78d6ebdc07d97666d986b9e557d ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_2a63548c17bc773344f27e5819855b7b;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_b664d78d6ebdc07d97666d986b9e557d->m_frame.f_lineno = 968;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b664d78d6ebdc07d97666d986b9e557d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b664d78d6ebdc07d97666d986b9e557d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b664d78d6ebdc07d97666d986b9e557d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b664d78d6ebdc07d97666d986b9e557d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b664d78d6ebdc07d97666d986b9e557d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b664d78d6ebdc07d97666d986b9e557d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b664d78d6ebdc07d97666d986b9e557d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b664d78d6ebdc07d97666d986b9e557d == cache_frame_b664d78d6ebdc07d97666d986b9e557d )
    {
        Py_DECREF( frame_b664d78d6ebdc07d97666d986b9e557d );
    }
    cache_frame_b664d78d6ebdc07d97666d986b9e557d = NULL;

    assertFrameObject( frame_b664d78d6ebdc07d97666d986b9e557d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_107___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_107___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_108___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_b9a64eab02561c7ba59bd763bc6ee1b4 = NULL;

    struct Nuitka_FrameObject *frame_b9a64eab02561c7ba59bd763bc6ee1b4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b9a64eab02561c7ba59bd763bc6ee1b4, codeobj_b9a64eab02561c7ba59bd763bc6ee1b4, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_b9a64eab02561c7ba59bd763bc6ee1b4 = cache_frame_b9a64eab02561c7ba59bd763bc6ee1b4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b9a64eab02561c7ba59bd763bc6ee1b4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b9a64eab02561c7ba59bd763bc6ee1b4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_InhibitAnyPolicy );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_InhibitAnyPolicy );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "InhibitAnyPolicy" );
        exception_tb = NULL;

        exception_lineno = 971;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 971;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_skip_certs );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 974;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_skip_certs );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 974;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 974;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b9a64eab02561c7ba59bd763bc6ee1b4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b9a64eab02561c7ba59bd763bc6ee1b4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b9a64eab02561c7ba59bd763bc6ee1b4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b9a64eab02561c7ba59bd763bc6ee1b4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b9a64eab02561c7ba59bd763bc6ee1b4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b9a64eab02561c7ba59bd763bc6ee1b4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b9a64eab02561c7ba59bd763bc6ee1b4,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_b9a64eab02561c7ba59bd763bc6ee1b4 == cache_frame_b9a64eab02561c7ba59bd763bc6ee1b4 )
    {
        Py_DECREF( frame_b9a64eab02561c7ba59bd763bc6ee1b4 );
    }
    cache_frame_b9a64eab02561c7ba59bd763bc6ee1b4 = NULL;

    assertFrameObject( frame_b9a64eab02561c7ba59bd763bc6ee1b4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_108___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_108___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_109___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_4b0d9409191589b3b8889a0e1a8beb39 = NULL;

    struct Nuitka_FrameObject *frame_4b0d9409191589b3b8889a0e1a8beb39;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4b0d9409191589b3b8889a0e1a8beb39, codeobj_4b0d9409191589b3b8889a0e1a8beb39, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_4b0d9409191589b3b8889a0e1a8beb39 = cache_frame_4b0d9409191589b3b8889a0e1a8beb39;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4b0d9409191589b3b8889a0e1a8beb39 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4b0d9409191589b3b8889a0e1a8beb39 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 977;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 977;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4b0d9409191589b3b8889a0e1a8beb39 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4b0d9409191589b3b8889a0e1a8beb39 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4b0d9409191589b3b8889a0e1a8beb39 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4b0d9409191589b3b8889a0e1a8beb39, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4b0d9409191589b3b8889a0e1a8beb39->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4b0d9409191589b3b8889a0e1a8beb39, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4b0d9409191589b3b8889a0e1a8beb39,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_4b0d9409191589b3b8889a0e1a8beb39 == cache_frame_4b0d9409191589b3b8889a0e1a8beb39 )
    {
        Py_DECREF( frame_4b0d9409191589b3b8889a0e1a8beb39 );
    }
    cache_frame_4b0d9409191589b3b8889a0e1a8beb39 = NULL;

    assertFrameObject( frame_4b0d9409191589b3b8889a0e1a8beb39 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_109___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_109___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_110___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_245ca46202f093d6d661d0cc31b2f7cc = NULL;

    struct Nuitka_FrameObject *frame_245ca46202f093d6d661d0cc31b2f7cc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_245ca46202f093d6d661d0cc31b2f7cc, codeobj_245ca46202f093d6d661d0cc31b2f7cc, module_cryptography$x509$extensions, sizeof(void *) );
    frame_245ca46202f093d6d661d0cc31b2f7cc = cache_frame_245ca46202f093d6d661d0cc31b2f7cc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_245ca46202f093d6d661d0cc31b2f7cc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_245ca46202f093d6d661d0cc31b2f7cc ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_hash_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_skip_certs );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 980;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 980;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_245ca46202f093d6d661d0cc31b2f7cc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_245ca46202f093d6d661d0cc31b2f7cc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_245ca46202f093d6d661d0cc31b2f7cc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_245ca46202f093d6d661d0cc31b2f7cc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_245ca46202f093d6d661d0cc31b2f7cc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_245ca46202f093d6d661d0cc31b2f7cc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_245ca46202f093d6d661d0cc31b2f7cc,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_245ca46202f093d6d661d0cc31b2f7cc == cache_frame_245ca46202f093d6d661d0cc31b2f7cc )
    {
        Py_DECREF( frame_245ca46202f093d6d661d0cc31b2f7cc );
    }
    cache_frame_245ca46202f093d6d661d0cc31b2f7cc = NULL;

    assertFrameObject( frame_245ca46202f093d6d661d0cc31b2f7cc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_110___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_110___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_111___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_digital_signature = python_pars[ 1 ];
    PyObject *par_content_commitment = python_pars[ 2 ];
    PyObject *par_key_encipherment = python_pars[ 3 ];
    PyObject *par_data_encipherment = python_pars[ 4 ];
    PyObject *par_key_agreement = python_pars[ 5 ];
    PyObject *par_key_cert_sign = python_pars[ 6 ];
    PyObject *par_crl_sign = python_pars[ 7 ];
    PyObject *par_encipher_only = python_pars[ 8 ];
    PyObject *par_decipher_only = python_pars[ 9 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_name_5;
    PyObject *tmp_assattr_name_6;
    PyObject *tmp_assattr_name_7;
    PyObject *tmp_assattr_name_8;
    PyObject *tmp_assattr_name_9;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assattr_target_5;
    PyObject *tmp_assattr_target_6;
    PyObject *tmp_assattr_target_7;
    PyObject *tmp_assattr_target_8;
    PyObject *tmp_assattr_target_9;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_operand_name_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_797af5f1fd77e5cc555a75349b5fe3c0 = NULL;

    struct Nuitka_FrameObject *frame_797af5f1fd77e5cc555a75349b5fe3c0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_797af5f1fd77e5cc555a75349b5fe3c0, codeobj_797af5f1fd77e5cc555a75349b5fe3c0, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_797af5f1fd77e5cc555a75349b5fe3c0 = cache_frame_797af5f1fd77e5cc555a75349b5fe3c0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_797af5f1fd77e5cc555a75349b5fe3c0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_797af5f1fd77e5cc555a75349b5fe3c0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_operand_name_1 = par_key_agreement;

    CHECK_OBJECT( tmp_operand_name_1 );
    tmp_and_left_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 992;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 992;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_or_left_value_1 = par_encipher_only;

    CHECK_OBJECT( tmp_or_left_value_1 );
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 992;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    tmp_or_right_value_1 = par_decipher_only;

    CHECK_OBJECT( tmp_or_right_value_1 );
    tmp_and_right_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_and_right_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 992;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_1695020c9fca9629cae2bba3b13ed98d;
    frame_797af5f1fd77e5cc555a75349b5fe3c0->m_frame.f_lineno = 993;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 993;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_digital_signature;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__digital_signature, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 998;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_content_commitment;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__content_commitment, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 999;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = par_key_encipherment;

    CHECK_OBJECT( tmp_assattr_name_3 );
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__key_encipherment, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1000;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_4 = par_data_encipherment;

    CHECK_OBJECT( tmp_assattr_name_4 );
    tmp_assattr_target_4 = par_self;

    CHECK_OBJECT( tmp_assattr_target_4 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__data_encipherment, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1001;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_5 = par_key_agreement;

    CHECK_OBJECT( tmp_assattr_name_5 );
    tmp_assattr_target_5 = par_self;

    CHECK_OBJECT( tmp_assattr_target_5 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain__key_agreement, tmp_assattr_name_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1002;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_6 = par_key_cert_sign;

    CHECK_OBJECT( tmp_assattr_name_6 );
    tmp_assattr_target_6 = par_self;

    CHECK_OBJECT( tmp_assattr_target_6 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain__key_cert_sign, tmp_assattr_name_6 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1003;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_7 = par_crl_sign;

    CHECK_OBJECT( tmp_assattr_name_7 );
    tmp_assattr_target_7 = par_self;

    CHECK_OBJECT( tmp_assattr_target_7 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain__crl_sign, tmp_assattr_name_7 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1004;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_8 = par_encipher_only;

    CHECK_OBJECT( tmp_assattr_name_8 );
    tmp_assattr_target_8 = par_self;

    CHECK_OBJECT( tmp_assattr_target_8 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain__encipher_only, tmp_assattr_name_8 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1005;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_9 = par_decipher_only;

    CHECK_OBJECT( tmp_assattr_name_9 );
    tmp_assattr_target_9 = par_self;

    CHECK_OBJECT( tmp_assattr_target_9 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain__decipher_only, tmp_assattr_name_9 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1006;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_797af5f1fd77e5cc555a75349b5fe3c0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_797af5f1fd77e5cc555a75349b5fe3c0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_797af5f1fd77e5cc555a75349b5fe3c0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_797af5f1fd77e5cc555a75349b5fe3c0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_797af5f1fd77e5cc555a75349b5fe3c0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_797af5f1fd77e5cc555a75349b5fe3c0,
        type_description_1,
        par_self,
        par_digital_signature,
        par_content_commitment,
        par_key_encipherment,
        par_data_encipherment,
        par_key_agreement,
        par_key_cert_sign,
        par_crl_sign,
        par_encipher_only,
        par_decipher_only
    );


    // Release cached frame.
    if ( frame_797af5f1fd77e5cc555a75349b5fe3c0 == cache_frame_797af5f1fd77e5cc555a75349b5fe3c0 )
    {
        Py_DECREF( frame_797af5f1fd77e5cc555a75349b5fe3c0 );
    }
    cache_frame_797af5f1fd77e5cc555a75349b5fe3c0 = NULL;

    assertFrameObject( frame_797af5f1fd77e5cc555a75349b5fe3c0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_111___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_crl_sign );
    Py_DECREF( par_crl_sign );
    par_crl_sign = NULL;

    CHECK_OBJECT( (PyObject *)par_key_encipherment );
    Py_DECREF( par_key_encipherment );
    par_key_encipherment = NULL;

    CHECK_OBJECT( (PyObject *)par_digital_signature );
    Py_DECREF( par_digital_signature );
    par_digital_signature = NULL;

    CHECK_OBJECT( (PyObject *)par_decipher_only );
    Py_DECREF( par_decipher_only );
    par_decipher_only = NULL;

    CHECK_OBJECT( (PyObject *)par_key_agreement );
    Py_DECREF( par_key_agreement );
    par_key_agreement = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_encipher_only );
    Py_DECREF( par_encipher_only );
    par_encipher_only = NULL;

    CHECK_OBJECT( (PyObject *)par_content_commitment );
    Py_DECREF( par_content_commitment );
    par_content_commitment = NULL;

    CHECK_OBJECT( (PyObject *)par_key_cert_sign );
    Py_DECREF( par_key_cert_sign );
    par_key_cert_sign = NULL;

    CHECK_OBJECT( (PyObject *)par_data_encipherment );
    Py_DECREF( par_data_encipherment );
    par_data_encipherment = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_crl_sign );
    Py_DECREF( par_crl_sign );
    par_crl_sign = NULL;

    CHECK_OBJECT( (PyObject *)par_key_encipherment );
    Py_DECREF( par_key_encipherment );
    par_key_encipherment = NULL;

    CHECK_OBJECT( (PyObject *)par_digital_signature );
    Py_DECREF( par_digital_signature );
    par_digital_signature = NULL;

    CHECK_OBJECT( (PyObject *)par_decipher_only );
    Py_DECREF( par_decipher_only );
    par_decipher_only = NULL;

    CHECK_OBJECT( (PyObject *)par_key_agreement );
    Py_DECREF( par_key_agreement );
    par_key_agreement = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_encipher_only );
    Py_DECREF( par_encipher_only );
    par_encipher_only = NULL;

    CHECK_OBJECT( (PyObject *)par_content_commitment );
    Py_DECREF( par_content_commitment );
    par_content_commitment = NULL;

    CHECK_OBJECT( (PyObject *)par_key_cert_sign );
    Py_DECREF( par_key_cert_sign );
    par_key_cert_sign = NULL;

    CHECK_OBJECT( (PyObject *)par_data_encipherment );
    Py_DECREF( par_data_encipherment );
    par_data_encipherment = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_111___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_112_encipher_only( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_8d7d29dbad9addbf58f92f1a4bc533d0 = NULL;

    struct Nuitka_FrameObject *frame_8d7d29dbad9addbf58f92f1a4bc533d0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8d7d29dbad9addbf58f92f1a4bc533d0, codeobj_8d7d29dbad9addbf58f92f1a4bc533d0, module_cryptography$x509$extensions, sizeof(void *) );
    frame_8d7d29dbad9addbf58f92f1a4bc533d0 = cache_frame_8d7d29dbad9addbf58f92f1a4bc533d0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8d7d29dbad9addbf58f92f1a4bc533d0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8d7d29dbad9addbf58f92f1a4bc533d0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_key_agreement );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1018;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1018;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_fdf88dfad66dd7b1bb721469f9f06736;
    frame_8d7d29dbad9addbf58f92f1a4bc533d0->m_frame.f_lineno = 1019;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1019;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "o";
    goto frame_exception_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__encipher_only );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1023;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8d7d29dbad9addbf58f92f1a4bc533d0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8d7d29dbad9addbf58f92f1a4bc533d0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8d7d29dbad9addbf58f92f1a4bc533d0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8d7d29dbad9addbf58f92f1a4bc533d0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8d7d29dbad9addbf58f92f1a4bc533d0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8d7d29dbad9addbf58f92f1a4bc533d0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8d7d29dbad9addbf58f92f1a4bc533d0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8d7d29dbad9addbf58f92f1a4bc533d0 == cache_frame_8d7d29dbad9addbf58f92f1a4bc533d0 )
    {
        Py_DECREF( frame_8d7d29dbad9addbf58f92f1a4bc533d0 );
    }
    cache_frame_8d7d29dbad9addbf58f92f1a4bc533d0 = NULL;

    assertFrameObject( frame_8d7d29dbad9addbf58f92f1a4bc533d0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_112_encipher_only );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_112_encipher_only );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_113_decipher_only( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_6cf8b2c589661b0ba098edf538ce526d = NULL;

    struct Nuitka_FrameObject *frame_6cf8b2c589661b0ba098edf538ce526d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6cf8b2c589661b0ba098edf538ce526d, codeobj_6cf8b2c589661b0ba098edf538ce526d, module_cryptography$x509$extensions, sizeof(void *) );
    frame_6cf8b2c589661b0ba098edf538ce526d = cache_frame_6cf8b2c589661b0ba098edf538ce526d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6cf8b2c589661b0ba098edf538ce526d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6cf8b2c589661b0ba098edf538ce526d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_key_agreement );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1027;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1027;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_a173082fd91f8794530005b1589bf6b2;
    frame_6cf8b2c589661b0ba098edf538ce526d->m_frame.f_lineno = 1028;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1028;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "o";
    goto frame_exception_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__decipher_only );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1032;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6cf8b2c589661b0ba098edf538ce526d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6cf8b2c589661b0ba098edf538ce526d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6cf8b2c589661b0ba098edf538ce526d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6cf8b2c589661b0ba098edf538ce526d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6cf8b2c589661b0ba098edf538ce526d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6cf8b2c589661b0ba098edf538ce526d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6cf8b2c589661b0ba098edf538ce526d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6cf8b2c589661b0ba098edf538ce526d == cache_frame_6cf8b2c589661b0ba098edf538ce526d )
    {
        Py_DECREF( frame_6cf8b2c589661b0ba098edf538ce526d );
    }
    cache_frame_6cf8b2c589661b0ba098edf538ce526d = NULL;

    assertFrameObject( frame_6cf8b2c589661b0ba098edf538ce526d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_113_decipher_only );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_113_decipher_only );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_114___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_encipher_only = NULL;
    PyObject *var_decipher_only = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_a0f103b7065a35f97f5a35b2994585aa = NULL;

    struct Nuitka_FrameObject *frame_a0f103b7065a35f97f5a35b2994585aa;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a0f103b7065a35f97f5a35b2994585aa, codeobj_a0f103b7065a35f97f5a35b2994585aa, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a0f103b7065a35f97f5a35b2994585aa = cache_frame_a0f103b7065a35f97f5a35b2994585aa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a0f103b7065a35f97f5a35b2994585aa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a0f103b7065a35f97f5a35b2994585aa ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_encipher_only );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1036;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    assert( var_encipher_only == NULL );
    var_encipher_only = tmp_assign_source_1;

    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_decipher_only );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1037;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    assert( var_decipher_only == NULL );
    var_decipher_only = tmp_assign_source_2;

    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_a0f103b7065a35f97f5a35b2994585aa );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_a0f103b7065a35f97f5a35b2994585aa, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_a0f103b7065a35f97f5a35b2994585aa, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = PyExc_ValueError;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1038;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_3 = Py_None;
    {
        PyObject *old = var_encipher_only;
        var_encipher_only = tmp_assign_source_3;
        Py_INCREF( var_encipher_only );
        Py_XDECREF( old );
    }

    tmp_assign_source_4 = Py_None;
    assert( var_decipher_only == NULL );
    Py_INCREF( tmp_assign_source_4 );
    var_decipher_only = tmp_assign_source_4;

    goto branch_end_1;
    branch_no_1:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 1035;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_a0f103b7065a35f97f5a35b2994585aa->m_frame) frame_a0f103b7065a35f97f5a35b2994585aa->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_end_1:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_114___repr__ );
    return NULL;
    // End of try:
    try_end_1:;
    tmp_source_name_3 = const_str_digest_c3da50fdd18d409ebf6fe1322cd35c5d;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = var_encipher_only;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "encipher_only" );
        exception_tb = NULL;

        exception_lineno = 1049;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_decipher_only;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "decipher_only" );
        exception_tb = NULL;

        exception_lineno = 1049;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_a0f103b7065a35f97f5a35b2994585aa->m_frame.f_lineno = 1042;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1042;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_a0f103b7065a35f97f5a35b2994585aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_a0f103b7065a35f97f5a35b2994585aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_a0f103b7065a35f97f5a35b2994585aa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a0f103b7065a35f97f5a35b2994585aa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a0f103b7065a35f97f5a35b2994585aa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a0f103b7065a35f97f5a35b2994585aa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a0f103b7065a35f97f5a35b2994585aa,
        type_description_1,
        par_self,
        var_encipher_only,
        var_decipher_only
    );


    // Release cached frame.
    if ( frame_a0f103b7065a35f97f5a35b2994585aa == cache_frame_a0f103b7065a35f97f5a35b2994585aa )
    {
        Py_DECREF( frame_a0f103b7065a35f97f5a35b2994585aa );
    }
    cache_frame_a0f103b7065a35f97f5a35b2994585aa = NULL;

    assertFrameObject( frame_a0f103b7065a35f97f5a35b2994585aa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_114___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_encipher_only );
    var_encipher_only = NULL;

    Py_XDECREF( var_decipher_only );
    var_decipher_only = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_encipher_only );
    var_encipher_only = NULL;

    Py_XDECREF( var_decipher_only );
    var_decipher_only = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_114___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_115___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    int tmp_and_left_truth_3;
    int tmp_and_left_truth_4;
    int tmp_and_left_truth_5;
    int tmp_and_left_truth_6;
    int tmp_and_left_truth_7;
    int tmp_and_left_truth_8;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_left_value_3;
    PyObject *tmp_and_left_value_4;
    PyObject *tmp_and_left_value_5;
    PyObject *tmp_and_left_value_6;
    PyObject *tmp_and_left_value_7;
    PyObject *tmp_and_left_value_8;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_and_right_value_3;
    PyObject *tmp_and_right_value_4;
    PyObject *tmp_and_right_value_5;
    PyObject *tmp_and_right_value_6;
    PyObject *tmp_and_right_value_7;
    PyObject *tmp_and_right_value_8;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_left_4;
    PyObject *tmp_compexpr_left_5;
    PyObject *tmp_compexpr_left_6;
    PyObject *tmp_compexpr_left_7;
    PyObject *tmp_compexpr_left_8;
    PyObject *tmp_compexpr_left_9;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    PyObject *tmp_compexpr_right_4;
    PyObject *tmp_compexpr_right_5;
    PyObject *tmp_compexpr_right_6;
    PyObject *tmp_compexpr_right_7;
    PyObject *tmp_compexpr_right_8;
    PyObject *tmp_compexpr_right_9;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    static struct Nuitka_FrameObject *cache_frame_a90aeaeb6f8a3ed1eddebdacaf29192a = NULL;

    struct Nuitka_FrameObject *frame_a90aeaeb6f8a3ed1eddebdacaf29192a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a90aeaeb6f8a3ed1eddebdacaf29192a, codeobj_a90aeaeb6f8a3ed1eddebdacaf29192a, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_a90aeaeb6f8a3ed1eddebdacaf29192a = cache_frame_a90aeaeb6f8a3ed1eddebdacaf29192a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a90aeaeb6f8a3ed1eddebdacaf29192a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a90aeaeb6f8a3ed1eddebdacaf29192a ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_KeyUsage );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_KeyUsage );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "KeyUsage" );
        exception_tb = NULL;

        exception_lineno = 1052;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1052;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_digital_signature );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1056;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_digital_signature );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1056;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1056;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 1064;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_content_commitment );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1057;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_other;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_content_commitment );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 1057;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_2 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1057;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    if ( tmp_and_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_2 );

        exception_lineno = 1064;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    Py_DECREF( tmp_and_left_value_2 );
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_key_encipherment );
    if ( tmp_compexpr_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1058;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_other;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_key_encipherment );
    if ( tmp_compexpr_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_3 );

        exception_lineno = 1058;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_3 = RICH_COMPARE_EQ( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    Py_DECREF( tmp_compexpr_left_3 );
    Py_DECREF( tmp_compexpr_right_3 );
    if ( tmp_and_left_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1058;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_3 = CHECK_IF_TRUE( tmp_and_left_value_3 );
    if ( tmp_and_left_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_3 );

        exception_lineno = 1064;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_3 == 1 )
    {
        goto and_right_3;
    }
    else
    {
        goto and_left_3;
    }
    and_right_3:;
    Py_DECREF( tmp_and_left_value_3 );
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_data_encipherment );
    if ( tmp_compexpr_left_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1059;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = par_other;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_data_encipherment );
    if ( tmp_compexpr_right_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_4 );

        exception_lineno = 1059;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_4 = RICH_COMPARE_EQ( tmp_compexpr_left_4, tmp_compexpr_right_4 );
    Py_DECREF( tmp_compexpr_left_4 );
    Py_DECREF( tmp_compexpr_right_4 );
    if ( tmp_and_left_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1059;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_4 = CHECK_IF_TRUE( tmp_and_left_value_4 );
    if ( tmp_and_left_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_4 );

        exception_lineno = 1064;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_4 == 1 )
    {
        goto and_right_4;
    }
    else
    {
        goto and_left_4;
    }
    and_right_4:;
    Py_DECREF( tmp_and_left_value_4 );
    tmp_source_name_9 = par_self;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_key_agreement );
    if ( tmp_compexpr_left_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1060;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_10 = par_other;

    CHECK_OBJECT( tmp_source_name_10 );
    tmp_compexpr_right_5 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_key_agreement );
    if ( tmp_compexpr_right_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_5 );

        exception_lineno = 1060;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_5 = RICH_COMPARE_EQ( tmp_compexpr_left_5, tmp_compexpr_right_5 );
    Py_DECREF( tmp_compexpr_left_5 );
    Py_DECREF( tmp_compexpr_right_5 );
    if ( tmp_and_left_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1060;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_5 = CHECK_IF_TRUE( tmp_and_left_value_5 );
    if ( tmp_and_left_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_5 );

        exception_lineno = 1064;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_5 == 1 )
    {
        goto and_right_5;
    }
    else
    {
        goto and_left_5;
    }
    and_right_5:;
    Py_DECREF( tmp_and_left_value_5 );
    tmp_source_name_11 = par_self;

    CHECK_OBJECT( tmp_source_name_11 );
    tmp_compexpr_left_6 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_key_cert_sign );
    if ( tmp_compexpr_left_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1061;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_12 = par_other;

    CHECK_OBJECT( tmp_source_name_12 );
    tmp_compexpr_right_6 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_key_cert_sign );
    if ( tmp_compexpr_right_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_6 );

        exception_lineno = 1061;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_6 = RICH_COMPARE_EQ( tmp_compexpr_left_6, tmp_compexpr_right_6 );
    Py_DECREF( tmp_compexpr_left_6 );
    Py_DECREF( tmp_compexpr_right_6 );
    if ( tmp_and_left_value_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1061;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_6 = CHECK_IF_TRUE( tmp_and_left_value_6 );
    if ( tmp_and_left_truth_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_6 );

        exception_lineno = 1064;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_6 == 1 )
    {
        goto and_right_6;
    }
    else
    {
        goto and_left_6;
    }
    and_right_6:;
    Py_DECREF( tmp_and_left_value_6 );
    tmp_source_name_13 = par_self;

    CHECK_OBJECT( tmp_source_name_13 );
    tmp_compexpr_left_7 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_crl_sign );
    if ( tmp_compexpr_left_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1062;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_14 = par_other;

    CHECK_OBJECT( tmp_source_name_14 );
    tmp_compexpr_right_7 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_crl_sign );
    if ( tmp_compexpr_right_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_7 );

        exception_lineno = 1062;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_7 = RICH_COMPARE_EQ( tmp_compexpr_left_7, tmp_compexpr_right_7 );
    Py_DECREF( tmp_compexpr_left_7 );
    Py_DECREF( tmp_compexpr_right_7 );
    if ( tmp_and_left_value_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1062;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_7 = CHECK_IF_TRUE( tmp_and_left_value_7 );
    if ( tmp_and_left_truth_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_7 );

        exception_lineno = 1064;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_7 == 1 )
    {
        goto and_right_7;
    }
    else
    {
        goto and_left_7;
    }
    and_right_7:;
    Py_DECREF( tmp_and_left_value_7 );
    tmp_source_name_15 = par_self;

    CHECK_OBJECT( tmp_source_name_15 );
    tmp_compexpr_left_8 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain__encipher_only );
    if ( tmp_compexpr_left_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1063;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_16 = par_other;

    CHECK_OBJECT( tmp_source_name_16 );
    tmp_compexpr_right_8 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain__encipher_only );
    if ( tmp_compexpr_right_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_8 );

        exception_lineno = 1063;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_8 = RICH_COMPARE_EQ( tmp_compexpr_left_8, tmp_compexpr_right_8 );
    Py_DECREF( tmp_compexpr_left_8 );
    Py_DECREF( tmp_compexpr_right_8 );
    if ( tmp_and_left_value_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1063;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_8 = CHECK_IF_TRUE( tmp_and_left_value_8 );
    if ( tmp_and_left_truth_8 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_8 );

        exception_lineno = 1064;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_8 == 1 )
    {
        goto and_right_8;
    }
    else
    {
        goto and_left_8;
    }
    and_right_8:;
    Py_DECREF( tmp_and_left_value_8 );
    tmp_source_name_17 = par_self;

    CHECK_OBJECT( tmp_source_name_17 );
    tmp_compexpr_left_9 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain__decipher_only );
    if ( tmp_compexpr_left_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1064;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_18 = par_other;

    CHECK_OBJECT( tmp_source_name_18 );
    tmp_compexpr_right_9 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain__decipher_only );
    if ( tmp_compexpr_right_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_9 );

        exception_lineno = 1064;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_8 = RICH_COMPARE_EQ( tmp_compexpr_left_9, tmp_compexpr_right_9 );
    Py_DECREF( tmp_compexpr_left_9 );
    Py_DECREF( tmp_compexpr_right_9 );
    if ( tmp_and_right_value_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1064;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_7 = tmp_and_right_value_8;
    goto and_end_8;
    and_left_8:;
    tmp_and_right_value_7 = tmp_and_left_value_8;
    and_end_8:;
    tmp_and_right_value_6 = tmp_and_right_value_7;
    goto and_end_7;
    and_left_7:;
    tmp_and_right_value_6 = tmp_and_left_value_7;
    and_end_7:;
    tmp_and_right_value_5 = tmp_and_right_value_6;
    goto and_end_6;
    and_left_6:;
    tmp_and_right_value_5 = tmp_and_left_value_6;
    and_end_6:;
    tmp_and_right_value_4 = tmp_and_right_value_5;
    goto and_end_5;
    and_left_5:;
    tmp_and_right_value_4 = tmp_and_left_value_5;
    and_end_5:;
    tmp_and_right_value_3 = tmp_and_right_value_4;
    goto and_end_4;
    and_left_4:;
    tmp_and_right_value_3 = tmp_and_left_value_4;
    and_end_4:;
    tmp_and_right_value_2 = tmp_and_right_value_3;
    goto and_end_3;
    and_left_3:;
    tmp_and_right_value_2 = tmp_and_left_value_3;
    and_end_3:;
    tmp_and_right_value_1 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_and_right_value_1 = tmp_and_left_value_2;
    and_end_2:;
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a90aeaeb6f8a3ed1eddebdacaf29192a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a90aeaeb6f8a3ed1eddebdacaf29192a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a90aeaeb6f8a3ed1eddebdacaf29192a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a90aeaeb6f8a3ed1eddebdacaf29192a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a90aeaeb6f8a3ed1eddebdacaf29192a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a90aeaeb6f8a3ed1eddebdacaf29192a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a90aeaeb6f8a3ed1eddebdacaf29192a,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_a90aeaeb6f8a3ed1eddebdacaf29192a == cache_frame_a90aeaeb6f8a3ed1eddebdacaf29192a )
    {
        Py_DECREF( frame_a90aeaeb6f8a3ed1eddebdacaf29192a );
    }
    cache_frame_a90aeaeb6f8a3ed1eddebdacaf29192a = NULL;

    assertFrameObject( frame_a90aeaeb6f8a3ed1eddebdacaf29192a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_115___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_115___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_116___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_63793d5a1ced56f732c5a865370481f9 = NULL;

    struct Nuitka_FrameObject *frame_63793d5a1ced56f732c5a865370481f9;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_63793d5a1ced56f732c5a865370481f9, codeobj_63793d5a1ced56f732c5a865370481f9, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_63793d5a1ced56f732c5a865370481f9 = cache_frame_63793d5a1ced56f732c5a865370481f9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_63793d5a1ced56f732c5a865370481f9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_63793d5a1ced56f732c5a865370481f9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1068;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1068;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_63793d5a1ced56f732c5a865370481f9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_63793d5a1ced56f732c5a865370481f9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_63793d5a1ced56f732c5a865370481f9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_63793d5a1ced56f732c5a865370481f9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_63793d5a1ced56f732c5a865370481f9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_63793d5a1ced56f732c5a865370481f9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_63793d5a1ced56f732c5a865370481f9,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_63793d5a1ced56f732c5a865370481f9 == cache_frame_63793d5a1ced56f732c5a865370481f9 )
    {
        Py_DECREF( frame_63793d5a1ced56f732c5a865370481f9 );
    }
    cache_frame_63793d5a1ced56f732c5a865370481f9 = NULL;

    assertFrameObject( frame_63793d5a1ced56f732c5a865370481f9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_116___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_116___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_117___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_fb676fc0aa7f7213b586ead04828ec85 = NULL;

    struct Nuitka_FrameObject *frame_fb676fc0aa7f7213b586ead04828ec85;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fb676fc0aa7f7213b586ead04828ec85, codeobj_fb676fc0aa7f7213b586ead04828ec85, module_cryptography$x509$extensions, sizeof(void *) );
    frame_fb676fc0aa7f7213b586ead04828ec85 = cache_frame_fb676fc0aa7f7213b586ead04828ec85;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fb676fc0aa7f7213b586ead04828ec85 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fb676fc0aa7f7213b586ead04828ec85 ) == 2 ); // Frame stack

    // Framed code:
    tmp_hash_arg_1 = PyTuple_New( 9 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_digital_signature );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1072;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_content_commitment );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1072;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 1, tmp_tuple_element_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_key_encipherment );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1073;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 2, tmp_tuple_element_1 );
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_data_encipherment );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1073;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 3, tmp_tuple_element_1 );
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_key_agreement );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1074;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 4, tmp_tuple_element_1 );
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_key_cert_sign );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1074;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 5, tmp_tuple_element_1 );
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_crl_sign );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1075;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 6, tmp_tuple_element_1 );
    tmp_source_name_8 = par_self;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__encipher_only );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1075;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 7, tmp_tuple_element_1 );
    tmp_source_name_9 = par_self;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__decipher_only );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1076;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 8, tmp_tuple_element_1 );
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1071;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fb676fc0aa7f7213b586ead04828ec85 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fb676fc0aa7f7213b586ead04828ec85 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fb676fc0aa7f7213b586ead04828ec85 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fb676fc0aa7f7213b586ead04828ec85, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fb676fc0aa7f7213b586ead04828ec85->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fb676fc0aa7f7213b586ead04828ec85, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fb676fc0aa7f7213b586ead04828ec85,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_fb676fc0aa7f7213b586ead04828ec85 == cache_frame_fb676fc0aa7f7213b586ead04828ec85 )
    {
        Py_DECREF( frame_fb676fc0aa7f7213b586ead04828ec85 );
    }
    cache_frame_fb676fc0aa7f7213b586ead04828ec85 = NULL;

    assertFrameObject( frame_fb676fc0aa7f7213b586ead04828ec85 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_117___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_117___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_118___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_permitted_subtrees = python_pars[ 1 ];
    PyObject *par_excluded_subtrees = python_pars[ 2 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *tmp_genexpr_2__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    bool tmp_isnot_1;
    bool tmp_isnot_2;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_list_arg_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_outline_return_value_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    bool tmp_result;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_27f3275a0ef40b25b2c2ac83a6e7e96d = NULL;

    struct Nuitka_FrameObject *frame_27f3275a0ef40b25b2c2ac83a6e7e96d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;
    tmp_outline_return_value_2 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_27f3275a0ef40b25b2c2ac83a6e7e96d, codeobj_27f3275a0ef40b25b2c2ac83a6e7e96d, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_27f3275a0ef40b25b2c2ac83a6e7e96d = cache_frame_27f3275a0ef40b25b2c2ac83a6e7e96d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_27f3275a0ef40b25b2c2ac83a6e7e96d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_27f3275a0ef40b25b2c2ac83a6e7e96d ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_permitted_subtrees;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_list_arg_1 = par_permitted_subtrees;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1086;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_permitted_subtrees;
        assert( old != NULL );
        par_permitted_subtrees = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_permitted_subtrees;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1088;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_118___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_e68b59737d616b587e212e23bf9889ca,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_118___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_118___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_27f3275a0ef40b25b2c2ac83a6e7e96d->m_frame.f_lineno = 1087;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1087;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1087;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_1 = const_str_digest_881d5fa81af108f32d6b1d8d2d35a638;
    frame_27f3275a0ef40b25b2c2ac83a6e7e96d->m_frame.f_lineno = 1090;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1090;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_2 = par_permitted_subtrees;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_27f3275a0ef40b25b2c2ac83a6e7e96d->m_frame.f_lineno = 1095;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__validate_ip_name, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1095;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_compare_left_2 = par_excluded_subtrees;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = Py_None;
    tmp_isnot_2 = ( tmp_compare_left_2 != tmp_compare_right_2 );
    if ( tmp_isnot_2 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_list_arg_2 = par_excluded_subtrees;

    CHECK_OBJECT( tmp_list_arg_2 );
    tmp_assign_source_3 = PySequence_List( tmp_list_arg_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1098;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_excluded_subtrees;
        assert( old != NULL );
        par_excluded_subtrees = tmp_assign_source_3;
        Py_DECREF( old );
    }

    tmp_called_name_2 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_2 != NULL );
    tmp_iter_arg_2 = par_excluded_subtrees;

    CHECK_OBJECT( tmp_iter_arg_2 );
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1100;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_2__$0 == NULL );
    tmp_genexpr_2__$0 = tmp_assign_source_4;

    // Tried code:
    tmp_outline_return_value_2 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_118___init__$$$genexpr_2_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_a27de6359d8ab3d5836396a97af0dd56,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_2)->m_closure[0] = PyCell_NEW0( tmp_genexpr_2__$0 );
    assert( Py_SIZE( tmp_outline_return_value_2 ) >= 1 ); 


    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_118___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_3:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_2__$0 );
    Py_DECREF( tmp_genexpr_2__$0 );
    tmp_genexpr_2__$0 = NULL;

    goto outline_result_2;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_2__$0 );
    Py_DECREF( tmp_genexpr_2__$0 );
    tmp_genexpr_2__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_118___init__ );
    return NULL;
    outline_result_2:;
    tmp_args_element_name_3 = tmp_outline_return_value_2;
    frame_27f3275a0ef40b25b2c2ac83a6e7e96d->m_frame.f_lineno = 1099;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_cond_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1099;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 1099;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    tmp_make_exception_arg_2 = const_str_digest_a0744842c59ec0ec1342dee683ec7ac8;
    frame_27f3275a0ef40b25b2c2ac83a6e7e96d->m_frame.f_lineno = 1102;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 1102;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_4:;
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_4 = par_excluded_subtrees;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_27f3275a0ef40b25b2c2ac83a6e7e96d->m_frame.f_lineno = 1107;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__validate_ip_name, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1107;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    tmp_compexpr_left_1 = par_permitted_subtrees;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = Py_None;
    tmp_and_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 == tmp_compexpr_right_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    assert( !(tmp_and_left_truth_1 == -1) );
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_compexpr_left_2 = par_excluded_subtrees;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = Py_None;
    tmp_and_right_value_1 = BOOL_FROM( tmp_compexpr_left_2 == tmp_compexpr_right_2 );
    tmp_cond_value_3 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_3 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    assert( !(tmp_cond_truth_3 == -1) );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_make_exception_arg_3 = const_str_digest_ccd052a57d9b2466ec6174083baebf1e;
    frame_27f3275a0ef40b25b2c2ac83a6e7e96d->m_frame.f_lineno = 1110;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 1110;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_5:;
    tmp_assattr_name_1 = par_permitted_subtrees;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__permitted_subtrees, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_excluded_subtrees;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__excluded_subtrees, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1116;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27f3275a0ef40b25b2c2ac83a6e7e96d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27f3275a0ef40b25b2c2ac83a6e7e96d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_27f3275a0ef40b25b2c2ac83a6e7e96d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_27f3275a0ef40b25b2c2ac83a6e7e96d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_27f3275a0ef40b25b2c2ac83a6e7e96d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_27f3275a0ef40b25b2c2ac83a6e7e96d,
        type_description_1,
        par_self,
        par_permitted_subtrees,
        par_excluded_subtrees
    );


    // Release cached frame.
    if ( frame_27f3275a0ef40b25b2c2ac83a6e7e96d == cache_frame_27f3275a0ef40b25b2c2ac83a6e7e96d )
    {
        Py_DECREF( frame_27f3275a0ef40b25b2c2ac83a6e7e96d );
    }
    cache_frame_27f3275a0ef40b25b2c2ac83a6e7e96d = NULL;

    assertFrameObject( frame_27f3275a0ef40b25b2c2ac83a6e7e96d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_118___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_permitted_subtrees );
    Py_DECREF( par_permitted_subtrees );
    par_permitted_subtrees = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_excluded_subtrees );
    Py_DECREF( par_excluded_subtrees );
    par_excluded_subtrees = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_permitted_subtrees );
    par_permitted_subtrees = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_excluded_subtrees );
    par_excluded_subtrees = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_118___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_118___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_118___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_118___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_e68b59737d616b587e212e23bf9889ca, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 1088;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1088;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GeneralName" );
        exception_tb = NULL;

        exception_lineno = 1088;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1088;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1088;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1088;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_118___init__$$$genexpr_2_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_118___init__$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_118___init__$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_a27de6359d8ab3d5836396a97af0dd56, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 1100;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1100;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GeneralName" );
        exception_tb = NULL;

        exception_lineno = 1100;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1100;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1100;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1100;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_119___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_d82593620f5895cf8bf3aba5f81ef7d9 = NULL;

    struct Nuitka_FrameObject *frame_d82593620f5895cf8bf3aba5f81ef7d9;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d82593620f5895cf8bf3aba5f81ef7d9, codeobj_d82593620f5895cf8bf3aba5f81ef7d9, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_d82593620f5895cf8bf3aba5f81ef7d9 = cache_frame_d82593620f5895cf8bf3aba5f81ef7d9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d82593620f5895cf8bf3aba5f81ef7d9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d82593620f5895cf8bf3aba5f81ef7d9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_NameConstraints );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NameConstraints );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "NameConstraints" );
        exception_tb = NULL;

        exception_lineno = 1119;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1119;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_excluded_subtrees );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1123;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_excluded_subtrees );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1123;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1123;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 1124;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_permitted_subtrees );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1124;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_other;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_permitted_subtrees );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 1124;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1124;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d82593620f5895cf8bf3aba5f81ef7d9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d82593620f5895cf8bf3aba5f81ef7d9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d82593620f5895cf8bf3aba5f81ef7d9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d82593620f5895cf8bf3aba5f81ef7d9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d82593620f5895cf8bf3aba5f81ef7d9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d82593620f5895cf8bf3aba5f81ef7d9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d82593620f5895cf8bf3aba5f81ef7d9,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_d82593620f5895cf8bf3aba5f81ef7d9 == cache_frame_d82593620f5895cf8bf3aba5f81ef7d9 )
    {
        Py_DECREF( frame_d82593620f5895cf8bf3aba5f81ef7d9 );
    }
    cache_frame_d82593620f5895cf8bf3aba5f81ef7d9 = NULL;

    assertFrameObject( frame_d82593620f5895cf8bf3aba5f81ef7d9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_119___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_119___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_120___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_8735c6c8ac5e6c3fd0af4da21d827208 = NULL;

    struct Nuitka_FrameObject *frame_8735c6c8ac5e6c3fd0af4da21d827208;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8735c6c8ac5e6c3fd0af4da21d827208, codeobj_8735c6c8ac5e6c3fd0af4da21d827208, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_8735c6c8ac5e6c3fd0af4da21d827208 = cache_frame_8735c6c8ac5e6c3fd0af4da21d827208;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8735c6c8ac5e6c3fd0af4da21d827208 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8735c6c8ac5e6c3fd0af4da21d827208 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1128;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1128;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8735c6c8ac5e6c3fd0af4da21d827208 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8735c6c8ac5e6c3fd0af4da21d827208 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8735c6c8ac5e6c3fd0af4da21d827208 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8735c6c8ac5e6c3fd0af4da21d827208, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8735c6c8ac5e6c3fd0af4da21d827208->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8735c6c8ac5e6c3fd0af4da21d827208, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8735c6c8ac5e6c3fd0af4da21d827208,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_8735c6c8ac5e6c3fd0af4da21d827208 == cache_frame_8735c6c8ac5e6c3fd0af4da21d827208 )
    {
        Py_DECREF( frame_8735c6c8ac5e6c3fd0af4da21d827208 );
    }
    cache_frame_8735c6c8ac5e6c3fd0af4da21d827208 = NULL;

    assertFrameObject( frame_8735c6c8ac5e6c3fd0af4da21d827208 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_120___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_120___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_121__validate_ip_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tree = python_pars[ 1 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_ab8ef2a24d0f1a790614f3268e20e185 = NULL;

    struct Nuitka_FrameObject *frame_ab8ef2a24d0f1a790614f3268e20e185;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ab8ef2a24d0f1a790614f3268e20e185, codeobj_ab8ef2a24d0f1a790614f3268e20e185, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_ab8ef2a24d0f1a790614f3268e20e185 = cache_frame_ab8ef2a24d0f1a790614f3268e20e185;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ab8ef2a24d0f1a790614f3268e20e185 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ab8ef2a24d0f1a790614f3268e20e185 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_any );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_tree;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1131;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_1;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_121__validate_ip_name$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_efa7c6c8ebb42411f84380efc042fa9b,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_121__validate_ip_name );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_121__validate_ip_name );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_ab8ef2a24d0f1a790614f3268e20e185->m_frame.f_lineno = 1131;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1131;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1131;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_7d42ffe02af672349902ee30e189a05b;
    frame_ab8ef2a24d0f1a790614f3268e20e185->m_frame.f_lineno = 1134;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1134;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab8ef2a24d0f1a790614f3268e20e185 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab8ef2a24d0f1a790614f3268e20e185 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ab8ef2a24d0f1a790614f3268e20e185, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ab8ef2a24d0f1a790614f3268e20e185->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ab8ef2a24d0f1a790614f3268e20e185, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ab8ef2a24d0f1a790614f3268e20e185,
        type_description_1,
        par_self,
        par_tree
    );


    // Release cached frame.
    if ( frame_ab8ef2a24d0f1a790614f3268e20e185 == cache_frame_ab8ef2a24d0f1a790614f3268e20e185 )
    {
        Py_DECREF( frame_ab8ef2a24d0f1a790614f3268e20e185 );
    }
    cache_frame_ab8ef2a24d0f1a790614f3268e20e185 = NULL;

    assertFrameObject( frame_ab8ef2a24d0f1a790614f3268e20e185 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_121__validate_ip_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_tree );
    Py_DECREF( par_tree );
    par_tree = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_tree );
    Py_DECREF( par_tree );
    par_tree = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_121__validate_ip_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_121__validate_ip_name$$$genexpr_1_genexpr_locals {
    PyObject *var_name
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_121__validate_ip_name$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_121__validate_ip_name$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_name = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_efa7c6c8ebb42411f84380efc042fa9b, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 1131;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1131;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_name;
        var_name = tmp_assign_source_2;
        Py_INCREF( var_name );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_name;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_IPAddress );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPAddress );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPAddress" );
        exception_tb = NULL;

        exception_lineno = 1131;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_and_left_value_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1131;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1131;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_source_name_1 = var_name;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_isinstance_inst_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_value );
    if ( tmp_isinstance_inst_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1132;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    tmp_isinstance_cls_2 = PyTuple_New( 2 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ipaddress );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ipaddress );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_isinstance_inst_2 );
        Py_DECREF( tmp_isinstance_cls_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ipaddress" );
        exception_tb = NULL;

        exception_lineno = 1132;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_IPv4Network );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_inst_2 );
        Py_DECREF( tmp_isinstance_cls_2 );

        exception_lineno = 1132;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_2, 0, tmp_tuple_element_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ipaddress );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ipaddress );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_isinstance_inst_2 );
        Py_DECREF( tmp_isinstance_cls_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ipaddress" );
        exception_tb = NULL;

        exception_lineno = 1132;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_IPv6Network );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_inst_2 );
        Py_DECREF( tmp_isinstance_cls_2 );

        exception_lineno = 1132;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_2, 1, tmp_tuple_element_1 );
    tmp_operand_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    Py_DECREF( tmp_isinstance_inst_2 );
    Py_DECREF( tmp_isinstance_cls_2 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1131;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    tmp_and_right_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1131;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    tmp_expression_name_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_expression_name_1 = tmp_and_left_value_1;
    and_end_1:;
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1131;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1131;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_name
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_122___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_0c5f8fcaef9aafcfe368d2f302930746 = NULL;

    struct Nuitka_FrameObject *frame_0c5f8fcaef9aafcfe368d2f302930746;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0c5f8fcaef9aafcfe368d2f302930746, codeobj_0c5f8fcaef9aafcfe368d2f302930746, module_cryptography$x509$extensions, sizeof(void *) );
    frame_0c5f8fcaef9aafcfe368d2f302930746 = cache_frame_0c5f8fcaef9aafcfe368d2f302930746;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0c5f8fcaef9aafcfe368d2f302930746 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0c5f8fcaef9aafcfe368d2f302930746 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_unicode_digest_91632884773c30442b9e2ac13e53950d;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_0c5f8fcaef9aafcfe368d2f302930746->m_frame.f_lineno = 1141;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1141;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c5f8fcaef9aafcfe368d2f302930746 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c5f8fcaef9aafcfe368d2f302930746 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c5f8fcaef9aafcfe368d2f302930746 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0c5f8fcaef9aafcfe368d2f302930746, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0c5f8fcaef9aafcfe368d2f302930746->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0c5f8fcaef9aafcfe368d2f302930746, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0c5f8fcaef9aafcfe368d2f302930746,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_0c5f8fcaef9aafcfe368d2f302930746 == cache_frame_0c5f8fcaef9aafcfe368d2f302930746 )
    {
        Py_DECREF( frame_0c5f8fcaef9aafcfe368d2f302930746 );
    }
    cache_frame_0c5f8fcaef9aafcfe368d2f302930746 = NULL;

    assertFrameObject( frame_0c5f8fcaef9aafcfe368d2f302930746 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_122___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_122___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_123___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_ps = NULL;
    PyObject *var_es = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_hash_arg_1;
    bool tmp_isnot_1;
    bool tmp_isnot_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_tuple_arg_1;
    PyObject *tmp_tuple_arg_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_5d6578b18c844fbf92e4e1cc396ff560 = NULL;

    struct Nuitka_FrameObject *frame_5d6578b18c844fbf92e4e1cc396ff560;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5d6578b18c844fbf92e4e1cc396ff560, codeobj_5d6578b18c844fbf92e4e1cc396ff560, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5d6578b18c844fbf92e4e1cc396ff560 = cache_frame_5d6578b18c844fbf92e4e1cc396ff560;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5d6578b18c844fbf92e4e1cc396ff560 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5d6578b18c844fbf92e4e1cc396ff560 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_permitted_subtrees );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1146;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_permitted_subtrees );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1147;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1147;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_ps == NULL );
    var_ps = tmp_assign_source_1;

    goto branch_end_1;
    branch_no_1:;
    tmp_assign_source_2 = Py_None;
    assert( var_ps == NULL );
    Py_INCREF( tmp_assign_source_2 );
    var_ps = tmp_assign_source_2;

    branch_end_1:;
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_excluded_subtrees );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1151;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = Py_None;
    tmp_isnot_2 = ( tmp_compare_left_2 != tmp_compare_right_2 );
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_isnot_2 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_tuple_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_excluded_subtrees );
    if ( tmp_tuple_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1152;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_3 = PySequence_Tuple( tmp_tuple_arg_2 );
    Py_DECREF( tmp_tuple_arg_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1152;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_es == NULL );
    var_es = tmp_assign_source_3;

    goto branch_end_2;
    branch_no_2:;
    tmp_assign_source_4 = Py_None;
    assert( var_es == NULL );
    Py_INCREF( tmp_assign_source_4 );
    var_es = tmp_assign_source_4;

    branch_end_2:;
    tmp_hash_arg_1 = PyTuple_New( 2 );
    tmp_tuple_element_1 = var_ps;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_hash_arg_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_es;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_hash_arg_1, 1, tmp_tuple_element_1 );
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1156;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d6578b18c844fbf92e4e1cc396ff560 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d6578b18c844fbf92e4e1cc396ff560 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d6578b18c844fbf92e4e1cc396ff560 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5d6578b18c844fbf92e4e1cc396ff560, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5d6578b18c844fbf92e4e1cc396ff560->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5d6578b18c844fbf92e4e1cc396ff560, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5d6578b18c844fbf92e4e1cc396ff560,
        type_description_1,
        par_self,
        var_ps,
        var_es
    );


    // Release cached frame.
    if ( frame_5d6578b18c844fbf92e4e1cc396ff560 == cache_frame_5d6578b18c844fbf92e4e1cc396ff560 )
    {
        Py_DECREF( frame_5d6578b18c844fbf92e4e1cc396ff560 );
    }
    cache_frame_5d6578b18c844fbf92e4e1cc396ff560 = NULL;

    assertFrameObject( frame_5d6578b18c844fbf92e4e1cc396ff560 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_123___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_ps );
    Py_DECREF( var_ps );
    var_ps = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_es );
    Py_DECREF( var_es );
    var_es = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_ps );
    var_ps = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_es );
    var_es = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_123___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_124___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_oid = python_pars[ 1 ];
    PyObject *par_critical = python_pars[ 2 ];
    PyObject *par_value = python_pars[ 3 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_90f9dc917871442a40fd7dbb81775ea8 = NULL;

    struct Nuitka_FrameObject *frame_90f9dc917871442a40fd7dbb81775ea8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_90f9dc917871442a40fd7dbb81775ea8, codeobj_90f9dc917871442a40fd7dbb81775ea8, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_90f9dc917871442a40fd7dbb81775ea8 = cache_frame_90f9dc917871442a40fd7dbb81775ea8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_90f9dc917871442a40fd7dbb81775ea8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_90f9dc917871442a40fd7dbb81775ea8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_oid;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ObjectIdentifier" );
        exception_tb = NULL;

        exception_lineno = 1164;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_d8b4cb10b00d6765b713cf768245d18d;
    frame_90f9dc917871442a40fd7dbb81775ea8->m_frame.f_lineno = 1165;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1165;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_isinstance_inst_2 = par_critical;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_isinstance_cls_2 = (PyObject *)&PyBool_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1169;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_1961eae2d00689b393091e3fc681acbe;
    frame_90f9dc917871442a40fd7dbb81775ea8->m_frame.f_lineno = 1170;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 1170;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_assattr_name_1 = par_oid;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__oid, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1172;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_critical;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__critical, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = par_value;

    CHECK_OBJECT( tmp_assattr_name_3 );
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__value, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1174;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_90f9dc917871442a40fd7dbb81775ea8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_90f9dc917871442a40fd7dbb81775ea8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_90f9dc917871442a40fd7dbb81775ea8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_90f9dc917871442a40fd7dbb81775ea8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_90f9dc917871442a40fd7dbb81775ea8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_90f9dc917871442a40fd7dbb81775ea8,
        type_description_1,
        par_self,
        par_oid,
        par_critical,
        par_value
    );


    // Release cached frame.
    if ( frame_90f9dc917871442a40fd7dbb81775ea8 == cache_frame_90f9dc917871442a40fd7dbb81775ea8 )
    {
        Py_DECREF( frame_90f9dc917871442a40fd7dbb81775ea8 );
    }
    cache_frame_90f9dc917871442a40fd7dbb81775ea8 = NULL;

    assertFrameObject( frame_90f9dc917871442a40fd7dbb81775ea8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_124___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_oid );
    Py_DECREF( par_oid );
    par_oid = NULL;

    CHECK_OBJECT( (PyObject *)par_critical );
    Py_DECREF( par_critical );
    par_critical = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_oid );
    Py_DECREF( par_oid );
    par_oid = NULL;

    CHECK_OBJECT( (PyObject *)par_critical );
    Py_DECREF( par_critical );
    par_critical = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_124___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_125___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_97bcd8a86a0e71a6d026a07d84b45ed7 = NULL;

    struct Nuitka_FrameObject *frame_97bcd8a86a0e71a6d026a07d84b45ed7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_97bcd8a86a0e71a6d026a07d84b45ed7, codeobj_97bcd8a86a0e71a6d026a07d84b45ed7, module_cryptography$x509$extensions, sizeof(void *) );
    frame_97bcd8a86a0e71a6d026a07d84b45ed7 = cache_frame_97bcd8a86a0e71a6d026a07d84b45ed7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_97bcd8a86a0e71a6d026a07d84b45ed7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_97bcd8a86a0e71a6d026a07d84b45ed7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_15f4645c15394598b5ad3d887ad62f4a;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_97bcd8a86a0e71a6d026a07d84b45ed7->m_frame.f_lineno = 1181;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1181;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_97bcd8a86a0e71a6d026a07d84b45ed7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_97bcd8a86a0e71a6d026a07d84b45ed7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_97bcd8a86a0e71a6d026a07d84b45ed7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_97bcd8a86a0e71a6d026a07d84b45ed7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_97bcd8a86a0e71a6d026a07d84b45ed7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_97bcd8a86a0e71a6d026a07d84b45ed7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_97bcd8a86a0e71a6d026a07d84b45ed7,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_97bcd8a86a0e71a6d026a07d84b45ed7 == cache_frame_97bcd8a86a0e71a6d026a07d84b45ed7 )
    {
        Py_DECREF( frame_97bcd8a86a0e71a6d026a07d84b45ed7 );
    }
    cache_frame_97bcd8a86a0e71a6d026a07d84b45ed7 = NULL;

    assertFrameObject( frame_97bcd8a86a0e71a6d026a07d84b45ed7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_125___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_125___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_126___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    static struct Nuitka_FrameObject *cache_frame_c8a574578584b58b662d6a22e972cb4a = NULL;

    struct Nuitka_FrameObject *frame_c8a574578584b58b662d6a22e972cb4a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c8a574578584b58b662d6a22e972cb4a, codeobj_c8a574578584b58b662d6a22e972cb4a, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_c8a574578584b58b662d6a22e972cb4a = cache_frame_c8a574578584b58b662d6a22e972cb4a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c8a574578584b58b662d6a22e972cb4a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c8a574578584b58b662d6a22e972cb4a ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_Extension );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Extension );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Extension" );
        exception_tb = NULL;

        exception_lineno = 1185;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1185;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_oid );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1189;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_oid );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1189;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1189;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 1191;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_critical );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1190;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_other;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_critical );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 1190;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_2 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1190;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    if ( tmp_and_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_2 );

        exception_lineno = 1191;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    Py_DECREF( tmp_and_left_value_2 );
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_value );
    if ( tmp_compexpr_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1191;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_other;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_value );
    if ( tmp_compexpr_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_3 );

        exception_lineno = 1191;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_2 = RICH_COMPARE_EQ( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    Py_DECREF( tmp_compexpr_left_3 );
    Py_DECREF( tmp_compexpr_right_3 );
    if ( tmp_and_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1191;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_and_right_value_1 = tmp_and_left_value_2;
    and_end_2:;
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c8a574578584b58b662d6a22e972cb4a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c8a574578584b58b662d6a22e972cb4a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c8a574578584b58b662d6a22e972cb4a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c8a574578584b58b662d6a22e972cb4a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c8a574578584b58b662d6a22e972cb4a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c8a574578584b58b662d6a22e972cb4a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c8a574578584b58b662d6a22e972cb4a,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_c8a574578584b58b662d6a22e972cb4a == cache_frame_c8a574578584b58b662d6a22e972cb4a )
    {
        Py_DECREF( frame_c8a574578584b58b662d6a22e972cb4a );
    }
    cache_frame_c8a574578584b58b662d6a22e972cb4a = NULL;

    assertFrameObject( frame_c8a574578584b58b662d6a22e972cb4a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_126___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_126___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_127___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_083fd7a326fcbb7a6d20eb602df89ced = NULL;

    struct Nuitka_FrameObject *frame_083fd7a326fcbb7a6d20eb602df89ced;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_083fd7a326fcbb7a6d20eb602df89ced, codeobj_083fd7a326fcbb7a6d20eb602df89ced, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_083fd7a326fcbb7a6d20eb602df89ced = cache_frame_083fd7a326fcbb7a6d20eb602df89ced;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_083fd7a326fcbb7a6d20eb602df89ced );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_083fd7a326fcbb7a6d20eb602df89ced ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1195;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1195;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_083fd7a326fcbb7a6d20eb602df89ced );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_083fd7a326fcbb7a6d20eb602df89ced );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_083fd7a326fcbb7a6d20eb602df89ced );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_083fd7a326fcbb7a6d20eb602df89ced, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_083fd7a326fcbb7a6d20eb602df89ced->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_083fd7a326fcbb7a6d20eb602df89ced, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_083fd7a326fcbb7a6d20eb602df89ced,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_083fd7a326fcbb7a6d20eb602df89ced == cache_frame_083fd7a326fcbb7a6d20eb602df89ced )
    {
        Py_DECREF( frame_083fd7a326fcbb7a6d20eb602df89ced );
    }
    cache_frame_083fd7a326fcbb7a6d20eb602df89ced = NULL;

    assertFrameObject( frame_083fd7a326fcbb7a6d20eb602df89ced );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_127___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_127___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_128___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_595f73a82e458cba3cad4ec3ac173f24 = NULL;

    struct Nuitka_FrameObject *frame_595f73a82e458cba3cad4ec3ac173f24;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_595f73a82e458cba3cad4ec3ac173f24, codeobj_595f73a82e458cba3cad4ec3ac173f24, module_cryptography$x509$extensions, sizeof(void *) );
    frame_595f73a82e458cba3cad4ec3ac173f24 = cache_frame_595f73a82e458cba3cad4ec3ac173f24;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_595f73a82e458cba3cad4ec3ac173f24 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_595f73a82e458cba3cad4ec3ac173f24 ) == 2 ); // Frame stack

    // Framed code:
    tmp_hash_arg_1 = PyTuple_New( 3 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_oid );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1198;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_critical );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1198;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 1, tmp_tuple_element_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_value );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1198;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 2, tmp_tuple_element_1 );
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1198;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_595f73a82e458cba3cad4ec3ac173f24 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_595f73a82e458cba3cad4ec3ac173f24 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_595f73a82e458cba3cad4ec3ac173f24 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_595f73a82e458cba3cad4ec3ac173f24, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_595f73a82e458cba3cad4ec3ac173f24->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_595f73a82e458cba3cad4ec3ac173f24, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_595f73a82e458cba3cad4ec3ac173f24,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_595f73a82e458cba3cad4ec3ac173f24 == cache_frame_595f73a82e458cba3cad4ec3ac173f24 )
    {
        Py_DECREF( frame_595f73a82e458cba3cad4ec3ac173f24 );
    }
    cache_frame_595f73a82e458cba3cad4ec3ac173f24 = NULL;

    assertFrameObject( frame_595f73a82e458cba3cad4ec3ac173f24 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_128___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_128___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_129___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_general_names = python_pars[ 1 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_2222a6dca432c7c5cdd7e181de61cc46 = NULL;

    struct Nuitka_FrameObject *frame_2222a6dca432c7c5cdd7e181de61cc46;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2222a6dca432c7c5cdd7e181de61cc46, codeobj_2222a6dca432c7c5cdd7e181de61cc46, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_2222a6dca432c7c5cdd7e181de61cc46 = cache_frame_2222a6dca432c7c5cdd7e181de61cc46;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2222a6dca432c7c5cdd7e181de61cc46 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2222a6dca432c7c5cdd7e181de61cc46 ) == 2 ); // Frame stack

    // Framed code:
    tmp_list_arg_1 = par_general_names;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1203;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_general_names;
        assert( old != NULL );
        par_general_names = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_general_names;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1204;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_f4d9248322167b2ac77a2fb751c6795b,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_129___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_129___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_2222a6dca432c7c5cdd7e181de61cc46->m_frame.f_lineno = 1204;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1204;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1204;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_2622a0002f5b5df69415ebf4bce9a343;
    frame_2222a6dca432c7c5cdd7e181de61cc46->m_frame.f_lineno = 1205;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1205;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_general_names;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__general_names, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1210;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2222a6dca432c7c5cdd7e181de61cc46 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2222a6dca432c7c5cdd7e181de61cc46 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2222a6dca432c7c5cdd7e181de61cc46, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2222a6dca432c7c5cdd7e181de61cc46->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2222a6dca432c7c5cdd7e181de61cc46, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2222a6dca432c7c5cdd7e181de61cc46,
        type_description_1,
        par_self,
        par_general_names
    );


    // Release cached frame.
    if ( frame_2222a6dca432c7c5cdd7e181de61cc46 == cache_frame_2222a6dca432c7c5cdd7e181de61cc46 )
    {
        Py_DECREF( frame_2222a6dca432c7c5cdd7e181de61cc46 );
    }
    cache_frame_2222a6dca432c7c5cdd7e181de61cc46 = NULL;

    assertFrameObject( frame_2222a6dca432c7c5cdd7e181de61cc46 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_129___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_general_names );
    Py_DECREF( par_general_names );
    par_general_names = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_general_names );
    Py_DECREF( par_general_names );
    par_general_names = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_129___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_f4d9248322167b2ac77a2fb751c6795b, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 1204;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1204;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GeneralName" );
        exception_tb = NULL;

        exception_lineno = 1204;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1204;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1204;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1204;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_130_get_values_for_type( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_CellObject *par_type = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_objs = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *tmp_genexpr_2__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_outline_return_value_2;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_333cc1037c812d2229525293f8f2e028 = NULL;

    struct Nuitka_FrameObject *frame_333cc1037c812d2229525293f8f2e028;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;
    tmp_outline_return_value_2 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_333cc1037c812d2229525293f8f2e028, codeobj_333cc1037c812d2229525293f8f2e028, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_333cc1037c812d2229525293f8f2e028 = cache_frame_333cc1037c812d2229525293f8f2e028;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_333cc1037c812d2229525293f8f2e028 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_333cc1037c812d2229525293f8f2e028 ) == 2 ); // Frame stack

    // Framed code:
    tmp_iter_arg_1 = par_self;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1217;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_130_get_values_for_type$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_781e6ff451377bc709ff6533ef34d0bb,
        2
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[1] = par_type;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[1] );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 2 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_130_get_values_for_type );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_130_get_values_for_type );
    return NULL;
    outline_result_1:;
    tmp_assign_source_1 = tmp_outline_return_value_1;
    assert( var_objs == NULL );
    var_objs = tmp_assign_source_1;

    if ( par_type == NULL )
    {
        tmp_compare_left_1 = NULL;
    }
    else
    {
        tmp_compare_left_1 = PyCell_GET( par_type );
    }

    if ( tmp_compare_left_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "type" );
        exception_tb = NULL;

        exception_lineno = 1218;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OtherName );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OtherName );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "OtherName" );
        exception_tb = NULL;

        exception_lineno = 1218;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }

    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1218;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_iter_arg_2 = var_objs;

    CHECK_OBJECT( tmp_iter_arg_2 );
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1219;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_2__$0 == NULL );
    tmp_genexpr_2__$0 = tmp_assign_source_4;

    // Tried code:
    tmp_outline_return_value_2 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_130_get_values_for_type$$$genexpr_2_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_fa6f15834600be01ff30b260874e5673,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_2)->m_closure[0] = PyCell_NEW0( tmp_genexpr_2__$0 );
    assert( Py_SIZE( tmp_outline_return_value_2 ) >= 1 ); 


    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_130_get_values_for_type );
    return NULL;
    // Return handler code:
    try_return_handler_3:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_2__$0 );
    Py_DECREF( tmp_genexpr_2__$0 );
    tmp_genexpr_2__$0 = NULL;

    goto outline_result_2;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_2__$0 );
    Py_DECREF( tmp_genexpr_2__$0 );
    tmp_genexpr_2__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_130_get_values_for_type );
    return NULL;
    outline_result_2:;
    tmp_assign_source_3 = tmp_outline_return_value_2;
    {
        PyObject *old = var_objs;
        assert( old != NULL );
        var_objs = tmp_assign_source_3;
        Py_DECREF( old );
    }

    branch_no_1:;
    tmp_list_arg_1 = var_objs;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_return_value = PySequence_List( tmp_list_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1220;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_333cc1037c812d2229525293f8f2e028 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_333cc1037c812d2229525293f8f2e028 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_333cc1037c812d2229525293f8f2e028 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_333cc1037c812d2229525293f8f2e028, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_333cc1037c812d2229525293f8f2e028->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_333cc1037c812d2229525293f8f2e028, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_333cc1037c812d2229525293f8f2e028,
        type_description_1,
        par_self,
        par_type,
        var_objs
    );


    // Release cached frame.
    if ( frame_333cc1037c812d2229525293f8f2e028 == cache_frame_333cc1037c812d2229525293f8f2e028 )
    {
        Py_DECREF( frame_333cc1037c812d2229525293f8f2e028 );
    }
    cache_frame_333cc1037c812d2229525293f8f2e028 = NULL;

    assertFrameObject( frame_333cc1037c812d2229525293f8f2e028 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_130_get_values_for_type );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)var_objs );
    Py_DECREF( var_objs );
    var_objs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_objs );
    var_objs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_130_get_values_for_type );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_130_get_values_for_type$$$genexpr_1_genexpr_locals {
    PyObject *var_i
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_130_get_values_for_type$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_130_get_values_for_type$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_i = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_781e6ff451377bc709ff6533ef34d0bb, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "Noc";
        exception_lineno = 1217;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1217;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_2;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_i;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    if ( generator->m_closure[1] == NULL )
    {
        tmp_isinstance_cls_1 = NULL;
    }
    else
    {
        tmp_isinstance_cls_1 = PyCell_GET( generator->m_closure[1] );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "type" );
        exception_tb = NULL;

        exception_lineno = 1217;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1217;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_expression_name_1 = var_i;

    CHECK_OBJECT( tmp_expression_name_1 );
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1217;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    branch_no_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1217;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_i,
            generator->m_closure[1]
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_130_get_values_for_type$$$genexpr_2_genexpr_locals {
    PyObject *var_i
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_130_get_values_for_type$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_130_get_values_for_type$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_i = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_fa6f15834600be01ff30b260874e5673, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 1219;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1219;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_2;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_source_name_1 = var_i;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_expression_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_value );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1219;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1219;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1219;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_i
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_131___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_e076e7a305486e6abcaf1216659b6e19 = NULL;

    struct Nuitka_FrameObject *frame_e076e7a305486e6abcaf1216659b6e19;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e076e7a305486e6abcaf1216659b6e19, codeobj_e076e7a305486e6abcaf1216659b6e19, module_cryptography$x509$extensions, sizeof(void *) );
    frame_e076e7a305486e6abcaf1216659b6e19 = cache_frame_e076e7a305486e6abcaf1216659b6e19;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e076e7a305486e6abcaf1216659b6e19 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e076e7a305486e6abcaf1216659b6e19 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_096877126149ba9ef6483d7f63c2f65e;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__general_names );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1223;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_e076e7a305486e6abcaf1216659b6e19->m_frame.f_lineno = 1223;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1223;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e076e7a305486e6abcaf1216659b6e19 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e076e7a305486e6abcaf1216659b6e19 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e076e7a305486e6abcaf1216659b6e19 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e076e7a305486e6abcaf1216659b6e19, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e076e7a305486e6abcaf1216659b6e19->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e076e7a305486e6abcaf1216659b6e19, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e076e7a305486e6abcaf1216659b6e19,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_e076e7a305486e6abcaf1216659b6e19 == cache_frame_e076e7a305486e6abcaf1216659b6e19 )
    {
        Py_DECREF( frame_e076e7a305486e6abcaf1216659b6e19 );
    }
    cache_frame_e076e7a305486e6abcaf1216659b6e19 = NULL;

    assertFrameObject( frame_e076e7a305486e6abcaf1216659b6e19 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_131___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_131___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_132___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_186cdc657e777afed82927af6bc4a1ac = NULL;

    struct Nuitka_FrameObject *frame_186cdc657e777afed82927af6bc4a1ac;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_186cdc657e777afed82927af6bc4a1ac, codeobj_186cdc657e777afed82927af6bc4a1ac, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_186cdc657e777afed82927af6bc4a1ac = cache_frame_186cdc657e777afed82927af6bc4a1ac;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_186cdc657e777afed82927af6bc4a1ac );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_186cdc657e777afed82927af6bc4a1ac ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralNames );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralNames );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GeneralNames" );
        exception_tb = NULL;

        exception_lineno = 1226;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1226;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__general_names );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1229;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__general_names );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1229;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1229;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_186cdc657e777afed82927af6bc4a1ac );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_186cdc657e777afed82927af6bc4a1ac );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_186cdc657e777afed82927af6bc4a1ac );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_186cdc657e777afed82927af6bc4a1ac, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_186cdc657e777afed82927af6bc4a1ac->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_186cdc657e777afed82927af6bc4a1ac, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_186cdc657e777afed82927af6bc4a1ac,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_186cdc657e777afed82927af6bc4a1ac == cache_frame_186cdc657e777afed82927af6bc4a1ac )
    {
        Py_DECREF( frame_186cdc657e777afed82927af6bc4a1ac );
    }
    cache_frame_186cdc657e777afed82927af6bc4a1ac = NULL;

    assertFrameObject( frame_186cdc657e777afed82927af6bc4a1ac );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_132___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_132___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_133___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_106adc7dbc7e53b3b99843320941121f = NULL;

    struct Nuitka_FrameObject *frame_106adc7dbc7e53b3b99843320941121f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_106adc7dbc7e53b3b99843320941121f, codeobj_106adc7dbc7e53b3b99843320941121f, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_106adc7dbc7e53b3b99843320941121f = cache_frame_106adc7dbc7e53b3b99843320941121f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_106adc7dbc7e53b3b99843320941121f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_106adc7dbc7e53b3b99843320941121f ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1232;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1232;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_106adc7dbc7e53b3b99843320941121f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_106adc7dbc7e53b3b99843320941121f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_106adc7dbc7e53b3b99843320941121f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_106adc7dbc7e53b3b99843320941121f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_106adc7dbc7e53b3b99843320941121f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_106adc7dbc7e53b3b99843320941121f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_106adc7dbc7e53b3b99843320941121f,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_106adc7dbc7e53b3b99843320941121f == cache_frame_106adc7dbc7e53b3b99843320941121f )
    {
        Py_DECREF( frame_106adc7dbc7e53b3b99843320941121f );
    }
    cache_frame_106adc7dbc7e53b3b99843320941121f = NULL;

    assertFrameObject( frame_106adc7dbc7e53b3b99843320941121f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_133___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_133___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_134___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_arg_1;
    static struct Nuitka_FrameObject *cache_frame_500e5c17bcdaddaa2217eaf4f19855d0 = NULL;

    struct Nuitka_FrameObject *frame_500e5c17bcdaddaa2217eaf4f19855d0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_500e5c17bcdaddaa2217eaf4f19855d0, codeobj_500e5c17bcdaddaa2217eaf4f19855d0, module_cryptography$x509$extensions, sizeof(void *) );
    frame_500e5c17bcdaddaa2217eaf4f19855d0 = cache_frame_500e5c17bcdaddaa2217eaf4f19855d0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_500e5c17bcdaddaa2217eaf4f19855d0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_500e5c17bcdaddaa2217eaf4f19855d0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__general_names );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1235;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_hash_arg_1 = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1235;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1235;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_500e5c17bcdaddaa2217eaf4f19855d0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_500e5c17bcdaddaa2217eaf4f19855d0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_500e5c17bcdaddaa2217eaf4f19855d0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_500e5c17bcdaddaa2217eaf4f19855d0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_500e5c17bcdaddaa2217eaf4f19855d0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_500e5c17bcdaddaa2217eaf4f19855d0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_500e5c17bcdaddaa2217eaf4f19855d0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_500e5c17bcdaddaa2217eaf4f19855d0 == cache_frame_500e5c17bcdaddaa2217eaf4f19855d0 )
    {
        Py_DECREF( frame_500e5c17bcdaddaa2217eaf4f19855d0 );
    }
    cache_frame_500e5c17bcdaddaa2217eaf4f19855d0 = NULL;

    assertFrameObject( frame_500e5c17bcdaddaa2217eaf4f19855d0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_134___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_134___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_135___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_general_names = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_67f775c2ac36778d8149bcd69067f7f5 = NULL;

    struct Nuitka_FrameObject *frame_67f775c2ac36778d8149bcd69067f7f5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_67f775c2ac36778d8149bcd69067f7f5, codeobj_67f775c2ac36778d8149bcd69067f7f5, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_67f775c2ac36778d8149bcd69067f7f5 = cache_frame_67f775c2ac36778d8149bcd69067f7f5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_67f775c2ac36778d8149bcd69067f7f5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_67f775c2ac36778d8149bcd69067f7f5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralNames );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralNames );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GeneralNames" );
        exception_tb = NULL;

        exception_lineno = 1243;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_general_names;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_67f775c2ac36778d8149bcd69067f7f5->m_frame.f_lineno = 1243;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1243;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__general_names, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1243;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_67f775c2ac36778d8149bcd69067f7f5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_67f775c2ac36778d8149bcd69067f7f5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_67f775c2ac36778d8149bcd69067f7f5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_67f775c2ac36778d8149bcd69067f7f5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_67f775c2ac36778d8149bcd69067f7f5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_67f775c2ac36778d8149bcd69067f7f5,
        type_description_1,
        par_self,
        par_general_names
    );


    // Release cached frame.
    if ( frame_67f775c2ac36778d8149bcd69067f7f5 == cache_frame_67f775c2ac36778d8149bcd69067f7f5 )
    {
        Py_DECREF( frame_67f775c2ac36778d8149bcd69067f7f5 );
    }
    cache_frame_67f775c2ac36778d8149bcd69067f7f5 = NULL;

    assertFrameObject( frame_67f775c2ac36778d8149bcd69067f7f5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_135___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_general_names );
    Py_DECREF( par_general_names );
    par_general_names = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_general_names );
    Py_DECREF( par_general_names );
    par_general_names = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_135___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_136_get_values_for_type( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_type = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_321d3d2d646eb033dd31542f84fb8ad7 = NULL;

    struct Nuitka_FrameObject *frame_321d3d2d646eb033dd31542f84fb8ad7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_321d3d2d646eb033dd31542f84fb8ad7, codeobj_321d3d2d646eb033dd31542f84fb8ad7, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_321d3d2d646eb033dd31542f84fb8ad7 = cache_frame_321d3d2d646eb033dd31542f84fb8ad7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_321d3d2d646eb033dd31542f84fb8ad7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_321d3d2d646eb033dd31542f84fb8ad7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__general_names );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1248;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_type;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_321d3d2d646eb033dd31542f84fb8ad7->m_frame.f_lineno = 1248;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_get_values_for_type, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1248;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_321d3d2d646eb033dd31542f84fb8ad7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_321d3d2d646eb033dd31542f84fb8ad7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_321d3d2d646eb033dd31542f84fb8ad7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_321d3d2d646eb033dd31542f84fb8ad7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_321d3d2d646eb033dd31542f84fb8ad7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_321d3d2d646eb033dd31542f84fb8ad7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_321d3d2d646eb033dd31542f84fb8ad7,
        type_description_1,
        par_self,
        par_type
    );


    // Release cached frame.
    if ( frame_321d3d2d646eb033dd31542f84fb8ad7 == cache_frame_321d3d2d646eb033dd31542f84fb8ad7 )
    {
        Py_DECREF( frame_321d3d2d646eb033dd31542f84fb8ad7 );
    }
    cache_frame_321d3d2d646eb033dd31542f84fb8ad7 = NULL;

    assertFrameObject( frame_321d3d2d646eb033dd31542f84fb8ad7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_136_get_values_for_type );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_136_get_values_for_type );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_137___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_751849f6c514a7f7c9c0b68ae52b5141 = NULL;

    struct Nuitka_FrameObject *frame_751849f6c514a7f7c9c0b68ae52b5141;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_751849f6c514a7f7c9c0b68ae52b5141, codeobj_751849f6c514a7f7c9c0b68ae52b5141, module_cryptography$x509$extensions, sizeof(void *) );
    frame_751849f6c514a7f7c9c0b68ae52b5141 = cache_frame_751849f6c514a7f7c9c0b68ae52b5141;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_751849f6c514a7f7c9c0b68ae52b5141 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_751849f6c514a7f7c9c0b68ae52b5141 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_de6ca45cc2c0d21b3ea9542eeb752d64;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__general_names );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1251;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_751849f6c514a7f7c9c0b68ae52b5141->m_frame.f_lineno = 1251;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1251;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_751849f6c514a7f7c9c0b68ae52b5141 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_751849f6c514a7f7c9c0b68ae52b5141 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_751849f6c514a7f7c9c0b68ae52b5141 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_751849f6c514a7f7c9c0b68ae52b5141, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_751849f6c514a7f7c9c0b68ae52b5141->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_751849f6c514a7f7c9c0b68ae52b5141, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_751849f6c514a7f7c9c0b68ae52b5141,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_751849f6c514a7f7c9c0b68ae52b5141 == cache_frame_751849f6c514a7f7c9c0b68ae52b5141 )
    {
        Py_DECREF( frame_751849f6c514a7f7c9c0b68ae52b5141 );
    }
    cache_frame_751849f6c514a7f7c9c0b68ae52b5141 = NULL;

    assertFrameObject( frame_751849f6c514a7f7c9c0b68ae52b5141 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_137___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_137___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_138___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_8bab69c94615c96edcfa248584419f98 = NULL;

    struct Nuitka_FrameObject *frame_8bab69c94615c96edcfa248584419f98;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8bab69c94615c96edcfa248584419f98, codeobj_8bab69c94615c96edcfa248584419f98, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_8bab69c94615c96edcfa248584419f98 = cache_frame_8bab69c94615c96edcfa248584419f98;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8bab69c94615c96edcfa248584419f98 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8bab69c94615c96edcfa248584419f98 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SubjectAlternativeName );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SubjectAlternativeName );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "SubjectAlternativeName" );
        exception_tb = NULL;

        exception_lineno = 1254;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1254;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__general_names );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1257;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__general_names );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1257;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1257;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8bab69c94615c96edcfa248584419f98 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8bab69c94615c96edcfa248584419f98 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8bab69c94615c96edcfa248584419f98 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8bab69c94615c96edcfa248584419f98, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8bab69c94615c96edcfa248584419f98->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8bab69c94615c96edcfa248584419f98, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8bab69c94615c96edcfa248584419f98,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_8bab69c94615c96edcfa248584419f98 == cache_frame_8bab69c94615c96edcfa248584419f98 )
    {
        Py_DECREF( frame_8bab69c94615c96edcfa248584419f98 );
    }
    cache_frame_8bab69c94615c96edcfa248584419f98 = NULL;

    assertFrameObject( frame_8bab69c94615c96edcfa248584419f98 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_138___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_138___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_139___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_2799c6e1c293d05ed77773714e41415f = NULL;

    struct Nuitka_FrameObject *frame_2799c6e1c293d05ed77773714e41415f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2799c6e1c293d05ed77773714e41415f, codeobj_2799c6e1c293d05ed77773714e41415f, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_2799c6e1c293d05ed77773714e41415f = cache_frame_2799c6e1c293d05ed77773714e41415f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2799c6e1c293d05ed77773714e41415f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2799c6e1c293d05ed77773714e41415f ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1260;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1260;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2799c6e1c293d05ed77773714e41415f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2799c6e1c293d05ed77773714e41415f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2799c6e1c293d05ed77773714e41415f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2799c6e1c293d05ed77773714e41415f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2799c6e1c293d05ed77773714e41415f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2799c6e1c293d05ed77773714e41415f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2799c6e1c293d05ed77773714e41415f,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_2799c6e1c293d05ed77773714e41415f == cache_frame_2799c6e1c293d05ed77773714e41415f )
    {
        Py_DECREF( frame_2799c6e1c293d05ed77773714e41415f );
    }
    cache_frame_2799c6e1c293d05ed77773714e41415f = NULL;

    assertFrameObject( frame_2799c6e1c293d05ed77773714e41415f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_139___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_139___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_140___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_99466dbcc845cc7abe2836db2cfbf366 = NULL;

    struct Nuitka_FrameObject *frame_99466dbcc845cc7abe2836db2cfbf366;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_99466dbcc845cc7abe2836db2cfbf366, codeobj_99466dbcc845cc7abe2836db2cfbf366, module_cryptography$x509$extensions, sizeof(void *) );
    frame_99466dbcc845cc7abe2836db2cfbf366 = cache_frame_99466dbcc845cc7abe2836db2cfbf366;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_99466dbcc845cc7abe2836db2cfbf366 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_99466dbcc845cc7abe2836db2cfbf366 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_hash_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__general_names );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1263;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1263;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_99466dbcc845cc7abe2836db2cfbf366 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_99466dbcc845cc7abe2836db2cfbf366 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_99466dbcc845cc7abe2836db2cfbf366 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_99466dbcc845cc7abe2836db2cfbf366, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_99466dbcc845cc7abe2836db2cfbf366->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_99466dbcc845cc7abe2836db2cfbf366, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_99466dbcc845cc7abe2836db2cfbf366,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_99466dbcc845cc7abe2836db2cfbf366 == cache_frame_99466dbcc845cc7abe2836db2cfbf366 )
    {
        Py_DECREF( frame_99466dbcc845cc7abe2836db2cfbf366 );
    }
    cache_frame_99466dbcc845cc7abe2836db2cfbf366 = NULL;

    assertFrameObject( frame_99466dbcc845cc7abe2836db2cfbf366 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_140___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_140___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_141___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_general_names = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_869ca61483dae9badd586b13a5a2c497 = NULL;

    struct Nuitka_FrameObject *frame_869ca61483dae9badd586b13a5a2c497;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_869ca61483dae9badd586b13a5a2c497, codeobj_869ca61483dae9badd586b13a5a2c497, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_869ca61483dae9badd586b13a5a2c497 = cache_frame_869ca61483dae9badd586b13a5a2c497;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_869ca61483dae9badd586b13a5a2c497 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_869ca61483dae9badd586b13a5a2c497 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralNames );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralNames );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GeneralNames" );
        exception_tb = NULL;

        exception_lineno = 1271;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_general_names;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_869ca61483dae9badd586b13a5a2c497->m_frame.f_lineno = 1271;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1271;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__general_names, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1271;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_869ca61483dae9badd586b13a5a2c497 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_869ca61483dae9badd586b13a5a2c497 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_869ca61483dae9badd586b13a5a2c497, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_869ca61483dae9badd586b13a5a2c497->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_869ca61483dae9badd586b13a5a2c497, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_869ca61483dae9badd586b13a5a2c497,
        type_description_1,
        par_self,
        par_general_names
    );


    // Release cached frame.
    if ( frame_869ca61483dae9badd586b13a5a2c497 == cache_frame_869ca61483dae9badd586b13a5a2c497 )
    {
        Py_DECREF( frame_869ca61483dae9badd586b13a5a2c497 );
    }
    cache_frame_869ca61483dae9badd586b13a5a2c497 = NULL;

    assertFrameObject( frame_869ca61483dae9badd586b13a5a2c497 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_141___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_general_names );
    Py_DECREF( par_general_names );
    par_general_names = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_general_names );
    Py_DECREF( par_general_names );
    par_general_names = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_141___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_142_get_values_for_type( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_type = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_dfa357761ff8a2cf04a1e4591e6ba131 = NULL;

    struct Nuitka_FrameObject *frame_dfa357761ff8a2cf04a1e4591e6ba131;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dfa357761ff8a2cf04a1e4591e6ba131, codeobj_dfa357761ff8a2cf04a1e4591e6ba131, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_dfa357761ff8a2cf04a1e4591e6ba131 = cache_frame_dfa357761ff8a2cf04a1e4591e6ba131;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dfa357761ff8a2cf04a1e4591e6ba131 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dfa357761ff8a2cf04a1e4591e6ba131 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__general_names );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1276;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_type;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_dfa357761ff8a2cf04a1e4591e6ba131->m_frame.f_lineno = 1276;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_get_values_for_type, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1276;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dfa357761ff8a2cf04a1e4591e6ba131 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_dfa357761ff8a2cf04a1e4591e6ba131 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dfa357761ff8a2cf04a1e4591e6ba131 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dfa357761ff8a2cf04a1e4591e6ba131, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dfa357761ff8a2cf04a1e4591e6ba131->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dfa357761ff8a2cf04a1e4591e6ba131, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dfa357761ff8a2cf04a1e4591e6ba131,
        type_description_1,
        par_self,
        par_type
    );


    // Release cached frame.
    if ( frame_dfa357761ff8a2cf04a1e4591e6ba131 == cache_frame_dfa357761ff8a2cf04a1e4591e6ba131 )
    {
        Py_DECREF( frame_dfa357761ff8a2cf04a1e4591e6ba131 );
    }
    cache_frame_dfa357761ff8a2cf04a1e4591e6ba131 = NULL;

    assertFrameObject( frame_dfa357761ff8a2cf04a1e4591e6ba131 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_142_get_values_for_type );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_142_get_values_for_type );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_143___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_6e3008cfbd7ffcd179f9b62324e3d1b8 = NULL;

    struct Nuitka_FrameObject *frame_6e3008cfbd7ffcd179f9b62324e3d1b8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6e3008cfbd7ffcd179f9b62324e3d1b8, codeobj_6e3008cfbd7ffcd179f9b62324e3d1b8, module_cryptography$x509$extensions, sizeof(void *) );
    frame_6e3008cfbd7ffcd179f9b62324e3d1b8 = cache_frame_6e3008cfbd7ffcd179f9b62324e3d1b8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6e3008cfbd7ffcd179f9b62324e3d1b8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6e3008cfbd7ffcd179f9b62324e3d1b8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_afa42db89846e96e9cfc2ab56578058d;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__general_names );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1279;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_6e3008cfbd7ffcd179f9b62324e3d1b8->m_frame.f_lineno = 1279;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1279;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6e3008cfbd7ffcd179f9b62324e3d1b8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6e3008cfbd7ffcd179f9b62324e3d1b8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6e3008cfbd7ffcd179f9b62324e3d1b8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6e3008cfbd7ffcd179f9b62324e3d1b8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6e3008cfbd7ffcd179f9b62324e3d1b8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6e3008cfbd7ffcd179f9b62324e3d1b8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6e3008cfbd7ffcd179f9b62324e3d1b8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6e3008cfbd7ffcd179f9b62324e3d1b8 == cache_frame_6e3008cfbd7ffcd179f9b62324e3d1b8 )
    {
        Py_DECREF( frame_6e3008cfbd7ffcd179f9b62324e3d1b8 );
    }
    cache_frame_6e3008cfbd7ffcd179f9b62324e3d1b8 = NULL;

    assertFrameObject( frame_6e3008cfbd7ffcd179f9b62324e3d1b8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_143___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_143___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_144___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_d785c5a91161828fe66a1f09a8282ede = NULL;

    struct Nuitka_FrameObject *frame_d785c5a91161828fe66a1f09a8282ede;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d785c5a91161828fe66a1f09a8282ede, codeobj_d785c5a91161828fe66a1f09a8282ede, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_d785c5a91161828fe66a1f09a8282ede = cache_frame_d785c5a91161828fe66a1f09a8282ede;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d785c5a91161828fe66a1f09a8282ede );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d785c5a91161828fe66a1f09a8282ede ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_IssuerAlternativeName );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IssuerAlternativeName );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "IssuerAlternativeName" );
        exception_tb = NULL;

        exception_lineno = 1282;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1282;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__general_names );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1285;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__general_names );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1285;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1285;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d785c5a91161828fe66a1f09a8282ede );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d785c5a91161828fe66a1f09a8282ede );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d785c5a91161828fe66a1f09a8282ede );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d785c5a91161828fe66a1f09a8282ede, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d785c5a91161828fe66a1f09a8282ede->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d785c5a91161828fe66a1f09a8282ede, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d785c5a91161828fe66a1f09a8282ede,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_d785c5a91161828fe66a1f09a8282ede == cache_frame_d785c5a91161828fe66a1f09a8282ede )
    {
        Py_DECREF( frame_d785c5a91161828fe66a1f09a8282ede );
    }
    cache_frame_d785c5a91161828fe66a1f09a8282ede = NULL;

    assertFrameObject( frame_d785c5a91161828fe66a1f09a8282ede );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_144___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_144___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_145___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_5ce4859f79d64aac185e077923698816 = NULL;

    struct Nuitka_FrameObject *frame_5ce4859f79d64aac185e077923698816;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5ce4859f79d64aac185e077923698816, codeobj_5ce4859f79d64aac185e077923698816, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_5ce4859f79d64aac185e077923698816 = cache_frame_5ce4859f79d64aac185e077923698816;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5ce4859f79d64aac185e077923698816 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5ce4859f79d64aac185e077923698816 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1288;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1288;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ce4859f79d64aac185e077923698816 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ce4859f79d64aac185e077923698816 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ce4859f79d64aac185e077923698816 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5ce4859f79d64aac185e077923698816, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5ce4859f79d64aac185e077923698816->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5ce4859f79d64aac185e077923698816, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5ce4859f79d64aac185e077923698816,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_5ce4859f79d64aac185e077923698816 == cache_frame_5ce4859f79d64aac185e077923698816 )
    {
        Py_DECREF( frame_5ce4859f79d64aac185e077923698816 );
    }
    cache_frame_5ce4859f79d64aac185e077923698816 = NULL;

    assertFrameObject( frame_5ce4859f79d64aac185e077923698816 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_145___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_145___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_146___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_9bff6aba8635fc588ed756614cb17cb8 = NULL;

    struct Nuitka_FrameObject *frame_9bff6aba8635fc588ed756614cb17cb8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9bff6aba8635fc588ed756614cb17cb8, codeobj_9bff6aba8635fc588ed756614cb17cb8, module_cryptography$x509$extensions, sizeof(void *) );
    frame_9bff6aba8635fc588ed756614cb17cb8 = cache_frame_9bff6aba8635fc588ed756614cb17cb8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9bff6aba8635fc588ed756614cb17cb8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9bff6aba8635fc588ed756614cb17cb8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_hash_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__general_names );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1291;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1291;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9bff6aba8635fc588ed756614cb17cb8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9bff6aba8635fc588ed756614cb17cb8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9bff6aba8635fc588ed756614cb17cb8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9bff6aba8635fc588ed756614cb17cb8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9bff6aba8635fc588ed756614cb17cb8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9bff6aba8635fc588ed756614cb17cb8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9bff6aba8635fc588ed756614cb17cb8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_9bff6aba8635fc588ed756614cb17cb8 == cache_frame_9bff6aba8635fc588ed756614cb17cb8 )
    {
        Py_DECREF( frame_9bff6aba8635fc588ed756614cb17cb8 );
    }
    cache_frame_9bff6aba8635fc588ed756614cb17cb8 = NULL;

    assertFrameObject( frame_9bff6aba8635fc588ed756614cb17cb8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_146___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_146___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_147___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_general_names = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_41d2fca2c6d1a037a39bc7c2cae9471c = NULL;

    struct Nuitka_FrameObject *frame_41d2fca2c6d1a037a39bc7c2cae9471c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_41d2fca2c6d1a037a39bc7c2cae9471c, codeobj_41d2fca2c6d1a037a39bc7c2cae9471c, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_41d2fca2c6d1a037a39bc7c2cae9471c = cache_frame_41d2fca2c6d1a037a39bc7c2cae9471c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_41d2fca2c6d1a037a39bc7c2cae9471c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_41d2fca2c6d1a037a39bc7c2cae9471c ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralNames );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralNames );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GeneralNames" );
        exception_tb = NULL;

        exception_lineno = 1299;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_general_names;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_41d2fca2c6d1a037a39bc7c2cae9471c->m_frame.f_lineno = 1299;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1299;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__general_names, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1299;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_41d2fca2c6d1a037a39bc7c2cae9471c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_41d2fca2c6d1a037a39bc7c2cae9471c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_41d2fca2c6d1a037a39bc7c2cae9471c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_41d2fca2c6d1a037a39bc7c2cae9471c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_41d2fca2c6d1a037a39bc7c2cae9471c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_41d2fca2c6d1a037a39bc7c2cae9471c,
        type_description_1,
        par_self,
        par_general_names
    );


    // Release cached frame.
    if ( frame_41d2fca2c6d1a037a39bc7c2cae9471c == cache_frame_41d2fca2c6d1a037a39bc7c2cae9471c )
    {
        Py_DECREF( frame_41d2fca2c6d1a037a39bc7c2cae9471c );
    }
    cache_frame_41d2fca2c6d1a037a39bc7c2cae9471c = NULL;

    assertFrameObject( frame_41d2fca2c6d1a037a39bc7c2cae9471c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_147___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_general_names );
    Py_DECREF( par_general_names );
    par_general_names = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_general_names );
    Py_DECREF( par_general_names );
    par_general_names = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_147___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_148_get_values_for_type( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_type = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_6cf10bf052c6bf6b809820f2dbf45aec = NULL;

    struct Nuitka_FrameObject *frame_6cf10bf052c6bf6b809820f2dbf45aec;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6cf10bf052c6bf6b809820f2dbf45aec, codeobj_6cf10bf052c6bf6b809820f2dbf45aec, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_6cf10bf052c6bf6b809820f2dbf45aec = cache_frame_6cf10bf052c6bf6b809820f2dbf45aec;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6cf10bf052c6bf6b809820f2dbf45aec );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6cf10bf052c6bf6b809820f2dbf45aec ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__general_names );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1304;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_type;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_6cf10bf052c6bf6b809820f2dbf45aec->m_frame.f_lineno = 1304;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_get_values_for_type, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1304;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6cf10bf052c6bf6b809820f2dbf45aec );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6cf10bf052c6bf6b809820f2dbf45aec );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6cf10bf052c6bf6b809820f2dbf45aec );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6cf10bf052c6bf6b809820f2dbf45aec, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6cf10bf052c6bf6b809820f2dbf45aec->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6cf10bf052c6bf6b809820f2dbf45aec, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6cf10bf052c6bf6b809820f2dbf45aec,
        type_description_1,
        par_self,
        par_type
    );


    // Release cached frame.
    if ( frame_6cf10bf052c6bf6b809820f2dbf45aec == cache_frame_6cf10bf052c6bf6b809820f2dbf45aec )
    {
        Py_DECREF( frame_6cf10bf052c6bf6b809820f2dbf45aec );
    }
    cache_frame_6cf10bf052c6bf6b809820f2dbf45aec = NULL;

    assertFrameObject( frame_6cf10bf052c6bf6b809820f2dbf45aec );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_148_get_values_for_type );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_148_get_values_for_type );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_149___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_c676f56e52e36e7b954928a8cf5ae824 = NULL;

    struct Nuitka_FrameObject *frame_c676f56e52e36e7b954928a8cf5ae824;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c676f56e52e36e7b954928a8cf5ae824, codeobj_c676f56e52e36e7b954928a8cf5ae824, module_cryptography$x509$extensions, sizeof(void *) );
    frame_c676f56e52e36e7b954928a8cf5ae824 = cache_frame_c676f56e52e36e7b954928a8cf5ae824;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c676f56e52e36e7b954928a8cf5ae824 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c676f56e52e36e7b954928a8cf5ae824 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_2a0138f3ee2cd707fb386e46f1612821;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__general_names );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1307;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_c676f56e52e36e7b954928a8cf5ae824->m_frame.f_lineno = 1307;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1307;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c676f56e52e36e7b954928a8cf5ae824 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c676f56e52e36e7b954928a8cf5ae824 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c676f56e52e36e7b954928a8cf5ae824 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c676f56e52e36e7b954928a8cf5ae824, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c676f56e52e36e7b954928a8cf5ae824->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c676f56e52e36e7b954928a8cf5ae824, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c676f56e52e36e7b954928a8cf5ae824,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_c676f56e52e36e7b954928a8cf5ae824 == cache_frame_c676f56e52e36e7b954928a8cf5ae824 )
    {
        Py_DECREF( frame_c676f56e52e36e7b954928a8cf5ae824 );
    }
    cache_frame_c676f56e52e36e7b954928a8cf5ae824 = NULL;

    assertFrameObject( frame_c676f56e52e36e7b954928a8cf5ae824 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_149___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_149___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_150___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_42aded348931584374c6be3e26f3a62e = NULL;

    struct Nuitka_FrameObject *frame_42aded348931584374c6be3e26f3a62e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_42aded348931584374c6be3e26f3a62e, codeobj_42aded348931584374c6be3e26f3a62e, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_42aded348931584374c6be3e26f3a62e = cache_frame_42aded348931584374c6be3e26f3a62e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_42aded348931584374c6be3e26f3a62e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_42aded348931584374c6be3e26f3a62e ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CertificateIssuer );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CertificateIssuer );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "CertificateIssuer" );
        exception_tb = NULL;

        exception_lineno = 1310;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1310;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__general_names );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1313;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__general_names );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1313;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1313;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_42aded348931584374c6be3e26f3a62e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_42aded348931584374c6be3e26f3a62e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_42aded348931584374c6be3e26f3a62e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_42aded348931584374c6be3e26f3a62e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_42aded348931584374c6be3e26f3a62e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_42aded348931584374c6be3e26f3a62e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_42aded348931584374c6be3e26f3a62e,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_42aded348931584374c6be3e26f3a62e == cache_frame_42aded348931584374c6be3e26f3a62e )
    {
        Py_DECREF( frame_42aded348931584374c6be3e26f3a62e );
    }
    cache_frame_42aded348931584374c6be3e26f3a62e = NULL;

    assertFrameObject( frame_42aded348931584374c6be3e26f3a62e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_150___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_150___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_151___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_4e01197d0e4e4c79cdf2d327dc689777 = NULL;

    struct Nuitka_FrameObject *frame_4e01197d0e4e4c79cdf2d327dc689777;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4e01197d0e4e4c79cdf2d327dc689777, codeobj_4e01197d0e4e4c79cdf2d327dc689777, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_4e01197d0e4e4c79cdf2d327dc689777 = cache_frame_4e01197d0e4e4c79cdf2d327dc689777;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4e01197d0e4e4c79cdf2d327dc689777 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4e01197d0e4e4c79cdf2d327dc689777 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1316;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1316;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4e01197d0e4e4c79cdf2d327dc689777 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4e01197d0e4e4c79cdf2d327dc689777 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4e01197d0e4e4c79cdf2d327dc689777 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4e01197d0e4e4c79cdf2d327dc689777, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4e01197d0e4e4c79cdf2d327dc689777->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4e01197d0e4e4c79cdf2d327dc689777, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4e01197d0e4e4c79cdf2d327dc689777,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_4e01197d0e4e4c79cdf2d327dc689777 == cache_frame_4e01197d0e4e4c79cdf2d327dc689777 )
    {
        Py_DECREF( frame_4e01197d0e4e4c79cdf2d327dc689777 );
    }
    cache_frame_4e01197d0e4e4c79cdf2d327dc689777 = NULL;

    assertFrameObject( frame_4e01197d0e4e4c79cdf2d327dc689777 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_151___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_151___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_152___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_05417fe8f5b9303ade0d507b76aed4e3 = NULL;

    struct Nuitka_FrameObject *frame_05417fe8f5b9303ade0d507b76aed4e3;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_05417fe8f5b9303ade0d507b76aed4e3, codeobj_05417fe8f5b9303ade0d507b76aed4e3, module_cryptography$x509$extensions, sizeof(void *) );
    frame_05417fe8f5b9303ade0d507b76aed4e3 = cache_frame_05417fe8f5b9303ade0d507b76aed4e3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_05417fe8f5b9303ade0d507b76aed4e3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_05417fe8f5b9303ade0d507b76aed4e3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_hash_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__general_names );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1319;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1319;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_05417fe8f5b9303ade0d507b76aed4e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_05417fe8f5b9303ade0d507b76aed4e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_05417fe8f5b9303ade0d507b76aed4e3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_05417fe8f5b9303ade0d507b76aed4e3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_05417fe8f5b9303ade0d507b76aed4e3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_05417fe8f5b9303ade0d507b76aed4e3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_05417fe8f5b9303ade0d507b76aed4e3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_05417fe8f5b9303ade0d507b76aed4e3 == cache_frame_05417fe8f5b9303ade0d507b76aed4e3 )
    {
        Py_DECREF( frame_05417fe8f5b9303ade0d507b76aed4e3 );
    }
    cache_frame_05417fe8f5b9303ade0d507b76aed4e3 = NULL;

    assertFrameObject( frame_05417fe8f5b9303ade0d507b76aed4e3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_152___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_152___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_153___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_reason = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_f7221220b795ab66d7e03e36dcbe8593 = NULL;

    struct Nuitka_FrameObject *frame_f7221220b795ab66d7e03e36dcbe8593;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f7221220b795ab66d7e03e36dcbe8593, codeobj_f7221220b795ab66d7e03e36dcbe8593, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_f7221220b795ab66d7e03e36dcbe8593 = cache_frame_f7221220b795ab66d7e03e36dcbe8593;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f7221220b795ab66d7e03e36dcbe8593 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f7221220b795ab66d7e03e36dcbe8593 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_reason;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ReasonFlags" );
        exception_tb = NULL;

        exception_lineno = 1327;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1327;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_d04c4a4e63138db9ecc900ec9847717c;
    frame_f7221220b795ab66d7e03e36dcbe8593->m_frame.f_lineno = 1328;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1328;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_reason;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__reason, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1330;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f7221220b795ab66d7e03e36dcbe8593 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f7221220b795ab66d7e03e36dcbe8593 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f7221220b795ab66d7e03e36dcbe8593, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f7221220b795ab66d7e03e36dcbe8593->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f7221220b795ab66d7e03e36dcbe8593, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f7221220b795ab66d7e03e36dcbe8593,
        type_description_1,
        par_self,
        par_reason
    );


    // Release cached frame.
    if ( frame_f7221220b795ab66d7e03e36dcbe8593 == cache_frame_f7221220b795ab66d7e03e36dcbe8593 )
    {
        Py_DECREF( frame_f7221220b795ab66d7e03e36dcbe8593 );
    }
    cache_frame_f7221220b795ab66d7e03e36dcbe8593 = NULL;

    assertFrameObject( frame_f7221220b795ab66d7e03e36dcbe8593 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_153___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_reason );
    Py_DECREF( par_reason );
    par_reason = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_reason );
    Py_DECREF( par_reason );
    par_reason = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_153___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_154___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_09be14c4282cabf6b9e19a783dec5f1b = NULL;

    struct Nuitka_FrameObject *frame_09be14c4282cabf6b9e19a783dec5f1b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_09be14c4282cabf6b9e19a783dec5f1b, codeobj_09be14c4282cabf6b9e19a783dec5f1b, module_cryptography$x509$extensions, sizeof(void *) );
    frame_09be14c4282cabf6b9e19a783dec5f1b = cache_frame_09be14c4282cabf6b9e19a783dec5f1b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_09be14c4282cabf6b9e19a783dec5f1b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_09be14c4282cabf6b9e19a783dec5f1b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_73d50e8900e7f2ac40a53b664096aa15;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__reason );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1333;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_09be14c4282cabf6b9e19a783dec5f1b->m_frame.f_lineno = 1333;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1333;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_09be14c4282cabf6b9e19a783dec5f1b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_09be14c4282cabf6b9e19a783dec5f1b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_09be14c4282cabf6b9e19a783dec5f1b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_09be14c4282cabf6b9e19a783dec5f1b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_09be14c4282cabf6b9e19a783dec5f1b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_09be14c4282cabf6b9e19a783dec5f1b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_09be14c4282cabf6b9e19a783dec5f1b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_09be14c4282cabf6b9e19a783dec5f1b == cache_frame_09be14c4282cabf6b9e19a783dec5f1b )
    {
        Py_DECREF( frame_09be14c4282cabf6b9e19a783dec5f1b );
    }
    cache_frame_09be14c4282cabf6b9e19a783dec5f1b = NULL;

    assertFrameObject( frame_09be14c4282cabf6b9e19a783dec5f1b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_154___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_154___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_155___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_a4f747c1a224ef94ef7f9cf43f8c3230 = NULL;

    struct Nuitka_FrameObject *frame_a4f747c1a224ef94ef7f9cf43f8c3230;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a4f747c1a224ef94ef7f9cf43f8c3230, codeobj_a4f747c1a224ef94ef7f9cf43f8c3230, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_a4f747c1a224ef94ef7f9cf43f8c3230 = cache_frame_a4f747c1a224ef94ef7f9cf43f8c3230;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a4f747c1a224ef94ef7f9cf43f8c3230 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a4f747c1a224ef94ef7f9cf43f8c3230 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLReason );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CRLReason );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "CRLReason" );
        exception_tb = NULL;

        exception_lineno = 1336;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1336;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_reason );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1339;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_reason );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1339;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1339;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a4f747c1a224ef94ef7f9cf43f8c3230 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a4f747c1a224ef94ef7f9cf43f8c3230 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a4f747c1a224ef94ef7f9cf43f8c3230 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a4f747c1a224ef94ef7f9cf43f8c3230, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a4f747c1a224ef94ef7f9cf43f8c3230->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a4f747c1a224ef94ef7f9cf43f8c3230, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a4f747c1a224ef94ef7f9cf43f8c3230,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_a4f747c1a224ef94ef7f9cf43f8c3230 == cache_frame_a4f747c1a224ef94ef7f9cf43f8c3230 )
    {
        Py_DECREF( frame_a4f747c1a224ef94ef7f9cf43f8c3230 );
    }
    cache_frame_a4f747c1a224ef94ef7f9cf43f8c3230 = NULL;

    assertFrameObject( frame_a4f747c1a224ef94ef7f9cf43f8c3230 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_155___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_155___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_156___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee = NULL;

    struct Nuitka_FrameObject *frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee, codeobj_8f443af4d4ccb5dbf9dc156cb2a6b3ee, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee = cache_frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1342;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1342;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee == cache_frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee )
    {
        Py_DECREF( frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee );
    }
    cache_frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee = NULL;

    assertFrameObject( frame_8f443af4d4ccb5dbf9dc156cb2a6b3ee );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_156___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_156___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_157___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b = NULL;

    struct Nuitka_FrameObject *frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b, codeobj_8e0b8ffe2152f7bb061afe1b8cc2cf5b, module_cryptography$x509$extensions, sizeof(void *) );
    frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b = cache_frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_hash_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_reason );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1345;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1345;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b == cache_frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b )
    {
        Py_DECREF( frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b );
    }
    cache_frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b = NULL;

    assertFrameObject( frame_8e0b8ffe2152f7bb061afe1b8cc2cf5b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_157___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_157___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_158___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_invalidity_date = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_6f138dddb9068ed9deb97d66f8a4a0ad = NULL;

    struct Nuitka_FrameObject *frame_6f138dddb9068ed9deb97d66f8a4a0ad;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6f138dddb9068ed9deb97d66f8a4a0ad, codeobj_6f138dddb9068ed9deb97d66f8a4a0ad, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_6f138dddb9068ed9deb97d66f8a4a0ad = cache_frame_6f138dddb9068ed9deb97d66f8a4a0ad;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6f138dddb9068ed9deb97d66f8a4a0ad );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6f138dddb9068ed9deb97d66f8a4a0ad ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_invalidity_date;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_datetime );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_datetime );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "datetime" );
        exception_tb = NULL;

        exception_lineno = 1355;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_datetime );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1355;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1355;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_91034dde8ef1b9b2896e23f094ab68ec;
    frame_6f138dddb9068ed9deb97d66f8a4a0ad->m_frame.f_lineno = 1356;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1356;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_invalidity_date;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__invalidity_date, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1358;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f138dddb9068ed9deb97d66f8a4a0ad );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f138dddb9068ed9deb97d66f8a4a0ad );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6f138dddb9068ed9deb97d66f8a4a0ad, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6f138dddb9068ed9deb97d66f8a4a0ad->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6f138dddb9068ed9deb97d66f8a4a0ad, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6f138dddb9068ed9deb97d66f8a4a0ad,
        type_description_1,
        par_self,
        par_invalidity_date
    );


    // Release cached frame.
    if ( frame_6f138dddb9068ed9deb97d66f8a4a0ad == cache_frame_6f138dddb9068ed9deb97d66f8a4a0ad )
    {
        Py_DECREF( frame_6f138dddb9068ed9deb97d66f8a4a0ad );
    }
    cache_frame_6f138dddb9068ed9deb97d66f8a4a0ad = NULL;

    assertFrameObject( frame_6f138dddb9068ed9deb97d66f8a4a0ad );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_158___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_invalidity_date );
    Py_DECREF( par_invalidity_date );
    par_invalidity_date = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_invalidity_date );
    Py_DECREF( par_invalidity_date );
    par_invalidity_date = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_158___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_159___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_ed63b3fd75ae09f84d1ac8d724b0892b = NULL;

    struct Nuitka_FrameObject *frame_ed63b3fd75ae09f84d1ac8d724b0892b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ed63b3fd75ae09f84d1ac8d724b0892b, codeobj_ed63b3fd75ae09f84d1ac8d724b0892b, module_cryptography$x509$extensions, sizeof(void *) );
    frame_ed63b3fd75ae09f84d1ac8d724b0892b = cache_frame_ed63b3fd75ae09f84d1ac8d724b0892b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ed63b3fd75ae09f84d1ac8d724b0892b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ed63b3fd75ae09f84d1ac8d724b0892b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_2e6a7667e25628285e79573956cb938f;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__invalidity_date );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1362;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_ed63b3fd75ae09f84d1ac8d724b0892b->m_frame.f_lineno = 1361;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1361;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ed63b3fd75ae09f84d1ac8d724b0892b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ed63b3fd75ae09f84d1ac8d724b0892b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ed63b3fd75ae09f84d1ac8d724b0892b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ed63b3fd75ae09f84d1ac8d724b0892b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ed63b3fd75ae09f84d1ac8d724b0892b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ed63b3fd75ae09f84d1ac8d724b0892b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ed63b3fd75ae09f84d1ac8d724b0892b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ed63b3fd75ae09f84d1ac8d724b0892b == cache_frame_ed63b3fd75ae09f84d1ac8d724b0892b )
    {
        Py_DECREF( frame_ed63b3fd75ae09f84d1ac8d724b0892b );
    }
    cache_frame_ed63b3fd75ae09f84d1ac8d724b0892b = NULL;

    assertFrameObject( frame_ed63b3fd75ae09f84d1ac8d724b0892b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_159___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_159___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_160___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_723e5289641b14306ae87c96d0c461c6 = NULL;

    struct Nuitka_FrameObject *frame_723e5289641b14306ae87c96d0c461c6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_723e5289641b14306ae87c96d0c461c6, codeobj_723e5289641b14306ae87c96d0c461c6, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_723e5289641b14306ae87c96d0c461c6 = cache_frame_723e5289641b14306ae87c96d0c461c6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_723e5289641b14306ae87c96d0c461c6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_723e5289641b14306ae87c96d0c461c6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_InvalidityDate );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_InvalidityDate );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "InvalidityDate" );
        exception_tb = NULL;

        exception_lineno = 1366;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1366;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_invalidity_date );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1369;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_invalidity_date );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1369;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1369;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_723e5289641b14306ae87c96d0c461c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_723e5289641b14306ae87c96d0c461c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_723e5289641b14306ae87c96d0c461c6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_723e5289641b14306ae87c96d0c461c6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_723e5289641b14306ae87c96d0c461c6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_723e5289641b14306ae87c96d0c461c6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_723e5289641b14306ae87c96d0c461c6,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_723e5289641b14306ae87c96d0c461c6 == cache_frame_723e5289641b14306ae87c96d0c461c6 )
    {
        Py_DECREF( frame_723e5289641b14306ae87c96d0c461c6 );
    }
    cache_frame_723e5289641b14306ae87c96d0c461c6 = NULL;

    assertFrameObject( frame_723e5289641b14306ae87c96d0c461c6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_160___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_160___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_161___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_2546b3ff0691355f96b84825af8536c7 = NULL;

    struct Nuitka_FrameObject *frame_2546b3ff0691355f96b84825af8536c7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2546b3ff0691355f96b84825af8536c7, codeobj_2546b3ff0691355f96b84825af8536c7, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_2546b3ff0691355f96b84825af8536c7 = cache_frame_2546b3ff0691355f96b84825af8536c7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2546b3ff0691355f96b84825af8536c7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2546b3ff0691355f96b84825af8536c7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1372;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1372;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2546b3ff0691355f96b84825af8536c7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2546b3ff0691355f96b84825af8536c7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2546b3ff0691355f96b84825af8536c7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2546b3ff0691355f96b84825af8536c7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2546b3ff0691355f96b84825af8536c7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2546b3ff0691355f96b84825af8536c7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2546b3ff0691355f96b84825af8536c7,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_2546b3ff0691355f96b84825af8536c7 == cache_frame_2546b3ff0691355f96b84825af8536c7 )
    {
        Py_DECREF( frame_2546b3ff0691355f96b84825af8536c7 );
    }
    cache_frame_2546b3ff0691355f96b84825af8536c7 = NULL;

    assertFrameObject( frame_2546b3ff0691355f96b84825af8536c7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_161___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_161___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_162___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_501ff7d581b05da1d05a86fe0ad85a96 = NULL;

    struct Nuitka_FrameObject *frame_501ff7d581b05da1d05a86fe0ad85a96;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_501ff7d581b05da1d05a86fe0ad85a96, codeobj_501ff7d581b05da1d05a86fe0ad85a96, module_cryptography$x509$extensions, sizeof(void *) );
    frame_501ff7d581b05da1d05a86fe0ad85a96 = cache_frame_501ff7d581b05da1d05a86fe0ad85a96;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_501ff7d581b05da1d05a86fe0ad85a96 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_501ff7d581b05da1d05a86fe0ad85a96 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_hash_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_invalidity_date );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1375;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1375;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_501ff7d581b05da1d05a86fe0ad85a96 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_501ff7d581b05da1d05a86fe0ad85a96 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_501ff7d581b05da1d05a86fe0ad85a96 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_501ff7d581b05da1d05a86fe0ad85a96, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_501ff7d581b05da1d05a86fe0ad85a96->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_501ff7d581b05da1d05a86fe0ad85a96, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_501ff7d581b05da1d05a86fe0ad85a96,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_501ff7d581b05da1d05a86fe0ad85a96 == cache_frame_501ff7d581b05da1d05a86fe0ad85a96 )
    {
        Py_DECREF( frame_501ff7d581b05da1d05a86fe0ad85a96 );
    }
    cache_frame_501ff7d581b05da1d05a86fe0ad85a96 = NULL;

    assertFrameObject( frame_501ff7d581b05da1d05a86fe0ad85a96 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_162___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_162___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_163___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_signed_certificate_timestamps = python_pars[ 1 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_cdd83968b5926d20e2e7b9ca4d0b58f0 = NULL;

    struct Nuitka_FrameObject *frame_cdd83968b5926d20e2e7b9ca4d0b58f0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cdd83968b5926d20e2e7b9ca4d0b58f0, codeobj_cdd83968b5926d20e2e7b9ca4d0b58f0, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_cdd83968b5926d20e2e7b9ca4d0b58f0 = cache_frame_cdd83968b5926d20e2e7b9ca4d0b58f0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cdd83968b5926d20e2e7b9ca4d0b58f0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cdd83968b5926d20e2e7b9ca4d0b58f0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_list_arg_1 = par_signed_certificate_timestamps;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1385;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_signed_certificate_timestamps;
        assert( old != NULL );
        par_signed_certificate_timestamps = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_signed_certificate_timestamps;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1387;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_163___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_81a666e8d664204b6485ad520243bcb4,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_163___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_163___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_cdd83968b5926d20e2e7b9ca4d0b58f0->m_frame.f_lineno = 1386;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1386;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1386;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_d3e161c72eca6237cebf732e747f2482;
    frame_cdd83968b5926d20e2e7b9ca4d0b58f0->m_frame.f_lineno = 1390;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1390;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_signed_certificate_timestamps;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__signed_certificate_timestamps, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1394;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cdd83968b5926d20e2e7b9ca4d0b58f0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cdd83968b5926d20e2e7b9ca4d0b58f0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cdd83968b5926d20e2e7b9ca4d0b58f0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cdd83968b5926d20e2e7b9ca4d0b58f0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cdd83968b5926d20e2e7b9ca4d0b58f0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cdd83968b5926d20e2e7b9ca4d0b58f0,
        type_description_1,
        par_self,
        par_signed_certificate_timestamps
    );


    // Release cached frame.
    if ( frame_cdd83968b5926d20e2e7b9ca4d0b58f0 == cache_frame_cdd83968b5926d20e2e7b9ca4d0b58f0 )
    {
        Py_DECREF( frame_cdd83968b5926d20e2e7b9ca4d0b58f0 );
    }
    cache_frame_cdd83968b5926d20e2e7b9ca4d0b58f0 = NULL;

    assertFrameObject( frame_cdd83968b5926d20e2e7b9ca4d0b58f0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_163___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_signed_certificate_timestamps );
    Py_DECREF( par_signed_certificate_timestamps );
    par_signed_certificate_timestamps = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_signed_certificate_timestamps );
    Py_DECREF( par_signed_certificate_timestamps );
    par_signed_certificate_timestamps = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_163___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_163___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_sct
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_163___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_163___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_sct = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_81a666e8d664204b6485ad520243bcb4, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 1387;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1387;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_sct;
        var_sct = tmp_assign_source_2;
        Py_INCREF( var_sct );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_sct;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SignedCertificateTimestamp );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SignedCertificateTimestamp );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "SignedCertificateTimestamp" );
        exception_tb = NULL;

        exception_lineno = 1387;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1387;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1387;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1387;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_sct
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_sct );
    var_sct = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_sct );
    var_sct = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_164___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_30db93ecd5f2bde29ae55c0d5f3ae202 = NULL;

    struct Nuitka_FrameObject *frame_30db93ecd5f2bde29ae55c0d5f3ae202;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_30db93ecd5f2bde29ae55c0d5f3ae202, codeobj_30db93ecd5f2bde29ae55c0d5f3ae202, module_cryptography$x509$extensions, sizeof(void *) );
    frame_30db93ecd5f2bde29ae55c0d5f3ae202 = cache_frame_30db93ecd5f2bde29ae55c0d5f3ae202;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_30db93ecd5f2bde29ae55c0d5f3ae202 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_30db93ecd5f2bde29ae55c0d5f3ae202 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_digest_171541ce3e17f273a42b3961194a7b72;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( tmp_called_name_1 != NULL );
    tmp_list_arg_1 = par_self;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_args_element_name_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1403;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_30db93ecd5f2bde29ae55c0d5f3ae202->m_frame.f_lineno = 1402;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1402;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_30db93ecd5f2bde29ae55c0d5f3ae202 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_30db93ecd5f2bde29ae55c0d5f3ae202 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_30db93ecd5f2bde29ae55c0d5f3ae202 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_30db93ecd5f2bde29ae55c0d5f3ae202, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_30db93ecd5f2bde29ae55c0d5f3ae202->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_30db93ecd5f2bde29ae55c0d5f3ae202, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_30db93ecd5f2bde29ae55c0d5f3ae202,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_30db93ecd5f2bde29ae55c0d5f3ae202 == cache_frame_30db93ecd5f2bde29ae55c0d5f3ae202 )
    {
        Py_DECREF( frame_30db93ecd5f2bde29ae55c0d5f3ae202 );
    }
    cache_frame_30db93ecd5f2bde29ae55c0d5f3ae202 = NULL;

    assertFrameObject( frame_30db93ecd5f2bde29ae55c0d5f3ae202 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_164___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_164___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_165___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_arg_1;
    static struct Nuitka_FrameObject *cache_frame_777c5f1cf0e58ad143e7d4d1541f3a9b = NULL;

    struct Nuitka_FrameObject *frame_777c5f1cf0e58ad143e7d4d1541f3a9b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_777c5f1cf0e58ad143e7d4d1541f3a9b, codeobj_777c5f1cf0e58ad143e7d4d1541f3a9b, module_cryptography$x509$extensions, sizeof(void *) );
    frame_777c5f1cf0e58ad143e7d4d1541f3a9b = cache_frame_777c5f1cf0e58ad143e7d4d1541f3a9b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_777c5f1cf0e58ad143e7d4d1541f3a9b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_777c5f1cf0e58ad143e7d4d1541f3a9b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__signed_certificate_timestamps );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1408;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_hash_arg_1 = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1408;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1408;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_777c5f1cf0e58ad143e7d4d1541f3a9b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_777c5f1cf0e58ad143e7d4d1541f3a9b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_777c5f1cf0e58ad143e7d4d1541f3a9b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_777c5f1cf0e58ad143e7d4d1541f3a9b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_777c5f1cf0e58ad143e7d4d1541f3a9b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_777c5f1cf0e58ad143e7d4d1541f3a9b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_777c5f1cf0e58ad143e7d4d1541f3a9b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_777c5f1cf0e58ad143e7d4d1541f3a9b == cache_frame_777c5f1cf0e58ad143e7d4d1541f3a9b )
    {
        Py_DECREF( frame_777c5f1cf0e58ad143e7d4d1541f3a9b );
    }
    cache_frame_777c5f1cf0e58ad143e7d4d1541f3a9b = NULL;

    assertFrameObject( frame_777c5f1cf0e58ad143e7d4d1541f3a9b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_165___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_165___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_166___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_7346d97a6acf28e8393536b873af6c89 = NULL;

    struct Nuitka_FrameObject *frame_7346d97a6acf28e8393536b873af6c89;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7346d97a6acf28e8393536b873af6c89, codeobj_7346d97a6acf28e8393536b873af6c89, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_7346d97a6acf28e8393536b873af6c89 = cache_frame_7346d97a6acf28e8393536b873af6c89;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7346d97a6acf28e8393536b873af6c89 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7346d97a6acf28e8393536b873af6c89 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_digest_97ac982b098bfd0facb64df38773c335 );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_digest_97ac982b098bfd0facb64df38773c335 );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PrecertificateSignedCertificateTimestamps" );
        exception_tb = NULL;

        exception_lineno = 1411;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1411;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__signed_certificate_timestamps );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1415;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__signed_certificate_timestamps );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1416;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1415;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7346d97a6acf28e8393536b873af6c89 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7346d97a6acf28e8393536b873af6c89 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7346d97a6acf28e8393536b873af6c89 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7346d97a6acf28e8393536b873af6c89, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7346d97a6acf28e8393536b873af6c89->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7346d97a6acf28e8393536b873af6c89, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7346d97a6acf28e8393536b873af6c89,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_7346d97a6acf28e8393536b873af6c89 == cache_frame_7346d97a6acf28e8393536b873af6c89 )
    {
        Py_DECREF( frame_7346d97a6acf28e8393536b873af6c89 );
    }
    cache_frame_7346d97a6acf28e8393536b873af6c89 = NULL;

    assertFrameObject( frame_7346d97a6acf28e8393536b873af6c89 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_166___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_166___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_167___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_3a5102eb577fb4372f9d34ba72a6e91e = NULL;

    struct Nuitka_FrameObject *frame_3a5102eb577fb4372f9d34ba72a6e91e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3a5102eb577fb4372f9d34ba72a6e91e, codeobj_3a5102eb577fb4372f9d34ba72a6e91e, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_3a5102eb577fb4372f9d34ba72a6e91e = cache_frame_3a5102eb577fb4372f9d34ba72a6e91e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3a5102eb577fb4372f9d34ba72a6e91e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3a5102eb577fb4372f9d34ba72a6e91e ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1420;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1420;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3a5102eb577fb4372f9d34ba72a6e91e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3a5102eb577fb4372f9d34ba72a6e91e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3a5102eb577fb4372f9d34ba72a6e91e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3a5102eb577fb4372f9d34ba72a6e91e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3a5102eb577fb4372f9d34ba72a6e91e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3a5102eb577fb4372f9d34ba72a6e91e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3a5102eb577fb4372f9d34ba72a6e91e,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_3a5102eb577fb4372f9d34ba72a6e91e == cache_frame_3a5102eb577fb4372f9d34ba72a6e91e )
    {
        Py_DECREF( frame_3a5102eb577fb4372f9d34ba72a6e91e );
    }
    cache_frame_3a5102eb577fb4372f9d34ba72a6e91e = NULL;

    assertFrameObject( frame_3a5102eb577fb4372f9d34ba72a6e91e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_167___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_167___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_168___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_nonce = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_c98d790ca6223d6a3644d33bd2467526 = NULL;

    struct Nuitka_FrameObject *frame_c98d790ca6223d6a3644d33bd2467526;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c98d790ca6223d6a3644d33bd2467526, codeobj_c98d790ca6223d6a3644d33bd2467526, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_c98d790ca6223d6a3644d33bd2467526 = cache_frame_c98d790ca6223d6a3644d33bd2467526;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c98d790ca6223d6a3644d33bd2467526 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c98d790ca6223d6a3644d33bd2467526 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_nonce;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1428;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_f37468dd5629ccacfbc304506e5ed113;
    frame_c98d790ca6223d6a3644d33bd2467526->m_frame.f_lineno = 1429;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1429;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_nonce;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__nonce, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1431;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c98d790ca6223d6a3644d33bd2467526 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c98d790ca6223d6a3644d33bd2467526 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c98d790ca6223d6a3644d33bd2467526, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c98d790ca6223d6a3644d33bd2467526->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c98d790ca6223d6a3644d33bd2467526, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c98d790ca6223d6a3644d33bd2467526,
        type_description_1,
        par_self,
        par_nonce
    );


    // Release cached frame.
    if ( frame_c98d790ca6223d6a3644d33bd2467526 == cache_frame_c98d790ca6223d6a3644d33bd2467526 )
    {
        Py_DECREF( frame_c98d790ca6223d6a3644d33bd2467526 );
    }
    cache_frame_c98d790ca6223d6a3644d33bd2467526 = NULL;

    assertFrameObject( frame_c98d790ca6223d6a3644d33bd2467526 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_168___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_nonce );
    Py_DECREF( par_nonce );
    par_nonce = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_nonce );
    Py_DECREF( par_nonce );
    par_nonce = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_168___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_169___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_78212c4b4aab735709dfbff7b76cb570 = NULL;

    struct Nuitka_FrameObject *frame_78212c4b4aab735709dfbff7b76cb570;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_78212c4b4aab735709dfbff7b76cb570, codeobj_78212c4b4aab735709dfbff7b76cb570, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_78212c4b4aab735709dfbff7b76cb570 = cache_frame_78212c4b4aab735709dfbff7b76cb570;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_78212c4b4aab735709dfbff7b76cb570 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_78212c4b4aab735709dfbff7b76cb570 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OCSPNonce );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OCSPNonce );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "OCSPNonce" );
        exception_tb = NULL;

        exception_lineno = 1434;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1434;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_nonce );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1437;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_nonce );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1437;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1437;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_78212c4b4aab735709dfbff7b76cb570 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_78212c4b4aab735709dfbff7b76cb570 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_78212c4b4aab735709dfbff7b76cb570 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_78212c4b4aab735709dfbff7b76cb570, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_78212c4b4aab735709dfbff7b76cb570->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_78212c4b4aab735709dfbff7b76cb570, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_78212c4b4aab735709dfbff7b76cb570,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_78212c4b4aab735709dfbff7b76cb570 == cache_frame_78212c4b4aab735709dfbff7b76cb570 )
    {
        Py_DECREF( frame_78212c4b4aab735709dfbff7b76cb570 );
    }
    cache_frame_78212c4b4aab735709dfbff7b76cb570 = NULL;

    assertFrameObject( frame_78212c4b4aab735709dfbff7b76cb570 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_169___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_169___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_170___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_3b9e5fcacf56da1f761df47407c4b7d4 = NULL;

    struct Nuitka_FrameObject *frame_3b9e5fcacf56da1f761df47407c4b7d4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3b9e5fcacf56da1f761df47407c4b7d4, codeobj_3b9e5fcacf56da1f761df47407c4b7d4, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_3b9e5fcacf56da1f761df47407c4b7d4 = cache_frame_3b9e5fcacf56da1f761df47407c4b7d4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3b9e5fcacf56da1f761df47407c4b7d4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3b9e5fcacf56da1f761df47407c4b7d4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1440;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1440;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3b9e5fcacf56da1f761df47407c4b7d4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3b9e5fcacf56da1f761df47407c4b7d4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3b9e5fcacf56da1f761df47407c4b7d4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3b9e5fcacf56da1f761df47407c4b7d4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3b9e5fcacf56da1f761df47407c4b7d4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3b9e5fcacf56da1f761df47407c4b7d4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3b9e5fcacf56da1f761df47407c4b7d4,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_3b9e5fcacf56da1f761df47407c4b7d4 == cache_frame_3b9e5fcacf56da1f761df47407c4b7d4 )
    {
        Py_DECREF( frame_3b9e5fcacf56da1f761df47407c4b7d4 );
    }
    cache_frame_3b9e5fcacf56da1f761df47407c4b7d4 = NULL;

    assertFrameObject( frame_3b9e5fcacf56da1f761df47407c4b7d4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_170___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_170___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_171___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_89af66793f1fc61aa38227cde0214ec2 = NULL;

    struct Nuitka_FrameObject *frame_89af66793f1fc61aa38227cde0214ec2;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_89af66793f1fc61aa38227cde0214ec2, codeobj_89af66793f1fc61aa38227cde0214ec2, module_cryptography$x509$extensions, sizeof(void *) );
    frame_89af66793f1fc61aa38227cde0214ec2 = cache_frame_89af66793f1fc61aa38227cde0214ec2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_89af66793f1fc61aa38227cde0214ec2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_89af66793f1fc61aa38227cde0214ec2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_hash_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_nonce );
    if ( tmp_hash_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1443;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1443;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_89af66793f1fc61aa38227cde0214ec2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_89af66793f1fc61aa38227cde0214ec2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_89af66793f1fc61aa38227cde0214ec2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_89af66793f1fc61aa38227cde0214ec2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_89af66793f1fc61aa38227cde0214ec2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_89af66793f1fc61aa38227cde0214ec2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_89af66793f1fc61aa38227cde0214ec2,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_89af66793f1fc61aa38227cde0214ec2 == cache_frame_89af66793f1fc61aa38227cde0214ec2 )
    {
        Py_DECREF( frame_89af66793f1fc61aa38227cde0214ec2 );
    }
    cache_frame_89af66793f1fc61aa38227cde0214ec2 = NULL;

    assertFrameObject( frame_89af66793f1fc61aa38227cde0214ec2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_171___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_171___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_172___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_093eaa0e810751ddd673b7c5be612109 = NULL;

    struct Nuitka_FrameObject *frame_093eaa0e810751ddd673b7c5be612109;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_093eaa0e810751ddd673b7c5be612109, codeobj_093eaa0e810751ddd673b7c5be612109, module_cryptography$x509$extensions, sizeof(void *) );
    frame_093eaa0e810751ddd673b7c5be612109 = cache_frame_093eaa0e810751ddd673b7c5be612109;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_093eaa0e810751ddd673b7c5be612109 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_093eaa0e810751ddd673b7c5be612109 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_92ebfd7d825e182438411c24725c884a;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_093eaa0e810751ddd673b7c5be612109->m_frame.f_lineno = 1446;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1446;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_093eaa0e810751ddd673b7c5be612109 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_093eaa0e810751ddd673b7c5be612109 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_093eaa0e810751ddd673b7c5be612109 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_093eaa0e810751ddd673b7c5be612109, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_093eaa0e810751ddd673b7c5be612109->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_093eaa0e810751ddd673b7c5be612109, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_093eaa0e810751ddd673b7c5be612109,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_093eaa0e810751ddd673b7c5be612109 == cache_frame_093eaa0e810751ddd673b7c5be612109 )
    {
        Py_DECREF( frame_093eaa0e810751ddd673b7c5be612109 );
    }
    cache_frame_093eaa0e810751ddd673b7c5be612109 = NULL;

    assertFrameObject( frame_093eaa0e810751ddd673b7c5be612109 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_172___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_172___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_173___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_full_name = python_pars[ 1 ];
    PyObject *par_relative_name = python_pars[ 2 ];
    PyObject *par_only_contains_user_certs = python_pars[ 3 ];
    PyObject *par_only_contains_ca_certs = python_pars[ 4 ];
    PyObject *par_only_some_reasons = python_pars[ 5 ];
    PyObject *par_indirect_crl = python_pars[ 6 ];
    PyObject *par_only_contains_attribute_certs = python_pars[ 7 ];
    PyObject *var_crl_constraints = NULL;
    PyObject *var_x = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    int tmp_and_left_truth_3;
    int tmp_and_left_truth_4;
    int tmp_and_left_truth_5;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_left_value_3;
    PyObject *tmp_and_left_value_4;
    PyObject *tmp_and_left_value_5;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_and_right_value_3;
    PyObject *tmp_and_right_value_4;
    PyObject *tmp_and_right_value_5;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_name_5;
    PyObject *tmp_assattr_name_6;
    PyObject *tmp_assattr_name_7;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assattr_target_5;
    PyObject *tmp_assattr_target_6;
    PyObject *tmp_assattr_target_7;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    int tmp_cond_truth_5;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_cond_value_5;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_cls_3;
    PyObject *tmp_isinstance_cls_4;
    PyObject *tmp_isinstance_cls_5;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_isinstance_inst_3;
    PyObject *tmp_isinstance_inst_4;
    PyObject *tmp_isinstance_inst_5;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_list_element_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_make_exception_arg_4;
    PyObject *tmp_make_exception_arg_5;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_operand_name_2;
    int tmp_or_left_truth_1;
    int tmp_or_left_truth_2;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_left_value_2;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_or_right_value_2;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_outline_return_value_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_raise_type_4;
    PyObject *tmp_raise_type_5;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_c93644efbdbc7699d1558444ac6d1411 = NULL;

    struct Nuitka_FrameObject *frame_c93644efbdbc7699d1558444ac6d1411;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;
    tmp_outline_return_value_2 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c93644efbdbc7699d1558444ac6d1411, codeobj_c93644efbdbc7699d1558444ac6d1411, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c93644efbdbc7699d1558444ac6d1411 = cache_frame_c93644efbdbc7699d1558444ac6d1411;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c93644efbdbc7699d1558444ac6d1411 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c93644efbdbc7699d1558444ac6d1411 ) == 2 ); // Frame stack

    // Framed code:
    tmp_and_left_value_1 = par_only_some_reasons;

    CHECK_OBJECT( tmp_and_left_value_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1460;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_isinstance_inst_1 = par_only_some_reasons;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyFrozenSet_Type;
    tmp_operand_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1460;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1460;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1460;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_all );
    assert( tmp_called_name_1 != NULL );
    tmp_iter_arg_1 = par_only_some_reasons;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1461;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_1;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_173___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_68b0050ce85ef4a64f787e21fb011498,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_173___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_173___init__ );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_c93644efbdbc7699d1558444ac6d1411->m_frame.f_lineno = 1460;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_operand_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_operand_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1460;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_right_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_2 );
    Py_DECREF( tmp_operand_name_2 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1460;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_and_right_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1460;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_28228272e91a15a54ff010026fcf7af8;
    frame_c93644efbdbc7699d1558444ac6d1411->m_frame.f_lineno = 1465;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1465;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_and_left_value_2 = par_only_some_reasons;

    CHECK_OBJECT( tmp_and_left_value_2 );
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    if ( tmp_and_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1471;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ReasonFlags" );
        exception_tb = NULL;

        exception_lineno = 1470;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_unspecified );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1470;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = par_only_some_reasons;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_or_left_value_2 = SEQUENCE_CONTAINS( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_or_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1470;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_2 = CHECK_IF_TRUE( tmp_or_left_value_2 );
    assert( !(tmp_or_left_truth_2 == -1) );
    if ( tmp_or_left_truth_2 == 1 )
    {
        goto or_left_2;
    }
    else
    {
        goto or_right_2;
    }
    or_right_2:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ReasonFlags" );
        exception_tb = NULL;

        exception_lineno = 1471;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_remove_from_crl );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1471;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_2 = par_only_some_reasons;

    CHECK_OBJECT( tmp_compexpr_right_2 );
    tmp_or_right_value_2 = SEQUENCE_CONTAINS( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    if ( tmp_or_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1471;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_2 = tmp_or_right_value_2;
    goto or_end_2;
    or_left_2:;
    tmp_and_right_value_2 = tmp_or_left_value_2;
    or_end_2:;
    tmp_cond_value_2 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_cond_value_2 = tmp_and_left_value_2;
    and_end_2:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1471;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_c6c3dada1f7f971d20a3492ccb208681;
    frame_c93644efbdbc7699d1558444ac6d1411->m_frame.f_lineno = 1473;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 1473;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_isinstance_inst_2 = par_only_contains_user_certs;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_isinstance_cls_2 = (PyObject *)&PyBool_Type;
    tmp_and_left_value_3 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    if ( tmp_and_left_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1479;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_3 = CHECK_IF_TRUE( tmp_and_left_value_3 );
    if ( tmp_and_left_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1482;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_3 == 1 )
    {
        goto and_right_3;
    }
    else
    {
        goto and_left_3;
    }
    and_right_3:;
    tmp_isinstance_inst_3 = par_only_contains_ca_certs;

    CHECK_OBJECT( tmp_isinstance_inst_3 );
    tmp_isinstance_cls_3 = (PyObject *)&PyBool_Type;
    tmp_and_left_value_4 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
    if ( tmp_and_left_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1480;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_4 = CHECK_IF_TRUE( tmp_and_left_value_4 );
    if ( tmp_and_left_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1482;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_4 == 1 )
    {
        goto and_right_4;
    }
    else
    {
        goto and_left_4;
    }
    and_right_4:;
    tmp_isinstance_inst_4 = par_indirect_crl;

    CHECK_OBJECT( tmp_isinstance_inst_4 );
    tmp_isinstance_cls_4 = (PyObject *)&PyBool_Type;
    tmp_and_left_value_5 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_4, tmp_isinstance_cls_4 );
    if ( tmp_and_left_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1481;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_5 = CHECK_IF_TRUE( tmp_and_left_value_5 );
    if ( tmp_and_left_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1482;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_5 == 1 )
    {
        goto and_right_5;
    }
    else
    {
        goto and_left_5;
    }
    and_right_5:;
    tmp_isinstance_inst_5 = par_only_contains_attribute_certs;

    CHECK_OBJECT( tmp_isinstance_inst_5 );
    tmp_isinstance_cls_5 = (PyObject *)&PyBool_Type;
    tmp_and_right_value_5 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_5, tmp_isinstance_cls_5 );
    if ( tmp_and_right_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1482;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_4 = tmp_and_right_value_5;
    goto and_end_5;
    and_left_5:;
    tmp_and_right_value_4 = tmp_and_left_value_5;
    and_end_5:;
    tmp_and_right_value_3 = tmp_and_right_value_4;
    goto and_end_4;
    and_left_4:;
    tmp_and_right_value_3 = tmp_and_left_value_4;
    and_end_4:;
    tmp_cond_value_3 = tmp_and_right_value_3;
    goto and_end_3;
    and_left_3:;
    tmp_cond_value_3 = tmp_and_left_value_3;
    and_end_3:;
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1482;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_3 = const_str_digest_c47beb1c7d1e047c9170d20aad4fb97b;
    frame_c93644efbdbc7699d1558444ac6d1411->m_frame.f_lineno = 1484;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 1484;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    tmp_assign_source_2 = PyList_New( 4 );
    tmp_list_element_1 = par_only_contains_user_certs;

    CHECK_OBJECT( tmp_list_element_1 );
    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_assign_source_2, 0, tmp_list_element_1 );
    tmp_list_element_1 = par_only_contains_ca_certs;

    CHECK_OBJECT( tmp_list_element_1 );
    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_assign_source_2, 1, tmp_list_element_1 );
    tmp_list_element_1 = par_indirect_crl;

    CHECK_OBJECT( tmp_list_element_1 );
    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_assign_source_2, 2, tmp_list_element_1 );
    tmp_list_element_1 = par_only_contains_attribute_certs;

    CHECK_OBJECT( tmp_list_element_1 );
    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_assign_source_2, 3, tmp_list_element_1 );
    assert( var_crl_constraints == NULL );
    var_crl_constraints = tmp_assign_source_2;

    // Tried code:
    tmp_iter_arg_2 = var_crl_constraints;

    CHECK_OBJECT( tmp_iter_arg_2 );
    tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1495;
        type_description_1 = "oooooooooo";
        goto try_except_handler_3;
    }
    assert( tmp_list_contraction_1__$0 == NULL );
    tmp_list_contraction_1__$0 = tmp_assign_source_3;

    tmp_assign_source_4 = PyList_New( 0 );
    assert( tmp_list_contraction_1__contraction_result == NULL );
    tmp_list_contraction_1__contraction_result = tmp_assign_source_4;

    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_list_contraction_1__$0;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_5 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooooo";
        exception_lineno = 1495;
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_list_contraction_1__iter_value_0;
        tmp_list_contraction_1__iter_value_0 = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_2 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1495;
        type_description_1 = "oooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_5;
    branch_no_5:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_3;
    branch_end_5:;
    // End of try:
    try_end_1:;
    tmp_assign_source_6 = tmp_list_contraction_1__iter_value_0;

    CHECK_OBJECT( tmp_assign_source_6 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_6;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_cond_value_4 = var_x;

    CHECK_OBJECT( tmp_cond_value_4 );
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1495;
        type_description_1 = "oooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_append_list_1 = tmp_list_contraction_1__contraction_result;

    CHECK_OBJECT( tmp_append_list_1 );
    tmp_append_value_1 = var_x;

    CHECK_OBJECT( tmp_append_value_1 );
    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1495;
        type_description_1 = "oooooooooo";
        goto try_except_handler_3;
    }
    branch_no_6:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1495;
        type_description_1 = "oooooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_outline_return_value_2 = tmp_list_contraction_1__contraction_result;

    CHECK_OBJECT( tmp_outline_return_value_2 );
    Py_INCREF( tmp_outline_return_value_2 );
    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_173___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_3:;
    CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__$0 );
    Py_DECREF( tmp_list_contraction_1__$0 );
    tmp_list_contraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__contraction_result );
    Py_DECREF( tmp_list_contraction_1__contraction_result );
    tmp_list_contraction_1__contraction_result = NULL;

    Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
    tmp_list_contraction_1__iter_value_0 = NULL;

    goto outline_result_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_list_contraction_1__$0 );
    tmp_list_contraction_1__$0 = NULL;

    Py_XDECREF( tmp_list_contraction_1__contraction_result );
    tmp_list_contraction_1__contraction_result = NULL;

    Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
    tmp_list_contraction_1__iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_173___init__ );
    return NULL;
    outline_result_2:;
    tmp_len_arg_1 = tmp_outline_return_value_2;
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    Py_DECREF( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1495;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = const_int_pos_1;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_2 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1495;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_make_exception_arg_4 = const_str_digest_1ea9692159fa7fd9f8e15a3506f4463c;
    frame_c93644efbdbc7699d1558444ac6d1411->m_frame.f_lineno = 1496;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_4 };
        tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_4 != NULL );
    exception_type = tmp_raise_type_4;
    exception_lineno = 1496;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooooo";
    goto frame_exception_exit_1;
    branch_no_4:;
    tmp_called_name_2 = LOOKUP_BUILTIN( const_str_plain_any );
    assert( tmp_called_name_2 != NULL );
    tmp_args_element_name_2 = PyList_New( 7 );
    tmp_list_element_2 = par_only_contains_user_certs;

    CHECK_OBJECT( tmp_list_element_2 );
    Py_INCREF( tmp_list_element_2 );
    PyList_SET_ITEM( tmp_args_element_name_2, 0, tmp_list_element_2 );
    tmp_list_element_2 = par_only_contains_ca_certs;

    CHECK_OBJECT( tmp_list_element_2 );
    Py_INCREF( tmp_list_element_2 );
    PyList_SET_ITEM( tmp_args_element_name_2, 1, tmp_list_element_2 );
    tmp_list_element_2 = par_indirect_crl;

    CHECK_OBJECT( tmp_list_element_2 );
    Py_INCREF( tmp_list_element_2 );
    PyList_SET_ITEM( tmp_args_element_name_2, 2, tmp_list_element_2 );
    tmp_list_element_2 = par_only_contains_attribute_certs;

    CHECK_OBJECT( tmp_list_element_2 );
    Py_INCREF( tmp_list_element_2 );
    PyList_SET_ITEM( tmp_args_element_name_2, 3, tmp_list_element_2 );
    tmp_list_element_2 = par_full_name;

    CHECK_OBJECT( tmp_list_element_2 );
    Py_INCREF( tmp_list_element_2 );
    PyList_SET_ITEM( tmp_args_element_name_2, 4, tmp_list_element_2 );
    tmp_list_element_2 = par_relative_name;

    CHECK_OBJECT( tmp_list_element_2 );
    Py_INCREF( tmp_list_element_2 );
    PyList_SET_ITEM( tmp_args_element_name_2, 5, tmp_list_element_2 );
    tmp_list_element_2 = par_only_some_reasons;

    CHECK_OBJECT( tmp_list_element_2 );
    Py_INCREF( tmp_list_element_2 );
    PyList_SET_ITEM( tmp_args_element_name_2, 6, tmp_list_element_2 );
    frame_c93644efbdbc7699d1558444ac6d1411->m_frame.f_lineno = 1503;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_cond_value_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_cond_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1503;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_5 = CHECK_IF_TRUE( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_5 );

        exception_lineno = 1503;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == 1 )
    {
        goto branch_no_7;
    }
    else
    {
        goto branch_yes_7;
    }
    branch_yes_7:;
    tmp_make_exception_arg_5 = const_str_digest_de9abd61df15d9c64a5a616e9749f115;
    frame_c93644efbdbc7699d1558444ac6d1411->m_frame.f_lineno = 1509;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_5 };
        tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_5 != NULL );
    exception_type = tmp_raise_type_5;
    exception_lineno = 1509;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooooo";
    goto frame_exception_exit_1;
    branch_no_7:;
    tmp_assattr_name_1 = par_only_contains_user_certs;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__only_contains_user_certs, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1517;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_only_contains_ca_certs;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__only_contains_ca_certs, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1518;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = par_indirect_crl;

    CHECK_OBJECT( tmp_assattr_name_3 );
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__indirect_crl, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1519;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_4 = par_only_contains_attribute_certs;

    CHECK_OBJECT( tmp_assattr_name_4 );
    tmp_assattr_target_4 = par_self;

    CHECK_OBJECT( tmp_assattr_target_4 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__only_contains_attribute_certs, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1520;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_5 = par_only_some_reasons;

    CHECK_OBJECT( tmp_assattr_name_5 );
    tmp_assattr_target_5 = par_self;

    CHECK_OBJECT( tmp_assattr_target_5 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain__only_some_reasons, tmp_assattr_name_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1521;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_6 = par_full_name;

    CHECK_OBJECT( tmp_assattr_name_6 );
    tmp_assattr_target_6 = par_self;

    CHECK_OBJECT( tmp_assattr_target_6 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain__full_name, tmp_assattr_name_6 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1522;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_7 = par_relative_name;

    CHECK_OBJECT( tmp_assattr_name_7 );
    tmp_assattr_target_7 = par_self;

    CHECK_OBJECT( tmp_assattr_target_7 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain__relative_name, tmp_assattr_name_7 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1523;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c93644efbdbc7699d1558444ac6d1411 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c93644efbdbc7699d1558444ac6d1411 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c93644efbdbc7699d1558444ac6d1411, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c93644efbdbc7699d1558444ac6d1411->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c93644efbdbc7699d1558444ac6d1411, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c93644efbdbc7699d1558444ac6d1411,
        type_description_1,
        par_self,
        par_full_name,
        par_relative_name,
        par_only_contains_user_certs,
        par_only_contains_ca_certs,
        par_only_some_reasons,
        par_indirect_crl,
        par_only_contains_attribute_certs,
        var_crl_constraints,
        var_x
    );


    // Release cached frame.
    if ( frame_c93644efbdbc7699d1558444ac6d1411 == cache_frame_c93644efbdbc7699d1558444ac6d1411 )
    {
        Py_DECREF( frame_c93644efbdbc7699d1558444ac6d1411 );
    }
    cache_frame_c93644efbdbc7699d1558444ac6d1411 = NULL;

    assertFrameObject( frame_c93644efbdbc7699d1558444ac6d1411 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_173___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_only_some_reasons );
    Py_DECREF( par_only_some_reasons );
    par_only_some_reasons = NULL;

    CHECK_OBJECT( (PyObject *)par_only_contains_ca_certs );
    Py_DECREF( par_only_contains_ca_certs );
    par_only_contains_ca_certs = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_only_contains_attribute_certs );
    Py_DECREF( par_only_contains_attribute_certs );
    par_only_contains_attribute_certs = NULL;

    CHECK_OBJECT( (PyObject *)par_indirect_crl );
    Py_DECREF( par_indirect_crl );
    par_indirect_crl = NULL;

    CHECK_OBJECT( (PyObject *)par_relative_name );
    Py_DECREF( par_relative_name );
    par_relative_name = NULL;

    CHECK_OBJECT( (PyObject *)par_only_contains_user_certs );
    Py_DECREF( par_only_contains_user_certs );
    par_only_contains_user_certs = NULL;

    CHECK_OBJECT( (PyObject *)var_crl_constraints );
    Py_DECREF( var_crl_constraints );
    var_crl_constraints = NULL;

    CHECK_OBJECT( (PyObject *)par_full_name );
    Py_DECREF( par_full_name );
    par_full_name = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_only_some_reasons );
    Py_DECREF( par_only_some_reasons );
    par_only_some_reasons = NULL;

    CHECK_OBJECT( (PyObject *)par_only_contains_ca_certs );
    Py_DECREF( par_only_contains_ca_certs );
    par_only_contains_ca_certs = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_only_contains_attribute_certs );
    Py_DECREF( par_only_contains_attribute_certs );
    par_only_contains_attribute_certs = NULL;

    CHECK_OBJECT( (PyObject *)par_indirect_crl );
    Py_DECREF( par_indirect_crl );
    par_indirect_crl = NULL;

    CHECK_OBJECT( (PyObject *)par_relative_name );
    Py_DECREF( par_relative_name );
    par_relative_name = NULL;

    CHECK_OBJECT( (PyObject *)par_only_contains_user_certs );
    Py_DECREF( par_only_contains_user_certs );
    par_only_contains_user_certs = NULL;

    Py_XDECREF( var_crl_constraints );
    var_crl_constraints = NULL;

    CHECK_OBJECT( (PyObject *)par_full_name );
    Py_DECREF( par_full_name );
    par_full_name = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_173___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct cryptography$x509$extensions$$$function_173___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *cryptography$x509$extensions$$$function_173___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void cryptography$x509$extensions$$$function_173___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_x = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_68b0050ce85ef4a64f787e21fb011498, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 1461;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1461;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_2;
        Py_INCREF( var_x );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_x;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ReasonFlags" );
        exception_tb = NULL;

        exception_lineno = 1461;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_expression_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1461;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    Py_INCREF( tmp_expression_name_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1461;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1461;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_x
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_cryptography$x509$extensions$$$function_174___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_1b541eeb081b95502e02af418188e21b = NULL;

    struct Nuitka_FrameObject *frame_1b541eeb081b95502e02af418188e21b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1b541eeb081b95502e02af418188e21b, codeobj_1b541eeb081b95502e02af418188e21b, module_cryptography$x509$extensions, sizeof(void *) );
    frame_1b541eeb081b95502e02af418188e21b = cache_frame_1b541eeb081b95502e02af418188e21b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1b541eeb081b95502e02af418188e21b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1b541eeb081b95502e02af418188e21b ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_4896564d0ed5e6b06237436d00bf3cad;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_1b541eeb081b95502e02af418188e21b->m_frame.f_lineno = 1527;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1527;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b541eeb081b95502e02af418188e21b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b541eeb081b95502e02af418188e21b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b541eeb081b95502e02af418188e21b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1b541eeb081b95502e02af418188e21b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1b541eeb081b95502e02af418188e21b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1b541eeb081b95502e02af418188e21b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1b541eeb081b95502e02af418188e21b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_1b541eeb081b95502e02af418188e21b == cache_frame_1b541eeb081b95502e02af418188e21b )
    {
        Py_DECREF( frame_1b541eeb081b95502e02af418188e21b );
    }
    cache_frame_1b541eeb081b95502e02af418188e21b = NULL;

    assertFrameObject( frame_1b541eeb081b95502e02af418188e21b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_174___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_174___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_175___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    int tmp_and_left_truth_3;
    int tmp_and_left_truth_4;
    int tmp_and_left_truth_5;
    int tmp_and_left_truth_6;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_left_value_3;
    PyObject *tmp_and_left_value_4;
    PyObject *tmp_and_left_value_5;
    PyObject *tmp_and_left_value_6;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_and_right_value_3;
    PyObject *tmp_and_right_value_4;
    PyObject *tmp_and_right_value_5;
    PyObject *tmp_and_right_value_6;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_left_4;
    PyObject *tmp_compexpr_left_5;
    PyObject *tmp_compexpr_left_6;
    PyObject *tmp_compexpr_left_7;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    PyObject *tmp_compexpr_right_4;
    PyObject *tmp_compexpr_right_5;
    PyObject *tmp_compexpr_right_6;
    PyObject *tmp_compexpr_right_7;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    static struct Nuitka_FrameObject *cache_frame_7f765b3590326b8670f2d2e63a18abd5 = NULL;

    struct Nuitka_FrameObject *frame_7f765b3590326b8670f2d2e63a18abd5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7f765b3590326b8670f2d2e63a18abd5, codeobj_7f765b3590326b8670f2d2e63a18abd5, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_7f765b3590326b8670f2d2e63a18abd5 = cache_frame_7f765b3590326b8670f2d2e63a18abd5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7f765b3590326b8670f2d2e63a18abd5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7f765b3590326b8670f2d2e63a18abd5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_IssuingDistributionPoint );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IssuingDistributionPoint );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "IssuingDistributionPoint" );
        exception_tb = NULL;

        exception_lineno = 1538;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1538;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_full_name );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1542;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_full_name );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1542;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1542;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 1548;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_relative_name );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1543;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_other;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_relative_name );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 1543;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_2 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1543;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    if ( tmp_and_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_2 );

        exception_lineno = 1548;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    Py_DECREF( tmp_and_left_value_2 );
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_only_contains_user_certs );
    if ( tmp_compexpr_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1544;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_other;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_only_contains_user_certs );
    if ( tmp_compexpr_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_3 );

        exception_lineno = 1544;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_3 = RICH_COMPARE_EQ( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    Py_DECREF( tmp_compexpr_left_3 );
    Py_DECREF( tmp_compexpr_right_3 );
    if ( tmp_and_left_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1544;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_3 = CHECK_IF_TRUE( tmp_and_left_value_3 );
    if ( tmp_and_left_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_3 );

        exception_lineno = 1548;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_3 == 1 )
    {
        goto and_right_3;
    }
    else
    {
        goto and_left_3;
    }
    and_right_3:;
    Py_DECREF( tmp_and_left_value_3 );
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_only_contains_ca_certs );
    if ( tmp_compexpr_left_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1545;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = par_other;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_only_contains_ca_certs );
    if ( tmp_compexpr_right_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_4 );

        exception_lineno = 1545;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_4 = RICH_COMPARE_EQ( tmp_compexpr_left_4, tmp_compexpr_right_4 );
    Py_DECREF( tmp_compexpr_left_4 );
    Py_DECREF( tmp_compexpr_right_4 );
    if ( tmp_and_left_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1545;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_4 = CHECK_IF_TRUE( tmp_and_left_value_4 );
    if ( tmp_and_left_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_4 );

        exception_lineno = 1548;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_4 == 1 )
    {
        goto and_right_4;
    }
    else
    {
        goto and_left_4;
    }
    and_right_4:;
    Py_DECREF( tmp_and_left_value_4 );
    tmp_source_name_9 = par_self;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_only_some_reasons );
    if ( tmp_compexpr_left_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1546;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_10 = par_other;

    CHECK_OBJECT( tmp_source_name_10 );
    tmp_compexpr_right_5 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_only_some_reasons );
    if ( tmp_compexpr_right_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_5 );

        exception_lineno = 1546;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_5 = RICH_COMPARE_EQ( tmp_compexpr_left_5, tmp_compexpr_right_5 );
    Py_DECREF( tmp_compexpr_left_5 );
    Py_DECREF( tmp_compexpr_right_5 );
    if ( tmp_and_left_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1546;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_5 = CHECK_IF_TRUE( tmp_and_left_value_5 );
    if ( tmp_and_left_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_5 );

        exception_lineno = 1548;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_5 == 1 )
    {
        goto and_right_5;
    }
    else
    {
        goto and_left_5;
    }
    and_right_5:;
    Py_DECREF( tmp_and_left_value_5 );
    tmp_source_name_11 = par_self;

    CHECK_OBJECT( tmp_source_name_11 );
    tmp_compexpr_left_6 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_indirect_crl );
    if ( tmp_compexpr_left_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1547;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_12 = par_other;

    CHECK_OBJECT( tmp_source_name_12 );
    tmp_compexpr_right_6 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_indirect_crl );
    if ( tmp_compexpr_right_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_6 );

        exception_lineno = 1547;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_6 = RICH_COMPARE_EQ( tmp_compexpr_left_6, tmp_compexpr_right_6 );
    Py_DECREF( tmp_compexpr_left_6 );
    Py_DECREF( tmp_compexpr_right_6 );
    if ( tmp_and_left_value_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1547;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_6 = CHECK_IF_TRUE( tmp_and_left_value_6 );
    if ( tmp_and_left_truth_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_6 );

        exception_lineno = 1548;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_6 == 1 )
    {
        goto and_right_6;
    }
    else
    {
        goto and_left_6;
    }
    and_right_6:;
    Py_DECREF( tmp_and_left_value_6 );
    tmp_source_name_13 = par_self;

    CHECK_OBJECT( tmp_source_name_13 );
    tmp_compexpr_left_7 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_only_contains_attribute_certs );
    if ( tmp_compexpr_left_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1548;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_14 = par_other;

    CHECK_OBJECT( tmp_source_name_14 );
    tmp_compexpr_right_7 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_only_contains_attribute_certs );
    if ( tmp_compexpr_right_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_7 );

        exception_lineno = 1549;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_6 = RICH_COMPARE_EQ( tmp_compexpr_left_7, tmp_compexpr_right_7 );
    Py_DECREF( tmp_compexpr_left_7 );
    Py_DECREF( tmp_compexpr_right_7 );
    if ( tmp_and_right_value_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1548;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_5 = tmp_and_right_value_6;
    goto and_end_6;
    and_left_6:;
    tmp_and_right_value_5 = tmp_and_left_value_6;
    and_end_6:;
    tmp_and_right_value_4 = tmp_and_right_value_5;
    goto and_end_5;
    and_left_5:;
    tmp_and_right_value_4 = tmp_and_left_value_5;
    and_end_5:;
    tmp_and_right_value_3 = tmp_and_right_value_4;
    goto and_end_4;
    and_left_4:;
    tmp_and_right_value_3 = tmp_and_left_value_4;
    and_end_4:;
    tmp_and_right_value_2 = tmp_and_right_value_3;
    goto and_end_3;
    and_left_3:;
    tmp_and_right_value_2 = tmp_and_left_value_3;
    and_end_3:;
    tmp_and_right_value_1 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_and_right_value_1 = tmp_and_left_value_2;
    and_end_2:;
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7f765b3590326b8670f2d2e63a18abd5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7f765b3590326b8670f2d2e63a18abd5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7f765b3590326b8670f2d2e63a18abd5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7f765b3590326b8670f2d2e63a18abd5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7f765b3590326b8670f2d2e63a18abd5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7f765b3590326b8670f2d2e63a18abd5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7f765b3590326b8670f2d2e63a18abd5,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_7f765b3590326b8670f2d2e63a18abd5 == cache_frame_7f765b3590326b8670f2d2e63a18abd5 )
    {
        Py_DECREF( frame_7f765b3590326b8670f2d2e63a18abd5 );
    }
    cache_frame_7f765b3590326b8670f2d2e63a18abd5 = NULL;

    assertFrameObject( frame_7f765b3590326b8670f2d2e63a18abd5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_175___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_175___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_176___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_9ba8ec00a538bc1740a345849883dfb7 = NULL;

    struct Nuitka_FrameObject *frame_9ba8ec00a538bc1740a345849883dfb7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9ba8ec00a538bc1740a345849883dfb7, codeobj_9ba8ec00a538bc1740a345849883dfb7, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_9ba8ec00a538bc1740a345849883dfb7 = cache_frame_9ba8ec00a538bc1740a345849883dfb7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9ba8ec00a538bc1740a345849883dfb7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9ba8ec00a538bc1740a345849883dfb7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1553;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1553;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9ba8ec00a538bc1740a345849883dfb7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9ba8ec00a538bc1740a345849883dfb7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9ba8ec00a538bc1740a345849883dfb7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9ba8ec00a538bc1740a345849883dfb7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9ba8ec00a538bc1740a345849883dfb7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9ba8ec00a538bc1740a345849883dfb7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9ba8ec00a538bc1740a345849883dfb7,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_9ba8ec00a538bc1740a345849883dfb7 == cache_frame_9ba8ec00a538bc1740a345849883dfb7 )
    {
        Py_DECREF( frame_9ba8ec00a538bc1740a345849883dfb7 );
    }
    cache_frame_9ba8ec00a538bc1740a345849883dfb7 = NULL;

    assertFrameObject( frame_9ba8ec00a538bc1740a345849883dfb7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_176___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_176___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_177___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_8f969f316377d0f9b0caba40b49b8c02 = NULL;

    struct Nuitka_FrameObject *frame_8f969f316377d0f9b0caba40b49b8c02;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8f969f316377d0f9b0caba40b49b8c02, codeobj_8f969f316377d0f9b0caba40b49b8c02, module_cryptography$x509$extensions, sizeof(void *) );
    frame_8f969f316377d0f9b0caba40b49b8c02 = cache_frame_8f969f316377d0f9b0caba40b49b8c02;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8f969f316377d0f9b0caba40b49b8c02 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8f969f316377d0f9b0caba40b49b8c02 ) == 2 ); // Frame stack

    // Framed code:
    tmp_hash_arg_1 = PyTuple_New( 7 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_full_name );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1557;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_relative_name );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1558;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 1, tmp_tuple_element_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_only_contains_user_certs );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1559;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 2, tmp_tuple_element_1 );
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_only_contains_ca_certs );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1560;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 3, tmp_tuple_element_1 );
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_only_some_reasons );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1561;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 4, tmp_tuple_element_1 );
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_indirect_crl );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1562;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 5, tmp_tuple_element_1 );
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_only_contains_attribute_certs );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1563;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 6, tmp_tuple_element_1 );
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1556;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f969f316377d0f9b0caba40b49b8c02 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f969f316377d0f9b0caba40b49b8c02 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f969f316377d0f9b0caba40b49b8c02 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8f969f316377d0f9b0caba40b49b8c02, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8f969f316377d0f9b0caba40b49b8c02->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8f969f316377d0f9b0caba40b49b8c02, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8f969f316377d0f9b0caba40b49b8c02,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8f969f316377d0f9b0caba40b49b8c02 == cache_frame_8f969f316377d0f9b0caba40b49b8c02 )
    {
        Py_DECREF( frame_8f969f316377d0f9b0caba40b49b8c02 );
    }
    cache_frame_8f969f316377d0f9b0caba40b49b8c02 = NULL;

    assertFrameObject( frame_8f969f316377d0f9b0caba40b49b8c02 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_177___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_177___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_178___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_oid = python_pars[ 1 ];
    PyObject *par_value = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_e2a74a50be727bc49fb93340dd76c5a6 = NULL;

    struct Nuitka_FrameObject *frame_e2a74a50be727bc49fb93340dd76c5a6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e2a74a50be727bc49fb93340dd76c5a6, codeobj_e2a74a50be727bc49fb93340dd76c5a6, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e2a74a50be727bc49fb93340dd76c5a6 = cache_frame_e2a74a50be727bc49fb93340dd76c5a6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e2a74a50be727bc49fb93340dd76c5a6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e2a74a50be727bc49fb93340dd76c5a6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_oid;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ObjectIdentifier" );
        exception_tb = NULL;

        exception_lineno = 1584;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1584;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_f63518e696f94cef547d30428c9b8408;
    frame_e2a74a50be727bc49fb93340dd76c5a6->m_frame.f_lineno = 1585;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1585;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_oid;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__oid, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1586;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_value;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__value, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1587;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2a74a50be727bc49fb93340dd76c5a6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2a74a50be727bc49fb93340dd76c5a6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e2a74a50be727bc49fb93340dd76c5a6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e2a74a50be727bc49fb93340dd76c5a6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e2a74a50be727bc49fb93340dd76c5a6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e2a74a50be727bc49fb93340dd76c5a6,
        type_description_1,
        par_self,
        par_oid,
        par_value
    );


    // Release cached frame.
    if ( frame_e2a74a50be727bc49fb93340dd76c5a6 == cache_frame_e2a74a50be727bc49fb93340dd76c5a6 )
    {
        Py_DECREF( frame_e2a74a50be727bc49fb93340dd76c5a6 );
    }
    cache_frame_e2a74a50be727bc49fb93340dd76c5a6 = NULL;

    assertFrameObject( frame_e2a74a50be727bc49fb93340dd76c5a6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_178___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_oid );
    Py_DECREF( par_oid );
    par_oid = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_oid );
    Py_DECREF( par_oid );
    par_oid = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_178___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_179___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_e6076427abefcbfd63f41a0300f8f79c = NULL;

    struct Nuitka_FrameObject *frame_e6076427abefcbfd63f41a0300f8f79c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e6076427abefcbfd63f41a0300f8f79c, codeobj_e6076427abefcbfd63f41a0300f8f79c, module_cryptography$x509$extensions, sizeof(void *) );
    frame_e6076427abefcbfd63f41a0300f8f79c = cache_frame_e6076427abefcbfd63f41a0300f8f79c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e6076427abefcbfd63f41a0300f8f79c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e6076427abefcbfd63f41a0300f8f79c ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = const_str_digest_293839491199d08c5eee9ab993bbfcfe;
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_e6076427abefcbfd63f41a0300f8f79c->m_frame.f_lineno = 1594;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1594;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e6076427abefcbfd63f41a0300f8f79c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e6076427abefcbfd63f41a0300f8f79c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e6076427abefcbfd63f41a0300f8f79c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e6076427abefcbfd63f41a0300f8f79c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e6076427abefcbfd63f41a0300f8f79c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e6076427abefcbfd63f41a0300f8f79c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e6076427abefcbfd63f41a0300f8f79c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_e6076427abefcbfd63f41a0300f8f79c == cache_frame_e6076427abefcbfd63f41a0300f8f79c )
    {
        Py_DECREF( frame_e6076427abefcbfd63f41a0300f8f79c );
    }
    cache_frame_e6076427abefcbfd63f41a0300f8f79c = NULL;

    assertFrameObject( frame_e6076427abefcbfd63f41a0300f8f79c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_179___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_179___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_180___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_52a71a816261aa20655054a6cf2cd004 = NULL;

    struct Nuitka_FrameObject *frame_52a71a816261aa20655054a6cf2cd004;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_52a71a816261aa20655054a6cf2cd004, codeobj_52a71a816261aa20655054a6cf2cd004, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_52a71a816261aa20655054a6cf2cd004 = cache_frame_52a71a816261aa20655054a6cf2cd004;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_52a71a816261aa20655054a6cf2cd004 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_52a71a816261aa20655054a6cf2cd004 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_UnrecognizedExtension );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_UnrecognizedExtension );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "UnrecognizedExtension" );
        exception_tb = NULL;

        exception_lineno = 1600;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1600;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_oid );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1603;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_other;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_oid );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1603;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1603;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 1603;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_value );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1603;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_other;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_value );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 1603;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1603;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_52a71a816261aa20655054a6cf2cd004 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_52a71a816261aa20655054a6cf2cd004 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_52a71a816261aa20655054a6cf2cd004 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_52a71a816261aa20655054a6cf2cd004, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_52a71a816261aa20655054a6cf2cd004->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_52a71a816261aa20655054a6cf2cd004, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_52a71a816261aa20655054a6cf2cd004,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_52a71a816261aa20655054a6cf2cd004 == cache_frame_52a71a816261aa20655054a6cf2cd004 )
    {
        Py_DECREF( frame_52a71a816261aa20655054a6cf2cd004 );
    }
    cache_frame_52a71a816261aa20655054a6cf2cd004 = NULL;

    assertFrameObject( frame_52a71a816261aa20655054a6cf2cd004 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_180___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_180___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_181___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_cea77827f2eac305a5259abe26384ad4 = NULL;

    struct Nuitka_FrameObject *frame_cea77827f2eac305a5259abe26384ad4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cea77827f2eac305a5259abe26384ad4, codeobj_cea77827f2eac305a5259abe26384ad4, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *) );
    frame_cea77827f2eac305a5259abe26384ad4 = cache_frame_cea77827f2eac305a5259abe26384ad4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cea77827f2eac305a5259abe26384ad4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cea77827f2eac305a5259abe26384ad4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_self;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = par_other;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_operand_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1606;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1606;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cea77827f2eac305a5259abe26384ad4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cea77827f2eac305a5259abe26384ad4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cea77827f2eac305a5259abe26384ad4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cea77827f2eac305a5259abe26384ad4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cea77827f2eac305a5259abe26384ad4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cea77827f2eac305a5259abe26384ad4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cea77827f2eac305a5259abe26384ad4,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_cea77827f2eac305a5259abe26384ad4 == cache_frame_cea77827f2eac305a5259abe26384ad4 )
    {
        Py_DECREF( frame_cea77827f2eac305a5259abe26384ad4 );
    }
    cache_frame_cea77827f2eac305a5259abe26384ad4 = NULL;

    assertFrameObject( frame_cea77827f2eac305a5259abe26384ad4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_181___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_181___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_cryptography$x509$extensions$$$function_182___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_hash_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_06ede4ab871537b61c08c580959fa458 = NULL;

    struct Nuitka_FrameObject *frame_06ede4ab871537b61c08c580959fa458;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_06ede4ab871537b61c08c580959fa458, codeobj_06ede4ab871537b61c08c580959fa458, module_cryptography$x509$extensions, sizeof(void *) );
    frame_06ede4ab871537b61c08c580959fa458 = cache_frame_06ede4ab871537b61c08c580959fa458;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_06ede4ab871537b61c08c580959fa458 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_06ede4ab871537b61c08c580959fa458 ) == 2 ); // Frame stack

    // Framed code:
    tmp_hash_arg_1 = PyTuple_New( 2 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_oid );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1609;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_value );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_hash_arg_1 );

        exception_lineno = 1609;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_hash_arg_1, 1, tmp_tuple_element_1 );
    tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
    Py_DECREF( tmp_hash_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1609;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_06ede4ab871537b61c08c580959fa458 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_06ede4ab871537b61c08c580959fa458 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_06ede4ab871537b61c08c580959fa458 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_06ede4ab871537b61c08c580959fa458, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_06ede4ab871537b61c08c580959fa458->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_06ede4ab871537b61c08c580959fa458, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_06ede4ab871537b61c08c580959fa458,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_06ede4ab871537b61c08c580959fa458 == cache_frame_06ede4ab871537b61c08c580959fa458 )
    {
        Py_DECREF( frame_06ede4ab871537b61c08c580959fa458 );
    }
    cache_frame_06ede4ab871537b61c08c580959fa458 = NULL;

    assertFrameObject( frame_06ede4ab871537b61c08c580959fa458 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_182___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions$$$function_182___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_100___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_100___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_825cf7bc77cbec1bc71ec3174af38633,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_101___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_101___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_bd2f597ab578a8ca34dcbdb4451318c2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_102___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_102___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9577bd5f33b7ffea2ef89eff32e0a9cf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_103___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_103___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_269cb9bd17342eadc310b70cb566e7ca,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_104___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_104___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_207c446b384b5fff7b758b710ebcd306,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_105___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_105___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d34b80df37edbf7f7bad1484045d4000,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_106___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_106___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5979b7dcae0cb17ab58172bc693ecfcc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_107___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_107___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b664d78d6ebdc07d97666d986b9e557d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_108___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_108___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b9a64eab02561c7ba59bd763bc6ee1b4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_109___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_109___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4b0d9409191589b3b8889a0e1a8beb39,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_10___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_10___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ca7ebae402d55046675fc70d82ea120a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_110___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_110___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_245ca46202f093d6d661d0cc31b2f7cc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_111___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_111___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_797af5f1fd77e5cc555a75349b5fe3c0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_112_encipher_only(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_112_encipher_only,
        const_str_plain_encipher_only,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8d7d29dbad9addbf58f92f1a4bc533d0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_113_decipher_only(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_113_decipher_only,
        const_str_plain_decipher_only,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6cf8b2c589661b0ba098edf538ce526d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_114___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_114___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a0f103b7065a35f97f5a35b2994585aa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_115___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_115___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a90aeaeb6f8a3ed1eddebdacaf29192a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_116___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_116___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_63793d5a1ced56f732c5a865370481f9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_117___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_117___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_fb676fc0aa7f7213b586ead04828ec85,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_118___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_118___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_27f3275a0ef40b25b2c2ac83a6e7e96d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_119___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_119___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d82593620f5895cf8bf3aba5f81ef7d9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_11___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_11___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3d456b8c68fc0d32404a21a843d53ce8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_120___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_120___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8735c6c8ac5e6c3fd0af4da21d827208,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_121__validate_ip_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_121__validate_ip_name,
        const_str_plain__validate_ip_name,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ab8ef2a24d0f1a790614f3268e20e185,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_122___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_122___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0c5f8fcaef9aafcfe368d2f302930746,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_123___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_123___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5d6578b18c844fbf92e4e1cc396ff560,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_124___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_124___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_90f9dc917871442a40fd7dbb81775ea8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_125___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_125___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_97bcd8a86a0e71a6d026a07d84b45ed7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_126___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_126___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c8a574578584b58b662d6a22e972cb4a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_127___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_127___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_083fd7a326fcbb7a6d20eb602df89ced,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_128___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_128___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_595f73a82e458cba3cad4ec3ac173f24,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_129___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_129___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2222a6dca432c7c5cdd7e181de61cc46,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_12___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_12___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_275e644d3ba496e282a9a7e1ed6c862f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_130_get_values_for_type(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_130_get_values_for_type,
        const_str_plain_get_values_for_type,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_333cc1037c812d2229525293f8f2e028,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_131___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_131___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e076e7a305486e6abcaf1216659b6e19,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_132___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_132___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_186cdc657e777afed82927af6bc4a1ac,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_133___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_133___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_106adc7dbc7e53b3b99843320941121f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_134___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_134___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_500e5c17bcdaddaa2217eaf4f19855d0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_135___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_135___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_67f775c2ac36778d8149bcd69067f7f5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_136_get_values_for_type(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_136_get_values_for_type,
        const_str_plain_get_values_for_type,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_321d3d2d646eb033dd31542f84fb8ad7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_137___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_137___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_751849f6c514a7f7c9c0b68ae52b5141,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_138___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_138___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8bab69c94615c96edcfa248584419f98,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_139___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_139___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2799c6e1c293d05ed77773714e41415f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_13___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_13___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_aeb0ee93788492df02f8efe63af9c8d6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_140___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_140___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_99466dbcc845cc7abe2836db2cfbf366,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_141___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_141___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_869ca61483dae9badd586b13a5a2c497,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_142_get_values_for_type(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_142_get_values_for_type,
        const_str_plain_get_values_for_type,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_dfa357761ff8a2cf04a1e4591e6ba131,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_143___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_143___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6e3008cfbd7ffcd179f9b62324e3d1b8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_144___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_144___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d785c5a91161828fe66a1f09a8282ede,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_145___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_145___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5ce4859f79d64aac185e077923698816,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_146___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_146___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9bff6aba8635fc588ed756614cb17cb8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_147___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_147___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_41d2fca2c6d1a037a39bc7c2cae9471c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_148_get_values_for_type(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_148_get_values_for_type,
        const_str_plain_get_values_for_type,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6cf10bf052c6bf6b809820f2dbf45aec,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_149___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_149___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c676f56e52e36e7b954928a8cf5ae824,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_14___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_14___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_16033c495aaaac6c823cfe41921d5827,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_150___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_150___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_42aded348931584374c6be3e26f3a62e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_151___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_151___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4e01197d0e4e4c79cdf2d327dc689777,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_152___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_152___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_05417fe8f5b9303ade0d507b76aed4e3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_153___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_153___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f7221220b795ab66d7e03e36dcbe8593,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_154___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_154___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_09be14c4282cabf6b9e19a783dec5f1b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_155___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_155___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a4f747c1a224ef94ef7f9cf43f8c3230,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_156___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_156___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8f443af4d4ccb5dbf9dc156cb2a6b3ee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_157___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_157___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8e0b8ffe2152f7bb061afe1b8cc2cf5b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_158___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_158___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6f138dddb9068ed9deb97d66f8a4a0ad,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_159___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_159___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ed63b3fd75ae09f84d1ac8d724b0892b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_15___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_15___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9dc41cd1ae78f5934b45799a32540da0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_160___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_160___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_723e5289641b14306ae87c96d0c461c6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_161___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_161___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2546b3ff0691355f96b84825af8536c7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_162___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_162___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_501ff7d581b05da1d05a86fe0ad85a96,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_163___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_163___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cdd83968b5926d20e2e7b9ca4d0b58f0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_164___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_164___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_30db93ecd5f2bde29ae55c0d5f3ae202,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_165___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_165___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_777c5f1cf0e58ad143e7d4d1541f3a9b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_166___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_166___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7346d97a6acf28e8393536b873af6c89,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_167___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_167___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3a5102eb577fb4372f9d34ba72a6e91e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_168___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_168___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c98d790ca6223d6a3644d33bd2467526,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_169___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_169___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_78212c4b4aab735709dfbff7b76cb570,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_16_from_issuer_public_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_16_from_issuer_public_key,
        const_str_plain_from_issuer_public_key,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7ff35117673a9277a1a56b314dcb491c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_170___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_170___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3b9e5fcacf56da1f761df47407c4b7d4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_171___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_171___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_89af66793f1fc61aa38227cde0214ec2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_172___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_172___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_093eaa0e810751ddd673b7c5be612109,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_173___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_173___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c93644efbdbc7699d1558444ac6d1411,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_174___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_174___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1b541eeb081b95502e02af418188e21b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_175___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_175___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7f765b3590326b8670f2d2e63a18abd5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_176___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_176___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9ba8ec00a538bc1740a345849883dfb7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_177___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_177___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8f969f316377d0f9b0caba40b49b8c02,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_178___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_178___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e2a74a50be727bc49fb93340dd76c5a6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_179___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_179___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e6076427abefcbfd63f41a0300f8f79c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_17_from_issuer_subject_key_identifier(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_17_from_issuer_subject_key_identifier,
        const_str_plain_from_issuer_subject_key_identifier,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_73bb14bed3dfca8611c927e438dcc6d1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_180___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_180___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_52a71a816261aa20655054a6cf2cd004,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_181___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_181___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cea77827f2eac305a5259abe26384ad4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_182___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_182___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_06ede4ab871537b61c08c580959fa458,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_18___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_18___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_24a659e0b5b173b5b0c0638bb94387a8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_19___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_19___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cc7a4dc2c94b88b2c8cc7d6f77071a16,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_1__key_identifier_from_public_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_1__key_identifier_from_public_key,
        const_str_plain__key_identifier_from_public_key,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d43c3be20699fac34d3694aa86e1d73a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_20___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_20___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_98f0485697a13d329db62f025ca69055,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_21___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_21___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3507eef1aab655efc5eb282ddd6df11f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_22___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_22___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_60b448e7e2dc606440735ac8e5d8691f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_23_from_public_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_23_from_public_key,
        const_str_plain_from_public_key,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_022896bc33b4a7204d84fa2b6880e6cc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_24___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_24___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c664490bf2cb1f2b87743a30375121be,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_25___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_25___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_57b878bd30a7b81e486b96e3c4401c0a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_26___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_26___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a832e1e599b4539b0c4897fe94eb7731,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_27___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_27___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_659a0820a281f91b587826d06e5c7fee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_28___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_28___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_40f213b6f11b241a43740142e00ab9ab,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_29___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_29___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f799b95668610ebc24d3f07b237690e1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_2__make_sequence_methods(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_2__make_sequence_methods,
        const_str_plain__make_sequence_methods,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d730e719f82fc7facbe4eb13d71303fc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_1_len_method( struct Nuitka_CellObject *closure_field_name )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_1_len_method,
        const_str_plain_len_method,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_64cba0da5a657c80e4c65b31e75f4900,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        1
    );

result->m_closure[0] = closure_field_name;
Py_INCREF( result->m_closure[0] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_2_iter_method( struct Nuitka_CellObject *closure_field_name )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_2_iter_method,
        const_str_plain_iter_method,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5b8d0f2a0e6c3090c7a94dd8ad77bf87,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        1
    );

result->m_closure[0] = closure_field_name;
Py_INCREF( result->m_closure[0] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_3_getitem_method( struct Nuitka_CellObject *closure_field_name )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_2__make_sequence_methods$$$function_3_getitem_method,
        const_str_plain_getitem_method,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e5d51e6845904641cf548956df6959bf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        1
    );

result->m_closure[0] = closure_field_name;
Py_INCREF( result->m_closure[0] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_30___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_30___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cd463798241da98486e9c3fa55f5fc4d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_31___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_31___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1ad98fd393824af3d185d3a361c38cfa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_32___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_32___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_fb2d1e86479ac610614a07d93fea0f47,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_33___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_33___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9b119bc9e22a532e859a09afb821f8e4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_34___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_34___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d999c9f13b6b8303947563cefca3f80f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_35___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_35___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4e91e44c3bcc754dd269c486ee08327b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_36___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_36___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_82367caa71540dce30cd160871f23994,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_37___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_37___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6d5e1e6a7899503b88d3340b3792fdf9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_38___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_38___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4ca18bfa12c3bc19559b0a1931a20efa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_39___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_39___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b40e6da599a2c89c752888c535860a7a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_3___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_3___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_177dcec9eb5c8b0e02169c0f6f894e57,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_40___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_40___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_dc0f15fbcff159e2a6f1050cb1735e72,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_41___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_41___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e7e78460243290e4e69f97e186caf46f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_42___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_42___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d4425f82b152e2d24c56b73e79a512b0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_43___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_43___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c2b4b4eb68b8cda65212caee479d5c37,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_44___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_44___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2a4cd2aacba5505bee324db73a85961b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_45___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_45___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2d3cca7ece0d16a2395b72a526be98a8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_46___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_46___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a028e2d79c3f3de23eb6a9238178dcbb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_47___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_47___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_570758ffab42816481105f89d6aa8913,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_48___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_48___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7343becceae098df6e086719547e2f7e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_49___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_49___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6cf426505a8a71ab8f24c6f71a74b0cb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_4___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_4___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_551214abb8a6570be6ada69e6e1f5f07,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_50___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_50___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b18c87e2d8e243dd66ad82ea564ebd88,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_51___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_51___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a5a40d86b13e608d03513b23b4a76c2b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_52___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_52___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_58ca4cf1e6f5ee2247eee7ab1590e625,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_53___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_53___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e83a154ae2975041ff88351280be1927,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_54___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_54___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7070792c3c3a6ccf6682eea55ee7c662,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_55___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_55___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_967d20a02668c8df3b981c121e92390c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_56___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_56___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_75efb6deb95f95a6df103413ee1e48a9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_57___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_57___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2426e68a1691573cdabc00868b370303,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_58___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_58___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_fa2931ec8fdcd4814cb233f5a491f5a6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_59___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_59___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_548e0e17232c8f06b933389489c7d4f9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_5_oid(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_5_oid,
        const_str_plain_oid,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_408986620bf31dc37b5b1cb7c3f1a6dc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        const_str_digest_35185795abbb3b5bbc0cab5aa03aab83,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_60___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_60___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b7fdc0353e23c582f08622537806bb7a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_61___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_61___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1911d24b26514a8ef43cc8a5f5185162,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_62___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_62___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_eead1fd5104b0d4f8d1d4ffd849695ab,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_63___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_63___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_593e248f319c1962ca90d8a41e9a9b37,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_64___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_64___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3bafaa5dacbb94a3ec12b882c27fef71,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_65___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_65___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_235720495b109b09daf397b30088ca24,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_66___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_66___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5cb549ee87f94a874ff5835c02e8bf76,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_67___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_67___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2dbe05eea4e50ba135d849bf18bf240c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_68___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_68___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ceeefbfafb213371719a30a4754165d4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_69___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_69___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f9a53cd0e4d5f2dd63b517a6ab23b164,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_6___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_6___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_bd49e54fb09a1da0efb6cacab0b984e7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_70___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_70___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9ee5e0eb8ddcfdfc231fceb269a57aa0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_71___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_71___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_32a5567534533d3fcb64d922d269cbb9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_72___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_72___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5905ebf138e75fb05d5d095e8ff6e294,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_73___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_73___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b17d8bfe741848af9af0ee2a9bb1f68b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_74___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_74___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b33015c9c8f142821188a53ad7ed0219,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_75___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_75___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3497c1c37e412baefa4af9a9a209b6ae,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_76___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_76___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_412598eaeb7e5076c659e7571e1acadb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_77___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_77___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_51616706c0e3c52cf5160713d5617964,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_78___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_78___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a584e498103128fd6f0f75adcfa25ce5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_79___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_79___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a0de3733aff74e9bc6ad1271640bbb3a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_7_get_extension_for_oid(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_7_get_extension_for_oid,
        const_str_plain_get_extension_for_oid,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_acac3422c0e3d6f57a7c8462949c204c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_80___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_80___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8f3f5ca8f9dcd2eee7756b96f3f2bbe0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_81___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_81___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c6ffc7f3b129e13eebcbcd394632062a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_82___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_82___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8deead5e9a69c59660a72414a4a524b9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_83___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_83___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5d6754a9c513375f07c3b917f00663b8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_84___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_84___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_819e7ded813ebd3724f65aaa539d9d5c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_85___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_85___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_69a9fb7c23f7735a4e94f6c7a371cd0d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_86___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_86___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2f56c60eb8999fc8e0ae18eca4bed6ea,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_87___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_87___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a59e3470eb3314c071ae13b9d32dfac6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_88___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_88___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5a3287b9f9778171857e124b22ebfc17,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_89___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_89___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a9673f6324198b7604937ea246a4d5fb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_8_get_extension_for_class(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_8_get_extension_for_class,
        const_str_plain_get_extension_for_class,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1929fcfaa60d306de7136ca2141845f6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_90___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_90___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_12a61a0f3bdbcdc560a8ea860e2877f1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_91___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_91___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ff852a570e805f80242c9e3d5522b935,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_92___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_92___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0f9bf51bf63188a54bf9db4e12622b3b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_93___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_93___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_24eca4c72db0e65a6c34b09011c8543e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_94___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_94___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a902b9ea7d61e52337a09f3bba2dcc2f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_95___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_95___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8fb9d15244005ec133e79705c05a61d3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_96___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_96___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_41293317db5a160a626e998b0bcaae37,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_97___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_97___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_48635dd8a2061be9a32ee8f29fed87cb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_98___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_98___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d1ce443d1458827659a4c2d5d052464f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_99___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_99___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8e09650574ba24d0fac88dd7967ee8ec,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_9___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_9___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_64a6ae9ffc5aa8649774f127c5759ec5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_cryptography$x509$extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_cryptography$x509$extensions =
{
    PyModuleDef_HEAD_INIT,
    "cryptography.x509.extensions",   /* m_name */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___package__;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;
#endif
#if PYTHON_VERSION >= 330
extern PyObject *const_str_plain___loader__;
extern PyObject *metapath_based_loader;
#endif
#if PYTHON_VERSION >= 330
extern PyObject *const_str_plain___spec__;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( cryptography$x509$extensions )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_cryptography$x509$extensions );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    puts("cryptography.x509.extensions: Calling setupMetaPathBasedLoader().");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("cryptography.x509.extensions: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("cryptography.x509.extensions: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initcryptography$x509$extensions" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_cryptography$x509$extensions = Py_InitModule4(
        "cryptography.x509.extensions",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else

    module_cryptography$x509$extensions = PyModule_Create( &mdef_cryptography$x509$extensions );
#endif

    moduledict_cryptography$x509$extensions = MODULE_DICT( module_cryptography$x509$extensions );

    // Update "__package__" value to what it ought to be.
    {
#if 0
#if PYTHON_VERSION < 300 || PYTHON_VERSION >= 330
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___name__ );

        UPDATE_STRING_DICT1(
            moduledict_cryptography$x509$extensions,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#endif

#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___name__ );
        char const *module_name_cstr = PyString_AS_STRING( module_name );

        char const *last_dot = strrchr( module_name_cstr, '.' );

        if ( last_dot != NULL )
        {
            UPDATE_STRING_DICT1(
                moduledict_cryptography$x509$extensions,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize( module_name_cstr, last_dot - module_name_cstr )
            );
        }
#elif PYTHON_VERSION < 330
        UPDATE_STRING_DICT1(
            moduledict_cryptography$x509$extensions,
            (Nuitka_StringObject *)const_str_plain___package__,
            Py_None
        );
#else
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___name__ );
        Py_ssize_t dot_index = PyUnicode_Find( module_name, const_str_dot, 0, PyUnicode_GetLength( module_name ), -1 );

        if ( dot_index != -1 )
        {
            UPDATE_STRING_DICT1(
                moduledict_cryptography$x509$extensions,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring( module_name, 0, dot_index )
            );
        }
#endif
#endif
    }

    CHECK_OBJECT( module_cryptography$x509$extensions );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PySys_GetObject( (char *)"modules" ), const_str_digest_7822abce90b4f23aa7a437cf95bbfec5, module_cryptography$x509$extensions );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if ( GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

        UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___builtins__, value );
    }

#if PYTHON_VERSION >= 330
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___loader__, metapath_based_loader );
#endif

#if PYTHON_VERSION >= 340
#if 0
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___spec__, Py_None );
#else
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT( bootstrap_module );
        PyObject *module_spec_class = PyObject_GetAttrString( bootstrap_module, "ModuleSpec" );
        Py_DECREF( bootstrap_module );

        PyObject *args[] = {
            GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___name__ ),
            metapath_based_loader
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );

        UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___spec__, spec_value );

        Py_DECREF( module_spec_class );
    }
#endif
#endif


    // Temp variables if any
    PyObject *tmp_AuthorityInformationAccess$tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_AuthorityInformationAccess$tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_AuthorityInformationAccess$tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_AuthorityInformationAccess$tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_CRLDistributionPoints$tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_CRLDistributionPoints$tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_CRLDistributionPoints$tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_CRLDistributionPoints$tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_CertificateIssuer$tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_CertificateIssuer$tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_CertificateIssuer$tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_CertificateIssuer$tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_CertificatePolicies$tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_CertificatePolicies$tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_CertificatePolicies$tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_CertificatePolicies$tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_ExtendedKeyUsage$tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_ExtendedKeyUsage$tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_ExtendedKeyUsage$tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_ExtendedKeyUsage$tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_Extensions$tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_Extensions$tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_Extensions$tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_Extensions$tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_FreshestCRL$tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_FreshestCRL$tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_FreshestCRL$tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_FreshestCRL$tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_GeneralNames$tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_GeneralNames$tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_GeneralNames$tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_GeneralNames$tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_IssuerAlternativeName$tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_IssuerAlternativeName$tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_IssuerAlternativeName$tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_IssuerAlternativeName$tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_SubjectAlternativeName$tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_SubjectAlternativeName$tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_SubjectAlternativeName$tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_SubjectAlternativeName$tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_TLSFeature$tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_TLSFeature$tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_TLSFeature$tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_TLSFeature$tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_class_creation_10__class = NULL;
    PyObject *tmp_class_creation_10__class_dict = NULL;
    PyObject *tmp_class_creation_10__metaclass = NULL;
    PyObject *tmp_class_creation_11__class = NULL;
    PyObject *tmp_class_creation_11__class_dict = NULL;
    PyObject *tmp_class_creation_11__metaclass = NULL;
    PyObject *tmp_class_creation_12__class = NULL;
    PyObject *tmp_class_creation_12__class_dict = NULL;
    PyObject *tmp_class_creation_12__metaclass = NULL;
    PyObject *tmp_class_creation_13__class = NULL;
    PyObject *tmp_class_creation_13__class_dict = NULL;
    PyObject *tmp_class_creation_13__metaclass = NULL;
    PyObject *tmp_class_creation_14__class = NULL;
    PyObject *tmp_class_creation_14__class_dict = NULL;
    PyObject *tmp_class_creation_14__metaclass = NULL;
    PyObject *tmp_class_creation_15__bases = NULL;
    PyObject *tmp_class_creation_15__class = NULL;
    PyObject *tmp_class_creation_15__class_dict = NULL;
    PyObject *tmp_class_creation_15__metaclass = NULL;
    PyObject *tmp_class_creation_16__class = NULL;
    PyObject *tmp_class_creation_16__class_dict = NULL;
    PyObject *tmp_class_creation_16__metaclass = NULL;
    PyObject *tmp_class_creation_17__class = NULL;
    PyObject *tmp_class_creation_17__class_dict = NULL;
    PyObject *tmp_class_creation_17__metaclass = NULL;
    PyObject *tmp_class_creation_18__class = NULL;
    PyObject *tmp_class_creation_18__class_dict = NULL;
    PyObject *tmp_class_creation_18__metaclass = NULL;
    PyObject *tmp_class_creation_19__class = NULL;
    PyObject *tmp_class_creation_19__class_dict = NULL;
    PyObject *tmp_class_creation_19__metaclass = NULL;
    PyObject *tmp_class_creation_1__bases = NULL;
    PyObject *tmp_class_creation_1__class = NULL;
    PyObject *tmp_class_creation_1__class_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_20__class = NULL;
    PyObject *tmp_class_creation_20__class_dict = NULL;
    PyObject *tmp_class_creation_20__metaclass = NULL;
    PyObject *tmp_class_creation_21__class = NULL;
    PyObject *tmp_class_creation_21__class_dict = NULL;
    PyObject *tmp_class_creation_21__metaclass = NULL;
    PyObject *tmp_class_creation_22__class = NULL;
    PyObject *tmp_class_creation_22__class_dict = NULL;
    PyObject *tmp_class_creation_22__metaclass = NULL;
    PyObject *tmp_class_creation_23__class = NULL;
    PyObject *tmp_class_creation_23__class_dict = NULL;
    PyObject *tmp_class_creation_23__metaclass = NULL;
    PyObject *tmp_class_creation_24__class = NULL;
    PyObject *tmp_class_creation_24__class_dict = NULL;
    PyObject *tmp_class_creation_24__metaclass = NULL;
    PyObject *tmp_class_creation_25__bases = NULL;
    PyObject *tmp_class_creation_25__class = NULL;
    PyObject *tmp_class_creation_25__class_dict = NULL;
    PyObject *tmp_class_creation_25__metaclass = NULL;
    PyObject *tmp_class_creation_26__class = NULL;
    PyObject *tmp_class_creation_26__class_dict = NULL;
    PyObject *tmp_class_creation_26__metaclass = NULL;
    PyObject *tmp_class_creation_27__class = NULL;
    PyObject *tmp_class_creation_27__class_dict = NULL;
    PyObject *tmp_class_creation_27__metaclass = NULL;
    PyObject *tmp_class_creation_28__class = NULL;
    PyObject *tmp_class_creation_28__class_dict = NULL;
    PyObject *tmp_class_creation_28__metaclass = NULL;
    PyObject *tmp_class_creation_29__class = NULL;
    PyObject *tmp_class_creation_29__class_dict = NULL;
    PyObject *tmp_class_creation_29__metaclass = NULL;
    PyObject *tmp_class_creation_2__bases = NULL;
    PyObject *tmp_class_creation_2__class = NULL;
    PyObject *tmp_class_creation_2__class_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_30__class = NULL;
    PyObject *tmp_class_creation_30__class_dict = NULL;
    PyObject *tmp_class_creation_30__metaclass = NULL;
    PyObject *tmp_class_creation_31__class = NULL;
    PyObject *tmp_class_creation_31__class_dict = NULL;
    PyObject *tmp_class_creation_31__metaclass = NULL;
    PyObject *tmp_class_creation_32__class = NULL;
    PyObject *tmp_class_creation_32__class_dict = NULL;
    PyObject *tmp_class_creation_32__metaclass = NULL;
    PyObject *tmp_class_creation_33__class = NULL;
    PyObject *tmp_class_creation_33__class_dict = NULL;
    PyObject *tmp_class_creation_33__metaclass = NULL;
    PyObject *tmp_class_creation_34__class = NULL;
    PyObject *tmp_class_creation_34__class_dict = NULL;
    PyObject *tmp_class_creation_34__metaclass = NULL;
    PyObject *tmp_class_creation_35__class = NULL;
    PyObject *tmp_class_creation_35__class_dict = NULL;
    PyObject *tmp_class_creation_35__metaclass = NULL;
    PyObject *tmp_class_creation_36__class = NULL;
    PyObject *tmp_class_creation_36__class_dict = NULL;
    PyObject *tmp_class_creation_36__metaclass = NULL;
    PyObject *tmp_class_creation_37__class = NULL;
    PyObject *tmp_class_creation_37__class_dict = NULL;
    PyObject *tmp_class_creation_37__metaclass = NULL;
    PyObject *tmp_class_creation_38__class = NULL;
    PyObject *tmp_class_creation_38__class_dict = NULL;
    PyObject *tmp_class_creation_38__metaclass = NULL;
    PyObject *tmp_class_creation_39__class = NULL;
    PyObject *tmp_class_creation_39__class_dict = NULL;
    PyObject *tmp_class_creation_39__metaclass = NULL;
    PyObject *tmp_class_creation_3__class = NULL;
    PyObject *tmp_class_creation_3__class_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_4__class = NULL;
    PyObject *tmp_class_creation_4__class_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_5__class = NULL;
    PyObject *tmp_class_creation_5__class_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_6__class = NULL;
    PyObject *tmp_class_creation_6__class_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_7__class = NULL;
    PyObject *tmp_class_creation_7__class_dict = NULL;
    PyObject *tmp_class_creation_7__metaclass = NULL;
    PyObject *tmp_class_creation_8__class = NULL;
    PyObject *tmp_class_creation_8__class_dict = NULL;
    PyObject *tmp_class_creation_8__metaclass = NULL;
    PyObject *tmp_class_creation_9__class = NULL;
    PyObject *tmp_class_creation_9__class_dict = NULL;
    PyObject *tmp_class_creation_9__metaclass = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *tmp_import_from_1__module = NULL;
    PyObject *tmp_import_from_2__module = NULL;
    PyObject *tmp_import_from_3__module = NULL;
    PyObject *tmp_import_from_4__module = NULL;
    PyObject *tmp_import_from_5__module = NULL;
    PyObject *tmp_select_metaclass_15__base = NULL;
    PyObject *tmp_select_metaclass_1__base = NULL;
    PyObject *tmp_select_metaclass_25__base = NULL;
    PyObject *tmp_select_metaclass_2__base = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;
    PyObject *exception_keeper_type_28;
    PyObject *exception_keeper_value_28;
    PyTracebackObject *exception_keeper_tb_28;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_28;
    PyObject *exception_keeper_type_29;
    PyObject *exception_keeper_value_29;
    PyTracebackObject *exception_keeper_tb_29;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_29;
    PyObject *exception_keeper_type_30;
    PyObject *exception_keeper_value_30;
    PyTracebackObject *exception_keeper_tb_30;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_30;
    PyObject *exception_keeper_type_31;
    PyObject *exception_keeper_value_31;
    PyTracebackObject *exception_keeper_tb_31;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_31;
    PyObject *exception_keeper_type_32;
    PyObject *exception_keeper_value_32;
    PyTracebackObject *exception_keeper_tb_32;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_32;
    PyObject *exception_keeper_type_33;
    PyObject *exception_keeper_value_33;
    PyTracebackObject *exception_keeper_tb_33;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_33;
    PyObject *exception_keeper_type_34;
    PyObject *exception_keeper_value_34;
    PyTracebackObject *exception_keeper_tb_34;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_34;
    PyObject *exception_keeper_type_35;
    PyObject *exception_keeper_value_35;
    PyTracebackObject *exception_keeper_tb_35;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_35;
    PyObject *exception_keeper_type_36;
    PyObject *exception_keeper_value_36;
    PyTracebackObject *exception_keeper_tb_36;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_36;
    PyObject *exception_keeper_type_37;
    PyObject *exception_keeper_value_37;
    PyTracebackObject *exception_keeper_tb_37;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_37;
    PyObject *exception_keeper_type_38;
    PyObject *exception_keeper_value_38;
    PyTracebackObject *exception_keeper_tb_38;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_38;
    PyObject *exception_keeper_type_39;
    PyObject *exception_keeper_value_39;
    PyTracebackObject *exception_keeper_tb_39;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_39;
    PyObject *exception_keeper_type_40;
    PyObject *exception_keeper_value_40;
    PyTracebackObject *exception_keeper_tb_40;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_40;
    PyObject *exception_keeper_type_41;
    PyObject *exception_keeper_value_41;
    PyTracebackObject *exception_keeper_tb_41;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_41;
    PyObject *exception_keeper_type_42;
    PyObject *exception_keeper_value_42;
    PyTracebackObject *exception_keeper_tb_42;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_42;
    PyObject *exception_keeper_type_43;
    PyObject *exception_keeper_value_43;
    PyTracebackObject *exception_keeper_tb_43;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_43;
    PyObject *exception_keeper_type_44;
    PyObject *exception_keeper_value_44;
    PyTracebackObject *exception_keeper_tb_44;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_44;
    PyObject *exception_keeper_type_45;
    PyObject *exception_keeper_value_45;
    PyTracebackObject *exception_keeper_tb_45;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_45;
    PyObject *exception_keeper_type_46;
    PyObject *exception_keeper_value_46;
    PyTracebackObject *exception_keeper_tb_46;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_46;
    PyObject *exception_keeper_type_47;
    PyObject *exception_keeper_value_47;
    PyTracebackObject *exception_keeper_tb_47;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_47;
    PyObject *exception_keeper_type_48;
    PyObject *exception_keeper_value_48;
    PyTracebackObject *exception_keeper_tb_48;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_48;
    PyObject *exception_keeper_type_49;
    PyObject *exception_keeper_value_49;
    PyTracebackObject *exception_keeper_tb_49;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_49;
    PyObject *exception_keeper_type_50;
    PyObject *exception_keeper_value_50;
    PyTracebackObject *exception_keeper_tb_50;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_50;
    PyObject *exception_keeper_type_51;
    PyObject *exception_keeper_value_51;
    PyTracebackObject *exception_keeper_tb_51;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_51;
    PyObject *exception_keeper_type_52;
    PyObject *exception_keeper_value_52;
    PyTracebackObject *exception_keeper_tb_52;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_52;
    PyObject *exception_keeper_type_53;
    PyObject *exception_keeper_value_53;
    PyTracebackObject *exception_keeper_tb_53;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_53;
    PyObject *exception_keeper_type_54;
    PyObject *exception_keeper_value_54;
    PyTracebackObject *exception_keeper_tb_54;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_54;
    PyObject *exception_keeper_type_55;
    PyObject *exception_keeper_value_55;
    PyTracebackObject *exception_keeper_tb_55;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_55;
    PyObject *exception_keeper_type_56;
    PyObject *exception_keeper_value_56;
    PyTracebackObject *exception_keeper_tb_56;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_56;
    PyObject *exception_keeper_type_57;
    PyObject *exception_keeper_value_57;
    PyTracebackObject *exception_keeper_tb_57;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_57;
    PyObject *exception_keeper_type_58;
    PyObject *exception_keeper_value_58;
    PyTracebackObject *exception_keeper_tb_58;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_58;
    PyObject *exception_keeper_type_59;
    PyObject *exception_keeper_value_59;
    PyTracebackObject *exception_keeper_tb_59;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_59;
    PyObject *exception_keeper_type_60;
    PyObject *exception_keeper_value_60;
    PyTracebackObject *exception_keeper_tb_60;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_60;
    PyObject *exception_keeper_type_61;
    PyObject *exception_keeper_value_61;
    PyTracebackObject *exception_keeper_tb_61;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_61;
    PyObject *exception_keeper_type_62;
    PyObject *exception_keeper_value_62;
    PyTracebackObject *exception_keeper_tb_62;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_62;
    PyObject *exception_keeper_type_63;
    PyObject *exception_keeper_value_63;
    PyTracebackObject *exception_keeper_tb_63;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_63;
    PyObject *exception_keeper_type_64;
    PyObject *exception_keeper_value_64;
    PyTracebackObject *exception_keeper_tb_64;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_64;
    PyObject *exception_keeper_type_65;
    PyObject *exception_keeper_value_65;
    PyTracebackObject *exception_keeper_tb_65;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_65;
    PyObject *exception_keeper_type_66;
    PyObject *exception_keeper_value_66;
    PyTracebackObject *exception_keeper_tb_66;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_66;
    PyObject *exception_keeper_type_67;
    PyObject *exception_keeper_value_67;
    PyTracebackObject *exception_keeper_tb_67;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_67;
    PyObject *exception_keeper_type_68;
    PyObject *exception_keeper_value_68;
    PyTracebackObject *exception_keeper_tb_68;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_68;
    PyObject *exception_keeper_type_69;
    PyObject *exception_keeper_value_69;
    PyTracebackObject *exception_keeper_tb_69;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_69;
    PyObject *exception_keeper_type_70;
    PyObject *exception_keeper_value_70;
    PyTracebackObject *exception_keeper_tb_70;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_70;
    PyObject *exception_keeper_type_71;
    PyObject *exception_keeper_value_71;
    PyTracebackObject *exception_keeper_tb_71;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_71;
    PyObject *exception_keeper_type_72;
    PyObject *exception_keeper_value_72;
    PyTracebackObject *exception_keeper_tb_72;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_72;
    PyObject *exception_keeper_type_73;
    PyObject *exception_keeper_value_73;
    PyTracebackObject *exception_keeper_tb_73;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_73;
    PyObject *exception_keeper_type_74;
    PyObject *exception_keeper_value_74;
    PyTracebackObject *exception_keeper_tb_74;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_74;
    PyObject *exception_keeper_type_75;
    PyObject *exception_keeper_value_75;
    PyTracebackObject *exception_keeper_tb_75;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_75;
    PyObject *exception_keeper_type_76;
    PyObject *exception_keeper_value_76;
    PyTracebackObject *exception_keeper_tb_76;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_76;
    PyObject *exception_keeper_type_77;
    PyObject *exception_keeper_value_77;
    PyTracebackObject *exception_keeper_tb_77;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_77;
    PyObject *exception_keeper_type_78;
    PyObject *exception_keeper_value_78;
    PyTracebackObject *exception_keeper_tb_78;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_78;
    PyObject *exception_keeper_type_79;
    PyObject *exception_keeper_value_79;
    PyTracebackObject *exception_keeper_tb_79;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_79;
    PyObject *exception_keeper_type_80;
    PyObject *exception_keeper_value_80;
    PyTracebackObject *exception_keeper_tb_80;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_80;
    PyObject *exception_keeper_type_81;
    PyObject *exception_keeper_value_81;
    PyTracebackObject *exception_keeper_tb_81;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_81;
    PyObject *exception_keeper_type_82;
    PyObject *exception_keeper_value_82;
    PyTracebackObject *exception_keeper_tb_82;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_82;
    PyObject *exception_keeper_type_83;
    PyObject *exception_keeper_value_83;
    PyTracebackObject *exception_keeper_tb_83;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_83;
    PyObject *exception_keeper_type_84;
    PyObject *exception_keeper_value_84;
    PyTracebackObject *exception_keeper_tb_84;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_84;
    PyObject *exception_keeper_type_85;
    PyObject *exception_keeper_value_85;
    PyTracebackObject *exception_keeper_tb_85;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_85;
    PyObject *exception_keeper_type_86;
    PyObject *exception_keeper_value_86;
    PyTracebackObject *exception_keeper_tb_86;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_86;
    PyObject *exception_keeper_type_87;
    PyObject *exception_keeper_value_87;
    PyTracebackObject *exception_keeper_tb_87;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_87;
    PyObject *exception_keeper_type_88;
    PyObject *exception_keeper_value_88;
    PyTracebackObject *exception_keeper_tb_88;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_88;
    PyObject *exception_keeper_type_89;
    PyObject *exception_keeper_value_89;
    PyTracebackObject *exception_keeper_tb_89;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_89;
    PyObject *exception_keeper_type_90;
    PyObject *exception_keeper_value_90;
    PyTracebackObject *exception_keeper_tb_90;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_90;
    PyObject *exception_keeper_type_91;
    PyObject *exception_keeper_value_91;
    PyTracebackObject *exception_keeper_tb_91;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_91;
    PyObject *exception_keeper_type_92;
    PyObject *exception_keeper_value_92;
    PyTracebackObject *exception_keeper_tb_92;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_92;
    PyObject *exception_keeper_type_93;
    PyObject *exception_keeper_value_93;
    PyTracebackObject *exception_keeper_tb_93;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_93;
    PyObject *exception_keeper_type_94;
    PyObject *exception_keeper_value_94;
    PyTracebackObject *exception_keeper_tb_94;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_94;
    PyObject *exception_keeper_type_95;
    PyObject *exception_keeper_value_95;
    PyTracebackObject *exception_keeper_tb_95;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_95;
    PyObject *exception_keeper_type_96;
    PyObject *exception_keeper_value_96;
    PyTracebackObject *exception_keeper_tb_96;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_96;
    PyObject *exception_keeper_type_97;
    PyObject *exception_keeper_value_97;
    PyTracebackObject *exception_keeper_tb_97;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_97;
    PyObject *exception_keeper_type_98;
    PyObject *exception_keeper_value_98;
    PyTracebackObject *exception_keeper_tb_98;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_98;
    PyObject *exception_keeper_type_99;
    PyObject *exception_keeper_value_99;
    PyTracebackObject *exception_keeper_tb_99;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_99;
    PyObject *exception_keeper_type_100;
    PyObject *exception_keeper_value_100;
    PyTracebackObject *exception_keeper_tb_100;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_100;
    PyObject *exception_keeper_type_101;
    PyObject *exception_keeper_value_101;
    PyTracebackObject *exception_keeper_tb_101;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_101;
    PyObject *exception_keeper_type_102;
    PyObject *exception_keeper_value_102;
    PyTracebackObject *exception_keeper_tb_102;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_102;
    PyObject *exception_keeper_type_103;
    PyObject *exception_keeper_value_103;
    PyTracebackObject *exception_keeper_tb_103;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_103;
    PyObject *exception_keeper_type_104;
    PyObject *exception_keeper_value_104;
    PyTracebackObject *exception_keeper_tb_104;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_104;
    PyObject *exception_keeper_type_105;
    PyObject *exception_keeper_value_105;
    PyTracebackObject *exception_keeper_tb_105;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_105;
    PyObject *exception_keeper_type_106;
    PyObject *exception_keeper_value_106;
    PyTracebackObject *exception_keeper_tb_106;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_106;
    PyObject *exception_keeper_type_107;
    PyObject *exception_keeper_value_107;
    PyTracebackObject *exception_keeper_tb_107;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_107;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_element_name_22;
    PyObject *tmp_args_element_name_23;
    PyObject *tmp_args_element_name_24;
    PyObject *tmp_args_element_name_25;
    PyObject *tmp_args_element_name_26;
    PyObject *tmp_args_element_name_27;
    PyObject *tmp_args_element_name_28;
    PyObject *tmp_args_element_name_29;
    PyObject *tmp_args_element_name_30;
    PyObject *tmp_args_element_name_31;
    PyObject *tmp_args_element_name_32;
    PyObject *tmp_args_element_name_33;
    PyObject *tmp_args_element_name_34;
    PyObject *tmp_args_element_name_35;
    PyObject *tmp_args_element_name_36;
    PyObject *tmp_args_element_name_37;
    PyObject *tmp_args_element_name_38;
    PyObject *tmp_args_element_name_39;
    PyObject *tmp_args_element_name_40;
    PyObject *tmp_args_element_name_41;
    PyObject *tmp_args_element_name_42;
    PyObject *tmp_args_element_name_43;
    PyObject *tmp_args_element_name_44;
    PyObject *tmp_args_element_name_45;
    PyObject *tmp_args_element_name_46;
    PyObject *tmp_args_element_name_47;
    PyObject *tmp_args_element_name_48;
    PyObject *tmp_args_element_name_49;
    PyObject *tmp_args_element_name_50;
    PyObject *tmp_args_element_name_51;
    PyObject *tmp_args_element_name_52;
    PyObject *tmp_args_element_name_53;
    PyObject *tmp_args_element_name_54;
    PyObject *tmp_args_element_name_55;
    PyObject *tmp_args_element_name_56;
    PyObject *tmp_args_element_name_57;
    PyObject *tmp_args_element_name_58;
    PyObject *tmp_args_element_name_59;
    PyObject *tmp_args_element_name_60;
    PyObject *tmp_args_element_name_61;
    PyObject *tmp_args_element_name_62;
    PyObject *tmp_args_element_name_63;
    PyObject *tmp_args_element_name_64;
    PyObject *tmp_args_element_name_65;
    PyObject *tmp_args_element_name_66;
    PyObject *tmp_args_element_name_67;
    PyObject *tmp_args_element_name_68;
    PyObject *tmp_args_element_name_69;
    PyObject *tmp_args_element_name_70;
    PyObject *tmp_args_element_name_71;
    PyObject *tmp_args_element_name_72;
    PyObject *tmp_args_element_name_73;
    PyObject *tmp_args_element_name_74;
    PyObject *tmp_args_element_name_75;
    PyObject *tmp_args_element_name_76;
    PyObject *tmp_args_element_name_77;
    PyObject *tmp_args_element_name_78;
    PyObject *tmp_args_element_name_79;
    PyObject *tmp_args_element_name_80;
    PyObject *tmp_args_element_name_81;
    PyObject *tmp_args_element_name_82;
    PyObject *tmp_args_element_name_83;
    PyObject *tmp_args_element_name_84;
    PyObject *tmp_args_element_name_85;
    PyObject *tmp_args_element_name_86;
    PyObject *tmp_args_element_name_87;
    PyObject *tmp_args_element_name_88;
    PyObject *tmp_args_element_name_89;
    PyObject *tmp_args_element_name_90;
    PyObject *tmp_args_element_name_91;
    PyObject *tmp_args_element_name_92;
    PyObject *tmp_args_element_name_93;
    PyObject *tmp_args_element_name_94;
    PyObject *tmp_args_element_name_95;
    PyObject *tmp_args_element_name_96;
    PyObject *tmp_args_element_name_97;
    PyObject *tmp_args_element_name_98;
    PyObject *tmp_args_element_name_99;
    PyObject *tmp_args_element_name_100;
    PyObject *tmp_args_element_name_101;
    PyObject *tmp_args_element_name_102;
    PyObject *tmp_args_element_name_103;
    PyObject *tmp_args_element_name_104;
    PyObject *tmp_args_element_name_105;
    PyObject *tmp_args_element_name_106;
    PyObject *tmp_args_element_name_107;
    PyObject *tmp_args_element_name_108;
    PyObject *tmp_args_element_name_109;
    PyObject *tmp_args_element_name_110;
    PyObject *tmp_args_element_name_111;
    PyObject *tmp_args_element_name_112;
    PyObject *tmp_args_element_name_113;
    PyObject *tmp_args_element_name_114;
    PyObject *tmp_args_element_name_115;
    PyObject *tmp_args_element_name_116;
    PyObject *tmp_args_element_name_117;
    PyObject *tmp_args_element_name_118;
    PyObject *tmp_args_element_name_119;
    PyObject *tmp_args_element_name_120;
    PyObject *tmp_args_element_name_121;
    PyObject *tmp_args_element_name_122;
    PyObject *tmp_args_element_name_123;
    PyObject *tmp_args_element_name_124;
    PyObject *tmp_args_element_name_125;
    PyObject *tmp_args_element_name_126;
    PyObject *tmp_args_element_name_127;
    PyObject *tmp_args_element_name_128;
    PyObject *tmp_args_element_name_129;
    PyObject *tmp_args_element_name_130;
    PyObject *tmp_args_element_name_131;
    PyObject *tmp_args_element_name_132;
    PyObject *tmp_args_element_name_133;
    PyObject *tmp_args_element_name_134;
    PyObject *tmp_args_element_name_135;
    PyObject *tmp_args_element_name_136;
    PyObject *tmp_args_element_name_137;
    PyObject *tmp_args_element_name_138;
    PyObject *tmp_args_element_name_139;
    PyObject *tmp_args_element_name_140;
    PyObject *tmp_args_element_name_141;
    PyObject *tmp_args_element_name_142;
    PyObject *tmp_args_element_name_143;
    PyObject *tmp_args_element_name_144;
    PyObject *tmp_args_element_name_145;
    PyObject *tmp_args_element_name_146;
    PyObject *tmp_args_element_name_147;
    PyObject *tmp_args_element_name_148;
    PyObject *tmp_args_element_name_149;
    PyObject *tmp_args_element_name_150;
    PyObject *tmp_args_element_name_151;
    PyObject *tmp_args_element_name_152;
    PyObject *tmp_args_element_name_153;
    PyObject *tmp_args_element_name_154;
    PyObject *tmp_args_element_name_155;
    PyObject *tmp_args_element_name_156;
    PyObject *tmp_args_element_name_157;
    PyObject *tmp_args_element_name_158;
    PyObject *tmp_args_element_name_159;
    PyObject *tmp_args_element_name_160;
    PyObject *tmp_args_element_name_161;
    PyObject *tmp_args_element_name_162;
    PyObject *tmp_args_element_name_163;
    PyObject *tmp_args_element_name_164;
    PyObject *tmp_args_element_name_165;
    PyObject *tmp_args_element_name_166;
    PyObject *tmp_args_element_name_167;
    PyObject *tmp_args_element_name_168;
    PyObject *tmp_args_element_name_169;
    PyObject *tmp_args_element_name_170;
    PyObject *tmp_args_element_name_171;
    PyObject *tmp_args_element_name_172;
    PyObject *tmp_args_element_name_173;
    PyObject *tmp_args_element_name_174;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_assign_source_30;
    PyObject *tmp_assign_source_31;
    PyObject *tmp_assign_source_32;
    PyObject *tmp_assign_source_33;
    PyObject *tmp_assign_source_34;
    PyObject *tmp_assign_source_35;
    PyObject *tmp_assign_source_36;
    PyObject *tmp_assign_source_37;
    PyObject *tmp_assign_source_38;
    PyObject *tmp_assign_source_39;
    PyObject *tmp_assign_source_40;
    PyObject *tmp_assign_source_41;
    PyObject *tmp_assign_source_42;
    PyObject *tmp_assign_source_43;
    PyObject *tmp_assign_source_44;
    PyObject *tmp_assign_source_45;
    PyObject *tmp_assign_source_46;
    PyObject *tmp_assign_source_47;
    PyObject *tmp_assign_source_48;
    PyObject *tmp_assign_source_49;
    PyObject *tmp_assign_source_50;
    PyObject *tmp_assign_source_51;
    PyObject *tmp_assign_source_52;
    PyObject *tmp_assign_source_53;
    PyObject *tmp_assign_source_54;
    PyObject *tmp_assign_source_55;
    PyObject *tmp_assign_source_56;
    PyObject *tmp_assign_source_57;
    PyObject *tmp_assign_source_58;
    PyObject *tmp_assign_source_59;
    PyObject *tmp_assign_source_60;
    PyObject *tmp_assign_source_61;
    PyObject *tmp_assign_source_62;
    PyObject *tmp_assign_source_63;
    PyObject *tmp_assign_source_64;
    PyObject *tmp_assign_source_65;
    PyObject *tmp_assign_source_66;
    PyObject *tmp_assign_source_67;
    PyObject *tmp_assign_source_68;
    PyObject *tmp_assign_source_69;
    PyObject *tmp_assign_source_70;
    PyObject *tmp_assign_source_71;
    PyObject *tmp_assign_source_72;
    PyObject *tmp_assign_source_73;
    PyObject *tmp_assign_source_74;
    PyObject *tmp_assign_source_75;
    PyObject *tmp_assign_source_76;
    PyObject *tmp_assign_source_77;
    PyObject *tmp_assign_source_78;
    PyObject *tmp_assign_source_79;
    PyObject *tmp_assign_source_80;
    PyObject *tmp_assign_source_81;
    PyObject *tmp_assign_source_82;
    PyObject *tmp_assign_source_83;
    PyObject *tmp_assign_source_84;
    PyObject *tmp_assign_source_85;
    PyObject *tmp_assign_source_86;
    PyObject *tmp_assign_source_87;
    PyObject *tmp_assign_source_88;
    PyObject *tmp_assign_source_89;
    PyObject *tmp_assign_source_90;
    PyObject *tmp_assign_source_91;
    PyObject *tmp_assign_source_92;
    PyObject *tmp_assign_source_93;
    PyObject *tmp_assign_source_94;
    PyObject *tmp_assign_source_95;
    PyObject *tmp_assign_source_96;
    PyObject *tmp_assign_source_97;
    PyObject *tmp_assign_source_98;
    PyObject *tmp_assign_source_99;
    PyObject *tmp_assign_source_100;
    PyObject *tmp_assign_source_101;
    PyObject *tmp_assign_source_102;
    PyObject *tmp_assign_source_103;
    PyObject *tmp_assign_source_104;
    PyObject *tmp_assign_source_105;
    PyObject *tmp_assign_source_106;
    PyObject *tmp_assign_source_107;
    PyObject *tmp_assign_source_108;
    PyObject *tmp_assign_source_109;
    PyObject *tmp_assign_source_110;
    PyObject *tmp_assign_source_111;
    PyObject *tmp_assign_source_112;
    PyObject *tmp_assign_source_113;
    PyObject *tmp_assign_source_114;
    PyObject *tmp_assign_source_115;
    PyObject *tmp_assign_source_116;
    PyObject *tmp_assign_source_117;
    PyObject *tmp_assign_source_118;
    PyObject *tmp_assign_source_119;
    PyObject *tmp_assign_source_120;
    PyObject *tmp_assign_source_121;
    PyObject *tmp_assign_source_122;
    PyObject *tmp_assign_source_123;
    PyObject *tmp_assign_source_124;
    PyObject *tmp_assign_source_125;
    PyObject *tmp_assign_source_126;
    PyObject *tmp_assign_source_127;
    PyObject *tmp_assign_source_128;
    PyObject *tmp_assign_source_129;
    PyObject *tmp_assign_source_130;
    PyObject *tmp_assign_source_131;
    PyObject *tmp_assign_source_132;
    PyObject *tmp_assign_source_133;
    PyObject *tmp_assign_source_134;
    PyObject *tmp_assign_source_135;
    PyObject *tmp_assign_source_136;
    PyObject *tmp_assign_source_137;
    PyObject *tmp_assign_source_138;
    PyObject *tmp_assign_source_139;
    PyObject *tmp_assign_source_140;
    PyObject *tmp_assign_source_141;
    PyObject *tmp_assign_source_142;
    PyObject *tmp_assign_source_143;
    PyObject *tmp_assign_source_144;
    PyObject *tmp_assign_source_145;
    PyObject *tmp_assign_source_146;
    PyObject *tmp_assign_source_147;
    PyObject *tmp_assign_source_148;
    PyObject *tmp_assign_source_149;
    PyObject *tmp_assign_source_150;
    PyObject *tmp_assign_source_151;
    PyObject *tmp_assign_source_152;
    PyObject *tmp_assign_source_153;
    PyObject *tmp_assign_source_154;
    PyObject *tmp_assign_source_155;
    PyObject *tmp_assign_source_156;
    PyObject *tmp_assign_source_157;
    PyObject *tmp_assign_source_158;
    PyObject *tmp_assign_source_159;
    PyObject *tmp_assign_source_160;
    PyObject *tmp_assign_source_161;
    PyObject *tmp_assign_source_162;
    PyObject *tmp_assign_source_163;
    PyObject *tmp_assign_source_164;
    PyObject *tmp_assign_source_165;
    PyObject *tmp_assign_source_166;
    PyObject *tmp_assign_source_167;
    PyObject *tmp_assign_source_168;
    PyObject *tmp_assign_source_169;
    PyObject *tmp_assign_source_170;
    PyObject *tmp_assign_source_171;
    PyObject *tmp_assign_source_172;
    PyObject *tmp_assign_source_173;
    PyObject *tmp_assign_source_174;
    PyObject *tmp_assign_source_175;
    PyObject *tmp_assign_source_176;
    PyObject *tmp_assign_source_177;
    PyObject *tmp_assign_source_178;
    PyObject *tmp_assign_source_179;
    PyObject *tmp_assign_source_180;
    PyObject *tmp_assign_source_181;
    PyObject *tmp_assign_source_182;
    PyObject *tmp_assign_source_183;
    PyObject *tmp_assign_source_184;
    PyObject *tmp_assign_source_185;
    PyObject *tmp_assign_source_186;
    PyObject *tmp_assign_source_187;
    PyObject *tmp_assign_source_188;
    PyObject *tmp_assign_source_189;
    PyObject *tmp_assign_source_190;
    PyObject *tmp_assign_source_191;
    PyObject *tmp_assign_source_192;
    PyObject *tmp_assign_source_193;
    PyObject *tmp_assign_source_194;
    PyObject *tmp_assign_source_195;
    PyObject *tmp_assign_source_196;
    PyObject *tmp_assign_source_197;
    PyObject *tmp_assign_source_198;
    PyObject *tmp_assign_source_199;
    PyObject *tmp_assign_source_200;
    PyObject *tmp_assign_source_201;
    PyObject *tmp_assign_source_202;
    PyObject *tmp_assign_source_203;
    PyObject *tmp_assign_source_204;
    PyObject *tmp_assign_source_205;
    PyObject *tmp_assign_source_206;
    PyObject *tmp_assign_source_207;
    PyObject *tmp_assign_source_208;
    PyObject *tmp_assign_source_209;
    PyObject *tmp_assign_source_210;
    PyObject *tmp_assign_source_211;
    PyObject *tmp_assign_source_212;
    PyObject *tmp_assign_source_213;
    PyObject *tmp_assign_source_214;
    PyObject *tmp_assign_source_215;
    PyObject *tmp_assign_source_216;
    PyObject *tmp_assign_source_217;
    PyObject *tmp_assign_source_218;
    PyObject *tmp_assign_source_219;
    PyObject *tmp_assign_source_220;
    PyObject *tmp_assign_source_221;
    PyObject *tmp_assign_source_222;
    PyObject *tmp_assign_source_223;
    PyObject *tmp_assign_source_224;
    PyObject *tmp_assign_source_225;
    PyObject *tmp_assign_source_226;
    PyObject *tmp_assign_source_227;
    PyObject *tmp_assign_source_228;
    PyObject *tmp_assign_source_229;
    PyObject *tmp_assign_source_230;
    PyObject *tmp_assign_source_231;
    PyObject *tmp_assign_source_232;
    PyObject *tmp_assign_source_233;
    PyObject *tmp_assign_source_234;
    PyObject *tmp_assign_source_235;
    PyObject *tmp_assign_source_236;
    PyObject *tmp_assign_source_237;
    PyObject *tmp_assign_source_238;
    PyObject *tmp_assign_source_239;
    PyObject *tmp_assign_source_240;
    PyObject *tmp_assign_source_241;
    PyObject *tmp_assign_source_242;
    PyObject *tmp_assign_source_243;
    PyObject *tmp_assign_source_244;
    PyObject *tmp_assign_source_245;
    PyObject *tmp_assign_source_246;
    PyObject *tmp_assign_source_247;
    PyObject *tmp_assign_source_248;
    PyObject *tmp_assign_source_249;
    PyObject *tmp_assign_source_250;
    PyObject *tmp_assign_source_251;
    PyObject *tmp_assign_source_252;
    PyObject *tmp_assign_source_253;
    PyObject *tmp_assign_source_254;
    PyObject *tmp_assign_source_255;
    PyObject *tmp_assign_source_256;
    PyObject *tmp_assign_source_257;
    PyObject *tmp_assign_source_258;
    PyObject *tmp_assign_source_259;
    PyObject *tmp_assign_source_260;
    PyObject *tmp_assign_source_261;
    PyObject *tmp_assign_source_262;
    PyObject *tmp_assign_source_263;
    PyObject *tmp_assign_source_264;
    PyObject *tmp_assign_source_265;
    PyObject *tmp_assign_source_266;
    PyObject *tmp_assign_source_267;
    PyObject *tmp_assign_source_268;
    PyObject *tmp_assign_source_269;
    PyObject *tmp_assign_source_270;
    PyObject *tmp_assign_source_271;
    PyObject *tmp_assign_source_272;
    PyObject *tmp_assign_source_273;
    PyObject *tmp_assign_source_274;
    PyObject *tmp_assign_source_275;
    PyObject *tmp_assign_source_276;
    PyObject *tmp_assign_source_277;
    PyObject *tmp_assign_source_278;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_instance_10;
    PyObject *tmp_called_instance_11;
    PyObject *tmp_called_instance_12;
    PyObject *tmp_called_instance_13;
    PyObject *tmp_called_instance_14;
    PyObject *tmp_called_instance_15;
    PyObject *tmp_called_instance_16;
    PyObject *tmp_called_instance_17;
    PyObject *tmp_called_instance_18;
    PyObject *tmp_called_instance_19;
    PyObject *tmp_called_instance_20;
    PyObject *tmp_called_instance_21;
    PyObject *tmp_called_instance_22;
    PyObject *tmp_called_instance_23;
    PyObject *tmp_called_instance_24;
    PyObject *tmp_called_instance_25;
    PyObject *tmp_called_instance_26;
    PyObject *tmp_called_instance_27;
    PyObject *tmp_called_instance_28;
    PyObject *tmp_called_instance_29;
    PyObject *tmp_called_instance_30;
    PyObject *tmp_called_instance_31;
    PyObject *tmp_called_instance_32;
    PyObject *tmp_called_instance_33;
    PyObject *tmp_called_instance_34;
    PyObject *tmp_called_instance_35;
    PyObject *tmp_called_instance_36;
    PyObject *tmp_called_instance_37;
    PyObject *tmp_called_instance_38;
    PyObject *tmp_called_instance_39;
    PyObject *tmp_called_instance_40;
    PyObject *tmp_called_instance_41;
    PyObject *tmp_called_instance_42;
    PyObject *tmp_called_instance_43;
    PyObject *tmp_called_instance_44;
    PyObject *tmp_called_instance_45;
    PyObject *tmp_called_instance_46;
    PyObject *tmp_called_instance_47;
    PyObject *tmp_called_instance_48;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    PyObject *tmp_called_name_21;
    PyObject *tmp_called_name_22;
    PyObject *tmp_called_name_23;
    PyObject *tmp_called_name_24;
    PyObject *tmp_called_name_25;
    PyObject *tmp_called_name_26;
    PyObject *tmp_called_name_27;
    PyObject *tmp_called_name_28;
    PyObject *tmp_called_name_29;
    PyObject *tmp_called_name_30;
    PyObject *tmp_called_name_31;
    PyObject *tmp_called_name_32;
    PyObject *tmp_called_name_33;
    PyObject *tmp_called_name_34;
    PyObject *tmp_called_name_35;
    PyObject *tmp_called_name_36;
    PyObject *tmp_called_name_37;
    PyObject *tmp_called_name_38;
    PyObject *tmp_called_name_39;
    PyObject *tmp_called_name_40;
    PyObject *tmp_called_name_41;
    PyObject *tmp_called_name_42;
    PyObject *tmp_called_name_43;
    PyObject *tmp_called_name_44;
    PyObject *tmp_called_name_45;
    PyObject *tmp_called_name_46;
    PyObject *tmp_called_name_47;
    PyObject *tmp_called_name_48;
    PyObject *tmp_called_name_49;
    PyObject *tmp_called_name_50;
    PyObject *tmp_called_name_51;
    PyObject *tmp_called_name_52;
    PyObject *tmp_called_name_53;
    PyObject *tmp_called_name_54;
    PyObject *tmp_called_name_55;
    PyObject *tmp_called_name_56;
    PyObject *tmp_called_name_57;
    PyObject *tmp_called_name_58;
    PyObject *tmp_called_name_59;
    PyObject *tmp_called_name_60;
    PyObject *tmp_called_name_61;
    PyObject *tmp_called_name_62;
    PyObject *tmp_called_name_63;
    PyObject *tmp_called_name_64;
    PyObject *tmp_called_name_65;
    PyObject *tmp_called_name_66;
    PyObject *tmp_called_name_67;
    PyObject *tmp_called_name_68;
    PyObject *tmp_called_name_69;
    PyObject *tmp_called_name_70;
    PyObject *tmp_called_name_71;
    PyObject *tmp_called_name_72;
    PyObject *tmp_called_name_73;
    PyObject *tmp_called_name_74;
    PyObject *tmp_called_name_75;
    PyObject *tmp_called_name_76;
    PyObject *tmp_called_name_77;
    PyObject *tmp_called_name_78;
    PyObject *tmp_called_name_79;
    PyObject *tmp_called_name_80;
    PyObject *tmp_called_name_81;
    PyObject *tmp_called_name_82;
    PyObject *tmp_called_name_83;
    PyObject *tmp_called_name_84;
    PyObject *tmp_called_name_85;
    PyObject *tmp_called_name_86;
    PyObject *tmp_called_name_87;
    PyObject *tmp_called_name_88;
    PyObject *tmp_called_name_89;
    PyObject *tmp_called_name_90;
    PyObject *tmp_called_name_91;
    PyObject *tmp_called_name_92;
    PyObject *tmp_called_name_93;
    PyObject *tmp_called_name_94;
    PyObject *tmp_called_name_95;
    PyObject *tmp_called_name_96;
    PyObject *tmp_called_name_97;
    PyObject *tmp_called_name_98;
    PyObject *tmp_called_name_99;
    PyObject *tmp_called_name_100;
    PyObject *tmp_called_name_101;
    PyObject *tmp_called_name_102;
    PyObject *tmp_called_name_103;
    PyObject *tmp_called_name_104;
    PyObject *tmp_called_name_105;
    PyObject *tmp_called_name_106;
    PyObject *tmp_called_name_107;
    PyObject *tmp_classmethod_arg_1;
    PyObject *tmp_classmethod_arg_2;
    PyObject *tmp_classmethod_arg_3;
    int tmp_cmp_In_1;
    int tmp_cmp_In_2;
    int tmp_cmp_In_3;
    int tmp_cmp_In_4;
    int tmp_cmp_In_5;
    int tmp_cmp_In_6;
    int tmp_cmp_In_7;
    int tmp_cmp_In_8;
    int tmp_cmp_In_9;
    int tmp_cmp_In_10;
    int tmp_cmp_In_11;
    int tmp_cmp_In_12;
    int tmp_cmp_In_13;
    int tmp_cmp_In_14;
    int tmp_cmp_In_15;
    int tmp_cmp_In_16;
    int tmp_cmp_In_17;
    int tmp_cmp_In_18;
    int tmp_cmp_In_19;
    int tmp_cmp_In_20;
    int tmp_cmp_In_21;
    int tmp_cmp_In_22;
    int tmp_cmp_In_23;
    int tmp_cmp_In_24;
    int tmp_cmp_In_25;
    int tmp_cmp_In_26;
    int tmp_cmp_In_27;
    int tmp_cmp_In_28;
    int tmp_cmp_In_29;
    int tmp_cmp_In_30;
    int tmp_cmp_In_31;
    int tmp_cmp_In_32;
    int tmp_cmp_In_33;
    int tmp_cmp_In_34;
    int tmp_cmp_In_35;
    int tmp_cmp_In_36;
    int tmp_cmp_In_37;
    int tmp_cmp_In_38;
    int tmp_cmp_In_39;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_left_9;
    PyObject *tmp_compare_left_10;
    PyObject *tmp_compare_left_11;
    PyObject *tmp_compare_left_12;
    PyObject *tmp_compare_left_13;
    PyObject *tmp_compare_left_14;
    PyObject *tmp_compare_left_15;
    PyObject *tmp_compare_left_16;
    PyObject *tmp_compare_left_17;
    PyObject *tmp_compare_left_18;
    PyObject *tmp_compare_left_19;
    PyObject *tmp_compare_left_20;
    PyObject *tmp_compare_left_21;
    PyObject *tmp_compare_left_22;
    PyObject *tmp_compare_left_23;
    PyObject *tmp_compare_left_24;
    PyObject *tmp_compare_left_25;
    PyObject *tmp_compare_left_26;
    PyObject *tmp_compare_left_27;
    PyObject *tmp_compare_left_28;
    PyObject *tmp_compare_left_29;
    PyObject *tmp_compare_left_30;
    PyObject *tmp_compare_left_31;
    PyObject *tmp_compare_left_32;
    PyObject *tmp_compare_left_33;
    PyObject *tmp_compare_left_34;
    PyObject *tmp_compare_left_35;
    PyObject *tmp_compare_left_36;
    PyObject *tmp_compare_left_37;
    PyObject *tmp_compare_left_38;
    PyObject *tmp_compare_left_39;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_compare_right_9;
    PyObject *tmp_compare_right_10;
    PyObject *tmp_compare_right_11;
    PyObject *tmp_compare_right_12;
    PyObject *tmp_compare_right_13;
    PyObject *tmp_compare_right_14;
    PyObject *tmp_compare_right_15;
    PyObject *tmp_compare_right_16;
    PyObject *tmp_compare_right_17;
    PyObject *tmp_compare_right_18;
    PyObject *tmp_compare_right_19;
    PyObject *tmp_compare_right_20;
    PyObject *tmp_compare_right_21;
    PyObject *tmp_compare_right_22;
    PyObject *tmp_compare_right_23;
    PyObject *tmp_compare_right_24;
    PyObject *tmp_compare_right_25;
    PyObject *tmp_compare_right_26;
    PyObject *tmp_compare_right_27;
    PyObject *tmp_compare_right_28;
    PyObject *tmp_compare_right_29;
    PyObject *tmp_compare_right_30;
    PyObject *tmp_compare_right_31;
    PyObject *tmp_compare_right_32;
    PyObject *tmp_compare_right_33;
    PyObject *tmp_compare_right_34;
    PyObject *tmp_compare_right_35;
    PyObject *tmp_compare_right_36;
    PyObject *tmp_compare_right_37;
    PyObject *tmp_compare_right_38;
    PyObject *tmp_compare_right_39;
    PyObject *tmp_dict_name_1;
    PyObject *tmp_dict_name_2;
    PyObject *tmp_dict_name_3;
    PyObject *tmp_dict_name_4;
    PyObject *tmp_dict_name_5;
    PyObject *tmp_dict_name_6;
    PyObject *tmp_dict_name_7;
    PyObject *tmp_dict_name_8;
    PyObject *tmp_dict_name_9;
    PyObject *tmp_dict_name_10;
    PyObject *tmp_dict_name_11;
    PyObject *tmp_dict_name_12;
    PyObject *tmp_dict_name_13;
    PyObject *tmp_dict_name_14;
    PyObject *tmp_dict_name_15;
    PyObject *tmp_dict_name_16;
    PyObject *tmp_dict_name_17;
    PyObject *tmp_dict_name_18;
    PyObject *tmp_dict_name_19;
    PyObject *tmp_dict_name_20;
    PyObject *tmp_dict_name_21;
    PyObject *tmp_dict_name_22;
    PyObject *tmp_dict_name_23;
    PyObject *tmp_dict_name_24;
    PyObject *tmp_dict_name_25;
    PyObject *tmp_dict_name_26;
    PyObject *tmp_dict_name_27;
    PyObject *tmp_dict_name_28;
    PyObject *tmp_dict_name_29;
    PyObject *tmp_dict_name_30;
    PyObject *tmp_dict_name_31;
    PyObject *tmp_dict_name_32;
    PyObject *tmp_dict_name_33;
    PyObject *tmp_dict_name_34;
    PyObject *tmp_dict_name_35;
    PyObject *tmp_dict_name_36;
    PyObject *tmp_dict_name_37;
    PyObject *tmp_dict_name_38;
    PyObject *tmp_dict_name_39;
    PyObject *tmp_dict_seq_1;
    PyObject *tmp_dictset_value;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_fromlist_name_2;
    PyObject *tmp_fromlist_name_3;
    PyObject *tmp_fromlist_name_4;
    PyObject *tmp_fromlist_name_5;
    PyObject *tmp_fromlist_name_6;
    PyObject *tmp_fromlist_name_7;
    PyObject *tmp_fromlist_name_8;
    PyObject *tmp_fromlist_name_9;
    PyObject *tmp_fromlist_name_10;
    PyObject *tmp_fromlist_name_11;
    PyObject *tmp_fromlist_name_12;
    PyObject *tmp_fromlist_name_13;
    PyObject *tmp_fromlist_name_14;
    PyObject *tmp_fromlist_name_15;
    PyObject *tmp_fromlist_name_16;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_globals_name_2;
    PyObject *tmp_globals_name_3;
    PyObject *tmp_globals_name_4;
    PyObject *tmp_globals_name_5;
    PyObject *tmp_globals_name_6;
    PyObject *tmp_globals_name_7;
    PyObject *tmp_globals_name_8;
    PyObject *tmp_globals_name_9;
    PyObject *tmp_globals_name_10;
    PyObject *tmp_globals_name_11;
    PyObject *tmp_globals_name_12;
    PyObject *tmp_globals_name_13;
    PyObject *tmp_globals_name_14;
    PyObject *tmp_globals_name_15;
    PyObject *tmp_globals_name_16;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_import_name_from_3;
    PyObject *tmp_import_name_from_4;
    PyObject *tmp_import_name_from_5;
    PyObject *tmp_import_name_from_6;
    PyObject *tmp_import_name_from_7;
    PyObject *tmp_import_name_from_8;
    PyObject *tmp_import_name_from_9;
    PyObject *tmp_import_name_from_10;
    PyObject *tmp_import_name_from_11;
    PyObject *tmp_import_name_from_12;
    PyObject *tmp_import_name_from_13;
    PyObject *tmp_import_name_from_14;
    PyObject *tmp_import_name_from_15;
    PyObject *tmp_import_name_from_16;
    PyObject *tmp_import_name_from_17;
    PyObject *tmp_import_name_from_18;
    PyObject *tmp_import_name_from_19;
    PyObject *tmp_import_name_from_20;
    PyObject *tmp_import_name_from_21;
    PyObject *tmp_import_name_from_22;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_iter_arg_3;
    PyObject *tmp_iter_arg_4;
    PyObject *tmp_iter_arg_5;
    PyObject *tmp_iter_arg_6;
    PyObject *tmp_iter_arg_7;
    PyObject *tmp_iter_arg_8;
    PyObject *tmp_iter_arg_9;
    PyObject *tmp_iter_arg_10;
    PyObject *tmp_iter_arg_11;
    PyObject *tmp_iter_arg_12;
    PyObject *tmp_iter_arg_13;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_iterator_name_2;
    PyObject *tmp_iterator_name_3;
    PyObject *tmp_iterator_name_4;
    PyObject *tmp_iterator_name_5;
    PyObject *tmp_iterator_name_6;
    PyObject *tmp_iterator_name_7;
    PyObject *tmp_iterator_name_8;
    PyObject *tmp_iterator_name_9;
    PyObject *tmp_iterator_name_10;
    PyObject *tmp_iterator_name_11;
    PyObject *tmp_iterator_name_12;
    PyObject *tmp_key_name_1;
    PyObject *tmp_key_name_2;
    PyObject *tmp_key_name_3;
    PyObject *tmp_key_name_4;
    PyObject *tmp_key_name_5;
    PyObject *tmp_key_name_6;
    PyObject *tmp_key_name_7;
    PyObject *tmp_key_name_8;
    PyObject *tmp_key_name_9;
    PyObject *tmp_key_name_10;
    PyObject *tmp_key_name_11;
    PyObject *tmp_key_name_12;
    PyObject *tmp_key_name_13;
    PyObject *tmp_key_name_14;
    PyObject *tmp_key_name_15;
    PyObject *tmp_key_name_16;
    PyObject *tmp_key_name_17;
    PyObject *tmp_key_name_18;
    PyObject *tmp_key_name_19;
    PyObject *tmp_key_name_20;
    PyObject *tmp_key_name_21;
    PyObject *tmp_key_name_22;
    PyObject *tmp_key_name_23;
    PyObject *tmp_key_name_24;
    PyObject *tmp_key_name_25;
    PyObject *tmp_key_name_26;
    PyObject *tmp_key_name_27;
    PyObject *tmp_key_name_28;
    PyObject *tmp_key_name_29;
    PyObject *tmp_key_name_30;
    PyObject *tmp_key_name_31;
    PyObject *tmp_key_name_32;
    PyObject *tmp_key_name_33;
    PyObject *tmp_key_name_34;
    PyObject *tmp_key_name_35;
    PyObject *tmp_key_name_36;
    PyObject *tmp_key_name_37;
    PyObject *tmp_key_name_38;
    PyObject *tmp_key_name_39;
    PyObject *tmp_level_name_1;
    PyObject *tmp_level_name_2;
    PyObject *tmp_level_name_3;
    PyObject *tmp_level_name_4;
    PyObject *tmp_level_name_5;
    PyObject *tmp_level_name_6;
    PyObject *tmp_level_name_7;
    PyObject *tmp_level_name_8;
    PyObject *tmp_level_name_9;
    PyObject *tmp_level_name_10;
    PyObject *tmp_level_name_11;
    PyObject *tmp_level_name_12;
    PyObject *tmp_level_name_13;
    PyObject *tmp_level_name_14;
    PyObject *tmp_level_name_15;
    PyObject *tmp_level_name_16;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_locals_name_2;
    PyObject *tmp_locals_name_3;
    PyObject *tmp_locals_name_4;
    PyObject *tmp_locals_name_5;
    PyObject *tmp_locals_name_6;
    PyObject *tmp_locals_name_7;
    PyObject *tmp_locals_name_8;
    PyObject *tmp_locals_name_9;
    PyObject *tmp_locals_name_10;
    PyObject *tmp_locals_name_11;
    PyObject *tmp_locals_name_12;
    PyObject *tmp_locals_name_13;
    PyObject *tmp_locals_name_14;
    PyObject *tmp_locals_name_15;
    PyObject *tmp_locals_name_16;
    PyObject *tmp_name_name_1;
    PyObject *tmp_name_name_2;
    PyObject *tmp_name_name_3;
    PyObject *tmp_name_name_4;
    PyObject *tmp_name_name_5;
    PyObject *tmp_name_name_6;
    PyObject *tmp_name_name_7;
    PyObject *tmp_name_name_8;
    PyObject *tmp_name_name_9;
    PyObject *tmp_name_name_10;
    PyObject *tmp_name_name_11;
    PyObject *tmp_name_name_12;
    PyObject *tmp_name_name_13;
    PyObject *tmp_name_name_14;
    PyObject *tmp_name_name_15;
    PyObject *tmp_name_name_16;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_outline_return_value_2;
    PyObject *tmp_outline_return_value_3;
    PyObject *tmp_outline_return_value_4;
    PyObject *tmp_outline_return_value_5;
    PyObject *tmp_outline_return_value_6;
    PyObject *tmp_outline_return_value_7;
    PyObject *tmp_outline_return_value_8;
    PyObject *tmp_outline_return_value_9;
    PyObject *tmp_outline_return_value_10;
    PyObject *tmp_outline_return_value_11;
    PyObject *tmp_outline_return_value_12;
    PyObject *tmp_outline_return_value_13;
    PyObject *tmp_outline_return_value_14;
    PyObject *tmp_outline_return_value_15;
    PyObject *tmp_outline_return_value_16;
    PyObject *tmp_outline_return_value_17;
    PyObject *tmp_outline_return_value_18;
    PyObject *tmp_outline_return_value_19;
    PyObject *tmp_outline_return_value_20;
    PyObject *tmp_outline_return_value_21;
    PyObject *tmp_outline_return_value_22;
    PyObject *tmp_outline_return_value_23;
    PyObject *tmp_outline_return_value_24;
    PyObject *tmp_outline_return_value_25;
    PyObject *tmp_outline_return_value_26;
    PyObject *tmp_outline_return_value_27;
    PyObject *tmp_outline_return_value_28;
    PyObject *tmp_outline_return_value_29;
    PyObject *tmp_outline_return_value_30;
    PyObject *tmp_outline_return_value_31;
    PyObject *tmp_outline_return_value_32;
    PyObject *tmp_outline_return_value_33;
    PyObject *tmp_outline_return_value_34;
    PyObject *tmp_outline_return_value_35;
    PyObject *tmp_outline_return_value_36;
    PyObject *tmp_outline_return_value_37;
    PyObject *tmp_outline_return_value_38;
    PyObject *tmp_outline_return_value_39;
    PyObject *tmp_outline_return_value_40;
    PyObject *tmp_outline_return_value_41;
    PyObject *tmp_outline_return_value_42;
    PyObject *tmp_outline_return_value_43;
    PyObject *tmp_outline_return_value_44;
    int tmp_res;
    PyObject *tmp_set_locals;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    PyObject *tmp_source_name_19;
    PyObject *tmp_source_name_20;
    PyObject *tmp_source_name_21;
    PyObject *tmp_source_name_22;
    PyObject *tmp_source_name_23;
    PyObject *tmp_source_name_24;
    PyObject *tmp_source_name_25;
    PyObject *tmp_source_name_26;
    PyObject *tmp_source_name_27;
    PyObject *tmp_source_name_28;
    PyObject *tmp_source_name_29;
    PyObject *tmp_source_name_30;
    PyObject *tmp_source_name_31;
    PyObject *tmp_source_name_32;
    PyObject *tmp_source_name_33;
    PyObject *tmp_source_name_34;
    PyObject *tmp_source_name_35;
    PyObject *tmp_source_name_36;
    PyObject *tmp_source_name_37;
    PyObject *tmp_source_name_38;
    PyObject *tmp_source_name_39;
    PyObject *tmp_source_name_40;
    PyObject *tmp_source_name_41;
    PyObject *tmp_source_name_42;
    PyObject *tmp_source_name_43;
    PyObject *tmp_source_name_44;
    PyObject *tmp_source_name_45;
    PyObject *tmp_source_name_46;
    PyObject *tmp_source_name_47;
    PyObject *tmp_source_name_48;
    PyObject *tmp_source_name_49;
    PyObject *tmp_source_name_50;
    PyObject *tmp_source_name_51;
    PyObject *tmp_source_name_52;
    PyObject *tmp_source_name_53;
    PyObject *tmp_source_name_54;
    PyObject *tmp_source_name_55;
    PyObject *tmp_source_name_56;
    PyObject *tmp_source_name_57;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_tuple_element_4;
    PyObject *tmp_type_arg_1;
    PyObject *tmp_type_arg_2;
    PyObject *tmp_type_arg_3;
    PyObject *tmp_type_arg_4;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    PyObject *tmp_unpack_3;
    PyObject *tmp_unpack_4;
    PyObject *tmp_unpack_5;
    PyObject *tmp_unpack_6;
    PyObject *tmp_unpack_7;
    PyObject *tmp_unpack_8;
    PyObject *tmp_unpack_9;
    PyObject *tmp_unpack_10;
    PyObject *tmp_unpack_11;
    PyObject *tmp_unpack_12;
    PyObject *tmp_unpack_13;
    PyObject *tmp_unpack_14;
    PyObject *tmp_unpack_15;
    PyObject *tmp_unpack_16;
    PyObject *tmp_unpack_17;
    PyObject *tmp_unpack_18;
    PyObject *tmp_unpack_19;
    PyObject *tmp_unpack_20;
    PyObject *tmp_unpack_21;
    PyObject *tmp_unpack_22;
    PyObject *tmp_unpack_23;
    PyObject *tmp_unpack_24;
    PyObject *tmp_unpack_25;
    PyObject *tmp_unpack_26;
    PyObject *tmp_unpack_27;
    PyObject *tmp_unpack_28;
    PyObject *tmp_unpack_29;
    PyObject *tmp_unpack_30;
    PyObject *tmp_unpack_31;
    PyObject *tmp_unpack_32;
    PyObject *tmp_unpack_33;
    PyObject *tmp_unpack_34;
    PyObject *tmp_unpack_35;
    PyObject *tmp_unpack_36;
    static struct Nuitka_FrameObject *cache_frame_cc2dd91dca578c1e2053b1e93066de1e_2 = NULL;

    struct Nuitka_FrameObject *frame_cc2dd91dca578c1e2053b1e93066de1e_2;

    static struct Nuitka_FrameObject *cache_frame_ee3c270008e9c546283aead71bfc3864_3 = NULL;

    struct Nuitka_FrameObject *frame_ee3c270008e9c546283aead71bfc3864_3;

    static struct Nuitka_FrameObject *cache_frame_0850861f8e53ba258cf8c812b5257de8_4 = NULL;

    struct Nuitka_FrameObject *frame_0850861f8e53ba258cf8c812b5257de8_4;

    static struct Nuitka_FrameObject *cache_frame_9785c3bd15b32f86e88298ed70b78f98_5 = NULL;

    struct Nuitka_FrameObject *frame_9785c3bd15b32f86e88298ed70b78f98_5;

    static struct Nuitka_FrameObject *cache_frame_08a1b65564a30b1f1e14109e0bae6149_6 = NULL;

    struct Nuitka_FrameObject *frame_08a1b65564a30b1f1e14109e0bae6149_6;

    static struct Nuitka_FrameObject *cache_frame_69802bcecece78bdea4189479571dd66_7 = NULL;

    struct Nuitka_FrameObject *frame_69802bcecece78bdea4189479571dd66_7;

    static struct Nuitka_FrameObject *cache_frame_4f772ca62aff292069d20685ea8ad5a3_8 = NULL;

    struct Nuitka_FrameObject *frame_4f772ca62aff292069d20685ea8ad5a3_8;

    static struct Nuitka_FrameObject *cache_frame_1b99be5f5125e520c5e83672fe393339_9 = NULL;

    struct Nuitka_FrameObject *frame_1b99be5f5125e520c5e83672fe393339_9;

    static struct Nuitka_FrameObject *cache_frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10 = NULL;

    struct Nuitka_FrameObject *frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10;

    static struct Nuitka_FrameObject *cache_frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11 = NULL;

    struct Nuitka_FrameObject *frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11;

    static struct Nuitka_FrameObject *cache_frame_dce89ec5d6ba48c58dbdd43f0b34646a_12 = NULL;

    struct Nuitka_FrameObject *frame_dce89ec5d6ba48c58dbdd43f0b34646a_12;

    static struct Nuitka_FrameObject *cache_frame_712d92b931f86762fe66868302371b42_13 = NULL;

    struct Nuitka_FrameObject *frame_712d92b931f86762fe66868302371b42_13;

    static struct Nuitka_FrameObject *cache_frame_465314d58281e7cbbb03e4f8c9567305_14 = NULL;

    struct Nuitka_FrameObject *frame_465314d58281e7cbbb03e4f8c9567305_14;

    static struct Nuitka_FrameObject *cache_frame_6086204b98cd7a3504a399bfa8318f89_15 = NULL;

    struct Nuitka_FrameObject *frame_6086204b98cd7a3504a399bfa8318f89_15;

    static struct Nuitka_FrameObject *cache_frame_d28e44372df668104d77395650e260bf_16 = NULL;

    struct Nuitka_FrameObject *frame_d28e44372df668104d77395650e260bf_16;

    static struct Nuitka_FrameObject *cache_frame_2098416324e0e575808c7fc7af839a8b_17 = NULL;

    struct Nuitka_FrameObject *frame_2098416324e0e575808c7fc7af839a8b_17;

    static struct Nuitka_FrameObject *cache_frame_35875bcb7c761051b162bab059cb2263_18 = NULL;

    struct Nuitka_FrameObject *frame_35875bcb7c761051b162bab059cb2263_18;

    static struct Nuitka_FrameObject *cache_frame_d61a1308ab34f09405007abf3d96513d_19 = NULL;

    struct Nuitka_FrameObject *frame_d61a1308ab34f09405007abf3d96513d_19;

    static struct Nuitka_FrameObject *cache_frame_47c73715590dd417125d0b31840d019d_20 = NULL;

    struct Nuitka_FrameObject *frame_47c73715590dd417125d0b31840d019d_20;

    static struct Nuitka_FrameObject *cache_frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21 = NULL;

    struct Nuitka_FrameObject *frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21;

    static struct Nuitka_FrameObject *cache_frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22 = NULL;

    struct Nuitka_FrameObject *frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22;

    static struct Nuitka_FrameObject *cache_frame_91766bb581ac47f3950cf4363ddf6101_23 = NULL;

    struct Nuitka_FrameObject *frame_91766bb581ac47f3950cf4363ddf6101_23;

    static struct Nuitka_FrameObject *cache_frame_d7dc6886ba34e40cd7ef252f6e349251_24 = NULL;

    struct Nuitka_FrameObject *frame_d7dc6886ba34e40cd7ef252f6e349251_24;

    static struct Nuitka_FrameObject *cache_frame_d1c2e4d7460a8ac2798c7a347fc9360d_25 = NULL;

    struct Nuitka_FrameObject *frame_d1c2e4d7460a8ac2798c7a347fc9360d_25;

    static struct Nuitka_FrameObject *cache_frame_cf753b2aac21c54581e397ad48de68ce_26 = NULL;

    struct Nuitka_FrameObject *frame_cf753b2aac21c54581e397ad48de68ce_26;

    static struct Nuitka_FrameObject *cache_frame_f6cb175ee3c5700aba57c91b105c56e0_27 = NULL;

    struct Nuitka_FrameObject *frame_f6cb175ee3c5700aba57c91b105c56e0_27;

    static struct Nuitka_FrameObject *cache_frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28 = NULL;

    struct Nuitka_FrameObject *frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28;

    static struct Nuitka_FrameObject *cache_frame_729253a47ed1776955e8d27ecd2e7328_29 = NULL;

    struct Nuitka_FrameObject *frame_729253a47ed1776955e8d27ecd2e7328_29;

    static struct Nuitka_FrameObject *cache_frame_34264ca058405cbbc64ede36ef24ba67_30 = NULL;

    struct Nuitka_FrameObject *frame_34264ca058405cbbc64ede36ef24ba67_30;

    static struct Nuitka_FrameObject *cache_frame_a4a29737b836789d950c2cc5c6053ad4_31 = NULL;

    struct Nuitka_FrameObject *frame_a4a29737b836789d950c2cc5c6053ad4_31;

    static struct Nuitka_FrameObject *cache_frame_bd5df53feaf3918c5d9af33cf2bcef94_32 = NULL;

    struct Nuitka_FrameObject *frame_bd5df53feaf3918c5d9af33cf2bcef94_32;

    static struct Nuitka_FrameObject *cache_frame_223717f5f7d37ac0eeb879531047bfcf_33 = NULL;

    struct Nuitka_FrameObject *frame_223717f5f7d37ac0eeb879531047bfcf_33;

    static struct Nuitka_FrameObject *cache_frame_a0dcedc74a44194c715350024de9064f_34 = NULL;

    struct Nuitka_FrameObject *frame_a0dcedc74a44194c715350024de9064f_34;

    static struct Nuitka_FrameObject *cache_frame_2db8e09794d5a59d04ae35a3fa1b13f2_35 = NULL;

    struct Nuitka_FrameObject *frame_2db8e09794d5a59d04ae35a3fa1b13f2_35;

    static struct Nuitka_FrameObject *cache_frame_97f6035c4dcab8dd27ed5558d571757a_36 = NULL;

    struct Nuitka_FrameObject *frame_97f6035c4dcab8dd27ed5558d571757a_36;

    struct Nuitka_FrameObject *frame_80de6067447f8063ab4895e4ecf97af8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_4 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_5 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_6 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_7 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_8 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_9 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_10 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_11 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_12 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_13 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_14 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_15 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_16 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_17 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_18 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_19 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_20 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_21 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_22 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_23 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_24 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_25 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_26 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_27 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_28 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_29 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_30 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_31 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_32 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_33 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_34 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_35 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_36 = NULL;
    tmp_outline_return_value_1 = NULL;
    tmp_outline_return_value_2 = NULL;
    tmp_outline_return_value_3 = NULL;
    tmp_outline_return_value_4 = NULL;
    tmp_outline_return_value_5 = NULL;
    tmp_outline_return_value_6 = NULL;
    tmp_outline_return_value_7 = NULL;
    tmp_outline_return_value_8 = NULL;
    tmp_outline_return_value_9 = NULL;
    tmp_outline_return_value_10 = NULL;
    tmp_outline_return_value_11 = NULL;
    tmp_outline_return_value_12 = NULL;
    tmp_outline_return_value_13 = NULL;
    tmp_outline_return_value_14 = NULL;
    tmp_outline_return_value_15 = NULL;
    tmp_outline_return_value_16 = NULL;
    tmp_outline_return_value_17 = NULL;
    tmp_outline_return_value_18 = NULL;
    tmp_outline_return_value_19 = NULL;
    tmp_outline_return_value_20 = NULL;
    tmp_outline_return_value_21 = NULL;
    tmp_outline_return_value_22 = NULL;
    tmp_outline_return_value_23 = NULL;
    tmp_outline_return_value_24 = NULL;
    tmp_outline_return_value_25 = NULL;
    tmp_outline_return_value_26 = NULL;
    tmp_outline_return_value_27 = NULL;
    tmp_outline_return_value_28 = NULL;
    tmp_outline_return_value_29 = NULL;
    tmp_outline_return_value_30 = NULL;
    tmp_outline_return_value_31 = NULL;
    tmp_outline_return_value_32 = NULL;
    tmp_outline_return_value_33 = NULL;
    tmp_outline_return_value_34 = NULL;
    tmp_outline_return_value_35 = NULL;
    tmp_outline_return_value_36 = NULL;
    tmp_outline_return_value_37 = NULL;
    tmp_outline_return_value_38 = NULL;
    tmp_outline_return_value_39 = NULL;
    tmp_outline_return_value_40 = NULL;
    tmp_outline_return_value_41 = NULL;
    tmp_outline_return_value_42 = NULL;
    tmp_outline_return_value_43 = NULL;
    tmp_outline_return_value_44 = NULL;
    PyObject *locals_AccessDescription_334 = NULL;
    PyObject *locals_CertificatePolicies_680 = NULL;
    PyObject *locals_CertificateIssuer_1295 = NULL;
    PyObject *locals_FreshestCRL_477 = NULL;
    PyObject *locals_KeyUsage_986 = NULL;
    PyObject *locals_Extension_1162 = NULL;
    PyObject *locals_IssuerAlternativeName_1267 = NULL;
    PyObject *locals_UserNotice_761 = NULL;
    PyObject *locals_InhibitAnyPolicy_955 = NULL;
    PyObject *locals_NameConstraints_1081 = NULL;
    PyObject *locals_PolicyConstraints_619 = NULL;
    PyObject *locals_PrecertPoison_886 = NULL;
    PyObject *locals_PolicyInformation_711 = NULL;
    PyObject *locals_CRLReason_1323 = NULL;
    PyObject *locals_DeltaCRLIndicator_413 = NULL;
    PyObject *locals_OCSPNonce_1424 = NULL;
    PyObject *locals_IssuingDistributionPoint_1452 = NULL;
    PyObject *locals_CRLNumber_143 = NULL;
    PyObject *locals_TLSFeatureType_940 = NULL;
    PyObject *locals_InvalidityDate_1351 = NULL;
    PyObject *locals_Extensions_107 = NULL;
    PyObject *locals_ExtendedKeyUsage_835 = NULL;
    PyObject *locals_AuthorityInformationAccess_303 = NULL;
    PyObject *locals_CRLDistributionPoints_441 = NULL;
    PyObject *locals_BasicConstraints_371 = NULL;
    PyObject *locals_SubjectKeyIdentifier_274 = NULL;
    PyObject *locals_SubjectAlternativeName_1239 = NULL;
    PyObject *locals_ExtensionNotFound_92 = NULL;
    PyObject *locals_GeneralNames_1201 = NULL;
    PyObject *locals_OCSPNoCheck_866 = NULL;
    PyObject *locals_UnrecognizedExtension_1582 = NULL;
    PyObject *locals_DuplicateExtension_86 = NULL;
    PyObject *locals_TLSFeature_906 = NULL;
    PyObject *locals_DistributionPoint_512 = NULL;
    PyObject *locals_NoticeReference_798 = NULL;
    PyObject *locals_ReasonFlags_605 = NULL;
    PyObject *locals_PrecertificateSignedCertificateTimestamps_1381 = NULL;
    PyObject *locals_AuthorityKeyIdentifier_171 = NULL;
    PyObject *locals_ExtensionType_99 = NULL;

    // Module code.
    tmp_assign_source_1 = Py_None;
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    tmp_assign_source_2 = module_filename_obj;
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    tmp_assign_source_3 = PyImport_ImportModule("__future__");
    assert( tmp_assign_source_3 != NULL );
    assert( tmp_import_from_1__module == NULL );
    Py_INCREF( tmp_assign_source_3 );
    tmp_import_from_1__module = tmp_assign_source_3;

    // Frame without reuse.
    frame_80de6067447f8063ab4895e4ecf97af8 = MAKE_MODULE_FRAME( codeobj_80de6067447f8063ab4895e4ecf97af8, module_cryptography$x509$extensions );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_80de6067447f8063ab4895e4ecf97af8 );
    assert( Py_REFCNT( frame_80de6067447f8063ab4895e4ecf97af8 ) == 2 );

    // Framed code:
    // Tried code:
    tmp_import_name_from_1 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_1 );
    tmp_assign_source_4 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_absolute_import );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 5;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_absolute_import, tmp_assign_source_4 );
    tmp_import_name_from_2 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_2 );
    tmp_assign_source_5 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_division );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 5;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_division, tmp_assign_source_5 );
    tmp_import_name_from_3 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_3 );
    tmp_assign_source_6 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_print_function );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 5;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_print_function, tmp_assign_source_6 );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    tmp_name_name_1 = const_str_plain_abc;
    tmp_globals_name_1 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = Py_None;
    tmp_level_name_1 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 7;
    tmp_assign_source_7 = IMPORT_MODULE5( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1, tmp_level_name_1 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 7;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_abc, tmp_assign_source_7 );
    tmp_name_name_2 = const_str_plain_datetime;
    tmp_globals_name_2 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_2 = Py_None;
    tmp_fromlist_name_2 = Py_None;
    tmp_level_name_2 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 8;
    tmp_assign_source_8 = IMPORT_MODULE5( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2, tmp_level_name_2 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 8;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_datetime, tmp_assign_source_8 );
    tmp_name_name_3 = const_str_plain_hashlib;
    tmp_globals_name_3 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_3 = Py_None;
    tmp_fromlist_name_3 = Py_None;
    tmp_level_name_3 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 9;
    tmp_assign_source_9 = IMPORT_MODULE5( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3, tmp_level_name_3 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 9;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_hashlib, tmp_assign_source_9 );
    tmp_name_name_4 = const_str_plain_ipaddress;
    tmp_globals_name_4 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_4 = Py_None;
    tmp_fromlist_name_4 = Py_None;
    tmp_level_name_4 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 10;
    tmp_assign_source_10 = IMPORT_MODULE5( tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4, tmp_level_name_4 );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 10;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ipaddress, tmp_assign_source_10 );
    tmp_name_name_5 = const_str_plain_warnings;
    tmp_globals_name_5 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_5 = Py_None;
    tmp_fromlist_name_5 = Py_None;
    tmp_level_name_5 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 11;
    tmp_assign_source_11 = IMPORT_MODULE5( tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5, tmp_level_name_5 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_warnings, tmp_assign_source_11 );
    tmp_name_name_6 = const_str_plain_enum;
    tmp_globals_name_6 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_6 = Py_None;
    tmp_fromlist_name_6 = const_tuple_str_plain_Enum_tuple;
    tmp_level_name_6 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 12;
    tmp_import_name_from_4 = IMPORT_MODULE5( tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6, tmp_level_name_6 );
    if ( tmp_import_name_from_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 12;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_12 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain_Enum );
    Py_DECREF( tmp_import_name_from_4 );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 12;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_Enum, tmp_assign_source_12 );
    tmp_name_name_7 = const_str_plain_six;
    tmp_globals_name_7 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_7 = Py_None;
    tmp_fromlist_name_7 = Py_None;
    tmp_level_name_7 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 14;
    tmp_assign_source_13 = IMPORT_MODULE5( tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7, tmp_level_name_7 );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 14;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six, tmp_assign_source_13 );
    tmp_name_name_8 = const_str_plain_cryptography;
    tmp_globals_name_8 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_8 = Py_None;
    tmp_fromlist_name_8 = const_tuple_str_plain_utils_tuple;
    tmp_level_name_8 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 16;
    tmp_import_name_from_5 = IMPORT_MODULE5( tmp_name_name_8, tmp_globals_name_8, tmp_locals_name_8, tmp_fromlist_name_8, tmp_level_name_8 );
    if ( tmp_import_name_from_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 16;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_14 = IMPORT_NAME( tmp_import_name_from_5, const_str_plain_utils );
    Py_DECREF( tmp_import_name_from_5 );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 16;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils, tmp_assign_source_14 );
    tmp_name_name_9 = const_str_digest_b311fd8ca9b218772fd89e927df64198;
    tmp_globals_name_9 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_9 = Py_None;
    tmp_fromlist_name_9 = const_tuple_55f45cc1ebe66c7c9c0566ce5a780f3f_tuple;
    tmp_level_name_9 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 17;
    tmp_assign_source_15 = IMPORT_MODULE5( tmp_name_name_9, tmp_globals_name_9, tmp_locals_name_9, tmp_fromlist_name_9, tmp_level_name_9 );
    if ( tmp_assign_source_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_2__module == NULL );
    tmp_import_from_2__module = tmp_assign_source_15;

    // Tried code:
    tmp_import_name_from_6 = tmp_import_from_2__module;

    CHECK_OBJECT( tmp_import_name_from_6 );
    tmp_assign_source_16 = IMPORT_NAME( tmp_import_name_from_6, const_str_plain_BIT_STRING );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_BIT_STRING, tmp_assign_source_16 );
    tmp_import_name_from_7 = tmp_import_from_2__module;

    CHECK_OBJECT( tmp_import_name_from_7 );
    tmp_assign_source_17 = IMPORT_NAME( tmp_import_name_from_7, const_str_plain_DERReader );
    if ( tmp_assign_source_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DERReader, tmp_assign_source_17 );
    tmp_import_name_from_8 = tmp_import_from_2__module;

    CHECK_OBJECT( tmp_import_name_from_8 );
    tmp_assign_source_18 = IMPORT_NAME( tmp_import_name_from_8, const_str_plain_OBJECT_IDENTIFIER );
    if ( tmp_assign_source_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OBJECT_IDENTIFIER, tmp_assign_source_18 );
    tmp_import_name_from_9 = tmp_import_from_2__module;

    CHECK_OBJECT( tmp_import_name_from_9 );
    tmp_assign_source_19 = IMPORT_NAME( tmp_import_name_from_9, const_str_plain_SEQUENCE );
    if ( tmp_assign_source_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SEQUENCE, tmp_assign_source_19 );
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_2__module );
    Py_DECREF( tmp_import_from_2__module );
    tmp_import_from_2__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_2__module );
    Py_DECREF( tmp_import_from_2__module );
    tmp_import_from_2__module = NULL;

    tmp_name_name_10 = const_str_digest_9db3cdd3cd765463b4eec6754eb8e087;
    tmp_globals_name_10 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_10 = Py_None;
    tmp_fromlist_name_10 = const_tuple_str_plain_constant_time_str_plain_serialization_tuple;
    tmp_level_name_10 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 20;
    tmp_assign_source_20 = IMPORT_MODULE5( tmp_name_name_10, tmp_globals_name_10, tmp_locals_name_10, tmp_fromlist_name_10, tmp_level_name_10 );
    if ( tmp_assign_source_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_3__module == NULL );
    tmp_import_from_3__module = tmp_assign_source_20;

    // Tried code:
    tmp_import_name_from_10 = tmp_import_from_3__module;

    CHECK_OBJECT( tmp_import_name_from_10 );
    tmp_assign_source_21 = IMPORT_NAME( tmp_import_name_from_10, const_str_plain_constant_time );
    if ( tmp_assign_source_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto try_except_handler_3;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_constant_time, tmp_assign_source_21 );
    tmp_import_name_from_11 = tmp_import_from_3__module;

    CHECK_OBJECT( tmp_import_name_from_11 );
    tmp_assign_source_22 = IMPORT_NAME( tmp_import_name_from_11, const_str_plain_serialization );
    if ( tmp_assign_source_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto try_except_handler_3;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization, tmp_assign_source_22 );
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    tmp_name_name_11 = const_str_digest_bd71b5d9106eb6b876b65e57bcd30837;
    tmp_globals_name_11 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_11 = Py_None;
    tmp_fromlist_name_11 = const_tuple_str_plain_EllipticCurvePublicKey_tuple;
    tmp_level_name_11 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 21;
    tmp_import_name_from_12 = IMPORT_MODULE5( tmp_name_name_11, tmp_globals_name_11, tmp_locals_name_11, tmp_fromlist_name_11, tmp_level_name_11 );
    if ( tmp_import_name_from_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 21;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_23 = IMPORT_NAME( tmp_import_name_from_12, const_str_plain_EllipticCurvePublicKey );
    Py_DECREF( tmp_import_name_from_12 );
    if ( tmp_assign_source_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 21;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_EllipticCurvePublicKey, tmp_assign_source_23 );
    tmp_name_name_12 = const_str_digest_97cd6fd5c8579a7068d86fbfd40e2f84;
    tmp_globals_name_12 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_12 = Py_None;
    tmp_fromlist_name_12 = const_tuple_str_plain_RSAPublicKey_tuple;
    tmp_level_name_12 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 22;
    tmp_import_name_from_13 = IMPORT_MODULE5( tmp_name_name_12, tmp_globals_name_12, tmp_locals_name_12, tmp_fromlist_name_12, tmp_level_name_12 );
    if ( tmp_import_name_from_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 22;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_24 = IMPORT_NAME( tmp_import_name_from_13, const_str_plain_RSAPublicKey );
    Py_DECREF( tmp_import_name_from_13 );
    if ( tmp_assign_source_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 22;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_RSAPublicKey, tmp_assign_source_24 );
    tmp_name_name_13 = const_str_digest_9c4dcd45c628f51f60b0e74617698ea7;
    tmp_globals_name_13 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_13 = Py_None;
    tmp_fromlist_name_13 = const_tuple_str_plain_SignedCertificateTimestamp_tuple;
    tmp_level_name_13 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 23;
    tmp_import_name_from_14 = IMPORT_MODULE5( tmp_name_name_13, tmp_globals_name_13, tmp_locals_name_13, tmp_fromlist_name_13, tmp_level_name_13 );
    if ( tmp_import_name_from_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 23;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_25 = IMPORT_NAME( tmp_import_name_from_14, const_str_plain_SignedCertificateTimestamp );
    Py_DECREF( tmp_import_name_from_14 );
    if ( tmp_assign_source_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 23;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SignedCertificateTimestamp, tmp_assign_source_25 );
    tmp_name_name_14 = const_str_digest_becb7ddc5eba88bda421a9fc23a1539c;
    tmp_globals_name_14 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_14 = Py_None;
    tmp_fromlist_name_14 = const_tuple_b58c59c90f8b7ff71dbfd006f561c9fe_tuple;
    tmp_level_name_14 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 26;
    tmp_assign_source_26 = IMPORT_MODULE5( tmp_name_name_14, tmp_globals_name_14, tmp_locals_name_14, tmp_fromlist_name_14, tmp_level_name_14 );
    if ( tmp_assign_source_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 26;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_4__module == NULL );
    tmp_import_from_4__module = tmp_assign_source_26;

    // Tried code:
    tmp_import_name_from_15 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_15 );
    tmp_assign_source_27 = IMPORT_NAME( tmp_import_name_from_15, const_str_plain_GeneralName );
    if ( tmp_assign_source_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 26;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName, tmp_assign_source_27 );
    tmp_import_name_from_16 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_16 );
    tmp_assign_source_28 = IMPORT_NAME( tmp_import_name_from_16, const_str_plain_IPAddress );
    if ( tmp_assign_source_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 26;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_IPAddress, tmp_assign_source_28 );
    tmp_import_name_from_17 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_17 );
    tmp_assign_source_29 = IMPORT_NAME( tmp_import_name_from_17, const_str_plain_OtherName );
    if ( tmp_assign_source_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 26;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OtherName, tmp_assign_source_29 );
    goto try_end_4;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_4__module );
    Py_DECREF( tmp_import_from_4__module );
    tmp_import_from_4__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_4__module );
    Py_DECREF( tmp_import_from_4__module );
    tmp_import_from_4__module = NULL;

    tmp_name_name_15 = const_str_digest_957c81bc7a15c28c0c453fa3270dbc10;
    tmp_globals_name_15 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_15 = Py_None;
    tmp_fromlist_name_15 = const_tuple_str_plain_RelativeDistinguishedName_tuple;
    tmp_level_name_15 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 27;
    tmp_import_name_from_18 = IMPORT_MODULE5( tmp_name_name_15, tmp_globals_name_15, tmp_locals_name_15, tmp_fromlist_name_15, tmp_level_name_15 );
    if ( tmp_import_name_from_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 27;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_30 = IMPORT_NAME( tmp_import_name_from_18, const_str_plain_RelativeDistinguishedName );
    Py_DECREF( tmp_import_name_from_18 );
    if ( tmp_assign_source_30 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 27;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_RelativeDistinguishedName, tmp_assign_source_30 );
    tmp_name_name_16 = const_str_digest_0dcb6991fe0fe1dc113b1f3e65627e35;
    tmp_globals_name_16 = (PyObject *)moduledict_cryptography$x509$extensions;
    tmp_locals_name_16 = Py_None;
    tmp_fromlist_name_16 = const_tuple_2a50e9eb562974724a6432490d012463_tuple;
    tmp_level_name_16 = const_int_0;
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 28;
    tmp_assign_source_31 = IMPORT_MODULE5( tmp_name_name_16, tmp_globals_name_16, tmp_locals_name_16, tmp_fromlist_name_16, tmp_level_name_16 );
    if ( tmp_assign_source_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 28;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_5__module == NULL );
    tmp_import_from_5__module = tmp_assign_source_31;

    // Tried code:
    tmp_import_name_from_19 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_19 );
    tmp_assign_source_32 = IMPORT_NAME( tmp_import_name_from_19, const_str_plain_CRLEntryExtensionOID );
    if ( tmp_assign_source_32 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 28;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID, tmp_assign_source_32 );
    tmp_import_name_from_20 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_20 );
    tmp_assign_source_33 = IMPORT_NAME( tmp_import_name_from_20, const_str_plain_ExtensionOID );
    if ( tmp_assign_source_33 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 28;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID, tmp_assign_source_33 );
    tmp_import_name_from_21 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_21 );
    tmp_assign_source_34 = IMPORT_NAME( tmp_import_name_from_21, const_str_plain_OCSPExtensionOID );
    if ( tmp_assign_source_34 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 28;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OCSPExtensionOID, tmp_assign_source_34 );
    tmp_import_name_from_22 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_22 );
    tmp_assign_source_35 = IMPORT_NAME( tmp_import_name_from_22, const_str_plain_ObjectIdentifier );
    if ( tmp_assign_source_35 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 28;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier, tmp_assign_source_35 );
    goto try_end_5;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_5__module );
    Py_DECREF( tmp_import_from_5__module );
    tmp_import_from_5__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_5__module );
    Py_DECREF( tmp_import_from_5__module );
    tmp_import_from_5__module = NULL;

    tmp_assign_source_36 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_1__key_identifier_from_public_key(  );
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__key_identifier_from_public_key, tmp_assign_source_36 );
    tmp_assign_source_37 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_2__make_sequence_methods(  );
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__make_sequence_methods, tmp_assign_source_37 );
    tmp_assign_source_38 = PyTuple_New( 1 );
    tmp_tuple_element_1 = PyExc_Exception;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_assign_source_38, 0, tmp_tuple_element_1 );
    assert( tmp_class_creation_1__bases == NULL );
    tmp_class_creation_1__bases = tmp_assign_source_38;

    tmp_set_locals = PyDict_New();
    locals_DuplicateExtension_86 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_DuplicateExtension_86, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_3___init__(  );
    tmp_res = PyDict_SetItem( locals_DuplicateExtension_86, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_1 = locals_DuplicateExtension_86;
    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_6;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_6:;
    Py_DECREF( locals_DuplicateExtension_86 );
    locals_DuplicateExtension_86 = NULL;
    goto outline_result_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_result_1:;
    tmp_assign_source_39 = tmp_outline_return_value_1;
    assert( tmp_class_creation_1__class_dict == NULL );
    tmp_class_creation_1__class_dict = tmp_assign_source_39;

    // Tried code:
    tmp_compare_left_1 = const_str_plain___metaclass__;
    tmp_compare_right_1 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_dict_name_1 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_dict_name_1 );
    tmp_key_name_1 = const_str_plain___metaclass__;
    tmp_assign_source_40 = DICT_GET_ITEM( tmp_dict_name_1, tmp_key_name_1 );
    if ( tmp_assign_source_40 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 86;

        goto try_except_handler_7;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_subscribed_name_1 = tmp_class_creation_1__bases;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_assign_source_41 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_assign_source_41 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 86;

        goto try_except_handler_7;
    }
    assert( tmp_select_metaclass_1__base == NULL );
    tmp_select_metaclass_1__base = tmp_assign_source_41;

    // Tried code:
    // Tried code:
    tmp_source_name_1 = tmp_select_metaclass_1__base;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_outline_return_value_2 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_1 );
    if ( tmp_outline_return_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 86;

        goto try_except_handler_9;
    }
    goto try_return_handler_8;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_9:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_6 );
    Py_XDECREF( exception_keeper_value_6 );
    Py_XDECREF( exception_keeper_tb_6 );
    tmp_type_arg_1 = tmp_select_metaclass_1__base;

    CHECK_OBJECT( tmp_type_arg_1 );
    tmp_outline_return_value_2 = BUILTIN_TYPE1( tmp_type_arg_1 );
    assert( tmp_outline_return_value_2 != NULL );
    goto try_return_handler_8;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_8:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_1__base );
    Py_DECREF( tmp_select_metaclass_1__base );
    tmp_select_metaclass_1__base = NULL;

    goto outline_result_2;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_1__base );
    Py_DECREF( tmp_select_metaclass_1__base );
    tmp_select_metaclass_1__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_result_2:;
    tmp_assign_source_40 = tmp_outline_return_value_2;
    condexpr_end_1:;
    assert( tmp_class_creation_1__metaclass == NULL );
    tmp_class_creation_1__metaclass = tmp_assign_source_40;

    tmp_called_name_1 = tmp_class_creation_1__metaclass;

    CHECK_OBJECT( tmp_called_name_1 );
    tmp_args_element_name_1 = const_str_plain_DuplicateExtension;
    tmp_args_element_name_2 = tmp_class_creation_1__bases;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 86;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_42 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_42 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 86;

        goto try_except_handler_7;
    }
    assert( tmp_class_creation_1__class == NULL );
    tmp_class_creation_1__class = tmp_assign_source_42;

    goto try_end_6;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases );
    Py_DECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    tmp_assign_source_43 = tmp_class_creation_1__class;

    CHECK_OBJECT( tmp_assign_source_43 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DuplicateExtension, tmp_assign_source_43 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class );
    Py_DECREF( tmp_class_creation_1__class );
    tmp_class_creation_1__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases );
    Py_DECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__metaclass );
    Py_DECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    tmp_assign_source_44 = PyTuple_New( 1 );
    tmp_tuple_element_2 = PyExc_Exception;
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_assign_source_44, 0, tmp_tuple_element_2 );
    assert( tmp_class_creation_2__bases == NULL );
    tmp_class_creation_2__bases = tmp_assign_source_44;

    tmp_set_locals = PyDict_New();
    locals_ExtensionNotFound_92 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_ExtensionNotFound_92, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_4___init__(  );
    tmp_res = PyDict_SetItem( locals_ExtensionNotFound_92, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_3 = locals_ExtensionNotFound_92;
    Py_INCREF( tmp_outline_return_value_3 );
    goto try_return_handler_10;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_10:;
    Py_DECREF( locals_ExtensionNotFound_92 );
    locals_ExtensionNotFound_92 = NULL;
    goto outline_result_3;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_result_3:;
    tmp_assign_source_45 = tmp_outline_return_value_3;
    assert( tmp_class_creation_2__class_dict == NULL );
    tmp_class_creation_2__class_dict = tmp_assign_source_45;

    // Tried code:
    tmp_compare_left_2 = const_str_plain___metaclass__;
    tmp_compare_right_2 = tmp_class_creation_2__class_dict;

    CHECK_OBJECT( tmp_compare_right_2 );
    tmp_cmp_In_2 = PySequence_Contains( tmp_compare_right_2, tmp_compare_left_2 );
    assert( !(tmp_cmp_In_2 == -1) );
    if ( tmp_cmp_In_2 == 1 )
    {
        goto condexpr_true_2;
    }
    else
    {
        goto condexpr_false_2;
    }
    condexpr_true_2:;
    tmp_dict_name_2 = tmp_class_creation_2__class_dict;

    CHECK_OBJECT( tmp_dict_name_2 );
    tmp_key_name_2 = const_str_plain___metaclass__;
    tmp_assign_source_46 = DICT_GET_ITEM( tmp_dict_name_2, tmp_key_name_2 );
    if ( tmp_assign_source_46 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 92;

        goto try_except_handler_11;
    }
    goto condexpr_end_2;
    condexpr_false_2:;
    tmp_subscribed_name_2 = tmp_class_creation_2__bases;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_0;
    tmp_assign_source_47 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_assign_source_47 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 92;

        goto try_except_handler_11;
    }
    assert( tmp_select_metaclass_2__base == NULL );
    tmp_select_metaclass_2__base = tmp_assign_source_47;

    // Tried code:
    // Tried code:
    tmp_source_name_2 = tmp_select_metaclass_2__base;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_outline_return_value_4 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
    if ( tmp_outline_return_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 92;

        goto try_except_handler_13;
    }
    goto try_return_handler_12;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_13:;
    exception_keeper_type_8 = exception_type;
    exception_keeper_value_8 = exception_value;
    exception_keeper_tb_8 = exception_tb;
    exception_keeper_lineno_8 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_8 );
    Py_XDECREF( exception_keeper_value_8 );
    Py_XDECREF( exception_keeper_tb_8 );
    tmp_type_arg_2 = tmp_select_metaclass_2__base;

    CHECK_OBJECT( tmp_type_arg_2 );
    tmp_outline_return_value_4 = BUILTIN_TYPE1( tmp_type_arg_2 );
    assert( tmp_outline_return_value_4 != NULL );
    goto try_return_handler_12;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_12:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_2__base );
    Py_DECREF( tmp_select_metaclass_2__base );
    tmp_select_metaclass_2__base = NULL;

    goto outline_result_4;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_2__base );
    Py_DECREF( tmp_select_metaclass_2__base );
    tmp_select_metaclass_2__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_result_4:;
    tmp_assign_source_46 = tmp_outline_return_value_4;
    condexpr_end_2:;
    assert( tmp_class_creation_2__metaclass == NULL );
    tmp_class_creation_2__metaclass = tmp_assign_source_46;

    tmp_called_name_2 = tmp_class_creation_2__metaclass;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_args_element_name_4 = const_str_plain_ExtensionNotFound;
    tmp_args_element_name_5 = tmp_class_creation_2__bases;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = tmp_class_creation_2__class_dict;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 92;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_48 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_48 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 92;

        goto try_except_handler_11;
    }
    assert( tmp_class_creation_2__class == NULL );
    tmp_class_creation_2__class = tmp_assign_source_48;

    goto try_end_7;
    // Exception handler code:
    try_except_handler_11:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__bases );
    Py_DECREF( tmp_class_creation_2__bases );
    tmp_class_creation_2__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    tmp_assign_source_49 = tmp_class_creation_2__class;

    CHECK_OBJECT( tmp_assign_source_49 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound, tmp_assign_source_49 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class );
    Py_DECREF( tmp_class_creation_2__class );
    tmp_class_creation_2__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__bases );
    Py_DECREF( tmp_class_creation_2__bases );
    tmp_class_creation_2__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__metaclass );
    Py_DECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_ExtensionType_99 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_ExtensionType_99, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cc2dd91dca578c1e2053b1e93066de1e_2, codeobj_cc2dd91dca578c1e2053b1e93066de1e, module_cryptography$x509$extensions, 0 );
    frame_cc2dd91dca578c1e2053b1e93066de1e_2 = cache_frame_cc2dd91dca578c1e2053b1e93066de1e_2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cc2dd91dca578c1e2053b1e93066de1e_2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cc2dd91dca578c1e2053b1e93066de1e_2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_abc );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abc );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "abc" );
        exception_tb = NULL;

        exception_lineno = 100;

        goto frame_exception_exit_2;
    }

    tmp_args_element_name_7 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_5_oid(  );
    frame_cc2dd91dca578c1e2053b1e93066de1e_2->m_frame.f_lineno = 100;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_abstractproperty, call_args );
    }

    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 100;

        goto frame_exception_exit_2;
    }
    tmp_res = PyDict_SetItem( locals_ExtensionType_99, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 100;

        goto frame_exception_exit_2;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cc2dd91dca578c1e2053b1e93066de1e_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cc2dd91dca578c1e2053b1e93066de1e_2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cc2dd91dca578c1e2053b1e93066de1e_2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cc2dd91dca578c1e2053b1e93066de1e_2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cc2dd91dca578c1e2053b1e93066de1e_2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cc2dd91dca578c1e2053b1e93066de1e_2,
        type_description_2
    );


    // Release cached frame.
    if ( frame_cc2dd91dca578c1e2053b1e93066de1e_2 == cache_frame_cc2dd91dca578c1e2053b1e93066de1e_2 )
    {
        Py_DECREF( frame_cc2dd91dca578c1e2053b1e93066de1e_2 );
    }
    cache_frame_cc2dd91dca578c1e2053b1e93066de1e_2 = NULL;

    assertFrameObject( frame_cc2dd91dca578c1e2053b1e93066de1e_2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_1;

    frame_no_exception_1:;

    goto skip_nested_handling_1;
    nested_frame_exit_1:;

    goto try_except_handler_15;
    skip_nested_handling_1:;
    tmp_outline_return_value_5 = locals_ExtensionType_99;
    Py_INCREF( tmp_outline_return_value_5 );
    goto try_return_handler_15;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_15:;
    Py_DECREF( locals_ExtensionType_99 );
    locals_ExtensionType_99 = NULL;
    goto outline_result_5;
    // Exception handler code:
    try_except_handler_15:;
    exception_keeper_type_10 = exception_type;
    exception_keeper_value_10 = exception_value;
    exception_keeper_tb_10 = exception_tb;
    exception_keeper_lineno_10 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_ExtensionType_99 );
    locals_ExtensionType_99 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_10;
    exception_value = exception_keeper_value_10;
    exception_tb = exception_keeper_tb_10;
    exception_lineno = exception_keeper_lineno_10;

    goto outline_exception_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_1:;
    exception_lineno = 99;
    goto try_except_handler_14;
    outline_result_5:;
    tmp_assign_source_50 = tmp_outline_return_value_5;
    assert( tmp_class_creation_3__class_dict == NULL );
    tmp_class_creation_3__class_dict = tmp_assign_source_50;

    tmp_compare_left_3 = const_str_plain___metaclass__;
    tmp_compare_right_3 = tmp_class_creation_3__class_dict;

    CHECK_OBJECT( tmp_compare_right_3 );
    tmp_cmp_In_3 = PySequence_Contains( tmp_compare_right_3, tmp_compare_left_3 );
    assert( !(tmp_cmp_In_3 == -1) );
    if ( tmp_cmp_In_3 == 1 )
    {
        goto condexpr_true_3;
    }
    else
    {
        goto condexpr_false_3;
    }
    condexpr_true_3:;
    tmp_dict_name_3 = tmp_class_creation_3__class_dict;

    CHECK_OBJECT( tmp_dict_name_3 );
    tmp_key_name_3 = const_str_plain___metaclass__;
    tmp_assign_source_51 = DICT_GET_ITEM( tmp_dict_name_3, tmp_key_name_3 );
    if ( tmp_assign_source_51 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 99;

        goto try_except_handler_14;
    }
    goto condexpr_end_3;
    condexpr_false_3:;
    tmp_assign_source_51 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_51 );
    condexpr_end_3:;
    assert( tmp_class_creation_3__metaclass == NULL );
    tmp_class_creation_3__metaclass = tmp_assign_source_51;

    tmp_called_name_3 = tmp_class_creation_3__metaclass;

    CHECK_OBJECT( tmp_called_name_3 );
    tmp_args_element_name_8 = const_str_plain_ExtensionType;
    tmp_args_element_name_9 = const_tuple_type_object_tuple;
    tmp_args_element_name_10 = tmp_class_creation_3__class_dict;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 99;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_assign_source_52 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    if ( tmp_assign_source_52 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 99;

        goto try_except_handler_14;
    }
    assert( tmp_class_creation_3__class == NULL );
    tmp_class_creation_3__class = tmp_assign_source_52;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_six );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "six" );
        exception_tb = NULL;

        exception_lineno = 98;

        goto try_except_handler_14;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_add_metaclass );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 98;

        goto try_except_handler_14;
    }
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_abc );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abc );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "abc" );
        exception_tb = NULL;

        exception_lineno = 98;

        goto try_except_handler_14;
    }

    tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_ABCMeta );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 98;

        goto try_except_handler_14;
    }
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 98;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_called_name_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 98;

        goto try_except_handler_14;
    }
    tmp_args_element_name_12 = tmp_class_creation_3__class;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 98;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_assign_source_53 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_assign_source_53 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 98;

        goto try_except_handler_14;
    }
    {
        PyObject *old = tmp_class_creation_3__class;
        assert( old != NULL );
        tmp_class_creation_3__class = tmp_assign_source_53;
        Py_DECREF( old );
    }

    goto try_end_8;
    // Exception handler code:
    try_except_handler_14:;
    exception_keeper_type_11 = exception_type;
    exception_keeper_value_11 = exception_value;
    exception_keeper_tb_11 = exception_tb;
    exception_keeper_lineno_11 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_3__class );
    tmp_class_creation_3__class = NULL;

    Py_XDECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_11;
    exception_value = exception_keeper_value_11;
    exception_tb = exception_keeper_tb_11;
    exception_lineno = exception_keeper_lineno_11;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    tmp_assign_source_54 = tmp_class_creation_3__class;

    CHECK_OBJECT( tmp_assign_source_54 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType, tmp_assign_source_54 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class );
    Py_DECREF( tmp_class_creation_3__class );
    tmp_class_creation_3__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_dict );
    Py_DECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__metaclass );
    Py_DECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_Extensions_107 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_Extensions_107, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_6___init__(  );
    tmp_res = PyDict_SetItem( locals_Extensions_107, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_7_get_extension_for_oid(  );
    tmp_res = PyDict_SetItem( locals_Extensions_107, const_str_plain_get_extension_for_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_8_get_extension_for_class(  );
    tmp_res = PyDict_SetItem( locals_Extensions_107, const_str_plain_get_extension_for_class, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ee3c270008e9c546283aead71bfc3864_3, codeobj_ee3c270008e9c546283aead71bfc3864, module_cryptography$x509$extensions, 0 );
    frame_ee3c270008e9c546283aead71bfc3864_3 = cache_frame_ee3c270008e9c546283aead71bfc3864_3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ee3c270008e9c546283aead71bfc3864_3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ee3c270008e9c546283aead71bfc3864_3 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_sequence_methods" );
        exception_tb = NULL;

        exception_lineno = 134;

        goto try_except_handler_18;
    }

    frame_ee3c270008e9c546283aead71bfc3864_3->m_frame.f_lineno = 134;
    tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_str_plain__extensions_tuple, 0 ) );

    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 134;

        goto try_except_handler_18;
    }
    tmp_assign_source_56 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_56 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 134;

        goto try_except_handler_18;
    }
    assert( tmp_Extensions$tuple_unpack_1__source_iter == NULL );
    tmp_Extensions$tuple_unpack_1__source_iter = tmp_assign_source_56;

    // Tried code:
    tmp_unpack_1 = tmp_Extensions$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_1 );
    tmp_assign_source_57 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_57 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 134;
        goto try_except_handler_19;
    }
    assert( tmp_Extensions$tuple_unpack_1__element_1 == NULL );
    tmp_Extensions$tuple_unpack_1__element_1 = tmp_assign_source_57;

    tmp_unpack_2 = tmp_Extensions$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_2 );
    tmp_assign_source_58 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_58 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 134;
        goto try_except_handler_19;
    }
    assert( tmp_Extensions$tuple_unpack_1__element_2 == NULL );
    tmp_Extensions$tuple_unpack_1__element_2 = tmp_assign_source_58;

    tmp_unpack_3 = tmp_Extensions$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_3 );
    tmp_assign_source_59 = UNPACK_NEXT( tmp_unpack_3, 2 );
    if ( tmp_assign_source_59 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 134;
        goto try_except_handler_19;
    }
    assert( tmp_Extensions$tuple_unpack_1__element_3 == NULL );
    tmp_Extensions$tuple_unpack_1__element_3 = tmp_assign_source_59;

    tmp_iterator_name_1 = tmp_Extensions$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_1 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 134;
                goto try_except_handler_19;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 134;
        goto try_except_handler_19;
    }
    goto try_end_9;
    // Exception handler code:
    try_except_handler_19:;
    exception_keeper_type_12 = exception_type;
    exception_keeper_value_12 = exception_value;
    exception_keeper_tb_12 = exception_tb;
    exception_keeper_lineno_12 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_Extensions$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_Extensions$tuple_unpack_1__source_iter );
    tmp_Extensions$tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_12;
    exception_value = exception_keeper_value_12;
    exception_tb = exception_keeper_tb_12;
    exception_lineno = exception_keeper_lineno_12;

    goto try_except_handler_18;
    // End of try:
    try_end_9:;
    goto try_end_10;
    // Exception handler code:
    try_except_handler_18:;
    exception_keeper_type_13 = exception_type;
    exception_keeper_value_13 = exception_value;
    exception_keeper_tb_13 = exception_tb;
    exception_keeper_lineno_13 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_Extensions$tuple_unpack_1__element_1 );
    tmp_Extensions$tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_Extensions$tuple_unpack_1__element_2 );
    tmp_Extensions$tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_Extensions$tuple_unpack_1__element_3 );
    tmp_Extensions$tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_13;
    exception_value = exception_keeper_value_13;
    exception_tb = exception_keeper_tb_13;
    exception_lineno = exception_keeper_lineno_13;

    goto frame_exception_exit_3;
    // End of try:
    try_end_10:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ee3c270008e9c546283aead71bfc3864_3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_exception_exit_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ee3c270008e9c546283aead71bfc3864_3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ee3c270008e9c546283aead71bfc3864_3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ee3c270008e9c546283aead71bfc3864_3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ee3c270008e9c546283aead71bfc3864_3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ee3c270008e9c546283aead71bfc3864_3,
        type_description_2
    );


    // Release cached frame.
    if ( frame_ee3c270008e9c546283aead71bfc3864_3 == cache_frame_ee3c270008e9c546283aead71bfc3864_3 )
    {
        Py_DECREF( frame_ee3c270008e9c546283aead71bfc3864_3 );
    }
    cache_frame_ee3c270008e9c546283aead71bfc3864_3 = NULL;

    assertFrameObject( frame_ee3c270008e9c546283aead71bfc3864_3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_2;

    frame_no_exception_2:;

    goto skip_nested_handling_2;
    nested_frame_exit_2:;

    goto try_except_handler_17;
    skip_nested_handling_2:;
    CHECK_OBJECT( (PyObject *)tmp_Extensions$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_Extensions$tuple_unpack_1__source_iter );
    tmp_Extensions$tuple_unpack_1__source_iter = NULL;

    tmp_dictset_value = tmp_Extensions$tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_Extensions_107, const_str_plain___len__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_Extensions$tuple_unpack_1__element_1 );
    tmp_Extensions$tuple_unpack_1__element_1 = NULL;

    tmp_dictset_value = tmp_Extensions$tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_Extensions_107, const_str_plain___iter__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_Extensions$tuple_unpack_1__element_2 );
    tmp_Extensions$tuple_unpack_1__element_2 = NULL;

    tmp_dictset_value = tmp_Extensions$tuple_unpack_1__element_3;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_Extensions_107, const_str_plain___getitem__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_Extensions$tuple_unpack_1__element_3 );
    tmp_Extensions$tuple_unpack_1__element_3 = NULL;

    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_9___repr__(  );
    tmp_res = PyDict_SetItem( locals_Extensions_107, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_6 = locals_Extensions_107;
    Py_INCREF( tmp_outline_return_value_6 );
    goto try_return_handler_17;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_17:;
    Py_DECREF( locals_Extensions_107 );
    locals_Extensions_107 = NULL;
    goto outline_result_6;
    // Exception handler code:
    try_except_handler_17:;
    exception_keeper_type_14 = exception_type;
    exception_keeper_value_14 = exception_value;
    exception_keeper_tb_14 = exception_tb;
    exception_keeper_lineno_14 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_Extensions_107 );
    locals_Extensions_107 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_14;
    exception_value = exception_keeper_value_14;
    exception_tb = exception_keeper_tb_14;
    exception_lineno = exception_keeper_lineno_14;

    goto outline_exception_2;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_2:;
    exception_lineno = 107;
    goto try_except_handler_16;
    outline_result_6:;
    tmp_assign_source_55 = tmp_outline_return_value_6;
    assert( tmp_class_creation_4__class_dict == NULL );
    tmp_class_creation_4__class_dict = tmp_assign_source_55;

    tmp_compare_left_4 = const_str_plain___metaclass__;
    tmp_compare_right_4 = tmp_class_creation_4__class_dict;

    CHECK_OBJECT( tmp_compare_right_4 );
    tmp_cmp_In_4 = PySequence_Contains( tmp_compare_right_4, tmp_compare_left_4 );
    assert( !(tmp_cmp_In_4 == -1) );
    if ( tmp_cmp_In_4 == 1 )
    {
        goto condexpr_true_4;
    }
    else
    {
        goto condexpr_false_4;
    }
    condexpr_true_4:;
    tmp_dict_name_4 = tmp_class_creation_4__class_dict;

    CHECK_OBJECT( tmp_dict_name_4 );
    tmp_key_name_4 = const_str_plain___metaclass__;
    tmp_assign_source_60 = DICT_GET_ITEM( tmp_dict_name_4, tmp_key_name_4 );
    if ( tmp_assign_source_60 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 107;

        goto try_except_handler_16;
    }
    goto condexpr_end_4;
    condexpr_false_4:;
    tmp_assign_source_60 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_60 );
    condexpr_end_4:;
    assert( tmp_class_creation_4__metaclass == NULL );
    tmp_class_creation_4__metaclass = tmp_assign_source_60;

    tmp_called_name_7 = tmp_class_creation_4__metaclass;

    CHECK_OBJECT( tmp_called_name_7 );
    tmp_args_element_name_13 = const_str_plain_Extensions;
    tmp_args_element_name_14 = const_tuple_type_object_tuple;
    tmp_args_element_name_15 = tmp_class_creation_4__class_dict;

    CHECK_OBJECT( tmp_args_element_name_15 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 107;
    {
        PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15 };
        tmp_assign_source_61 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_7, call_args );
    }

    if ( tmp_assign_source_61 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 107;

        goto try_except_handler_16;
    }
    assert( tmp_class_creation_4__class == NULL );
    tmp_class_creation_4__class = tmp_assign_source_61;

    goto try_end_11;
    // Exception handler code:
    try_except_handler_16:;
    exception_keeper_type_15 = exception_type;
    exception_keeper_value_15 = exception_value;
    exception_keeper_tb_15 = exception_tb;
    exception_keeper_lineno_15 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_15;
    exception_value = exception_keeper_value_15;
    exception_tb = exception_keeper_tb_15;
    exception_lineno = exception_keeper_lineno_15;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    tmp_assign_source_62 = tmp_class_creation_4__class;

    CHECK_OBJECT( tmp_assign_source_62 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_Extensions, tmp_assign_source_62 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class );
    Py_DECREF( tmp_class_creation_4__class );
    tmp_class_creation_4__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class_dict );
    Py_DECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__metaclass );
    Py_DECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_CRLNumber_143 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_CRLNumber_143, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0850861f8e53ba258cf8c812b5257de8_4, codeobj_0850861f8e53ba258cf8c812b5257de8, module_cryptography$x509$extensions, 0 );
    frame_0850861f8e53ba258cf8c812b5257de8_4 = cache_frame_0850861f8e53ba258cf8c812b5257de8_4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0850861f8e53ba258cf8c812b5257de8_4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0850861f8e53ba258cf8c812b5257de8_4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 144;

        goto frame_exception_exit_4;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_CRL_NUMBER );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 144;

        goto frame_exception_exit_4;
    }
    tmp_res = PyDict_SetItem( locals_CRLNumber_143, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 144;

        goto frame_exception_exit_4;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_10___init__(  );
    tmp_res = PyDict_SetItem( locals_CRLNumber_143, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_11___eq__(  );
    tmp_res = PyDict_SetItem( locals_CRLNumber_143, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_12___ne__(  );
    tmp_res = PyDict_SetItem( locals_CRLNumber_143, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_13___hash__(  );
    tmp_res = PyDict_SetItem( locals_CRLNumber_143, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_14___repr__(  );
    tmp_res = PyDict_SetItem( locals_CRLNumber_143, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 167;

        goto frame_exception_exit_4;
    }

    frame_0850861f8e53ba258cf8c812b5257de8_4->m_frame.f_lineno = 167;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__crl_number_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 167;

        goto frame_exception_exit_4;
    }
    tmp_res = PyDict_SetItem( locals_CRLNumber_143, const_str_plain_crl_number, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 167;

        goto frame_exception_exit_4;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0850861f8e53ba258cf8c812b5257de8_4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_3;

    frame_exception_exit_4:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0850861f8e53ba258cf8c812b5257de8_4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0850861f8e53ba258cf8c812b5257de8_4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0850861f8e53ba258cf8c812b5257de8_4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0850861f8e53ba258cf8c812b5257de8_4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0850861f8e53ba258cf8c812b5257de8_4,
        type_description_2
    );


    // Release cached frame.
    if ( frame_0850861f8e53ba258cf8c812b5257de8_4 == cache_frame_0850861f8e53ba258cf8c812b5257de8_4 )
    {
        Py_DECREF( frame_0850861f8e53ba258cf8c812b5257de8_4 );
    }
    cache_frame_0850861f8e53ba258cf8c812b5257de8_4 = NULL;

    assertFrameObject( frame_0850861f8e53ba258cf8c812b5257de8_4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_3;

    frame_no_exception_3:;

    goto skip_nested_handling_3;
    nested_frame_exit_3:;

    goto try_except_handler_21;
    skip_nested_handling_3:;
    tmp_outline_return_value_7 = locals_CRLNumber_143;
    Py_INCREF( tmp_outline_return_value_7 );
    goto try_return_handler_21;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_21:;
    Py_DECREF( locals_CRLNumber_143 );
    locals_CRLNumber_143 = NULL;
    goto outline_result_7;
    // Exception handler code:
    try_except_handler_21:;
    exception_keeper_type_16 = exception_type;
    exception_keeper_value_16 = exception_value;
    exception_keeper_tb_16 = exception_tb;
    exception_keeper_lineno_16 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_CRLNumber_143 );
    locals_CRLNumber_143 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_16;
    exception_value = exception_keeper_value_16;
    exception_tb = exception_keeper_tb_16;
    exception_lineno = exception_keeper_lineno_16;

    goto outline_exception_3;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_3:;
    exception_lineno = 143;
    goto try_except_handler_20;
    outline_result_7:;
    tmp_assign_source_63 = tmp_outline_return_value_7;
    assert( tmp_class_creation_5__class_dict == NULL );
    tmp_class_creation_5__class_dict = tmp_assign_source_63;

    tmp_compare_left_5 = const_str_plain___metaclass__;
    tmp_compare_right_5 = tmp_class_creation_5__class_dict;

    CHECK_OBJECT( tmp_compare_right_5 );
    tmp_cmp_In_5 = PySequence_Contains( tmp_compare_right_5, tmp_compare_left_5 );
    assert( !(tmp_cmp_In_5 == -1) );
    if ( tmp_cmp_In_5 == 1 )
    {
        goto condexpr_true_5;
    }
    else
    {
        goto condexpr_false_5;
    }
    condexpr_true_5:;
    tmp_dict_name_5 = tmp_class_creation_5__class_dict;

    CHECK_OBJECT( tmp_dict_name_5 );
    tmp_key_name_5 = const_str_plain___metaclass__;
    tmp_assign_source_64 = DICT_GET_ITEM( tmp_dict_name_5, tmp_key_name_5 );
    if ( tmp_assign_source_64 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 143;

        goto try_except_handler_20;
    }
    goto condexpr_end_5;
    condexpr_false_5:;
    tmp_assign_source_64 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_64 );
    condexpr_end_5:;
    assert( tmp_class_creation_5__metaclass == NULL );
    tmp_class_creation_5__metaclass = tmp_assign_source_64;

    tmp_called_name_8 = tmp_class_creation_5__metaclass;

    CHECK_OBJECT( tmp_called_name_8 );
    tmp_args_element_name_16 = const_str_plain_CRLNumber;
    tmp_args_element_name_17 = const_tuple_type_object_tuple;
    tmp_args_element_name_18 = tmp_class_creation_5__class_dict;

    CHECK_OBJECT( tmp_args_element_name_18 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 143;
    {
        PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18 };
        tmp_assign_source_65 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, call_args );
    }

    if ( tmp_assign_source_65 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 143;

        goto try_except_handler_20;
    }
    assert( tmp_class_creation_5__class == NULL );
    tmp_class_creation_5__class = tmp_assign_source_65;

    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 142;

        goto try_except_handler_20;
    }

    tmp_called_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_register_interface );
    if ( tmp_called_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 142;

        goto try_except_handler_20;
    }
    tmp_args_element_name_19 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_19 == NULL ))
    {
        tmp_args_element_name_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_19 == NULL )
    {
        Py_DECREF( tmp_called_name_10 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 142;

        goto try_except_handler_20;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 142;
    {
        PyObject *call_args[] = { tmp_args_element_name_19 };
        tmp_called_name_9 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
    }

    Py_DECREF( tmp_called_name_10 );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 142;

        goto try_except_handler_20;
    }
    tmp_args_element_name_20 = tmp_class_creation_5__class;

    CHECK_OBJECT( tmp_args_element_name_20 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 142;
    {
        PyObject *call_args[] = { tmp_args_element_name_20 };
        tmp_assign_source_66 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    if ( tmp_assign_source_66 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 142;

        goto try_except_handler_20;
    }
    {
        PyObject *old = tmp_class_creation_5__class;
        assert( old != NULL );
        tmp_class_creation_5__class = tmp_assign_source_66;
        Py_DECREF( old );
    }

    goto try_end_12;
    // Exception handler code:
    try_except_handler_20:;
    exception_keeper_type_17 = exception_type;
    exception_keeper_value_17 = exception_value;
    exception_keeper_tb_17 = exception_tb;
    exception_keeper_lineno_17 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_5__class );
    tmp_class_creation_5__class = NULL;

    Py_XDECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_17;
    exception_value = exception_keeper_value_17;
    exception_tb = exception_keeper_tb_17;
    exception_lineno = exception_keeper_lineno_17;

    goto frame_exception_exit_1;
    // End of try:
    try_end_12:;
    tmp_assign_source_67 = tmp_class_creation_5__class;

    CHECK_OBJECT( tmp_assign_source_67 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLNumber, tmp_assign_source_67 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class );
    Py_DECREF( tmp_class_creation_5__class );
    tmp_class_creation_5__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class_dict );
    Py_DECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__metaclass );
    Py_DECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_AuthorityKeyIdentifier_171 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_AuthorityKeyIdentifier_171, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9785c3bd15b32f86e88298ed70b78f98_5, codeobj_9785c3bd15b32f86e88298ed70b78f98, module_cryptography$x509$extensions, 0 );
    frame_9785c3bd15b32f86e88298ed70b78f98_5 = cache_frame_9785c3bd15b32f86e88298ed70b78f98_5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9785c3bd15b32f86e88298ed70b78f98_5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9785c3bd15b32f86e88298ed70b78f98_5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 172;

        goto frame_exception_exit_5;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_AUTHORITY_KEY_IDENTIFIER );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 172;

        goto frame_exception_exit_5;
    }
    tmp_res = PyDict_SetItem( locals_AuthorityKeyIdentifier_171, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 172;

        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_15___init__(  );
    tmp_res = PyDict_SetItem( locals_AuthorityKeyIdentifier_171, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_classmethod_arg_1 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_16_from_issuer_public_key(  );
    tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_1 );
    Py_DECREF( tmp_classmethod_arg_1 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 205;

        goto frame_exception_exit_5;
    }
    tmp_res = PyDict_SetItem( locals_AuthorityKeyIdentifier_171, const_str_plain_from_issuer_public_key, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 205;

        goto frame_exception_exit_5;
    }
    tmp_classmethod_arg_2 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_17_from_issuer_subject_key_identifier(  );
    tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_2 );
    Py_DECREF( tmp_classmethod_arg_2 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 214;

        goto frame_exception_exit_5;
    }
    tmp_res = PyDict_SetItem( locals_AuthorityKeyIdentifier_171, const_str_plain_from_issuer_subject_key_identifier, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 214;

        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_18___repr__(  );
    tmp_res = PyDict_SetItem( locals_AuthorityKeyIdentifier_171, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_19___eq__(  );
    tmp_res = PyDict_SetItem( locals_AuthorityKeyIdentifier_171, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_20___ne__(  );
    tmp_res = PyDict_SetItem( locals_AuthorityKeyIdentifier_171, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_21___hash__(  );
    tmp_res = PyDict_SetItem( locals_AuthorityKeyIdentifier_171, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 266;

        goto frame_exception_exit_5;
    }

    frame_9785c3bd15b32f86e88298ed70b78f98_5->m_frame.f_lineno = 266;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__key_identifier_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto frame_exception_exit_5;
    }
    tmp_res = PyDict_SetItem( locals_AuthorityKeyIdentifier_171, const_str_plain_key_identifier, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto frame_exception_exit_5;
    }
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 267;

        goto frame_exception_exit_5;
    }

    frame_9785c3bd15b32f86e88298ed70b78f98_5->m_frame.f_lineno = 267;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__authority_cert_issuer_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 267;

        goto frame_exception_exit_5;
    }
    tmp_res = PyDict_SetItem( locals_AuthorityKeyIdentifier_171, const_str_plain_authority_cert_issuer, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 267;

        goto frame_exception_exit_5;
    }
    tmp_called_instance_5 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_5 == NULL ))
    {
        tmp_called_instance_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 268;

        goto frame_exception_exit_5;
    }

    frame_9785c3bd15b32f86e88298ed70b78f98_5->m_frame.f_lineno = 268;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__authority_cert_serial_number_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 268;

        goto frame_exception_exit_5;
    }
    tmp_res = PyDict_SetItem( locals_AuthorityKeyIdentifier_171, const_str_plain_authority_cert_serial_number, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 268;

        goto frame_exception_exit_5;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9785c3bd15b32f86e88298ed70b78f98_5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_4;

    frame_exception_exit_5:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9785c3bd15b32f86e88298ed70b78f98_5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9785c3bd15b32f86e88298ed70b78f98_5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9785c3bd15b32f86e88298ed70b78f98_5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9785c3bd15b32f86e88298ed70b78f98_5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9785c3bd15b32f86e88298ed70b78f98_5,
        type_description_2
    );


    // Release cached frame.
    if ( frame_9785c3bd15b32f86e88298ed70b78f98_5 == cache_frame_9785c3bd15b32f86e88298ed70b78f98_5 )
    {
        Py_DECREF( frame_9785c3bd15b32f86e88298ed70b78f98_5 );
    }
    cache_frame_9785c3bd15b32f86e88298ed70b78f98_5 = NULL;

    assertFrameObject( frame_9785c3bd15b32f86e88298ed70b78f98_5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_4;

    frame_no_exception_4:;

    goto skip_nested_handling_4;
    nested_frame_exit_4:;

    goto try_except_handler_23;
    skip_nested_handling_4:;
    tmp_outline_return_value_8 = locals_AuthorityKeyIdentifier_171;
    Py_INCREF( tmp_outline_return_value_8 );
    goto try_return_handler_23;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_23:;
    Py_DECREF( locals_AuthorityKeyIdentifier_171 );
    locals_AuthorityKeyIdentifier_171 = NULL;
    goto outline_result_8;
    // Exception handler code:
    try_except_handler_23:;
    exception_keeper_type_18 = exception_type;
    exception_keeper_value_18 = exception_value;
    exception_keeper_tb_18 = exception_tb;
    exception_keeper_lineno_18 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_AuthorityKeyIdentifier_171 );
    locals_AuthorityKeyIdentifier_171 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_18;
    exception_value = exception_keeper_value_18;
    exception_tb = exception_keeper_tb_18;
    exception_lineno = exception_keeper_lineno_18;

    goto outline_exception_4;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_4:;
    exception_lineno = 171;
    goto try_except_handler_22;
    outline_result_8:;
    tmp_assign_source_68 = tmp_outline_return_value_8;
    assert( tmp_class_creation_6__class_dict == NULL );
    tmp_class_creation_6__class_dict = tmp_assign_source_68;

    tmp_compare_left_6 = const_str_plain___metaclass__;
    tmp_compare_right_6 = tmp_class_creation_6__class_dict;

    CHECK_OBJECT( tmp_compare_right_6 );
    tmp_cmp_In_6 = PySequence_Contains( tmp_compare_right_6, tmp_compare_left_6 );
    assert( !(tmp_cmp_In_6 == -1) );
    if ( tmp_cmp_In_6 == 1 )
    {
        goto condexpr_true_6;
    }
    else
    {
        goto condexpr_false_6;
    }
    condexpr_true_6:;
    tmp_dict_name_6 = tmp_class_creation_6__class_dict;

    CHECK_OBJECT( tmp_dict_name_6 );
    tmp_key_name_6 = const_str_plain___metaclass__;
    tmp_assign_source_69 = DICT_GET_ITEM( tmp_dict_name_6, tmp_key_name_6 );
    if ( tmp_assign_source_69 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 171;

        goto try_except_handler_22;
    }
    goto condexpr_end_6;
    condexpr_false_6:;
    tmp_assign_source_69 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_69 );
    condexpr_end_6:;
    assert( tmp_class_creation_6__metaclass == NULL );
    tmp_class_creation_6__metaclass = tmp_assign_source_69;

    tmp_called_name_11 = tmp_class_creation_6__metaclass;

    CHECK_OBJECT( tmp_called_name_11 );
    tmp_args_element_name_21 = const_str_plain_AuthorityKeyIdentifier;
    tmp_args_element_name_22 = const_tuple_type_object_tuple;
    tmp_args_element_name_23 = tmp_class_creation_6__class_dict;

    CHECK_OBJECT( tmp_args_element_name_23 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 171;
    {
        PyObject *call_args[] = { tmp_args_element_name_21, tmp_args_element_name_22, tmp_args_element_name_23 };
        tmp_assign_source_70 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_11, call_args );
    }

    if ( tmp_assign_source_70 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 171;

        goto try_except_handler_22;
    }
    assert( tmp_class_creation_6__class == NULL );
    tmp_class_creation_6__class = tmp_assign_source_70;

    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 170;

        goto try_except_handler_22;
    }

    tmp_called_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_register_interface );
    if ( tmp_called_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 170;

        goto try_except_handler_22;
    }
    tmp_args_element_name_24 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_24 == NULL ))
    {
        tmp_args_element_name_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_24 == NULL )
    {
        Py_DECREF( tmp_called_name_13 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 170;

        goto try_except_handler_22;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 170;
    {
        PyObject *call_args[] = { tmp_args_element_name_24 };
        tmp_called_name_12 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
    }

    Py_DECREF( tmp_called_name_13 );
    if ( tmp_called_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 170;

        goto try_except_handler_22;
    }
    tmp_args_element_name_25 = tmp_class_creation_6__class;

    CHECK_OBJECT( tmp_args_element_name_25 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 170;
    {
        PyObject *call_args[] = { tmp_args_element_name_25 };
        tmp_assign_source_71 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_12, call_args );
    }

    Py_DECREF( tmp_called_name_12 );
    if ( tmp_assign_source_71 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 170;

        goto try_except_handler_22;
    }
    {
        PyObject *old = tmp_class_creation_6__class;
        assert( old != NULL );
        tmp_class_creation_6__class = tmp_assign_source_71;
        Py_DECREF( old );
    }

    goto try_end_13;
    // Exception handler code:
    try_except_handler_22:;
    exception_keeper_type_19 = exception_type;
    exception_keeper_value_19 = exception_value;
    exception_keeper_tb_19 = exception_tb;
    exception_keeper_lineno_19 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_6__class );
    tmp_class_creation_6__class = NULL;

    Py_XDECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_19;
    exception_value = exception_keeper_value_19;
    exception_tb = exception_keeper_tb_19;
    exception_lineno = exception_keeper_lineno_19;

    goto frame_exception_exit_1;
    // End of try:
    try_end_13:;
    tmp_assign_source_72 = tmp_class_creation_6__class;

    CHECK_OBJECT( tmp_assign_source_72 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AuthorityKeyIdentifier, tmp_assign_source_72 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class );
    Py_DECREF( tmp_class_creation_6__class );
    tmp_class_creation_6__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class_dict );
    Py_DECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__metaclass );
    Py_DECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_SubjectKeyIdentifier_274 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_SubjectKeyIdentifier_274, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_08a1b65564a30b1f1e14109e0bae6149_6, codeobj_08a1b65564a30b1f1e14109e0bae6149, module_cryptography$x509$extensions, 0 );
    frame_08a1b65564a30b1f1e14109e0bae6149_6 = cache_frame_08a1b65564a30b1f1e14109e0bae6149_6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_08a1b65564a30b1f1e14109e0bae6149_6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_08a1b65564a30b1f1e14109e0bae6149_6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 275;

        goto frame_exception_exit_6;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_SUBJECT_KEY_IDENTIFIER );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 275;

        goto frame_exception_exit_6;
    }
    tmp_res = PyDict_SetItem( locals_SubjectKeyIdentifier_274, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 275;

        goto frame_exception_exit_6;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_22___init__(  );
    tmp_res = PyDict_SetItem( locals_SubjectKeyIdentifier_274, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_classmethod_arg_3 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_23_from_public_key(  );
    tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_3 );
    Py_DECREF( tmp_classmethod_arg_3 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 280;

        goto frame_exception_exit_6;
    }
    tmp_res = PyDict_SetItem( locals_SubjectKeyIdentifier_274, const_str_plain_from_public_key, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 280;

        goto frame_exception_exit_6;
    }
    tmp_called_instance_6 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_6 == NULL ))
    {
        tmp_called_instance_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 284;

        goto frame_exception_exit_6;
    }

    frame_08a1b65564a30b1f1e14109e0bae6149_6->m_frame.f_lineno = 284;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__digest_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 284;

        goto frame_exception_exit_6;
    }
    tmp_res = PyDict_SetItem( locals_SubjectKeyIdentifier_274, const_str_plain_digest, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 284;

        goto frame_exception_exit_6;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08a1b65564a30b1f1e14109e0bae6149_6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_5;

    frame_exception_exit_6:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08a1b65564a30b1f1e14109e0bae6149_6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_08a1b65564a30b1f1e14109e0bae6149_6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_08a1b65564a30b1f1e14109e0bae6149_6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_08a1b65564a30b1f1e14109e0bae6149_6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_08a1b65564a30b1f1e14109e0bae6149_6,
        type_description_2
    );


    // Release cached frame.
    if ( frame_08a1b65564a30b1f1e14109e0bae6149_6 == cache_frame_08a1b65564a30b1f1e14109e0bae6149_6 )
    {
        Py_DECREF( frame_08a1b65564a30b1f1e14109e0bae6149_6 );
    }
    cache_frame_08a1b65564a30b1f1e14109e0bae6149_6 = NULL;

    assertFrameObject( frame_08a1b65564a30b1f1e14109e0bae6149_6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_5;

    frame_no_exception_5:;

    goto skip_nested_handling_5;
    nested_frame_exit_5:;

    goto try_except_handler_25;
    skip_nested_handling_5:;
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_24___repr__(  );
    tmp_res = PyDict_SetItem( locals_SubjectKeyIdentifier_274, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_25___eq__(  );
    tmp_res = PyDict_SetItem( locals_SubjectKeyIdentifier_274, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_26___ne__(  );
    tmp_res = PyDict_SetItem( locals_SubjectKeyIdentifier_274, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_27___hash__(  );
    tmp_res = PyDict_SetItem( locals_SubjectKeyIdentifier_274, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_9 = locals_SubjectKeyIdentifier_274;
    Py_INCREF( tmp_outline_return_value_9 );
    goto try_return_handler_25;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_25:;
    Py_DECREF( locals_SubjectKeyIdentifier_274 );
    locals_SubjectKeyIdentifier_274 = NULL;
    goto outline_result_9;
    // Exception handler code:
    try_except_handler_25:;
    exception_keeper_type_20 = exception_type;
    exception_keeper_value_20 = exception_value;
    exception_keeper_tb_20 = exception_tb;
    exception_keeper_lineno_20 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_SubjectKeyIdentifier_274 );
    locals_SubjectKeyIdentifier_274 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_20;
    exception_value = exception_keeper_value_20;
    exception_tb = exception_keeper_tb_20;
    exception_lineno = exception_keeper_lineno_20;

    goto outline_exception_5;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_5:;
    exception_lineno = 274;
    goto try_except_handler_24;
    outline_result_9:;
    tmp_assign_source_73 = tmp_outline_return_value_9;
    assert( tmp_class_creation_7__class_dict == NULL );
    tmp_class_creation_7__class_dict = tmp_assign_source_73;

    tmp_compare_left_7 = const_str_plain___metaclass__;
    tmp_compare_right_7 = tmp_class_creation_7__class_dict;

    CHECK_OBJECT( tmp_compare_right_7 );
    tmp_cmp_In_7 = PySequence_Contains( tmp_compare_right_7, tmp_compare_left_7 );
    assert( !(tmp_cmp_In_7 == -1) );
    if ( tmp_cmp_In_7 == 1 )
    {
        goto condexpr_true_7;
    }
    else
    {
        goto condexpr_false_7;
    }
    condexpr_true_7:;
    tmp_dict_name_7 = tmp_class_creation_7__class_dict;

    CHECK_OBJECT( tmp_dict_name_7 );
    tmp_key_name_7 = const_str_plain___metaclass__;
    tmp_assign_source_74 = DICT_GET_ITEM( tmp_dict_name_7, tmp_key_name_7 );
    if ( tmp_assign_source_74 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 274;

        goto try_except_handler_24;
    }
    goto condexpr_end_7;
    condexpr_false_7:;
    tmp_assign_source_74 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_74 );
    condexpr_end_7:;
    assert( tmp_class_creation_7__metaclass == NULL );
    tmp_class_creation_7__metaclass = tmp_assign_source_74;

    tmp_called_name_14 = tmp_class_creation_7__metaclass;

    CHECK_OBJECT( tmp_called_name_14 );
    tmp_args_element_name_26 = const_str_plain_SubjectKeyIdentifier;
    tmp_args_element_name_27 = const_tuple_type_object_tuple;
    tmp_args_element_name_28 = tmp_class_creation_7__class_dict;

    CHECK_OBJECT( tmp_args_element_name_28 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 274;
    {
        PyObject *call_args[] = { tmp_args_element_name_26, tmp_args_element_name_27, tmp_args_element_name_28 };
        tmp_assign_source_75 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_14, call_args );
    }

    if ( tmp_assign_source_75 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 274;

        goto try_except_handler_24;
    }
    assert( tmp_class_creation_7__class == NULL );
    tmp_class_creation_7__class = tmp_assign_source_75;

    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 273;

        goto try_except_handler_24;
    }

    tmp_called_name_16 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_register_interface );
    if ( tmp_called_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 273;

        goto try_except_handler_24;
    }
    tmp_args_element_name_29 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_29 == NULL ))
    {
        tmp_args_element_name_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_29 == NULL )
    {
        Py_DECREF( tmp_called_name_16 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 273;

        goto try_except_handler_24;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 273;
    {
        PyObject *call_args[] = { tmp_args_element_name_29 };
        tmp_called_name_15 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_16, call_args );
    }

    Py_DECREF( tmp_called_name_16 );
    if ( tmp_called_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 273;

        goto try_except_handler_24;
    }
    tmp_args_element_name_30 = tmp_class_creation_7__class;

    CHECK_OBJECT( tmp_args_element_name_30 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 273;
    {
        PyObject *call_args[] = { tmp_args_element_name_30 };
        tmp_assign_source_76 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_15, call_args );
    }

    Py_DECREF( tmp_called_name_15 );
    if ( tmp_assign_source_76 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 273;

        goto try_except_handler_24;
    }
    {
        PyObject *old = tmp_class_creation_7__class;
        assert( old != NULL );
        tmp_class_creation_7__class = tmp_assign_source_76;
        Py_DECREF( old );
    }

    goto try_end_14;
    // Exception handler code:
    try_except_handler_24:;
    exception_keeper_type_21 = exception_type;
    exception_keeper_value_21 = exception_value;
    exception_keeper_tb_21 = exception_tb;
    exception_keeper_lineno_21 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_7__class );
    tmp_class_creation_7__class = NULL;

    Py_XDECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_21;
    exception_value = exception_keeper_value_21;
    exception_tb = exception_keeper_tb_21;
    exception_lineno = exception_keeper_lineno_21;

    goto frame_exception_exit_1;
    // End of try:
    try_end_14:;
    tmp_assign_source_77 = tmp_class_creation_7__class;

    CHECK_OBJECT( tmp_assign_source_77 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SubjectKeyIdentifier, tmp_assign_source_77 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class );
    Py_DECREF( tmp_class_creation_7__class );
    tmp_class_creation_7__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class_dict );
    Py_DECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__metaclass );
    Py_DECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_AuthorityInformationAccess_303 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_AuthorityInformationAccess_303, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_69802bcecece78bdea4189479571dd66_7, codeobj_69802bcecece78bdea4189479571dd66, module_cryptography$x509$extensions, 0 );
    frame_69802bcecece78bdea4189479571dd66_7 = cache_frame_69802bcecece78bdea4189479571dd66_7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_69802bcecece78bdea4189479571dd66_7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_69802bcecece78bdea4189479571dd66_7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 304;

        goto frame_exception_exit_7;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_AUTHORITY_INFORMATION_ACCESS );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 304;

        goto frame_exception_exit_7;
    }
    tmp_res = PyDict_SetItem( locals_AuthorityInformationAccess_303, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 304;

        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_28___init__(  );
    tmp_res = PyDict_SetItem( locals_AuthorityInformationAccess_303, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_called_name_17 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );

    if (unlikely( tmp_called_name_17 == NULL ))
    {
        tmp_called_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );
    }

    if ( tmp_called_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_sequence_methods" );
        exception_tb = NULL;

        exception_lineno = 316;

        goto try_except_handler_28;
    }

    frame_69802bcecece78bdea4189479571dd66_7->m_frame.f_lineno = 316;
    tmp_iter_arg_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_17, &PyTuple_GET_ITEM( const_tuple_str_plain__descriptions_tuple, 0 ) );

    if ( tmp_iter_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 316;

        goto try_except_handler_28;
    }
    tmp_assign_source_79 = MAKE_ITERATOR( tmp_iter_arg_2 );
    Py_DECREF( tmp_iter_arg_2 );
    if ( tmp_assign_source_79 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 316;

        goto try_except_handler_28;
    }
    assert( tmp_AuthorityInformationAccess$tuple_unpack_1__source_iter == NULL );
    tmp_AuthorityInformationAccess$tuple_unpack_1__source_iter = tmp_assign_source_79;

    // Tried code:
    tmp_unpack_4 = tmp_AuthorityInformationAccess$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_4 );
    tmp_assign_source_80 = UNPACK_NEXT( tmp_unpack_4, 0 );
    if ( tmp_assign_source_80 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 316;
        goto try_except_handler_29;
    }
    assert( tmp_AuthorityInformationAccess$tuple_unpack_1__element_1 == NULL );
    tmp_AuthorityInformationAccess$tuple_unpack_1__element_1 = tmp_assign_source_80;

    tmp_unpack_5 = tmp_AuthorityInformationAccess$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_5 );
    tmp_assign_source_81 = UNPACK_NEXT( tmp_unpack_5, 1 );
    if ( tmp_assign_source_81 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 316;
        goto try_except_handler_29;
    }
    assert( tmp_AuthorityInformationAccess$tuple_unpack_1__element_2 == NULL );
    tmp_AuthorityInformationAccess$tuple_unpack_1__element_2 = tmp_assign_source_81;

    tmp_unpack_6 = tmp_AuthorityInformationAccess$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_6 );
    tmp_assign_source_82 = UNPACK_NEXT( tmp_unpack_6, 2 );
    if ( tmp_assign_source_82 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 316;
        goto try_except_handler_29;
    }
    assert( tmp_AuthorityInformationAccess$tuple_unpack_1__element_3 == NULL );
    tmp_AuthorityInformationAccess$tuple_unpack_1__element_3 = tmp_assign_source_82;

    tmp_iterator_name_2 = tmp_AuthorityInformationAccess$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_2 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_2 ); assert( HAS_ITERNEXT( tmp_iterator_name_2 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_2 )->tp_iternext)( tmp_iterator_name_2 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 316;
                goto try_except_handler_29;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 316;
        goto try_except_handler_29;
    }
    goto try_end_15;
    // Exception handler code:
    try_except_handler_29:;
    exception_keeper_type_22 = exception_type;
    exception_keeper_value_22 = exception_value;
    exception_keeper_tb_22 = exception_tb;
    exception_keeper_lineno_22 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_AuthorityInformationAccess$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_AuthorityInformationAccess$tuple_unpack_1__source_iter );
    tmp_AuthorityInformationAccess$tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_22;
    exception_value = exception_keeper_value_22;
    exception_tb = exception_keeper_tb_22;
    exception_lineno = exception_keeper_lineno_22;

    goto try_except_handler_28;
    // End of try:
    try_end_15:;
    goto try_end_16;
    // Exception handler code:
    try_except_handler_28:;
    exception_keeper_type_23 = exception_type;
    exception_keeper_value_23 = exception_value;
    exception_keeper_tb_23 = exception_tb;
    exception_keeper_lineno_23 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_AuthorityInformationAccess$tuple_unpack_1__element_1 );
    tmp_AuthorityInformationAccess$tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_AuthorityInformationAccess$tuple_unpack_1__element_2 );
    tmp_AuthorityInformationAccess$tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_AuthorityInformationAccess$tuple_unpack_1__element_3 );
    tmp_AuthorityInformationAccess$tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_23;
    exception_value = exception_keeper_value_23;
    exception_tb = exception_keeper_tb_23;
    exception_lineno = exception_keeper_lineno_23;

    goto frame_exception_exit_7;
    // End of try:
    try_end_16:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_69802bcecece78bdea4189479571dd66_7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_6;

    frame_exception_exit_7:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_69802bcecece78bdea4189479571dd66_7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_69802bcecece78bdea4189479571dd66_7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_69802bcecece78bdea4189479571dd66_7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_69802bcecece78bdea4189479571dd66_7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_69802bcecece78bdea4189479571dd66_7,
        type_description_2
    );


    // Release cached frame.
    if ( frame_69802bcecece78bdea4189479571dd66_7 == cache_frame_69802bcecece78bdea4189479571dd66_7 )
    {
        Py_DECREF( frame_69802bcecece78bdea4189479571dd66_7 );
    }
    cache_frame_69802bcecece78bdea4189479571dd66_7 = NULL;

    assertFrameObject( frame_69802bcecece78bdea4189479571dd66_7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_6;

    frame_no_exception_6:;

    goto skip_nested_handling_6;
    nested_frame_exit_6:;

    goto try_except_handler_27;
    skip_nested_handling_6:;
    CHECK_OBJECT( (PyObject *)tmp_AuthorityInformationAccess$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_AuthorityInformationAccess$tuple_unpack_1__source_iter );
    tmp_AuthorityInformationAccess$tuple_unpack_1__source_iter = NULL;

    tmp_dictset_value = tmp_AuthorityInformationAccess$tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_AuthorityInformationAccess_303, const_str_plain___len__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_AuthorityInformationAccess$tuple_unpack_1__element_1 );
    tmp_AuthorityInformationAccess$tuple_unpack_1__element_1 = NULL;

    tmp_dictset_value = tmp_AuthorityInformationAccess$tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_AuthorityInformationAccess_303, const_str_plain___iter__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_AuthorityInformationAccess$tuple_unpack_1__element_2 );
    tmp_AuthorityInformationAccess$tuple_unpack_1__element_2 = NULL;

    tmp_dictset_value = tmp_AuthorityInformationAccess$tuple_unpack_1__element_3;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_AuthorityInformationAccess_303, const_str_plain___getitem__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_AuthorityInformationAccess$tuple_unpack_1__element_3 );
    tmp_AuthorityInformationAccess$tuple_unpack_1__element_3 = NULL;

    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_29___repr__(  );
    tmp_res = PyDict_SetItem( locals_AuthorityInformationAccess_303, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_30___eq__(  );
    tmp_res = PyDict_SetItem( locals_AuthorityInformationAccess_303, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_31___ne__(  );
    tmp_res = PyDict_SetItem( locals_AuthorityInformationAccess_303, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_32___hash__(  );
    tmp_res = PyDict_SetItem( locals_AuthorityInformationAccess_303, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_10 = locals_AuthorityInformationAccess_303;
    Py_INCREF( tmp_outline_return_value_10 );
    goto try_return_handler_27;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_27:;
    Py_DECREF( locals_AuthorityInformationAccess_303 );
    locals_AuthorityInformationAccess_303 = NULL;
    goto outline_result_10;
    // Exception handler code:
    try_except_handler_27:;
    exception_keeper_type_24 = exception_type;
    exception_keeper_value_24 = exception_value;
    exception_keeper_tb_24 = exception_tb;
    exception_keeper_lineno_24 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_AuthorityInformationAccess_303 );
    locals_AuthorityInformationAccess_303 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_24;
    exception_value = exception_keeper_value_24;
    exception_tb = exception_keeper_tb_24;
    exception_lineno = exception_keeper_lineno_24;

    goto outline_exception_6;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_6:;
    exception_lineno = 303;
    goto try_except_handler_26;
    outline_result_10:;
    tmp_assign_source_78 = tmp_outline_return_value_10;
    assert( tmp_class_creation_8__class_dict == NULL );
    tmp_class_creation_8__class_dict = tmp_assign_source_78;

    tmp_compare_left_8 = const_str_plain___metaclass__;
    tmp_compare_right_8 = tmp_class_creation_8__class_dict;

    CHECK_OBJECT( tmp_compare_right_8 );
    tmp_cmp_In_8 = PySequence_Contains( tmp_compare_right_8, tmp_compare_left_8 );
    assert( !(tmp_cmp_In_8 == -1) );
    if ( tmp_cmp_In_8 == 1 )
    {
        goto condexpr_true_8;
    }
    else
    {
        goto condexpr_false_8;
    }
    condexpr_true_8:;
    tmp_dict_name_8 = tmp_class_creation_8__class_dict;

    CHECK_OBJECT( tmp_dict_name_8 );
    tmp_key_name_8 = const_str_plain___metaclass__;
    tmp_assign_source_83 = DICT_GET_ITEM( tmp_dict_name_8, tmp_key_name_8 );
    if ( tmp_assign_source_83 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 303;

        goto try_except_handler_26;
    }
    goto condexpr_end_8;
    condexpr_false_8:;
    tmp_assign_source_83 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_83 );
    condexpr_end_8:;
    assert( tmp_class_creation_8__metaclass == NULL );
    tmp_class_creation_8__metaclass = tmp_assign_source_83;

    tmp_called_name_18 = tmp_class_creation_8__metaclass;

    CHECK_OBJECT( tmp_called_name_18 );
    tmp_args_element_name_31 = const_str_plain_AuthorityInformationAccess;
    tmp_args_element_name_32 = const_tuple_type_object_tuple;
    tmp_args_element_name_33 = tmp_class_creation_8__class_dict;

    CHECK_OBJECT( tmp_args_element_name_33 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 303;
    {
        PyObject *call_args[] = { tmp_args_element_name_31, tmp_args_element_name_32, tmp_args_element_name_33 };
        tmp_assign_source_84 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_18, call_args );
    }

    if ( tmp_assign_source_84 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 303;

        goto try_except_handler_26;
    }
    assert( tmp_class_creation_8__class == NULL );
    tmp_class_creation_8__class = tmp_assign_source_84;

    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 302;

        goto try_except_handler_26;
    }

    tmp_called_name_20 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_register_interface );
    if ( tmp_called_name_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 302;

        goto try_except_handler_26;
    }
    tmp_args_element_name_34 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_34 == NULL ))
    {
        tmp_args_element_name_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_34 == NULL )
    {
        Py_DECREF( tmp_called_name_20 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 302;

        goto try_except_handler_26;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 302;
    {
        PyObject *call_args[] = { tmp_args_element_name_34 };
        tmp_called_name_19 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_20, call_args );
    }

    Py_DECREF( tmp_called_name_20 );
    if ( tmp_called_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 302;

        goto try_except_handler_26;
    }
    tmp_args_element_name_35 = tmp_class_creation_8__class;

    CHECK_OBJECT( tmp_args_element_name_35 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 302;
    {
        PyObject *call_args[] = { tmp_args_element_name_35 };
        tmp_assign_source_85 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_19, call_args );
    }

    Py_DECREF( tmp_called_name_19 );
    if ( tmp_assign_source_85 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 302;

        goto try_except_handler_26;
    }
    {
        PyObject *old = tmp_class_creation_8__class;
        assert( old != NULL );
        tmp_class_creation_8__class = tmp_assign_source_85;
        Py_DECREF( old );
    }

    goto try_end_17;
    // Exception handler code:
    try_except_handler_26:;
    exception_keeper_type_25 = exception_type;
    exception_keeper_value_25 = exception_value;
    exception_keeper_tb_25 = exception_tb;
    exception_keeper_lineno_25 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_8__class );
    tmp_class_creation_8__class = NULL;

    Py_XDECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_25;
    exception_value = exception_keeper_value_25;
    exception_tb = exception_keeper_tb_25;
    exception_lineno = exception_keeper_lineno_25;

    goto frame_exception_exit_1;
    // End of try:
    try_end_17:;
    tmp_assign_source_86 = tmp_class_creation_8__class;

    CHECK_OBJECT( tmp_assign_source_86 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AuthorityInformationAccess, tmp_assign_source_86 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class );
    Py_DECREF( tmp_class_creation_8__class );
    tmp_class_creation_8__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class_dict );
    Py_DECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__metaclass );
    Py_DECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_AccessDescription_334 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_AccessDescription_334, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_33___init__(  );
    tmp_res = PyDict_SetItem( locals_AccessDescription_334, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_34___repr__(  );
    tmp_res = PyDict_SetItem( locals_AccessDescription_334, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_35___eq__(  );
    tmp_res = PyDict_SetItem( locals_AccessDescription_334, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_36___ne__(  );
    tmp_res = PyDict_SetItem( locals_AccessDescription_334, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_37___hash__(  );
    tmp_res = PyDict_SetItem( locals_AccessDescription_334, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4f772ca62aff292069d20685ea8ad5a3_8, codeobj_4f772ca62aff292069d20685ea8ad5a3, module_cryptography$x509$extensions, 0 );
    frame_4f772ca62aff292069d20685ea8ad5a3_8 = cache_frame_4f772ca62aff292069d20685ea8ad5a3_8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4f772ca62aff292069d20685ea8ad5a3_8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4f772ca62aff292069d20685ea8ad5a3_8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_7 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_7 == NULL ))
    {
        tmp_called_instance_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 366;

        goto frame_exception_exit_8;
    }

    frame_4f772ca62aff292069d20685ea8ad5a3_8->m_frame.f_lineno = 366;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__access_method_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 366;

        goto frame_exception_exit_8;
    }
    tmp_res = PyDict_SetItem( locals_AccessDescription_334, const_str_plain_access_method, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 366;

        goto frame_exception_exit_8;
    }
    tmp_called_instance_8 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_8 == NULL ))
    {
        tmp_called_instance_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 367;

        goto frame_exception_exit_8;
    }

    frame_4f772ca62aff292069d20685ea8ad5a3_8->m_frame.f_lineno = 367;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_8, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__access_location_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 367;

        goto frame_exception_exit_8;
    }
    tmp_res = PyDict_SetItem( locals_AccessDescription_334, const_str_plain_access_location, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 367;

        goto frame_exception_exit_8;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4f772ca62aff292069d20685ea8ad5a3_8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_7;

    frame_exception_exit_8:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4f772ca62aff292069d20685ea8ad5a3_8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4f772ca62aff292069d20685ea8ad5a3_8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4f772ca62aff292069d20685ea8ad5a3_8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4f772ca62aff292069d20685ea8ad5a3_8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4f772ca62aff292069d20685ea8ad5a3_8,
        type_description_2
    );


    // Release cached frame.
    if ( frame_4f772ca62aff292069d20685ea8ad5a3_8 == cache_frame_4f772ca62aff292069d20685ea8ad5a3_8 )
    {
        Py_DECREF( frame_4f772ca62aff292069d20685ea8ad5a3_8 );
    }
    cache_frame_4f772ca62aff292069d20685ea8ad5a3_8 = NULL;

    assertFrameObject( frame_4f772ca62aff292069d20685ea8ad5a3_8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_7;

    frame_no_exception_7:;

    goto skip_nested_handling_7;
    nested_frame_exit_7:;

    goto try_except_handler_31;
    skip_nested_handling_7:;
    tmp_outline_return_value_11 = locals_AccessDescription_334;
    Py_INCREF( tmp_outline_return_value_11 );
    goto try_return_handler_31;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_31:;
    Py_DECREF( locals_AccessDescription_334 );
    locals_AccessDescription_334 = NULL;
    goto outline_result_11;
    // Exception handler code:
    try_except_handler_31:;
    exception_keeper_type_26 = exception_type;
    exception_keeper_value_26 = exception_value;
    exception_keeper_tb_26 = exception_tb;
    exception_keeper_lineno_26 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_AccessDescription_334 );
    locals_AccessDescription_334 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_26;
    exception_value = exception_keeper_value_26;
    exception_tb = exception_keeper_tb_26;
    exception_lineno = exception_keeper_lineno_26;

    goto outline_exception_7;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_7:;
    exception_lineno = 334;
    goto try_except_handler_30;
    outline_result_11:;
    tmp_assign_source_87 = tmp_outline_return_value_11;
    assert( tmp_class_creation_9__class_dict == NULL );
    tmp_class_creation_9__class_dict = tmp_assign_source_87;

    tmp_compare_left_9 = const_str_plain___metaclass__;
    tmp_compare_right_9 = tmp_class_creation_9__class_dict;

    CHECK_OBJECT( tmp_compare_right_9 );
    tmp_cmp_In_9 = PySequence_Contains( tmp_compare_right_9, tmp_compare_left_9 );
    assert( !(tmp_cmp_In_9 == -1) );
    if ( tmp_cmp_In_9 == 1 )
    {
        goto condexpr_true_9;
    }
    else
    {
        goto condexpr_false_9;
    }
    condexpr_true_9:;
    tmp_dict_name_9 = tmp_class_creation_9__class_dict;

    CHECK_OBJECT( tmp_dict_name_9 );
    tmp_key_name_9 = const_str_plain___metaclass__;
    tmp_assign_source_88 = DICT_GET_ITEM( tmp_dict_name_9, tmp_key_name_9 );
    if ( tmp_assign_source_88 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 334;

        goto try_except_handler_30;
    }
    goto condexpr_end_9;
    condexpr_false_9:;
    tmp_assign_source_88 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_88 );
    condexpr_end_9:;
    assert( tmp_class_creation_9__metaclass == NULL );
    tmp_class_creation_9__metaclass = tmp_assign_source_88;

    tmp_called_name_21 = tmp_class_creation_9__metaclass;

    CHECK_OBJECT( tmp_called_name_21 );
    tmp_args_element_name_36 = const_str_plain_AccessDescription;
    tmp_args_element_name_37 = const_tuple_type_object_tuple;
    tmp_args_element_name_38 = tmp_class_creation_9__class_dict;

    CHECK_OBJECT( tmp_args_element_name_38 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 334;
    {
        PyObject *call_args[] = { tmp_args_element_name_36, tmp_args_element_name_37, tmp_args_element_name_38 };
        tmp_assign_source_89 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_21, call_args );
    }

    if ( tmp_assign_source_89 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 334;

        goto try_except_handler_30;
    }
    assert( tmp_class_creation_9__class == NULL );
    tmp_class_creation_9__class = tmp_assign_source_89;

    goto try_end_18;
    // Exception handler code:
    try_except_handler_30:;
    exception_keeper_type_27 = exception_type;
    exception_keeper_value_27 = exception_value;
    exception_keeper_tb_27 = exception_tb;
    exception_keeper_lineno_27 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_27;
    exception_value = exception_keeper_value_27;
    exception_tb = exception_keeper_tb_27;
    exception_lineno = exception_keeper_lineno_27;

    goto frame_exception_exit_1;
    // End of try:
    try_end_18:;
    tmp_assign_source_90 = tmp_class_creation_9__class;

    CHECK_OBJECT( tmp_assign_source_90 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AccessDescription, tmp_assign_source_90 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class );
    Py_DECREF( tmp_class_creation_9__class );
    tmp_class_creation_9__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class_dict );
    Py_DECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__metaclass );
    Py_DECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_BasicConstraints_371 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_BasicConstraints_371, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1b99be5f5125e520c5e83672fe393339_9, codeobj_1b99be5f5125e520c5e83672fe393339, module_cryptography$x509$extensions, 0 );
    frame_1b99be5f5125e520c5e83672fe393339_9 = cache_frame_1b99be5f5125e520c5e83672fe393339_9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1b99be5f5125e520c5e83672fe393339_9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1b99be5f5125e520c5e83672fe393339_9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_13 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_13 == NULL ))
    {
        tmp_source_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_13 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 372;

        goto frame_exception_exit_9;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_BASIC_CONSTRAINTS );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 372;

        goto frame_exception_exit_9;
    }
    tmp_res = PyDict_SetItem( locals_BasicConstraints_371, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 372;

        goto frame_exception_exit_9;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_38___init__(  );
    tmp_res = PyDict_SetItem( locals_BasicConstraints_371, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_instance_9 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_9 == NULL ))
    {
        tmp_called_instance_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 392;

        goto frame_exception_exit_9;
    }

    frame_1b99be5f5125e520c5e83672fe393339_9->m_frame.f_lineno = 392;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_9, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__ca_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 392;

        goto frame_exception_exit_9;
    }
    tmp_res = PyDict_SetItem( locals_BasicConstraints_371, const_str_plain_ca, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 392;

        goto frame_exception_exit_9;
    }
    tmp_called_instance_10 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_10 == NULL ))
    {
        tmp_called_instance_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 393;

        goto frame_exception_exit_9;
    }

    frame_1b99be5f5125e520c5e83672fe393339_9->m_frame.f_lineno = 393;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_10, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__path_length_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 393;

        goto frame_exception_exit_9;
    }
    tmp_res = PyDict_SetItem( locals_BasicConstraints_371, const_str_plain_path_length, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 393;

        goto frame_exception_exit_9;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b99be5f5125e520c5e83672fe393339_9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_8;

    frame_exception_exit_9:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b99be5f5125e520c5e83672fe393339_9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1b99be5f5125e520c5e83672fe393339_9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1b99be5f5125e520c5e83672fe393339_9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1b99be5f5125e520c5e83672fe393339_9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1b99be5f5125e520c5e83672fe393339_9,
        type_description_2
    );


    // Release cached frame.
    if ( frame_1b99be5f5125e520c5e83672fe393339_9 == cache_frame_1b99be5f5125e520c5e83672fe393339_9 )
    {
        Py_DECREF( frame_1b99be5f5125e520c5e83672fe393339_9 );
    }
    cache_frame_1b99be5f5125e520c5e83672fe393339_9 = NULL;

    assertFrameObject( frame_1b99be5f5125e520c5e83672fe393339_9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_8;

    frame_no_exception_8:;

    goto skip_nested_handling_8;
    nested_frame_exit_8:;

    goto try_except_handler_33;
    skip_nested_handling_8:;
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_39___repr__(  );
    tmp_res = PyDict_SetItem( locals_BasicConstraints_371, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_40___eq__(  );
    tmp_res = PyDict_SetItem( locals_BasicConstraints_371, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_41___ne__(  );
    tmp_res = PyDict_SetItem( locals_BasicConstraints_371, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_42___hash__(  );
    tmp_res = PyDict_SetItem( locals_BasicConstraints_371, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_12 = locals_BasicConstraints_371;
    Py_INCREF( tmp_outline_return_value_12 );
    goto try_return_handler_33;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_33:;
    Py_DECREF( locals_BasicConstraints_371 );
    locals_BasicConstraints_371 = NULL;
    goto outline_result_12;
    // Exception handler code:
    try_except_handler_33:;
    exception_keeper_type_28 = exception_type;
    exception_keeper_value_28 = exception_value;
    exception_keeper_tb_28 = exception_tb;
    exception_keeper_lineno_28 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_BasicConstraints_371 );
    locals_BasicConstraints_371 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_28;
    exception_value = exception_keeper_value_28;
    exception_tb = exception_keeper_tb_28;
    exception_lineno = exception_keeper_lineno_28;

    goto outline_exception_8;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_8:;
    exception_lineno = 371;
    goto try_except_handler_32;
    outline_result_12:;
    tmp_assign_source_91 = tmp_outline_return_value_12;
    assert( tmp_class_creation_10__class_dict == NULL );
    tmp_class_creation_10__class_dict = tmp_assign_source_91;

    tmp_compare_left_10 = const_str_plain___metaclass__;
    tmp_compare_right_10 = tmp_class_creation_10__class_dict;

    CHECK_OBJECT( tmp_compare_right_10 );
    tmp_cmp_In_10 = PySequence_Contains( tmp_compare_right_10, tmp_compare_left_10 );
    assert( !(tmp_cmp_In_10 == -1) );
    if ( tmp_cmp_In_10 == 1 )
    {
        goto condexpr_true_10;
    }
    else
    {
        goto condexpr_false_10;
    }
    condexpr_true_10:;
    tmp_dict_name_10 = tmp_class_creation_10__class_dict;

    CHECK_OBJECT( tmp_dict_name_10 );
    tmp_key_name_10 = const_str_plain___metaclass__;
    tmp_assign_source_92 = DICT_GET_ITEM( tmp_dict_name_10, tmp_key_name_10 );
    if ( tmp_assign_source_92 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 371;

        goto try_except_handler_32;
    }
    goto condexpr_end_10;
    condexpr_false_10:;
    tmp_assign_source_92 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_92 );
    condexpr_end_10:;
    assert( tmp_class_creation_10__metaclass == NULL );
    tmp_class_creation_10__metaclass = tmp_assign_source_92;

    tmp_called_name_22 = tmp_class_creation_10__metaclass;

    CHECK_OBJECT( tmp_called_name_22 );
    tmp_args_element_name_39 = const_str_plain_BasicConstraints;
    tmp_args_element_name_40 = const_tuple_type_object_tuple;
    tmp_args_element_name_41 = tmp_class_creation_10__class_dict;

    CHECK_OBJECT( tmp_args_element_name_41 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 371;
    {
        PyObject *call_args[] = { tmp_args_element_name_39, tmp_args_element_name_40, tmp_args_element_name_41 };
        tmp_assign_source_93 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_22, call_args );
    }

    if ( tmp_assign_source_93 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 371;

        goto try_except_handler_32;
    }
    assert( tmp_class_creation_10__class == NULL );
    tmp_class_creation_10__class = tmp_assign_source_93;

    tmp_source_name_14 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_14 == NULL ))
    {
        tmp_source_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 370;

        goto try_except_handler_32;
    }

    tmp_called_name_24 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_register_interface );
    if ( tmp_called_name_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 370;

        goto try_except_handler_32;
    }
    tmp_args_element_name_42 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_42 == NULL ))
    {
        tmp_args_element_name_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_42 == NULL )
    {
        Py_DECREF( tmp_called_name_24 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 370;

        goto try_except_handler_32;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 370;
    {
        PyObject *call_args[] = { tmp_args_element_name_42 };
        tmp_called_name_23 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_24, call_args );
    }

    Py_DECREF( tmp_called_name_24 );
    if ( tmp_called_name_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 370;

        goto try_except_handler_32;
    }
    tmp_args_element_name_43 = tmp_class_creation_10__class;

    CHECK_OBJECT( tmp_args_element_name_43 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 370;
    {
        PyObject *call_args[] = { tmp_args_element_name_43 };
        tmp_assign_source_94 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_23, call_args );
    }

    Py_DECREF( tmp_called_name_23 );
    if ( tmp_assign_source_94 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 370;

        goto try_except_handler_32;
    }
    {
        PyObject *old = tmp_class_creation_10__class;
        assert( old != NULL );
        tmp_class_creation_10__class = tmp_assign_source_94;
        Py_DECREF( old );
    }

    goto try_end_19;
    // Exception handler code:
    try_except_handler_32:;
    exception_keeper_type_29 = exception_type;
    exception_keeper_value_29 = exception_value;
    exception_keeper_tb_29 = exception_tb;
    exception_keeper_lineno_29 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_10__class );
    tmp_class_creation_10__class = NULL;

    Py_XDECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_29;
    exception_value = exception_keeper_value_29;
    exception_tb = exception_keeper_tb_29;
    exception_lineno = exception_keeper_lineno_29;

    goto frame_exception_exit_1;
    // End of try:
    try_end_19:;
    tmp_assign_source_95 = tmp_class_creation_10__class;

    CHECK_OBJECT( tmp_assign_source_95 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_BasicConstraints, tmp_assign_source_95 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class );
    Py_DECREF( tmp_class_creation_10__class );
    tmp_class_creation_10__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class_dict );
    Py_DECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__metaclass );
    Py_DECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_DeltaCRLIndicator_413 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_DeltaCRLIndicator_413, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10, codeobj_4bcdc3c1413ff63ddaed7210d6b7fcf6, module_cryptography$x509$extensions, 0 );
    frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10 = cache_frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_15 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_15 == NULL ))
    {
        tmp_source_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 414;

        goto frame_exception_exit_10;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_DELTA_CRL_INDICATOR );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 414;

        goto frame_exception_exit_10;
    }
    tmp_res = PyDict_SetItem( locals_DeltaCRLIndicator_413, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 414;

        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_43___init__(  );
    tmp_res = PyDict_SetItem( locals_DeltaCRLIndicator_413, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_instance_11 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_11 == NULL ))
    {
        tmp_called_instance_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 422;

        goto frame_exception_exit_10;
    }

    frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10->m_frame.f_lineno = 422;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_11, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__crl_number_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 422;

        goto frame_exception_exit_10;
    }
    tmp_res = PyDict_SetItem( locals_DeltaCRLIndicator_413, const_str_plain_crl_number, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 422;

        goto frame_exception_exit_10;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_9;

    frame_exception_exit_10:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10,
        type_description_2
    );


    // Release cached frame.
    if ( frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10 == cache_frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10 )
    {
        Py_DECREF( frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10 );
    }
    cache_frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10 = NULL;

    assertFrameObject( frame_4bcdc3c1413ff63ddaed7210d6b7fcf6_10 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_9;

    frame_no_exception_9:;

    goto skip_nested_handling_9;
    nested_frame_exit_9:;

    goto try_except_handler_35;
    skip_nested_handling_9:;
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_44___eq__(  );
    tmp_res = PyDict_SetItem( locals_DeltaCRLIndicator_413, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_45___ne__(  );
    tmp_res = PyDict_SetItem( locals_DeltaCRLIndicator_413, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_46___hash__(  );
    tmp_res = PyDict_SetItem( locals_DeltaCRLIndicator_413, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_47___repr__(  );
    tmp_res = PyDict_SetItem( locals_DeltaCRLIndicator_413, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_13 = locals_DeltaCRLIndicator_413;
    Py_INCREF( tmp_outline_return_value_13 );
    goto try_return_handler_35;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_35:;
    Py_DECREF( locals_DeltaCRLIndicator_413 );
    locals_DeltaCRLIndicator_413 = NULL;
    goto outline_result_13;
    // Exception handler code:
    try_except_handler_35:;
    exception_keeper_type_30 = exception_type;
    exception_keeper_value_30 = exception_value;
    exception_keeper_tb_30 = exception_tb;
    exception_keeper_lineno_30 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_DeltaCRLIndicator_413 );
    locals_DeltaCRLIndicator_413 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_30;
    exception_value = exception_keeper_value_30;
    exception_tb = exception_keeper_tb_30;
    exception_lineno = exception_keeper_lineno_30;

    goto outline_exception_9;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_9:;
    exception_lineno = 413;
    goto try_except_handler_34;
    outline_result_13:;
    tmp_assign_source_96 = tmp_outline_return_value_13;
    assert( tmp_class_creation_11__class_dict == NULL );
    tmp_class_creation_11__class_dict = tmp_assign_source_96;

    tmp_compare_left_11 = const_str_plain___metaclass__;
    tmp_compare_right_11 = tmp_class_creation_11__class_dict;

    CHECK_OBJECT( tmp_compare_right_11 );
    tmp_cmp_In_11 = PySequence_Contains( tmp_compare_right_11, tmp_compare_left_11 );
    assert( !(tmp_cmp_In_11 == -1) );
    if ( tmp_cmp_In_11 == 1 )
    {
        goto condexpr_true_11;
    }
    else
    {
        goto condexpr_false_11;
    }
    condexpr_true_11:;
    tmp_dict_name_11 = tmp_class_creation_11__class_dict;

    CHECK_OBJECT( tmp_dict_name_11 );
    tmp_key_name_11 = const_str_plain___metaclass__;
    tmp_assign_source_97 = DICT_GET_ITEM( tmp_dict_name_11, tmp_key_name_11 );
    if ( tmp_assign_source_97 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 413;

        goto try_except_handler_34;
    }
    goto condexpr_end_11;
    condexpr_false_11:;
    tmp_assign_source_97 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_97 );
    condexpr_end_11:;
    assert( tmp_class_creation_11__metaclass == NULL );
    tmp_class_creation_11__metaclass = tmp_assign_source_97;

    tmp_called_name_25 = tmp_class_creation_11__metaclass;

    CHECK_OBJECT( tmp_called_name_25 );
    tmp_args_element_name_44 = const_str_plain_DeltaCRLIndicator;
    tmp_args_element_name_45 = const_tuple_type_object_tuple;
    tmp_args_element_name_46 = tmp_class_creation_11__class_dict;

    CHECK_OBJECT( tmp_args_element_name_46 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 413;
    {
        PyObject *call_args[] = { tmp_args_element_name_44, tmp_args_element_name_45, tmp_args_element_name_46 };
        tmp_assign_source_98 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_25, call_args );
    }

    if ( tmp_assign_source_98 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 413;

        goto try_except_handler_34;
    }
    assert( tmp_class_creation_11__class == NULL );
    tmp_class_creation_11__class = tmp_assign_source_98;

    tmp_source_name_16 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_16 == NULL ))
    {
        tmp_source_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 412;

        goto try_except_handler_34;
    }

    tmp_called_name_27 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_register_interface );
    if ( tmp_called_name_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 412;

        goto try_except_handler_34;
    }
    tmp_args_element_name_47 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_47 == NULL ))
    {
        tmp_args_element_name_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_47 == NULL )
    {
        Py_DECREF( tmp_called_name_27 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 412;

        goto try_except_handler_34;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 412;
    {
        PyObject *call_args[] = { tmp_args_element_name_47 };
        tmp_called_name_26 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_27, call_args );
    }

    Py_DECREF( tmp_called_name_27 );
    if ( tmp_called_name_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 412;

        goto try_except_handler_34;
    }
    tmp_args_element_name_48 = tmp_class_creation_11__class;

    CHECK_OBJECT( tmp_args_element_name_48 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 412;
    {
        PyObject *call_args[] = { tmp_args_element_name_48 };
        tmp_assign_source_99 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_26, call_args );
    }

    Py_DECREF( tmp_called_name_26 );
    if ( tmp_assign_source_99 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 412;

        goto try_except_handler_34;
    }
    {
        PyObject *old = tmp_class_creation_11__class;
        assert( old != NULL );
        tmp_class_creation_11__class = tmp_assign_source_99;
        Py_DECREF( old );
    }

    goto try_end_20;
    // Exception handler code:
    try_except_handler_34:;
    exception_keeper_type_31 = exception_type;
    exception_keeper_value_31 = exception_value;
    exception_keeper_tb_31 = exception_tb;
    exception_keeper_lineno_31 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_11__class );
    tmp_class_creation_11__class = NULL;

    Py_XDECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_31;
    exception_value = exception_keeper_value_31;
    exception_tb = exception_keeper_tb_31;
    exception_lineno = exception_keeper_lineno_31;

    goto frame_exception_exit_1;
    // End of try:
    try_end_20:;
    tmp_assign_source_100 = tmp_class_creation_11__class;

    CHECK_OBJECT( tmp_assign_source_100 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DeltaCRLIndicator, tmp_assign_source_100 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class );
    Py_DECREF( tmp_class_creation_11__class );
    tmp_class_creation_11__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class_dict );
    Py_DECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__metaclass );
    Py_DECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_CRLDistributionPoints_441 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_CRLDistributionPoints_441, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11, codeobj_46d9b8cdfe49abc480fe0ac59bfd4d0e, module_cryptography$x509$extensions, 0 );
    frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11 = cache_frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_17 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_17 == NULL ))
    {
        tmp_source_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 442;

        goto frame_exception_exit_11;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_CRL_DISTRIBUTION_POINTS );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 442;

        goto frame_exception_exit_11;
    }
    tmp_res = PyDict_SetItem( locals_CRLDistributionPoints_441, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 442;

        goto frame_exception_exit_11;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_48___init__(  );
    tmp_res = PyDict_SetItem( locals_CRLDistributionPoints_441, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_called_name_28 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );

    if (unlikely( tmp_called_name_28 == NULL ))
    {
        tmp_called_name_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );
    }

    if ( tmp_called_name_28 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_sequence_methods" );
        exception_tb = NULL;

        exception_lineno = 456;

        goto try_except_handler_38;
    }

    frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11->m_frame.f_lineno = 456;
    tmp_iter_arg_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_28, &PyTuple_GET_ITEM( const_tuple_str_plain__distribution_points_tuple, 0 ) );

    if ( tmp_iter_arg_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 456;

        goto try_except_handler_38;
    }
    tmp_assign_source_102 = MAKE_ITERATOR( tmp_iter_arg_3 );
    Py_DECREF( tmp_iter_arg_3 );
    if ( tmp_assign_source_102 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 456;

        goto try_except_handler_38;
    }
    assert( tmp_CRLDistributionPoints$tuple_unpack_1__source_iter == NULL );
    tmp_CRLDistributionPoints$tuple_unpack_1__source_iter = tmp_assign_source_102;

    // Tried code:
    tmp_unpack_7 = tmp_CRLDistributionPoints$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_7 );
    tmp_assign_source_103 = UNPACK_NEXT( tmp_unpack_7, 0 );
    if ( tmp_assign_source_103 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 456;
        goto try_except_handler_39;
    }
    assert( tmp_CRLDistributionPoints$tuple_unpack_1__element_1 == NULL );
    tmp_CRLDistributionPoints$tuple_unpack_1__element_1 = tmp_assign_source_103;

    tmp_unpack_8 = tmp_CRLDistributionPoints$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_8 );
    tmp_assign_source_104 = UNPACK_NEXT( tmp_unpack_8, 1 );
    if ( tmp_assign_source_104 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 456;
        goto try_except_handler_39;
    }
    assert( tmp_CRLDistributionPoints$tuple_unpack_1__element_2 == NULL );
    tmp_CRLDistributionPoints$tuple_unpack_1__element_2 = tmp_assign_source_104;

    tmp_unpack_9 = tmp_CRLDistributionPoints$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_9 );
    tmp_assign_source_105 = UNPACK_NEXT( tmp_unpack_9, 2 );
    if ( tmp_assign_source_105 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 456;
        goto try_except_handler_39;
    }
    assert( tmp_CRLDistributionPoints$tuple_unpack_1__element_3 == NULL );
    tmp_CRLDistributionPoints$tuple_unpack_1__element_3 = tmp_assign_source_105;

    tmp_iterator_name_3 = tmp_CRLDistributionPoints$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_3 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_3 ); assert( HAS_ITERNEXT( tmp_iterator_name_3 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_3 )->tp_iternext)( tmp_iterator_name_3 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 456;
                goto try_except_handler_39;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 456;
        goto try_except_handler_39;
    }
    goto try_end_21;
    // Exception handler code:
    try_except_handler_39:;
    exception_keeper_type_32 = exception_type;
    exception_keeper_value_32 = exception_value;
    exception_keeper_tb_32 = exception_tb;
    exception_keeper_lineno_32 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_CRLDistributionPoints$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_CRLDistributionPoints$tuple_unpack_1__source_iter );
    tmp_CRLDistributionPoints$tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_32;
    exception_value = exception_keeper_value_32;
    exception_tb = exception_keeper_tb_32;
    exception_lineno = exception_keeper_lineno_32;

    goto try_except_handler_38;
    // End of try:
    try_end_21:;
    goto try_end_22;
    // Exception handler code:
    try_except_handler_38:;
    exception_keeper_type_33 = exception_type;
    exception_keeper_value_33 = exception_value;
    exception_keeper_tb_33 = exception_tb;
    exception_keeper_lineno_33 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_CRLDistributionPoints$tuple_unpack_1__element_1 );
    tmp_CRLDistributionPoints$tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_CRLDistributionPoints$tuple_unpack_1__element_2 );
    tmp_CRLDistributionPoints$tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_CRLDistributionPoints$tuple_unpack_1__element_3 );
    tmp_CRLDistributionPoints$tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_33;
    exception_value = exception_keeper_value_33;
    exception_tb = exception_keeper_tb_33;
    exception_lineno = exception_keeper_lineno_33;

    goto frame_exception_exit_11;
    // End of try:
    try_end_22:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_10;

    frame_exception_exit_11:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11,
        type_description_2
    );


    // Release cached frame.
    if ( frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11 == cache_frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11 )
    {
        Py_DECREF( frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11 );
    }
    cache_frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11 = NULL;

    assertFrameObject( frame_46d9b8cdfe49abc480fe0ac59bfd4d0e_11 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_10;

    frame_no_exception_10:;

    goto skip_nested_handling_10;
    nested_frame_exit_10:;

    goto try_except_handler_37;
    skip_nested_handling_10:;
    CHECK_OBJECT( (PyObject *)tmp_CRLDistributionPoints$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_CRLDistributionPoints$tuple_unpack_1__source_iter );
    tmp_CRLDistributionPoints$tuple_unpack_1__source_iter = NULL;

    tmp_dictset_value = tmp_CRLDistributionPoints$tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_CRLDistributionPoints_441, const_str_plain___len__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_CRLDistributionPoints$tuple_unpack_1__element_1 );
    tmp_CRLDistributionPoints$tuple_unpack_1__element_1 = NULL;

    tmp_dictset_value = tmp_CRLDistributionPoints$tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_CRLDistributionPoints_441, const_str_plain___iter__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_CRLDistributionPoints$tuple_unpack_1__element_2 );
    tmp_CRLDistributionPoints$tuple_unpack_1__element_2 = NULL;

    tmp_dictset_value = tmp_CRLDistributionPoints$tuple_unpack_1__element_3;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_CRLDistributionPoints_441, const_str_plain___getitem__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_CRLDistributionPoints$tuple_unpack_1__element_3 );
    tmp_CRLDistributionPoints$tuple_unpack_1__element_3 = NULL;

    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_49___repr__(  );
    tmp_res = PyDict_SetItem( locals_CRLDistributionPoints_441, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_50___eq__(  );
    tmp_res = PyDict_SetItem( locals_CRLDistributionPoints_441, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_51___ne__(  );
    tmp_res = PyDict_SetItem( locals_CRLDistributionPoints_441, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_52___hash__(  );
    tmp_res = PyDict_SetItem( locals_CRLDistributionPoints_441, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_14 = locals_CRLDistributionPoints_441;
    Py_INCREF( tmp_outline_return_value_14 );
    goto try_return_handler_37;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_37:;
    Py_DECREF( locals_CRLDistributionPoints_441 );
    locals_CRLDistributionPoints_441 = NULL;
    goto outline_result_14;
    // Exception handler code:
    try_except_handler_37:;
    exception_keeper_type_34 = exception_type;
    exception_keeper_value_34 = exception_value;
    exception_keeper_tb_34 = exception_tb;
    exception_keeper_lineno_34 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_CRLDistributionPoints_441 );
    locals_CRLDistributionPoints_441 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_34;
    exception_value = exception_keeper_value_34;
    exception_tb = exception_keeper_tb_34;
    exception_lineno = exception_keeper_lineno_34;

    goto outline_exception_10;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_10:;
    exception_lineno = 441;
    goto try_except_handler_36;
    outline_result_14:;
    tmp_assign_source_101 = tmp_outline_return_value_14;
    assert( tmp_class_creation_12__class_dict == NULL );
    tmp_class_creation_12__class_dict = tmp_assign_source_101;

    tmp_compare_left_12 = const_str_plain___metaclass__;
    tmp_compare_right_12 = tmp_class_creation_12__class_dict;

    CHECK_OBJECT( tmp_compare_right_12 );
    tmp_cmp_In_12 = PySequence_Contains( tmp_compare_right_12, tmp_compare_left_12 );
    assert( !(tmp_cmp_In_12 == -1) );
    if ( tmp_cmp_In_12 == 1 )
    {
        goto condexpr_true_12;
    }
    else
    {
        goto condexpr_false_12;
    }
    condexpr_true_12:;
    tmp_dict_name_12 = tmp_class_creation_12__class_dict;

    CHECK_OBJECT( tmp_dict_name_12 );
    tmp_key_name_12 = const_str_plain___metaclass__;
    tmp_assign_source_106 = DICT_GET_ITEM( tmp_dict_name_12, tmp_key_name_12 );
    if ( tmp_assign_source_106 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 441;

        goto try_except_handler_36;
    }
    goto condexpr_end_12;
    condexpr_false_12:;
    tmp_assign_source_106 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_106 );
    condexpr_end_12:;
    assert( tmp_class_creation_12__metaclass == NULL );
    tmp_class_creation_12__metaclass = tmp_assign_source_106;

    tmp_called_name_29 = tmp_class_creation_12__metaclass;

    CHECK_OBJECT( tmp_called_name_29 );
    tmp_args_element_name_49 = const_str_plain_CRLDistributionPoints;
    tmp_args_element_name_50 = const_tuple_type_object_tuple;
    tmp_args_element_name_51 = tmp_class_creation_12__class_dict;

    CHECK_OBJECT( tmp_args_element_name_51 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 441;
    {
        PyObject *call_args[] = { tmp_args_element_name_49, tmp_args_element_name_50, tmp_args_element_name_51 };
        tmp_assign_source_107 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_29, call_args );
    }

    if ( tmp_assign_source_107 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 441;

        goto try_except_handler_36;
    }
    assert( tmp_class_creation_12__class == NULL );
    tmp_class_creation_12__class = tmp_assign_source_107;

    tmp_source_name_18 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_18 == NULL ))
    {
        tmp_source_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 440;

        goto try_except_handler_36;
    }

    tmp_called_name_31 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_register_interface );
    if ( tmp_called_name_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 440;

        goto try_except_handler_36;
    }
    tmp_args_element_name_52 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_52 == NULL ))
    {
        tmp_args_element_name_52 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_52 == NULL )
    {
        Py_DECREF( tmp_called_name_31 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 440;

        goto try_except_handler_36;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 440;
    {
        PyObject *call_args[] = { tmp_args_element_name_52 };
        tmp_called_name_30 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_31, call_args );
    }

    Py_DECREF( tmp_called_name_31 );
    if ( tmp_called_name_30 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 440;

        goto try_except_handler_36;
    }
    tmp_args_element_name_53 = tmp_class_creation_12__class;

    CHECK_OBJECT( tmp_args_element_name_53 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 440;
    {
        PyObject *call_args[] = { tmp_args_element_name_53 };
        tmp_assign_source_108 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_30, call_args );
    }

    Py_DECREF( tmp_called_name_30 );
    if ( tmp_assign_source_108 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 440;

        goto try_except_handler_36;
    }
    {
        PyObject *old = tmp_class_creation_12__class;
        assert( old != NULL );
        tmp_class_creation_12__class = tmp_assign_source_108;
        Py_DECREF( old );
    }

    goto try_end_23;
    // Exception handler code:
    try_except_handler_36:;
    exception_keeper_type_35 = exception_type;
    exception_keeper_value_35 = exception_value;
    exception_keeper_tb_35 = exception_tb;
    exception_keeper_lineno_35 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_12__class );
    tmp_class_creation_12__class = NULL;

    Py_XDECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_35;
    exception_value = exception_keeper_value_35;
    exception_tb = exception_keeper_tb_35;
    exception_lineno = exception_keeper_lineno_35;

    goto frame_exception_exit_1;
    // End of try:
    try_end_23:;
    tmp_assign_source_109 = tmp_class_creation_12__class;

    CHECK_OBJECT( tmp_assign_source_109 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLDistributionPoints, tmp_assign_source_109 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class );
    Py_DECREF( tmp_class_creation_12__class );
    tmp_class_creation_12__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class_dict );
    Py_DECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__metaclass );
    Py_DECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_FreshestCRL_477 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_FreshestCRL_477, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dce89ec5d6ba48c58dbdd43f0b34646a_12, codeobj_dce89ec5d6ba48c58dbdd43f0b34646a, module_cryptography$x509$extensions, 0 );
    frame_dce89ec5d6ba48c58dbdd43f0b34646a_12 = cache_frame_dce89ec5d6ba48c58dbdd43f0b34646a_12;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dce89ec5d6ba48c58dbdd43f0b34646a_12 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dce89ec5d6ba48c58dbdd43f0b34646a_12 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_19 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_19 == NULL ))
    {
        tmp_source_name_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_19 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 478;

        goto frame_exception_exit_12;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_FRESHEST_CRL );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 478;

        goto frame_exception_exit_12;
    }
    tmp_res = PyDict_SetItem( locals_FreshestCRL_477, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 478;

        goto frame_exception_exit_12;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_53___init__(  );
    tmp_res = PyDict_SetItem( locals_FreshestCRL_477, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_called_name_32 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );

    if (unlikely( tmp_called_name_32 == NULL ))
    {
        tmp_called_name_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );
    }

    if ( tmp_called_name_32 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_sequence_methods" );
        exception_tb = NULL;

        exception_lineno = 492;

        goto try_except_handler_42;
    }

    frame_dce89ec5d6ba48c58dbdd43f0b34646a_12->m_frame.f_lineno = 492;
    tmp_iter_arg_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_32, &PyTuple_GET_ITEM( const_tuple_str_plain__distribution_points_tuple, 0 ) );

    if ( tmp_iter_arg_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 492;

        goto try_except_handler_42;
    }
    tmp_assign_source_111 = MAKE_ITERATOR( tmp_iter_arg_4 );
    Py_DECREF( tmp_iter_arg_4 );
    if ( tmp_assign_source_111 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 492;

        goto try_except_handler_42;
    }
    assert( tmp_FreshestCRL$tuple_unpack_1__source_iter == NULL );
    tmp_FreshestCRL$tuple_unpack_1__source_iter = tmp_assign_source_111;

    // Tried code:
    tmp_unpack_10 = tmp_FreshestCRL$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_10 );
    tmp_assign_source_112 = UNPACK_NEXT( tmp_unpack_10, 0 );
    if ( tmp_assign_source_112 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 492;
        goto try_except_handler_43;
    }
    assert( tmp_FreshestCRL$tuple_unpack_1__element_1 == NULL );
    tmp_FreshestCRL$tuple_unpack_1__element_1 = tmp_assign_source_112;

    tmp_unpack_11 = tmp_FreshestCRL$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_11 );
    tmp_assign_source_113 = UNPACK_NEXT( tmp_unpack_11, 1 );
    if ( tmp_assign_source_113 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 492;
        goto try_except_handler_43;
    }
    assert( tmp_FreshestCRL$tuple_unpack_1__element_2 == NULL );
    tmp_FreshestCRL$tuple_unpack_1__element_2 = tmp_assign_source_113;

    tmp_unpack_12 = tmp_FreshestCRL$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_12 );
    tmp_assign_source_114 = UNPACK_NEXT( tmp_unpack_12, 2 );
    if ( tmp_assign_source_114 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 492;
        goto try_except_handler_43;
    }
    assert( tmp_FreshestCRL$tuple_unpack_1__element_3 == NULL );
    tmp_FreshestCRL$tuple_unpack_1__element_3 = tmp_assign_source_114;

    tmp_iterator_name_4 = tmp_FreshestCRL$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_4 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_4 ); assert( HAS_ITERNEXT( tmp_iterator_name_4 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_4 )->tp_iternext)( tmp_iterator_name_4 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 492;
                goto try_except_handler_43;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 492;
        goto try_except_handler_43;
    }
    goto try_end_24;
    // Exception handler code:
    try_except_handler_43:;
    exception_keeper_type_36 = exception_type;
    exception_keeper_value_36 = exception_value;
    exception_keeper_tb_36 = exception_tb;
    exception_keeper_lineno_36 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_FreshestCRL$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_FreshestCRL$tuple_unpack_1__source_iter );
    tmp_FreshestCRL$tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_36;
    exception_value = exception_keeper_value_36;
    exception_tb = exception_keeper_tb_36;
    exception_lineno = exception_keeper_lineno_36;

    goto try_except_handler_42;
    // End of try:
    try_end_24:;
    goto try_end_25;
    // Exception handler code:
    try_except_handler_42:;
    exception_keeper_type_37 = exception_type;
    exception_keeper_value_37 = exception_value;
    exception_keeper_tb_37 = exception_tb;
    exception_keeper_lineno_37 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_FreshestCRL$tuple_unpack_1__element_1 );
    tmp_FreshestCRL$tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_FreshestCRL$tuple_unpack_1__element_2 );
    tmp_FreshestCRL$tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_FreshestCRL$tuple_unpack_1__element_3 );
    tmp_FreshestCRL$tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_37;
    exception_value = exception_keeper_value_37;
    exception_tb = exception_keeper_tb_37;
    exception_lineno = exception_keeper_lineno_37;

    goto frame_exception_exit_12;
    // End of try:
    try_end_25:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dce89ec5d6ba48c58dbdd43f0b34646a_12 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_11;

    frame_exception_exit_12:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dce89ec5d6ba48c58dbdd43f0b34646a_12 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dce89ec5d6ba48c58dbdd43f0b34646a_12, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dce89ec5d6ba48c58dbdd43f0b34646a_12->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dce89ec5d6ba48c58dbdd43f0b34646a_12, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dce89ec5d6ba48c58dbdd43f0b34646a_12,
        type_description_2
    );


    // Release cached frame.
    if ( frame_dce89ec5d6ba48c58dbdd43f0b34646a_12 == cache_frame_dce89ec5d6ba48c58dbdd43f0b34646a_12 )
    {
        Py_DECREF( frame_dce89ec5d6ba48c58dbdd43f0b34646a_12 );
    }
    cache_frame_dce89ec5d6ba48c58dbdd43f0b34646a_12 = NULL;

    assertFrameObject( frame_dce89ec5d6ba48c58dbdd43f0b34646a_12 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_11;

    frame_no_exception_11:;

    goto skip_nested_handling_11;
    nested_frame_exit_11:;

    goto try_except_handler_41;
    skip_nested_handling_11:;
    CHECK_OBJECT( (PyObject *)tmp_FreshestCRL$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_FreshestCRL$tuple_unpack_1__source_iter );
    tmp_FreshestCRL$tuple_unpack_1__source_iter = NULL;

    tmp_dictset_value = tmp_FreshestCRL$tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_FreshestCRL_477, const_str_plain___len__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_FreshestCRL$tuple_unpack_1__element_1 );
    tmp_FreshestCRL$tuple_unpack_1__element_1 = NULL;

    tmp_dictset_value = tmp_FreshestCRL$tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_FreshestCRL_477, const_str_plain___iter__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_FreshestCRL$tuple_unpack_1__element_2 );
    tmp_FreshestCRL$tuple_unpack_1__element_2 = NULL;

    tmp_dictset_value = tmp_FreshestCRL$tuple_unpack_1__element_3;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_FreshestCRL_477, const_str_plain___getitem__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_FreshestCRL$tuple_unpack_1__element_3 );
    tmp_FreshestCRL$tuple_unpack_1__element_3 = NULL;

    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_54___repr__(  );
    tmp_res = PyDict_SetItem( locals_FreshestCRL_477, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_55___eq__(  );
    tmp_res = PyDict_SetItem( locals_FreshestCRL_477, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_56___ne__(  );
    tmp_res = PyDict_SetItem( locals_FreshestCRL_477, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_57___hash__(  );
    tmp_res = PyDict_SetItem( locals_FreshestCRL_477, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_15 = locals_FreshestCRL_477;
    Py_INCREF( tmp_outline_return_value_15 );
    goto try_return_handler_41;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_41:;
    Py_DECREF( locals_FreshestCRL_477 );
    locals_FreshestCRL_477 = NULL;
    goto outline_result_15;
    // Exception handler code:
    try_except_handler_41:;
    exception_keeper_type_38 = exception_type;
    exception_keeper_value_38 = exception_value;
    exception_keeper_tb_38 = exception_tb;
    exception_keeper_lineno_38 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_FreshestCRL_477 );
    locals_FreshestCRL_477 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_38;
    exception_value = exception_keeper_value_38;
    exception_tb = exception_keeper_tb_38;
    exception_lineno = exception_keeper_lineno_38;

    goto outline_exception_11;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_11:;
    exception_lineno = 477;
    goto try_except_handler_40;
    outline_result_15:;
    tmp_assign_source_110 = tmp_outline_return_value_15;
    assert( tmp_class_creation_13__class_dict == NULL );
    tmp_class_creation_13__class_dict = tmp_assign_source_110;

    tmp_compare_left_13 = const_str_plain___metaclass__;
    tmp_compare_right_13 = tmp_class_creation_13__class_dict;

    CHECK_OBJECT( tmp_compare_right_13 );
    tmp_cmp_In_13 = PySequence_Contains( tmp_compare_right_13, tmp_compare_left_13 );
    assert( !(tmp_cmp_In_13 == -1) );
    if ( tmp_cmp_In_13 == 1 )
    {
        goto condexpr_true_13;
    }
    else
    {
        goto condexpr_false_13;
    }
    condexpr_true_13:;
    tmp_dict_name_13 = tmp_class_creation_13__class_dict;

    CHECK_OBJECT( tmp_dict_name_13 );
    tmp_key_name_13 = const_str_plain___metaclass__;
    tmp_assign_source_115 = DICT_GET_ITEM( tmp_dict_name_13, tmp_key_name_13 );
    if ( tmp_assign_source_115 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 477;

        goto try_except_handler_40;
    }
    goto condexpr_end_13;
    condexpr_false_13:;
    tmp_assign_source_115 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_115 );
    condexpr_end_13:;
    assert( tmp_class_creation_13__metaclass == NULL );
    tmp_class_creation_13__metaclass = tmp_assign_source_115;

    tmp_called_name_33 = tmp_class_creation_13__metaclass;

    CHECK_OBJECT( tmp_called_name_33 );
    tmp_args_element_name_54 = const_str_plain_FreshestCRL;
    tmp_args_element_name_55 = const_tuple_type_object_tuple;
    tmp_args_element_name_56 = tmp_class_creation_13__class_dict;

    CHECK_OBJECT( tmp_args_element_name_56 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 477;
    {
        PyObject *call_args[] = { tmp_args_element_name_54, tmp_args_element_name_55, tmp_args_element_name_56 };
        tmp_assign_source_116 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_33, call_args );
    }

    if ( tmp_assign_source_116 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 477;

        goto try_except_handler_40;
    }
    assert( tmp_class_creation_13__class == NULL );
    tmp_class_creation_13__class = tmp_assign_source_116;

    tmp_source_name_20 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_20 == NULL ))
    {
        tmp_source_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_20 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 476;

        goto try_except_handler_40;
    }

    tmp_called_name_35 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_register_interface );
    if ( tmp_called_name_35 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 476;

        goto try_except_handler_40;
    }
    tmp_args_element_name_57 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_57 == NULL ))
    {
        tmp_args_element_name_57 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_57 == NULL )
    {
        Py_DECREF( tmp_called_name_35 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 476;

        goto try_except_handler_40;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 476;
    {
        PyObject *call_args[] = { tmp_args_element_name_57 };
        tmp_called_name_34 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_35, call_args );
    }

    Py_DECREF( tmp_called_name_35 );
    if ( tmp_called_name_34 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 476;

        goto try_except_handler_40;
    }
    tmp_args_element_name_58 = tmp_class_creation_13__class;

    CHECK_OBJECT( tmp_args_element_name_58 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 476;
    {
        PyObject *call_args[] = { tmp_args_element_name_58 };
        tmp_assign_source_117 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_34, call_args );
    }

    Py_DECREF( tmp_called_name_34 );
    if ( tmp_assign_source_117 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 476;

        goto try_except_handler_40;
    }
    {
        PyObject *old = tmp_class_creation_13__class;
        assert( old != NULL );
        tmp_class_creation_13__class = tmp_assign_source_117;
        Py_DECREF( old );
    }

    goto try_end_26;
    // Exception handler code:
    try_except_handler_40:;
    exception_keeper_type_39 = exception_type;
    exception_keeper_value_39 = exception_value;
    exception_keeper_tb_39 = exception_tb;
    exception_keeper_lineno_39 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_13__class );
    tmp_class_creation_13__class = NULL;

    Py_XDECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_39;
    exception_value = exception_keeper_value_39;
    exception_tb = exception_keeper_tb_39;
    exception_lineno = exception_keeper_lineno_39;

    goto frame_exception_exit_1;
    // End of try:
    try_end_26:;
    tmp_assign_source_118 = tmp_class_creation_13__class;

    CHECK_OBJECT( tmp_assign_source_118 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_FreshestCRL, tmp_assign_source_118 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class );
    Py_DECREF( tmp_class_creation_13__class );
    tmp_class_creation_13__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class_dict );
    Py_DECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__metaclass );
    Py_DECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_DistributionPoint_512 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_DistributionPoint_512, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_58___init__(  );
    tmp_res = PyDict_SetItem( locals_DistributionPoint_512, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_59___repr__(  );
    tmp_res = PyDict_SetItem( locals_DistributionPoint_512, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_60___eq__(  );
    tmp_res = PyDict_SetItem( locals_DistributionPoint_512, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_61___ne__(  );
    tmp_res = PyDict_SetItem( locals_DistributionPoint_512, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_62___hash__(  );
    tmp_res = PyDict_SetItem( locals_DistributionPoint_512, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_712d92b931f86762fe66868302371b42_13, codeobj_712d92b931f86762fe66868302371b42, module_cryptography$x509$extensions, 0 );
    frame_712d92b931f86762fe66868302371b42_13 = cache_frame_712d92b931f86762fe66868302371b42_13;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_712d92b931f86762fe66868302371b42_13 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_712d92b931f86762fe66868302371b42_13 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_12 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_12 == NULL ))
    {
        tmp_called_instance_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 599;

        goto frame_exception_exit_13;
    }

    frame_712d92b931f86762fe66868302371b42_13->m_frame.f_lineno = 599;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_12, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__full_name_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 599;

        goto frame_exception_exit_13;
    }
    tmp_res = PyDict_SetItem( locals_DistributionPoint_512, const_str_plain_full_name, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 599;

        goto frame_exception_exit_13;
    }
    tmp_called_instance_13 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_13 == NULL ))
    {
        tmp_called_instance_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_13 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 600;

        goto frame_exception_exit_13;
    }

    frame_712d92b931f86762fe66868302371b42_13->m_frame.f_lineno = 600;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_13, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__relative_name_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 600;

        goto frame_exception_exit_13;
    }
    tmp_res = PyDict_SetItem( locals_DistributionPoint_512, const_str_plain_relative_name, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 600;

        goto frame_exception_exit_13;
    }
    tmp_called_instance_14 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_14 == NULL ))
    {
        tmp_called_instance_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 601;

        goto frame_exception_exit_13;
    }

    frame_712d92b931f86762fe66868302371b42_13->m_frame.f_lineno = 601;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_14, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__reasons_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 601;

        goto frame_exception_exit_13;
    }
    tmp_res = PyDict_SetItem( locals_DistributionPoint_512, const_str_plain_reasons, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 601;

        goto frame_exception_exit_13;
    }
    tmp_called_instance_15 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_15 == NULL ))
    {
        tmp_called_instance_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 602;

        goto frame_exception_exit_13;
    }

    frame_712d92b931f86762fe66868302371b42_13->m_frame.f_lineno = 602;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_15, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__crl_issuer_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 602;

        goto frame_exception_exit_13;
    }
    tmp_res = PyDict_SetItem( locals_DistributionPoint_512, const_str_plain_crl_issuer, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 602;

        goto frame_exception_exit_13;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_712d92b931f86762fe66868302371b42_13 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_12;

    frame_exception_exit_13:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_712d92b931f86762fe66868302371b42_13 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_712d92b931f86762fe66868302371b42_13, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_712d92b931f86762fe66868302371b42_13->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_712d92b931f86762fe66868302371b42_13, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_712d92b931f86762fe66868302371b42_13,
        type_description_2
    );


    // Release cached frame.
    if ( frame_712d92b931f86762fe66868302371b42_13 == cache_frame_712d92b931f86762fe66868302371b42_13 )
    {
        Py_DECREF( frame_712d92b931f86762fe66868302371b42_13 );
    }
    cache_frame_712d92b931f86762fe66868302371b42_13 = NULL;

    assertFrameObject( frame_712d92b931f86762fe66868302371b42_13 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_12;

    frame_no_exception_12:;

    goto skip_nested_handling_12;
    nested_frame_exit_12:;

    goto try_except_handler_45;
    skip_nested_handling_12:;
    tmp_outline_return_value_16 = locals_DistributionPoint_512;
    Py_INCREF( tmp_outline_return_value_16 );
    goto try_return_handler_45;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_45:;
    Py_DECREF( locals_DistributionPoint_512 );
    locals_DistributionPoint_512 = NULL;
    goto outline_result_16;
    // Exception handler code:
    try_except_handler_45:;
    exception_keeper_type_40 = exception_type;
    exception_keeper_value_40 = exception_value;
    exception_keeper_tb_40 = exception_tb;
    exception_keeper_lineno_40 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_DistributionPoint_512 );
    locals_DistributionPoint_512 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_40;
    exception_value = exception_keeper_value_40;
    exception_tb = exception_keeper_tb_40;
    exception_lineno = exception_keeper_lineno_40;

    goto outline_exception_12;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_12:;
    exception_lineno = 512;
    goto try_except_handler_44;
    outline_result_16:;
    tmp_assign_source_119 = tmp_outline_return_value_16;
    assert( tmp_class_creation_14__class_dict == NULL );
    tmp_class_creation_14__class_dict = tmp_assign_source_119;

    tmp_compare_left_14 = const_str_plain___metaclass__;
    tmp_compare_right_14 = tmp_class_creation_14__class_dict;

    CHECK_OBJECT( tmp_compare_right_14 );
    tmp_cmp_In_14 = PySequence_Contains( tmp_compare_right_14, tmp_compare_left_14 );
    assert( !(tmp_cmp_In_14 == -1) );
    if ( tmp_cmp_In_14 == 1 )
    {
        goto condexpr_true_14;
    }
    else
    {
        goto condexpr_false_14;
    }
    condexpr_true_14:;
    tmp_dict_name_14 = tmp_class_creation_14__class_dict;

    CHECK_OBJECT( tmp_dict_name_14 );
    tmp_key_name_14 = const_str_plain___metaclass__;
    tmp_assign_source_120 = DICT_GET_ITEM( tmp_dict_name_14, tmp_key_name_14 );
    if ( tmp_assign_source_120 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 512;

        goto try_except_handler_44;
    }
    goto condexpr_end_14;
    condexpr_false_14:;
    tmp_assign_source_120 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_120 );
    condexpr_end_14:;
    assert( tmp_class_creation_14__metaclass == NULL );
    tmp_class_creation_14__metaclass = tmp_assign_source_120;

    tmp_called_name_36 = tmp_class_creation_14__metaclass;

    CHECK_OBJECT( tmp_called_name_36 );
    tmp_args_element_name_59 = const_str_plain_DistributionPoint;
    tmp_args_element_name_60 = const_tuple_type_object_tuple;
    tmp_args_element_name_61 = tmp_class_creation_14__class_dict;

    CHECK_OBJECT( tmp_args_element_name_61 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 512;
    {
        PyObject *call_args[] = { tmp_args_element_name_59, tmp_args_element_name_60, tmp_args_element_name_61 };
        tmp_assign_source_121 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_36, call_args );
    }

    if ( tmp_assign_source_121 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 512;

        goto try_except_handler_44;
    }
    assert( tmp_class_creation_14__class == NULL );
    tmp_class_creation_14__class = tmp_assign_source_121;

    goto try_end_27;
    // Exception handler code:
    try_except_handler_44:;
    exception_keeper_type_41 = exception_type;
    exception_keeper_value_41 = exception_value;
    exception_keeper_tb_41 = exception_tb;
    exception_keeper_lineno_41 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_41;
    exception_value = exception_keeper_value_41;
    exception_tb = exception_keeper_tb_41;
    exception_lineno = exception_keeper_lineno_41;

    goto frame_exception_exit_1;
    // End of try:
    try_end_27:;
    tmp_assign_source_122 = tmp_class_creation_14__class;

    CHECK_OBJECT( tmp_assign_source_122 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DistributionPoint, tmp_assign_source_122 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class );
    Py_DECREF( tmp_class_creation_14__class );
    tmp_class_creation_14__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class_dict );
    Py_DECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__metaclass );
    Py_DECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    // Tried code:
    tmp_assign_source_123 = PyTuple_New( 1 );
    tmp_tuple_element_3 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_Enum );

    if (unlikely( tmp_tuple_element_3 == NULL ))
    {
        tmp_tuple_element_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Enum );
    }

    if ( tmp_tuple_element_3 == NULL )
    {
        Py_DECREF( tmp_assign_source_123 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Enum" );
        exception_tb = NULL;

        exception_lineno = 605;

        goto try_except_handler_46;
    }

    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_assign_source_123, 0, tmp_tuple_element_3 );
    assert( tmp_class_creation_15__bases == NULL );
    tmp_class_creation_15__bases = tmp_assign_source_123;

    tmp_set_locals = PyDict_New();
    locals_ReasonFlags_605 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_ReasonFlags_605, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_plain_unspecified;
    tmp_res = PyDict_SetItem( locals_ReasonFlags_605, const_str_plain_unspecified, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_plain_keyCompromise;
    tmp_res = PyDict_SetItem( locals_ReasonFlags_605, const_str_plain_key_compromise, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_plain_cACompromise;
    tmp_res = PyDict_SetItem( locals_ReasonFlags_605, const_str_plain_ca_compromise, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_plain_affiliationChanged;
    tmp_res = PyDict_SetItem( locals_ReasonFlags_605, const_str_plain_affiliation_changed, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_plain_superseded;
    tmp_res = PyDict_SetItem( locals_ReasonFlags_605, const_str_plain_superseded, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_plain_cessationOfOperation;
    tmp_res = PyDict_SetItem( locals_ReasonFlags_605, const_str_plain_cessation_of_operation, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_plain_certificateHold;
    tmp_res = PyDict_SetItem( locals_ReasonFlags_605, const_str_plain_certificate_hold, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_plain_privilegeWithdrawn;
    tmp_res = PyDict_SetItem( locals_ReasonFlags_605, const_str_plain_privilege_withdrawn, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_plain_aACompromise;
    tmp_res = PyDict_SetItem( locals_ReasonFlags_605, const_str_plain_aa_compromise, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_plain_removeFromCRL;
    tmp_res = PyDict_SetItem( locals_ReasonFlags_605, const_str_plain_remove_from_crl, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_17 = locals_ReasonFlags_605;
    Py_INCREF( tmp_outline_return_value_17 );
    goto try_return_handler_47;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_47:;
    Py_DECREF( locals_ReasonFlags_605 );
    locals_ReasonFlags_605 = NULL;
    goto outline_result_17;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_result_17:;
    tmp_assign_source_124 = tmp_outline_return_value_17;
    assert( tmp_class_creation_15__class_dict == NULL );
    tmp_class_creation_15__class_dict = tmp_assign_source_124;

    tmp_compare_left_15 = const_str_plain___metaclass__;
    tmp_compare_right_15 = tmp_class_creation_15__class_dict;

    CHECK_OBJECT( tmp_compare_right_15 );
    tmp_cmp_In_15 = PySequence_Contains( tmp_compare_right_15, tmp_compare_left_15 );
    assert( !(tmp_cmp_In_15 == -1) );
    if ( tmp_cmp_In_15 == 1 )
    {
        goto condexpr_true_15;
    }
    else
    {
        goto condexpr_false_15;
    }
    condexpr_true_15:;
    tmp_dict_name_15 = tmp_class_creation_15__class_dict;

    CHECK_OBJECT( tmp_dict_name_15 );
    tmp_key_name_15 = const_str_plain___metaclass__;
    tmp_assign_source_125 = DICT_GET_ITEM( tmp_dict_name_15, tmp_key_name_15 );
    if ( tmp_assign_source_125 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 605;

        goto try_except_handler_46;
    }
    goto condexpr_end_15;
    condexpr_false_15:;
    tmp_subscribed_name_3 = tmp_class_creation_15__bases;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_0;
    tmp_assign_source_126 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_assign_source_126 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 605;

        goto try_except_handler_46;
    }
    assert( tmp_select_metaclass_15__base == NULL );
    tmp_select_metaclass_15__base = tmp_assign_source_126;

    // Tried code:
    // Tried code:
    tmp_source_name_21 = tmp_select_metaclass_15__base;

    CHECK_OBJECT( tmp_source_name_21 );
    tmp_outline_return_value_18 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_21 );
    if ( tmp_outline_return_value_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 605;

        goto try_except_handler_49;
    }
    goto try_return_handler_48;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_49:;
    exception_keeper_type_42 = exception_type;
    exception_keeper_value_42 = exception_value;
    exception_keeper_tb_42 = exception_tb;
    exception_keeper_lineno_42 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_42 );
    Py_XDECREF( exception_keeper_value_42 );
    Py_XDECREF( exception_keeper_tb_42 );
    tmp_type_arg_3 = tmp_select_metaclass_15__base;

    CHECK_OBJECT( tmp_type_arg_3 );
    tmp_outline_return_value_18 = BUILTIN_TYPE1( tmp_type_arg_3 );
    assert( tmp_outline_return_value_18 != NULL );
    goto try_return_handler_48;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_48:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_15__base );
    Py_DECREF( tmp_select_metaclass_15__base );
    tmp_select_metaclass_15__base = NULL;

    goto outline_result_18;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_15__base );
    Py_DECREF( tmp_select_metaclass_15__base );
    tmp_select_metaclass_15__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_result_18:;
    tmp_assign_source_125 = tmp_outline_return_value_18;
    condexpr_end_15:;
    assert( tmp_class_creation_15__metaclass == NULL );
    tmp_class_creation_15__metaclass = tmp_assign_source_125;

    tmp_called_name_37 = tmp_class_creation_15__metaclass;

    CHECK_OBJECT( tmp_called_name_37 );
    tmp_args_element_name_62 = const_str_plain_ReasonFlags;
    tmp_args_element_name_63 = tmp_class_creation_15__bases;

    CHECK_OBJECT( tmp_args_element_name_63 );
    tmp_args_element_name_64 = tmp_class_creation_15__class_dict;

    CHECK_OBJECT( tmp_args_element_name_64 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 605;
    {
        PyObject *call_args[] = { tmp_args_element_name_62, tmp_args_element_name_63, tmp_args_element_name_64 };
        tmp_assign_source_127 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_37, call_args );
    }

    if ( tmp_assign_source_127 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 605;

        goto try_except_handler_46;
    }
    assert( tmp_class_creation_15__class == NULL );
    tmp_class_creation_15__class = tmp_assign_source_127;

    goto try_end_28;
    // Exception handler code:
    try_except_handler_46:;
    exception_keeper_type_43 = exception_type;
    exception_keeper_value_43 = exception_value;
    exception_keeper_tb_43 = exception_tb;
    exception_keeper_lineno_43 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_15__bases );
    tmp_class_creation_15__bases = NULL;

    Py_XDECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_43;
    exception_value = exception_keeper_value_43;
    exception_tb = exception_keeper_tb_43;
    exception_lineno = exception_keeper_lineno_43;

    goto frame_exception_exit_1;
    // End of try:
    try_end_28:;
    tmp_assign_source_128 = tmp_class_creation_15__class;

    CHECK_OBJECT( tmp_assign_source_128 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags, tmp_assign_source_128 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class );
    Py_DECREF( tmp_class_creation_15__class );
    tmp_class_creation_15__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__bases );
    Py_DECREF( tmp_class_creation_15__bases );
    tmp_class_creation_15__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class_dict );
    Py_DECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__metaclass );
    Py_DECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_PolicyConstraints_619 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_PolicyConstraints_619, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_465314d58281e7cbbb03e4f8c9567305_14, codeobj_465314d58281e7cbbb03e4f8c9567305, module_cryptography$x509$extensions, 0 );
    frame_465314d58281e7cbbb03e4f8c9567305_14 = cache_frame_465314d58281e7cbbb03e4f8c9567305_14;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_465314d58281e7cbbb03e4f8c9567305_14 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_465314d58281e7cbbb03e4f8c9567305_14 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_22 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_22 == NULL ))
    {
        tmp_source_name_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_22 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 620;

        goto frame_exception_exit_14;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain_POLICY_CONSTRAINTS );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 620;

        goto frame_exception_exit_14;
    }
    tmp_res = PyDict_SetItem( locals_PolicyConstraints_619, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 620;

        goto frame_exception_exit_14;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_63___init__(  );
    tmp_res = PyDict_SetItem( locals_PolicyConstraints_619, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_64___repr__(  );
    tmp_res = PyDict_SetItem( locals_PolicyConstraints_619, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_65___eq__(  );
    tmp_res = PyDict_SetItem( locals_PolicyConstraints_619, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_66___ne__(  );
    tmp_res = PyDict_SetItem( locals_PolicyConstraints_619, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_67___hash__(  );
    tmp_res = PyDict_SetItem( locals_PolicyConstraints_619, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_instance_16 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_16 == NULL ))
    {
        tmp_called_instance_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 671;

        goto frame_exception_exit_14;
    }

    frame_465314d58281e7cbbb03e4f8c9567305_14->m_frame.f_lineno = 671;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_16, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__require_explicit_policy_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 671;

        goto frame_exception_exit_14;
    }
    tmp_res = PyDict_SetItem( locals_PolicyConstraints_619, const_str_plain_require_explicit_policy, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 671;

        goto frame_exception_exit_14;
    }
    tmp_called_instance_17 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_17 == NULL ))
    {
        tmp_called_instance_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 674;

        goto frame_exception_exit_14;
    }

    frame_465314d58281e7cbbb03e4f8c9567305_14->m_frame.f_lineno = 674;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_17, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__inhibit_policy_mapping_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 674;

        goto frame_exception_exit_14;
    }
    tmp_res = PyDict_SetItem( locals_PolicyConstraints_619, const_str_plain_inhibit_policy_mapping, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 674;

        goto frame_exception_exit_14;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_465314d58281e7cbbb03e4f8c9567305_14 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_13;

    frame_exception_exit_14:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_465314d58281e7cbbb03e4f8c9567305_14 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_465314d58281e7cbbb03e4f8c9567305_14, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_465314d58281e7cbbb03e4f8c9567305_14->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_465314d58281e7cbbb03e4f8c9567305_14, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_465314d58281e7cbbb03e4f8c9567305_14,
        type_description_2
    );


    // Release cached frame.
    if ( frame_465314d58281e7cbbb03e4f8c9567305_14 == cache_frame_465314d58281e7cbbb03e4f8c9567305_14 )
    {
        Py_DECREF( frame_465314d58281e7cbbb03e4f8c9567305_14 );
    }
    cache_frame_465314d58281e7cbbb03e4f8c9567305_14 = NULL;

    assertFrameObject( frame_465314d58281e7cbbb03e4f8c9567305_14 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_13;

    frame_no_exception_13:;

    goto skip_nested_handling_13;
    nested_frame_exit_13:;

    goto try_except_handler_51;
    skip_nested_handling_13:;
    tmp_outline_return_value_19 = locals_PolicyConstraints_619;
    Py_INCREF( tmp_outline_return_value_19 );
    goto try_return_handler_51;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_51:;
    Py_DECREF( locals_PolicyConstraints_619 );
    locals_PolicyConstraints_619 = NULL;
    goto outline_result_19;
    // Exception handler code:
    try_except_handler_51:;
    exception_keeper_type_44 = exception_type;
    exception_keeper_value_44 = exception_value;
    exception_keeper_tb_44 = exception_tb;
    exception_keeper_lineno_44 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PolicyConstraints_619 );
    locals_PolicyConstraints_619 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_44;
    exception_value = exception_keeper_value_44;
    exception_tb = exception_keeper_tb_44;
    exception_lineno = exception_keeper_lineno_44;

    goto outline_exception_13;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_13:;
    exception_lineno = 619;
    goto try_except_handler_50;
    outline_result_19:;
    tmp_assign_source_129 = tmp_outline_return_value_19;
    assert( tmp_class_creation_16__class_dict == NULL );
    tmp_class_creation_16__class_dict = tmp_assign_source_129;

    tmp_compare_left_16 = const_str_plain___metaclass__;
    tmp_compare_right_16 = tmp_class_creation_16__class_dict;

    CHECK_OBJECT( tmp_compare_right_16 );
    tmp_cmp_In_16 = PySequence_Contains( tmp_compare_right_16, tmp_compare_left_16 );
    assert( !(tmp_cmp_In_16 == -1) );
    if ( tmp_cmp_In_16 == 1 )
    {
        goto condexpr_true_16;
    }
    else
    {
        goto condexpr_false_16;
    }
    condexpr_true_16:;
    tmp_dict_name_16 = tmp_class_creation_16__class_dict;

    CHECK_OBJECT( tmp_dict_name_16 );
    tmp_key_name_16 = const_str_plain___metaclass__;
    tmp_assign_source_130 = DICT_GET_ITEM( tmp_dict_name_16, tmp_key_name_16 );
    if ( tmp_assign_source_130 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 619;

        goto try_except_handler_50;
    }
    goto condexpr_end_16;
    condexpr_false_16:;
    tmp_assign_source_130 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_130 );
    condexpr_end_16:;
    assert( tmp_class_creation_16__metaclass == NULL );
    tmp_class_creation_16__metaclass = tmp_assign_source_130;

    tmp_called_name_38 = tmp_class_creation_16__metaclass;

    CHECK_OBJECT( tmp_called_name_38 );
    tmp_args_element_name_65 = const_str_plain_PolicyConstraints;
    tmp_args_element_name_66 = const_tuple_type_object_tuple;
    tmp_args_element_name_67 = tmp_class_creation_16__class_dict;

    CHECK_OBJECT( tmp_args_element_name_67 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 619;
    {
        PyObject *call_args[] = { tmp_args_element_name_65, tmp_args_element_name_66, tmp_args_element_name_67 };
        tmp_assign_source_131 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_38, call_args );
    }

    if ( tmp_assign_source_131 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 619;

        goto try_except_handler_50;
    }
    assert( tmp_class_creation_16__class == NULL );
    tmp_class_creation_16__class = tmp_assign_source_131;

    tmp_source_name_23 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_23 == NULL ))
    {
        tmp_source_name_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_23 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 618;

        goto try_except_handler_50;
    }

    tmp_called_name_40 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain_register_interface );
    if ( tmp_called_name_40 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 618;

        goto try_except_handler_50;
    }
    tmp_args_element_name_68 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_68 == NULL ))
    {
        tmp_args_element_name_68 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_68 == NULL )
    {
        Py_DECREF( tmp_called_name_40 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 618;

        goto try_except_handler_50;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 618;
    {
        PyObject *call_args[] = { tmp_args_element_name_68 };
        tmp_called_name_39 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_40, call_args );
    }

    Py_DECREF( tmp_called_name_40 );
    if ( tmp_called_name_39 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 618;

        goto try_except_handler_50;
    }
    tmp_args_element_name_69 = tmp_class_creation_16__class;

    CHECK_OBJECT( tmp_args_element_name_69 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 618;
    {
        PyObject *call_args[] = { tmp_args_element_name_69 };
        tmp_assign_source_132 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_39, call_args );
    }

    Py_DECREF( tmp_called_name_39 );
    if ( tmp_assign_source_132 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 618;

        goto try_except_handler_50;
    }
    {
        PyObject *old = tmp_class_creation_16__class;
        assert( old != NULL );
        tmp_class_creation_16__class = tmp_assign_source_132;
        Py_DECREF( old );
    }

    goto try_end_29;
    // Exception handler code:
    try_except_handler_50:;
    exception_keeper_type_45 = exception_type;
    exception_keeper_value_45 = exception_value;
    exception_keeper_tb_45 = exception_tb;
    exception_keeper_lineno_45 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_16__class );
    tmp_class_creation_16__class = NULL;

    Py_XDECREF( tmp_class_creation_16__class_dict );
    tmp_class_creation_16__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_45;
    exception_value = exception_keeper_value_45;
    exception_tb = exception_keeper_tb_45;
    exception_lineno = exception_keeper_lineno_45;

    goto frame_exception_exit_1;
    // End of try:
    try_end_29:;
    tmp_assign_source_133 = tmp_class_creation_16__class;

    CHECK_OBJECT( tmp_assign_source_133 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PolicyConstraints, tmp_assign_source_133 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class );
    Py_DECREF( tmp_class_creation_16__class );
    tmp_class_creation_16__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class_dict );
    Py_DECREF( tmp_class_creation_16__class_dict );
    tmp_class_creation_16__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__metaclass );
    Py_DECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_CertificatePolicies_680 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_CertificatePolicies_680, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6086204b98cd7a3504a399bfa8318f89_15, codeobj_6086204b98cd7a3504a399bfa8318f89, module_cryptography$x509$extensions, 0 );
    frame_6086204b98cd7a3504a399bfa8318f89_15 = cache_frame_6086204b98cd7a3504a399bfa8318f89_15;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6086204b98cd7a3504a399bfa8318f89_15 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6086204b98cd7a3504a399bfa8318f89_15 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_24 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_24 == NULL ))
    {
        tmp_source_name_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_24 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 681;

        goto frame_exception_exit_15;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain_CERTIFICATE_POLICIES );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 681;

        goto frame_exception_exit_15;
    }
    tmp_res = PyDict_SetItem( locals_CertificatePolicies_680, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 681;

        goto frame_exception_exit_15;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_68___init__(  );
    tmp_res = PyDict_SetItem( locals_CertificatePolicies_680, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_called_name_41 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );

    if (unlikely( tmp_called_name_41 == NULL ))
    {
        tmp_called_name_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );
    }

    if ( tmp_called_name_41 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_sequence_methods" );
        exception_tb = NULL;

        exception_lineno = 693;

        goto try_except_handler_54;
    }

    frame_6086204b98cd7a3504a399bfa8318f89_15->m_frame.f_lineno = 693;
    tmp_iter_arg_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_41, &PyTuple_GET_ITEM( const_tuple_str_plain__policies_tuple, 0 ) );

    if ( tmp_iter_arg_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 693;

        goto try_except_handler_54;
    }
    tmp_assign_source_135 = MAKE_ITERATOR( tmp_iter_arg_5 );
    Py_DECREF( tmp_iter_arg_5 );
    if ( tmp_assign_source_135 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 693;

        goto try_except_handler_54;
    }
    assert( tmp_CertificatePolicies$tuple_unpack_1__source_iter == NULL );
    tmp_CertificatePolicies$tuple_unpack_1__source_iter = tmp_assign_source_135;

    // Tried code:
    tmp_unpack_13 = tmp_CertificatePolicies$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_13 );
    tmp_assign_source_136 = UNPACK_NEXT( tmp_unpack_13, 0 );
    if ( tmp_assign_source_136 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 693;
        goto try_except_handler_55;
    }
    assert( tmp_CertificatePolicies$tuple_unpack_1__element_1 == NULL );
    tmp_CertificatePolicies$tuple_unpack_1__element_1 = tmp_assign_source_136;

    tmp_unpack_14 = tmp_CertificatePolicies$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_14 );
    tmp_assign_source_137 = UNPACK_NEXT( tmp_unpack_14, 1 );
    if ( tmp_assign_source_137 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 693;
        goto try_except_handler_55;
    }
    assert( tmp_CertificatePolicies$tuple_unpack_1__element_2 == NULL );
    tmp_CertificatePolicies$tuple_unpack_1__element_2 = tmp_assign_source_137;

    tmp_unpack_15 = tmp_CertificatePolicies$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_15 );
    tmp_assign_source_138 = UNPACK_NEXT( tmp_unpack_15, 2 );
    if ( tmp_assign_source_138 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 693;
        goto try_except_handler_55;
    }
    assert( tmp_CertificatePolicies$tuple_unpack_1__element_3 == NULL );
    tmp_CertificatePolicies$tuple_unpack_1__element_3 = tmp_assign_source_138;

    tmp_iterator_name_5 = tmp_CertificatePolicies$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_5 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_5 ); assert( HAS_ITERNEXT( tmp_iterator_name_5 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_5 )->tp_iternext)( tmp_iterator_name_5 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 693;
                goto try_except_handler_55;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 693;
        goto try_except_handler_55;
    }
    goto try_end_30;
    // Exception handler code:
    try_except_handler_55:;
    exception_keeper_type_46 = exception_type;
    exception_keeper_value_46 = exception_value;
    exception_keeper_tb_46 = exception_tb;
    exception_keeper_lineno_46 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_CertificatePolicies$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_CertificatePolicies$tuple_unpack_1__source_iter );
    tmp_CertificatePolicies$tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_46;
    exception_value = exception_keeper_value_46;
    exception_tb = exception_keeper_tb_46;
    exception_lineno = exception_keeper_lineno_46;

    goto try_except_handler_54;
    // End of try:
    try_end_30:;
    goto try_end_31;
    // Exception handler code:
    try_except_handler_54:;
    exception_keeper_type_47 = exception_type;
    exception_keeper_value_47 = exception_value;
    exception_keeper_tb_47 = exception_tb;
    exception_keeper_lineno_47 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_CertificatePolicies$tuple_unpack_1__element_1 );
    tmp_CertificatePolicies$tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_CertificatePolicies$tuple_unpack_1__element_2 );
    tmp_CertificatePolicies$tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_CertificatePolicies$tuple_unpack_1__element_3 );
    tmp_CertificatePolicies$tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_47;
    exception_value = exception_keeper_value_47;
    exception_tb = exception_keeper_tb_47;
    exception_lineno = exception_keeper_lineno_47;

    goto frame_exception_exit_15;
    // End of try:
    try_end_31:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6086204b98cd7a3504a399bfa8318f89_15 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_14;

    frame_exception_exit_15:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6086204b98cd7a3504a399bfa8318f89_15 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6086204b98cd7a3504a399bfa8318f89_15, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6086204b98cd7a3504a399bfa8318f89_15->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6086204b98cd7a3504a399bfa8318f89_15, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6086204b98cd7a3504a399bfa8318f89_15,
        type_description_2
    );


    // Release cached frame.
    if ( frame_6086204b98cd7a3504a399bfa8318f89_15 == cache_frame_6086204b98cd7a3504a399bfa8318f89_15 )
    {
        Py_DECREF( frame_6086204b98cd7a3504a399bfa8318f89_15 );
    }
    cache_frame_6086204b98cd7a3504a399bfa8318f89_15 = NULL;

    assertFrameObject( frame_6086204b98cd7a3504a399bfa8318f89_15 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_14;

    frame_no_exception_14:;

    goto skip_nested_handling_14;
    nested_frame_exit_14:;

    goto try_except_handler_53;
    skip_nested_handling_14:;
    CHECK_OBJECT( (PyObject *)tmp_CertificatePolicies$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_CertificatePolicies$tuple_unpack_1__source_iter );
    tmp_CertificatePolicies$tuple_unpack_1__source_iter = NULL;

    tmp_dictset_value = tmp_CertificatePolicies$tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_CertificatePolicies_680, const_str_plain___len__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_CertificatePolicies$tuple_unpack_1__element_1 );
    tmp_CertificatePolicies$tuple_unpack_1__element_1 = NULL;

    tmp_dictset_value = tmp_CertificatePolicies$tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_CertificatePolicies_680, const_str_plain___iter__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_CertificatePolicies$tuple_unpack_1__element_2 );
    tmp_CertificatePolicies$tuple_unpack_1__element_2 = NULL;

    tmp_dictset_value = tmp_CertificatePolicies$tuple_unpack_1__element_3;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_CertificatePolicies_680, const_str_plain___getitem__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_CertificatePolicies$tuple_unpack_1__element_3 );
    tmp_CertificatePolicies$tuple_unpack_1__element_3 = NULL;

    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_69___repr__(  );
    tmp_res = PyDict_SetItem( locals_CertificatePolicies_680, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_70___eq__(  );
    tmp_res = PyDict_SetItem( locals_CertificatePolicies_680, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_71___ne__(  );
    tmp_res = PyDict_SetItem( locals_CertificatePolicies_680, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_72___hash__(  );
    tmp_res = PyDict_SetItem( locals_CertificatePolicies_680, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_20 = locals_CertificatePolicies_680;
    Py_INCREF( tmp_outline_return_value_20 );
    goto try_return_handler_53;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_53:;
    Py_DECREF( locals_CertificatePolicies_680 );
    locals_CertificatePolicies_680 = NULL;
    goto outline_result_20;
    // Exception handler code:
    try_except_handler_53:;
    exception_keeper_type_48 = exception_type;
    exception_keeper_value_48 = exception_value;
    exception_keeper_tb_48 = exception_tb;
    exception_keeper_lineno_48 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_CertificatePolicies_680 );
    locals_CertificatePolicies_680 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_48;
    exception_value = exception_keeper_value_48;
    exception_tb = exception_keeper_tb_48;
    exception_lineno = exception_keeper_lineno_48;

    goto outline_exception_14;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_14:;
    exception_lineno = 680;
    goto try_except_handler_52;
    outline_result_20:;
    tmp_assign_source_134 = tmp_outline_return_value_20;
    assert( tmp_class_creation_17__class_dict == NULL );
    tmp_class_creation_17__class_dict = tmp_assign_source_134;

    tmp_compare_left_17 = const_str_plain___metaclass__;
    tmp_compare_right_17 = tmp_class_creation_17__class_dict;

    CHECK_OBJECT( tmp_compare_right_17 );
    tmp_cmp_In_17 = PySequence_Contains( tmp_compare_right_17, tmp_compare_left_17 );
    assert( !(tmp_cmp_In_17 == -1) );
    if ( tmp_cmp_In_17 == 1 )
    {
        goto condexpr_true_17;
    }
    else
    {
        goto condexpr_false_17;
    }
    condexpr_true_17:;
    tmp_dict_name_17 = tmp_class_creation_17__class_dict;

    CHECK_OBJECT( tmp_dict_name_17 );
    tmp_key_name_17 = const_str_plain___metaclass__;
    tmp_assign_source_139 = DICT_GET_ITEM( tmp_dict_name_17, tmp_key_name_17 );
    if ( tmp_assign_source_139 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 680;

        goto try_except_handler_52;
    }
    goto condexpr_end_17;
    condexpr_false_17:;
    tmp_assign_source_139 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_139 );
    condexpr_end_17:;
    assert( tmp_class_creation_17__metaclass == NULL );
    tmp_class_creation_17__metaclass = tmp_assign_source_139;

    tmp_called_name_42 = tmp_class_creation_17__metaclass;

    CHECK_OBJECT( tmp_called_name_42 );
    tmp_args_element_name_70 = const_str_plain_CertificatePolicies;
    tmp_args_element_name_71 = const_tuple_type_object_tuple;
    tmp_args_element_name_72 = tmp_class_creation_17__class_dict;

    CHECK_OBJECT( tmp_args_element_name_72 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 680;
    {
        PyObject *call_args[] = { tmp_args_element_name_70, tmp_args_element_name_71, tmp_args_element_name_72 };
        tmp_assign_source_140 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_42, call_args );
    }

    if ( tmp_assign_source_140 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 680;

        goto try_except_handler_52;
    }
    assert( tmp_class_creation_17__class == NULL );
    tmp_class_creation_17__class = tmp_assign_source_140;

    tmp_source_name_25 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_25 == NULL ))
    {
        tmp_source_name_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_25 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 679;

        goto try_except_handler_52;
    }

    tmp_called_name_44 = LOOKUP_ATTRIBUTE( tmp_source_name_25, const_str_plain_register_interface );
    if ( tmp_called_name_44 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 679;

        goto try_except_handler_52;
    }
    tmp_args_element_name_73 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_73 == NULL ))
    {
        tmp_args_element_name_73 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_73 == NULL )
    {
        Py_DECREF( tmp_called_name_44 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 679;

        goto try_except_handler_52;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 679;
    {
        PyObject *call_args[] = { tmp_args_element_name_73 };
        tmp_called_name_43 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_44, call_args );
    }

    Py_DECREF( tmp_called_name_44 );
    if ( tmp_called_name_43 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 679;

        goto try_except_handler_52;
    }
    tmp_args_element_name_74 = tmp_class_creation_17__class;

    CHECK_OBJECT( tmp_args_element_name_74 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 679;
    {
        PyObject *call_args[] = { tmp_args_element_name_74 };
        tmp_assign_source_141 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_43, call_args );
    }

    Py_DECREF( tmp_called_name_43 );
    if ( tmp_assign_source_141 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 679;

        goto try_except_handler_52;
    }
    {
        PyObject *old = tmp_class_creation_17__class;
        assert( old != NULL );
        tmp_class_creation_17__class = tmp_assign_source_141;
        Py_DECREF( old );
    }

    goto try_end_32;
    // Exception handler code:
    try_except_handler_52:;
    exception_keeper_type_49 = exception_type;
    exception_keeper_value_49 = exception_value;
    exception_keeper_tb_49 = exception_tb;
    exception_keeper_lineno_49 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_17__class );
    tmp_class_creation_17__class = NULL;

    Py_XDECREF( tmp_class_creation_17__class_dict );
    tmp_class_creation_17__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_17__metaclass );
    tmp_class_creation_17__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_49;
    exception_value = exception_keeper_value_49;
    exception_tb = exception_keeper_tb_49;
    exception_lineno = exception_keeper_lineno_49;

    goto frame_exception_exit_1;
    // End of try:
    try_end_32:;
    tmp_assign_source_142 = tmp_class_creation_17__class;

    CHECK_OBJECT( tmp_assign_source_142 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CertificatePolicies, tmp_assign_source_142 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__class );
    Py_DECREF( tmp_class_creation_17__class );
    tmp_class_creation_17__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__class_dict );
    Py_DECREF( tmp_class_creation_17__class_dict );
    tmp_class_creation_17__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__metaclass );
    Py_DECREF( tmp_class_creation_17__metaclass );
    tmp_class_creation_17__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_PolicyInformation_711 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_PolicyInformation_711, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_73___init__(  );
    tmp_res = PyDict_SetItem( locals_PolicyInformation_711, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_74___repr__(  );
    tmp_res = PyDict_SetItem( locals_PolicyInformation_711, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_75___eq__(  );
    tmp_res = PyDict_SetItem( locals_PolicyInformation_711, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_76___ne__(  );
    tmp_res = PyDict_SetItem( locals_PolicyInformation_711, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_77___hash__(  );
    tmp_res = PyDict_SetItem( locals_PolicyInformation_711, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d28e44372df668104d77395650e260bf_16, codeobj_d28e44372df668104d77395650e260bf, module_cryptography$x509$extensions, 0 );
    frame_d28e44372df668104d77395650e260bf_16 = cache_frame_d28e44372df668104d77395650e260bf_16;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d28e44372df668104d77395650e260bf_16 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d28e44372df668104d77395650e260bf_16 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_18 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_18 == NULL ))
    {
        tmp_called_instance_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 757;

        goto frame_exception_exit_16;
    }

    frame_d28e44372df668104d77395650e260bf_16->m_frame.f_lineno = 757;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_18, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__policy_identifier_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 757;

        goto frame_exception_exit_16;
    }
    tmp_res = PyDict_SetItem( locals_PolicyInformation_711, const_str_plain_policy_identifier, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 757;

        goto frame_exception_exit_16;
    }
    tmp_called_instance_19 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_19 == NULL ))
    {
        tmp_called_instance_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_19 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 758;

        goto frame_exception_exit_16;
    }

    frame_d28e44372df668104d77395650e260bf_16->m_frame.f_lineno = 758;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_19, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__policy_qualifiers_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 758;

        goto frame_exception_exit_16;
    }
    tmp_res = PyDict_SetItem( locals_PolicyInformation_711, const_str_plain_policy_qualifiers, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 758;

        goto frame_exception_exit_16;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d28e44372df668104d77395650e260bf_16 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_15;

    frame_exception_exit_16:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d28e44372df668104d77395650e260bf_16 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d28e44372df668104d77395650e260bf_16, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d28e44372df668104d77395650e260bf_16->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d28e44372df668104d77395650e260bf_16, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d28e44372df668104d77395650e260bf_16,
        type_description_2
    );


    // Release cached frame.
    if ( frame_d28e44372df668104d77395650e260bf_16 == cache_frame_d28e44372df668104d77395650e260bf_16 )
    {
        Py_DECREF( frame_d28e44372df668104d77395650e260bf_16 );
    }
    cache_frame_d28e44372df668104d77395650e260bf_16 = NULL;

    assertFrameObject( frame_d28e44372df668104d77395650e260bf_16 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_15;

    frame_no_exception_15:;

    goto skip_nested_handling_15;
    nested_frame_exit_15:;

    goto try_except_handler_57;
    skip_nested_handling_15:;
    tmp_outline_return_value_21 = locals_PolicyInformation_711;
    Py_INCREF( tmp_outline_return_value_21 );
    goto try_return_handler_57;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_57:;
    Py_DECREF( locals_PolicyInformation_711 );
    locals_PolicyInformation_711 = NULL;
    goto outline_result_21;
    // Exception handler code:
    try_except_handler_57:;
    exception_keeper_type_50 = exception_type;
    exception_keeper_value_50 = exception_value;
    exception_keeper_tb_50 = exception_tb;
    exception_keeper_lineno_50 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PolicyInformation_711 );
    locals_PolicyInformation_711 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_50;
    exception_value = exception_keeper_value_50;
    exception_tb = exception_keeper_tb_50;
    exception_lineno = exception_keeper_lineno_50;

    goto outline_exception_15;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_15:;
    exception_lineno = 711;
    goto try_except_handler_56;
    outline_result_21:;
    tmp_assign_source_143 = tmp_outline_return_value_21;
    assert( tmp_class_creation_18__class_dict == NULL );
    tmp_class_creation_18__class_dict = tmp_assign_source_143;

    tmp_compare_left_18 = const_str_plain___metaclass__;
    tmp_compare_right_18 = tmp_class_creation_18__class_dict;

    CHECK_OBJECT( tmp_compare_right_18 );
    tmp_cmp_In_18 = PySequence_Contains( tmp_compare_right_18, tmp_compare_left_18 );
    assert( !(tmp_cmp_In_18 == -1) );
    if ( tmp_cmp_In_18 == 1 )
    {
        goto condexpr_true_18;
    }
    else
    {
        goto condexpr_false_18;
    }
    condexpr_true_18:;
    tmp_dict_name_18 = tmp_class_creation_18__class_dict;

    CHECK_OBJECT( tmp_dict_name_18 );
    tmp_key_name_18 = const_str_plain___metaclass__;
    tmp_assign_source_144 = DICT_GET_ITEM( tmp_dict_name_18, tmp_key_name_18 );
    if ( tmp_assign_source_144 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 711;

        goto try_except_handler_56;
    }
    goto condexpr_end_18;
    condexpr_false_18:;
    tmp_assign_source_144 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_144 );
    condexpr_end_18:;
    assert( tmp_class_creation_18__metaclass == NULL );
    tmp_class_creation_18__metaclass = tmp_assign_source_144;

    tmp_called_name_45 = tmp_class_creation_18__metaclass;

    CHECK_OBJECT( tmp_called_name_45 );
    tmp_args_element_name_75 = const_str_plain_PolicyInformation;
    tmp_args_element_name_76 = const_tuple_type_object_tuple;
    tmp_args_element_name_77 = tmp_class_creation_18__class_dict;

    CHECK_OBJECT( tmp_args_element_name_77 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 711;
    {
        PyObject *call_args[] = { tmp_args_element_name_75, tmp_args_element_name_76, tmp_args_element_name_77 };
        tmp_assign_source_145 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_45, call_args );
    }

    if ( tmp_assign_source_145 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 711;

        goto try_except_handler_56;
    }
    assert( tmp_class_creation_18__class == NULL );
    tmp_class_creation_18__class = tmp_assign_source_145;

    goto try_end_33;
    // Exception handler code:
    try_except_handler_56:;
    exception_keeper_type_51 = exception_type;
    exception_keeper_value_51 = exception_value;
    exception_keeper_tb_51 = exception_tb;
    exception_keeper_lineno_51 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_18__class_dict );
    tmp_class_creation_18__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_18__metaclass );
    tmp_class_creation_18__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_51;
    exception_value = exception_keeper_value_51;
    exception_tb = exception_keeper_tb_51;
    exception_lineno = exception_keeper_lineno_51;

    goto frame_exception_exit_1;
    // End of try:
    try_end_33:;
    tmp_assign_source_146 = tmp_class_creation_18__class;

    CHECK_OBJECT( tmp_assign_source_146 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PolicyInformation, tmp_assign_source_146 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_18__class );
    Py_DECREF( tmp_class_creation_18__class );
    tmp_class_creation_18__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_18__class_dict );
    Py_DECREF( tmp_class_creation_18__class_dict );
    tmp_class_creation_18__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_18__metaclass );
    Py_DECREF( tmp_class_creation_18__metaclass );
    tmp_class_creation_18__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_UserNotice_761 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_UserNotice_761, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_78___init__(  );
    tmp_res = PyDict_SetItem( locals_UserNotice_761, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_79___repr__(  );
    tmp_res = PyDict_SetItem( locals_UserNotice_761, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_80___eq__(  );
    tmp_res = PyDict_SetItem( locals_UserNotice_761, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_81___ne__(  );
    tmp_res = PyDict_SetItem( locals_UserNotice_761, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_82___hash__(  );
    tmp_res = PyDict_SetItem( locals_UserNotice_761, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2098416324e0e575808c7fc7af839a8b_17, codeobj_2098416324e0e575808c7fc7af839a8b, module_cryptography$x509$extensions, 0 );
    frame_2098416324e0e575808c7fc7af839a8b_17 = cache_frame_2098416324e0e575808c7fc7af839a8b_17;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2098416324e0e575808c7fc7af839a8b_17 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2098416324e0e575808c7fc7af839a8b_17 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_20 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_20 == NULL ))
    {
        tmp_called_instance_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_20 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 794;

        goto frame_exception_exit_17;
    }

    frame_2098416324e0e575808c7fc7af839a8b_17->m_frame.f_lineno = 794;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_20, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__notice_reference_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 794;

        goto frame_exception_exit_17;
    }
    tmp_res = PyDict_SetItem( locals_UserNotice_761, const_str_plain_notice_reference, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 794;

        goto frame_exception_exit_17;
    }
    tmp_called_instance_21 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_21 == NULL ))
    {
        tmp_called_instance_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_21 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 795;

        goto frame_exception_exit_17;
    }

    frame_2098416324e0e575808c7fc7af839a8b_17->m_frame.f_lineno = 795;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_21, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__explicit_text_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 795;

        goto frame_exception_exit_17;
    }
    tmp_res = PyDict_SetItem( locals_UserNotice_761, const_str_plain_explicit_text, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 795;

        goto frame_exception_exit_17;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2098416324e0e575808c7fc7af839a8b_17 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_16;

    frame_exception_exit_17:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2098416324e0e575808c7fc7af839a8b_17 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2098416324e0e575808c7fc7af839a8b_17, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2098416324e0e575808c7fc7af839a8b_17->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2098416324e0e575808c7fc7af839a8b_17, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2098416324e0e575808c7fc7af839a8b_17,
        type_description_2
    );


    // Release cached frame.
    if ( frame_2098416324e0e575808c7fc7af839a8b_17 == cache_frame_2098416324e0e575808c7fc7af839a8b_17 )
    {
        Py_DECREF( frame_2098416324e0e575808c7fc7af839a8b_17 );
    }
    cache_frame_2098416324e0e575808c7fc7af839a8b_17 = NULL;

    assertFrameObject( frame_2098416324e0e575808c7fc7af839a8b_17 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_16;

    frame_no_exception_16:;

    goto skip_nested_handling_16;
    nested_frame_exit_16:;

    goto try_except_handler_59;
    skip_nested_handling_16:;
    tmp_outline_return_value_22 = locals_UserNotice_761;
    Py_INCREF( tmp_outline_return_value_22 );
    goto try_return_handler_59;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_59:;
    Py_DECREF( locals_UserNotice_761 );
    locals_UserNotice_761 = NULL;
    goto outline_result_22;
    // Exception handler code:
    try_except_handler_59:;
    exception_keeper_type_52 = exception_type;
    exception_keeper_value_52 = exception_value;
    exception_keeper_tb_52 = exception_tb;
    exception_keeper_lineno_52 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_UserNotice_761 );
    locals_UserNotice_761 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_52;
    exception_value = exception_keeper_value_52;
    exception_tb = exception_keeper_tb_52;
    exception_lineno = exception_keeper_lineno_52;

    goto outline_exception_16;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_16:;
    exception_lineno = 761;
    goto try_except_handler_58;
    outline_result_22:;
    tmp_assign_source_147 = tmp_outline_return_value_22;
    assert( tmp_class_creation_19__class_dict == NULL );
    tmp_class_creation_19__class_dict = tmp_assign_source_147;

    tmp_compare_left_19 = const_str_plain___metaclass__;
    tmp_compare_right_19 = tmp_class_creation_19__class_dict;

    CHECK_OBJECT( tmp_compare_right_19 );
    tmp_cmp_In_19 = PySequence_Contains( tmp_compare_right_19, tmp_compare_left_19 );
    assert( !(tmp_cmp_In_19 == -1) );
    if ( tmp_cmp_In_19 == 1 )
    {
        goto condexpr_true_19;
    }
    else
    {
        goto condexpr_false_19;
    }
    condexpr_true_19:;
    tmp_dict_name_19 = tmp_class_creation_19__class_dict;

    CHECK_OBJECT( tmp_dict_name_19 );
    tmp_key_name_19 = const_str_plain___metaclass__;
    tmp_assign_source_148 = DICT_GET_ITEM( tmp_dict_name_19, tmp_key_name_19 );
    if ( tmp_assign_source_148 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 761;

        goto try_except_handler_58;
    }
    goto condexpr_end_19;
    condexpr_false_19:;
    tmp_assign_source_148 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_148 );
    condexpr_end_19:;
    assert( tmp_class_creation_19__metaclass == NULL );
    tmp_class_creation_19__metaclass = tmp_assign_source_148;

    tmp_called_name_46 = tmp_class_creation_19__metaclass;

    CHECK_OBJECT( tmp_called_name_46 );
    tmp_args_element_name_78 = const_str_plain_UserNotice;
    tmp_args_element_name_79 = const_tuple_type_object_tuple;
    tmp_args_element_name_80 = tmp_class_creation_19__class_dict;

    CHECK_OBJECT( tmp_args_element_name_80 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 761;
    {
        PyObject *call_args[] = { tmp_args_element_name_78, tmp_args_element_name_79, tmp_args_element_name_80 };
        tmp_assign_source_149 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_46, call_args );
    }

    if ( tmp_assign_source_149 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 761;

        goto try_except_handler_58;
    }
    assert( tmp_class_creation_19__class == NULL );
    tmp_class_creation_19__class = tmp_assign_source_149;

    goto try_end_34;
    // Exception handler code:
    try_except_handler_58:;
    exception_keeper_type_53 = exception_type;
    exception_keeper_value_53 = exception_value;
    exception_keeper_tb_53 = exception_tb;
    exception_keeper_lineno_53 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_19__class_dict );
    tmp_class_creation_19__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_19__metaclass );
    tmp_class_creation_19__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_53;
    exception_value = exception_keeper_value_53;
    exception_tb = exception_keeper_tb_53;
    exception_lineno = exception_keeper_lineno_53;

    goto frame_exception_exit_1;
    // End of try:
    try_end_34:;
    tmp_assign_source_150 = tmp_class_creation_19__class;

    CHECK_OBJECT( tmp_assign_source_150 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_UserNotice, tmp_assign_source_150 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_19__class );
    Py_DECREF( tmp_class_creation_19__class );
    tmp_class_creation_19__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_19__class_dict );
    Py_DECREF( tmp_class_creation_19__class_dict );
    tmp_class_creation_19__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_19__metaclass );
    Py_DECREF( tmp_class_creation_19__metaclass );
    tmp_class_creation_19__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_NoticeReference_798 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_NoticeReference_798, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_83___init__(  );
    tmp_res = PyDict_SetItem( locals_NoticeReference_798, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_84___repr__(  );
    tmp_res = PyDict_SetItem( locals_NoticeReference_798, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_85___eq__(  );
    tmp_res = PyDict_SetItem( locals_NoticeReference_798, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_86___ne__(  );
    tmp_res = PyDict_SetItem( locals_NoticeReference_798, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_87___hash__(  );
    tmp_res = PyDict_SetItem( locals_NoticeReference_798, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_35875bcb7c761051b162bab059cb2263_18, codeobj_35875bcb7c761051b162bab059cb2263, module_cryptography$x509$extensions, 0 );
    frame_35875bcb7c761051b162bab059cb2263_18 = cache_frame_35875bcb7c761051b162bab059cb2263_18;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_35875bcb7c761051b162bab059cb2263_18 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_35875bcb7c761051b162bab059cb2263_18 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_22 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_22 == NULL ))
    {
        tmp_called_instance_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_22 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 830;

        goto frame_exception_exit_18;
    }

    frame_35875bcb7c761051b162bab059cb2263_18->m_frame.f_lineno = 830;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_22, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__organization_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 830;

        goto frame_exception_exit_18;
    }
    tmp_res = PyDict_SetItem( locals_NoticeReference_798, const_str_plain_organization, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 830;

        goto frame_exception_exit_18;
    }
    tmp_called_instance_23 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_23 == NULL ))
    {
        tmp_called_instance_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_23 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 831;

        goto frame_exception_exit_18;
    }

    frame_35875bcb7c761051b162bab059cb2263_18->m_frame.f_lineno = 831;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_23, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__notice_numbers_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 831;

        goto frame_exception_exit_18;
    }
    tmp_res = PyDict_SetItem( locals_NoticeReference_798, const_str_plain_notice_numbers, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 831;

        goto frame_exception_exit_18;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_35875bcb7c761051b162bab059cb2263_18 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_17;

    frame_exception_exit_18:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_35875bcb7c761051b162bab059cb2263_18 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_35875bcb7c761051b162bab059cb2263_18, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_35875bcb7c761051b162bab059cb2263_18->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_35875bcb7c761051b162bab059cb2263_18, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_35875bcb7c761051b162bab059cb2263_18,
        type_description_2
    );


    // Release cached frame.
    if ( frame_35875bcb7c761051b162bab059cb2263_18 == cache_frame_35875bcb7c761051b162bab059cb2263_18 )
    {
        Py_DECREF( frame_35875bcb7c761051b162bab059cb2263_18 );
    }
    cache_frame_35875bcb7c761051b162bab059cb2263_18 = NULL;

    assertFrameObject( frame_35875bcb7c761051b162bab059cb2263_18 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_17;

    frame_no_exception_17:;

    goto skip_nested_handling_17;
    nested_frame_exit_17:;

    goto try_except_handler_61;
    skip_nested_handling_17:;
    tmp_outline_return_value_23 = locals_NoticeReference_798;
    Py_INCREF( tmp_outline_return_value_23 );
    goto try_return_handler_61;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_61:;
    Py_DECREF( locals_NoticeReference_798 );
    locals_NoticeReference_798 = NULL;
    goto outline_result_23;
    // Exception handler code:
    try_except_handler_61:;
    exception_keeper_type_54 = exception_type;
    exception_keeper_value_54 = exception_value;
    exception_keeper_tb_54 = exception_tb;
    exception_keeper_lineno_54 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_NoticeReference_798 );
    locals_NoticeReference_798 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_54;
    exception_value = exception_keeper_value_54;
    exception_tb = exception_keeper_tb_54;
    exception_lineno = exception_keeper_lineno_54;

    goto outline_exception_17;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_17:;
    exception_lineno = 798;
    goto try_except_handler_60;
    outline_result_23:;
    tmp_assign_source_151 = tmp_outline_return_value_23;
    assert( tmp_class_creation_20__class_dict == NULL );
    tmp_class_creation_20__class_dict = tmp_assign_source_151;

    tmp_compare_left_20 = const_str_plain___metaclass__;
    tmp_compare_right_20 = tmp_class_creation_20__class_dict;

    CHECK_OBJECT( tmp_compare_right_20 );
    tmp_cmp_In_20 = PySequence_Contains( tmp_compare_right_20, tmp_compare_left_20 );
    assert( !(tmp_cmp_In_20 == -1) );
    if ( tmp_cmp_In_20 == 1 )
    {
        goto condexpr_true_20;
    }
    else
    {
        goto condexpr_false_20;
    }
    condexpr_true_20:;
    tmp_dict_name_20 = tmp_class_creation_20__class_dict;

    CHECK_OBJECT( tmp_dict_name_20 );
    tmp_key_name_20 = const_str_plain___metaclass__;
    tmp_assign_source_152 = DICT_GET_ITEM( tmp_dict_name_20, tmp_key_name_20 );
    if ( tmp_assign_source_152 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 798;

        goto try_except_handler_60;
    }
    goto condexpr_end_20;
    condexpr_false_20:;
    tmp_assign_source_152 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_152 );
    condexpr_end_20:;
    assert( tmp_class_creation_20__metaclass == NULL );
    tmp_class_creation_20__metaclass = tmp_assign_source_152;

    tmp_called_name_47 = tmp_class_creation_20__metaclass;

    CHECK_OBJECT( tmp_called_name_47 );
    tmp_args_element_name_81 = const_str_plain_NoticeReference;
    tmp_args_element_name_82 = const_tuple_type_object_tuple;
    tmp_args_element_name_83 = tmp_class_creation_20__class_dict;

    CHECK_OBJECT( tmp_args_element_name_83 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 798;
    {
        PyObject *call_args[] = { tmp_args_element_name_81, tmp_args_element_name_82, tmp_args_element_name_83 };
        tmp_assign_source_153 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_47, call_args );
    }

    if ( tmp_assign_source_153 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 798;

        goto try_except_handler_60;
    }
    assert( tmp_class_creation_20__class == NULL );
    tmp_class_creation_20__class = tmp_assign_source_153;

    goto try_end_35;
    // Exception handler code:
    try_except_handler_60:;
    exception_keeper_type_55 = exception_type;
    exception_keeper_value_55 = exception_value;
    exception_keeper_tb_55 = exception_tb;
    exception_keeper_lineno_55 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_20__class_dict );
    tmp_class_creation_20__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_20__metaclass );
    tmp_class_creation_20__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_55;
    exception_value = exception_keeper_value_55;
    exception_tb = exception_keeper_tb_55;
    exception_lineno = exception_keeper_lineno_55;

    goto frame_exception_exit_1;
    // End of try:
    try_end_35:;
    tmp_assign_source_154 = tmp_class_creation_20__class;

    CHECK_OBJECT( tmp_assign_source_154 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_NoticeReference, tmp_assign_source_154 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_20__class );
    Py_DECREF( tmp_class_creation_20__class );
    tmp_class_creation_20__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_20__class_dict );
    Py_DECREF( tmp_class_creation_20__class_dict );
    tmp_class_creation_20__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_20__metaclass );
    Py_DECREF( tmp_class_creation_20__metaclass );
    tmp_class_creation_20__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_ExtendedKeyUsage_835 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_ExtendedKeyUsage_835, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d61a1308ab34f09405007abf3d96513d_19, codeobj_d61a1308ab34f09405007abf3d96513d, module_cryptography$x509$extensions, 0 );
    frame_d61a1308ab34f09405007abf3d96513d_19 = cache_frame_d61a1308ab34f09405007abf3d96513d_19;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d61a1308ab34f09405007abf3d96513d_19 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d61a1308ab34f09405007abf3d96513d_19 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_26 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_26 == NULL ))
    {
        tmp_source_name_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_26 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 836;

        goto frame_exception_exit_19;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_26, const_str_plain_EXTENDED_KEY_USAGE );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 836;

        goto frame_exception_exit_19;
    }
    tmp_res = PyDict_SetItem( locals_ExtendedKeyUsage_835, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 836;

        goto frame_exception_exit_19;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_88___init__(  );
    tmp_res = PyDict_SetItem( locals_ExtendedKeyUsage_835, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_called_name_48 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );

    if (unlikely( tmp_called_name_48 == NULL ))
    {
        tmp_called_name_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );
    }

    if ( tmp_called_name_48 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_sequence_methods" );
        exception_tb = NULL;

        exception_lineno = 847;

        goto try_except_handler_64;
    }

    frame_d61a1308ab34f09405007abf3d96513d_19->m_frame.f_lineno = 847;
    tmp_iter_arg_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_48, &PyTuple_GET_ITEM( const_tuple_str_plain__usages_tuple, 0 ) );

    if ( tmp_iter_arg_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 847;

        goto try_except_handler_64;
    }
    tmp_assign_source_156 = MAKE_ITERATOR( tmp_iter_arg_6 );
    Py_DECREF( tmp_iter_arg_6 );
    if ( tmp_assign_source_156 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 847;

        goto try_except_handler_64;
    }
    assert( tmp_ExtendedKeyUsage$tuple_unpack_1__source_iter == NULL );
    tmp_ExtendedKeyUsage$tuple_unpack_1__source_iter = tmp_assign_source_156;

    // Tried code:
    tmp_unpack_16 = tmp_ExtendedKeyUsage$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_16 );
    tmp_assign_source_157 = UNPACK_NEXT( tmp_unpack_16, 0 );
    if ( tmp_assign_source_157 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 847;
        goto try_except_handler_65;
    }
    assert( tmp_ExtendedKeyUsage$tuple_unpack_1__element_1 == NULL );
    tmp_ExtendedKeyUsage$tuple_unpack_1__element_1 = tmp_assign_source_157;

    tmp_unpack_17 = tmp_ExtendedKeyUsage$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_17 );
    tmp_assign_source_158 = UNPACK_NEXT( tmp_unpack_17, 1 );
    if ( tmp_assign_source_158 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 847;
        goto try_except_handler_65;
    }
    assert( tmp_ExtendedKeyUsage$tuple_unpack_1__element_2 == NULL );
    tmp_ExtendedKeyUsage$tuple_unpack_1__element_2 = tmp_assign_source_158;

    tmp_unpack_18 = tmp_ExtendedKeyUsage$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_18 );
    tmp_assign_source_159 = UNPACK_NEXT( tmp_unpack_18, 2 );
    if ( tmp_assign_source_159 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 847;
        goto try_except_handler_65;
    }
    assert( tmp_ExtendedKeyUsage$tuple_unpack_1__element_3 == NULL );
    tmp_ExtendedKeyUsage$tuple_unpack_1__element_3 = tmp_assign_source_159;

    tmp_iterator_name_6 = tmp_ExtendedKeyUsage$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_6 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_6 ); assert( HAS_ITERNEXT( tmp_iterator_name_6 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_6 )->tp_iternext)( tmp_iterator_name_6 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 847;
                goto try_except_handler_65;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 847;
        goto try_except_handler_65;
    }
    goto try_end_36;
    // Exception handler code:
    try_except_handler_65:;
    exception_keeper_type_56 = exception_type;
    exception_keeper_value_56 = exception_value;
    exception_keeper_tb_56 = exception_tb;
    exception_keeper_lineno_56 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_ExtendedKeyUsage$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_ExtendedKeyUsage$tuple_unpack_1__source_iter );
    tmp_ExtendedKeyUsage$tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_56;
    exception_value = exception_keeper_value_56;
    exception_tb = exception_keeper_tb_56;
    exception_lineno = exception_keeper_lineno_56;

    goto try_except_handler_64;
    // End of try:
    try_end_36:;
    goto try_end_37;
    // Exception handler code:
    try_except_handler_64:;
    exception_keeper_type_57 = exception_type;
    exception_keeper_value_57 = exception_value;
    exception_keeper_tb_57 = exception_tb;
    exception_keeper_lineno_57 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_ExtendedKeyUsage$tuple_unpack_1__element_1 );
    tmp_ExtendedKeyUsage$tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_ExtendedKeyUsage$tuple_unpack_1__element_2 );
    tmp_ExtendedKeyUsage$tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_ExtendedKeyUsage$tuple_unpack_1__element_3 );
    tmp_ExtendedKeyUsage$tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_57;
    exception_value = exception_keeper_value_57;
    exception_tb = exception_keeper_tb_57;
    exception_lineno = exception_keeper_lineno_57;

    goto frame_exception_exit_19;
    // End of try:
    try_end_37:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d61a1308ab34f09405007abf3d96513d_19 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_18;

    frame_exception_exit_19:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d61a1308ab34f09405007abf3d96513d_19 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d61a1308ab34f09405007abf3d96513d_19, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d61a1308ab34f09405007abf3d96513d_19->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d61a1308ab34f09405007abf3d96513d_19, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d61a1308ab34f09405007abf3d96513d_19,
        type_description_2
    );


    // Release cached frame.
    if ( frame_d61a1308ab34f09405007abf3d96513d_19 == cache_frame_d61a1308ab34f09405007abf3d96513d_19 )
    {
        Py_DECREF( frame_d61a1308ab34f09405007abf3d96513d_19 );
    }
    cache_frame_d61a1308ab34f09405007abf3d96513d_19 = NULL;

    assertFrameObject( frame_d61a1308ab34f09405007abf3d96513d_19 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_18;

    frame_no_exception_18:;

    goto skip_nested_handling_18;
    nested_frame_exit_18:;

    goto try_except_handler_63;
    skip_nested_handling_18:;
    CHECK_OBJECT( (PyObject *)tmp_ExtendedKeyUsage$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_ExtendedKeyUsage$tuple_unpack_1__source_iter );
    tmp_ExtendedKeyUsage$tuple_unpack_1__source_iter = NULL;

    tmp_dictset_value = tmp_ExtendedKeyUsage$tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_ExtendedKeyUsage_835, const_str_plain___len__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_ExtendedKeyUsage$tuple_unpack_1__element_1 );
    tmp_ExtendedKeyUsage$tuple_unpack_1__element_1 = NULL;

    tmp_dictset_value = tmp_ExtendedKeyUsage$tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_ExtendedKeyUsage_835, const_str_plain___iter__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_ExtendedKeyUsage$tuple_unpack_1__element_2 );
    tmp_ExtendedKeyUsage$tuple_unpack_1__element_2 = NULL;

    tmp_dictset_value = tmp_ExtendedKeyUsage$tuple_unpack_1__element_3;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_ExtendedKeyUsage_835, const_str_plain___getitem__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_ExtendedKeyUsage$tuple_unpack_1__element_3 );
    tmp_ExtendedKeyUsage$tuple_unpack_1__element_3 = NULL;

    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_89___repr__(  );
    tmp_res = PyDict_SetItem( locals_ExtendedKeyUsage_835, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_90___eq__(  );
    tmp_res = PyDict_SetItem( locals_ExtendedKeyUsage_835, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_91___ne__(  );
    tmp_res = PyDict_SetItem( locals_ExtendedKeyUsage_835, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_92___hash__(  );
    tmp_res = PyDict_SetItem( locals_ExtendedKeyUsage_835, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_24 = locals_ExtendedKeyUsage_835;
    Py_INCREF( tmp_outline_return_value_24 );
    goto try_return_handler_63;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_63:;
    Py_DECREF( locals_ExtendedKeyUsage_835 );
    locals_ExtendedKeyUsage_835 = NULL;
    goto outline_result_24;
    // Exception handler code:
    try_except_handler_63:;
    exception_keeper_type_58 = exception_type;
    exception_keeper_value_58 = exception_value;
    exception_keeper_tb_58 = exception_tb;
    exception_keeper_lineno_58 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_ExtendedKeyUsage_835 );
    locals_ExtendedKeyUsage_835 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_58;
    exception_value = exception_keeper_value_58;
    exception_tb = exception_keeper_tb_58;
    exception_lineno = exception_keeper_lineno_58;

    goto outline_exception_18;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_18:;
    exception_lineno = 835;
    goto try_except_handler_62;
    outline_result_24:;
    tmp_assign_source_155 = tmp_outline_return_value_24;
    assert( tmp_class_creation_21__class_dict == NULL );
    tmp_class_creation_21__class_dict = tmp_assign_source_155;

    tmp_compare_left_21 = const_str_plain___metaclass__;
    tmp_compare_right_21 = tmp_class_creation_21__class_dict;

    CHECK_OBJECT( tmp_compare_right_21 );
    tmp_cmp_In_21 = PySequence_Contains( tmp_compare_right_21, tmp_compare_left_21 );
    assert( !(tmp_cmp_In_21 == -1) );
    if ( tmp_cmp_In_21 == 1 )
    {
        goto condexpr_true_21;
    }
    else
    {
        goto condexpr_false_21;
    }
    condexpr_true_21:;
    tmp_dict_name_21 = tmp_class_creation_21__class_dict;

    CHECK_OBJECT( tmp_dict_name_21 );
    tmp_key_name_21 = const_str_plain___metaclass__;
    tmp_assign_source_160 = DICT_GET_ITEM( tmp_dict_name_21, tmp_key_name_21 );
    if ( tmp_assign_source_160 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 835;

        goto try_except_handler_62;
    }
    goto condexpr_end_21;
    condexpr_false_21:;
    tmp_assign_source_160 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_160 );
    condexpr_end_21:;
    assert( tmp_class_creation_21__metaclass == NULL );
    tmp_class_creation_21__metaclass = tmp_assign_source_160;

    tmp_called_name_49 = tmp_class_creation_21__metaclass;

    CHECK_OBJECT( tmp_called_name_49 );
    tmp_args_element_name_84 = const_str_plain_ExtendedKeyUsage;
    tmp_args_element_name_85 = const_tuple_type_object_tuple;
    tmp_args_element_name_86 = tmp_class_creation_21__class_dict;

    CHECK_OBJECT( tmp_args_element_name_86 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 835;
    {
        PyObject *call_args[] = { tmp_args_element_name_84, tmp_args_element_name_85, tmp_args_element_name_86 };
        tmp_assign_source_161 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_49, call_args );
    }

    if ( tmp_assign_source_161 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 835;

        goto try_except_handler_62;
    }
    assert( tmp_class_creation_21__class == NULL );
    tmp_class_creation_21__class = tmp_assign_source_161;

    tmp_source_name_27 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_27 == NULL ))
    {
        tmp_source_name_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_27 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 834;

        goto try_except_handler_62;
    }

    tmp_called_name_51 = LOOKUP_ATTRIBUTE( tmp_source_name_27, const_str_plain_register_interface );
    if ( tmp_called_name_51 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 834;

        goto try_except_handler_62;
    }
    tmp_args_element_name_87 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_87 == NULL ))
    {
        tmp_args_element_name_87 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_87 == NULL )
    {
        Py_DECREF( tmp_called_name_51 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 834;

        goto try_except_handler_62;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 834;
    {
        PyObject *call_args[] = { tmp_args_element_name_87 };
        tmp_called_name_50 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_51, call_args );
    }

    Py_DECREF( tmp_called_name_51 );
    if ( tmp_called_name_50 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 834;

        goto try_except_handler_62;
    }
    tmp_args_element_name_88 = tmp_class_creation_21__class;

    CHECK_OBJECT( tmp_args_element_name_88 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 834;
    {
        PyObject *call_args[] = { tmp_args_element_name_88 };
        tmp_assign_source_162 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_50, call_args );
    }

    Py_DECREF( tmp_called_name_50 );
    if ( tmp_assign_source_162 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 834;

        goto try_except_handler_62;
    }
    {
        PyObject *old = tmp_class_creation_21__class;
        assert( old != NULL );
        tmp_class_creation_21__class = tmp_assign_source_162;
        Py_DECREF( old );
    }

    goto try_end_38;
    // Exception handler code:
    try_except_handler_62:;
    exception_keeper_type_59 = exception_type;
    exception_keeper_value_59 = exception_value;
    exception_keeper_tb_59 = exception_tb;
    exception_keeper_lineno_59 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_21__class );
    tmp_class_creation_21__class = NULL;

    Py_XDECREF( tmp_class_creation_21__class_dict );
    tmp_class_creation_21__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_21__metaclass );
    tmp_class_creation_21__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_59;
    exception_value = exception_keeper_value_59;
    exception_tb = exception_keeper_tb_59;
    exception_lineno = exception_keeper_lineno_59;

    goto frame_exception_exit_1;
    // End of try:
    try_end_38:;
    tmp_assign_source_163 = tmp_class_creation_21__class;

    CHECK_OBJECT( tmp_assign_source_163 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtendedKeyUsage, tmp_assign_source_163 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_21__class );
    Py_DECREF( tmp_class_creation_21__class );
    tmp_class_creation_21__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_21__class_dict );
    Py_DECREF( tmp_class_creation_21__class_dict );
    tmp_class_creation_21__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_21__metaclass );
    Py_DECREF( tmp_class_creation_21__metaclass );
    tmp_class_creation_21__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_OCSPNoCheck_866 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_OCSPNoCheck_866, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_47c73715590dd417125d0b31840d019d_20, codeobj_47c73715590dd417125d0b31840d019d, module_cryptography$x509$extensions, 0 );
    frame_47c73715590dd417125d0b31840d019d_20 = cache_frame_47c73715590dd417125d0b31840d019d_20;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_47c73715590dd417125d0b31840d019d_20 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_47c73715590dd417125d0b31840d019d_20 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_28 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_28 == NULL ))
    {
        tmp_source_name_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_28 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 867;

        goto frame_exception_exit_20;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_28, const_str_plain_OCSP_NO_CHECK );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 867;

        goto frame_exception_exit_20;
    }
    tmp_res = PyDict_SetItem( locals_OCSPNoCheck_866, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 867;

        goto frame_exception_exit_20;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_47c73715590dd417125d0b31840d019d_20 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_19;

    frame_exception_exit_20:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_47c73715590dd417125d0b31840d019d_20 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_47c73715590dd417125d0b31840d019d_20, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_47c73715590dd417125d0b31840d019d_20->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_47c73715590dd417125d0b31840d019d_20, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_47c73715590dd417125d0b31840d019d_20,
        type_description_2
    );


    // Release cached frame.
    if ( frame_47c73715590dd417125d0b31840d019d_20 == cache_frame_47c73715590dd417125d0b31840d019d_20 )
    {
        Py_DECREF( frame_47c73715590dd417125d0b31840d019d_20 );
    }
    cache_frame_47c73715590dd417125d0b31840d019d_20 = NULL;

    assertFrameObject( frame_47c73715590dd417125d0b31840d019d_20 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_19;

    frame_no_exception_19:;

    goto skip_nested_handling_19;
    nested_frame_exit_19:;

    goto try_except_handler_67;
    skip_nested_handling_19:;
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_93___eq__(  );
    tmp_res = PyDict_SetItem( locals_OCSPNoCheck_866, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_94___ne__(  );
    tmp_res = PyDict_SetItem( locals_OCSPNoCheck_866, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_95___hash__(  );
    tmp_res = PyDict_SetItem( locals_OCSPNoCheck_866, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_96___repr__(  );
    tmp_res = PyDict_SetItem( locals_OCSPNoCheck_866, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_25 = locals_OCSPNoCheck_866;
    Py_INCREF( tmp_outline_return_value_25 );
    goto try_return_handler_67;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_67:;
    Py_DECREF( locals_OCSPNoCheck_866 );
    locals_OCSPNoCheck_866 = NULL;
    goto outline_result_25;
    // Exception handler code:
    try_except_handler_67:;
    exception_keeper_type_60 = exception_type;
    exception_keeper_value_60 = exception_value;
    exception_keeper_tb_60 = exception_tb;
    exception_keeper_lineno_60 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_OCSPNoCheck_866 );
    locals_OCSPNoCheck_866 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_60;
    exception_value = exception_keeper_value_60;
    exception_tb = exception_keeper_tb_60;
    exception_lineno = exception_keeper_lineno_60;

    goto outline_exception_19;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_19:;
    exception_lineno = 866;
    goto try_except_handler_66;
    outline_result_25:;
    tmp_assign_source_164 = tmp_outline_return_value_25;
    assert( tmp_class_creation_22__class_dict == NULL );
    tmp_class_creation_22__class_dict = tmp_assign_source_164;

    tmp_compare_left_22 = const_str_plain___metaclass__;
    tmp_compare_right_22 = tmp_class_creation_22__class_dict;

    CHECK_OBJECT( tmp_compare_right_22 );
    tmp_cmp_In_22 = PySequence_Contains( tmp_compare_right_22, tmp_compare_left_22 );
    assert( !(tmp_cmp_In_22 == -1) );
    if ( tmp_cmp_In_22 == 1 )
    {
        goto condexpr_true_22;
    }
    else
    {
        goto condexpr_false_22;
    }
    condexpr_true_22:;
    tmp_dict_name_22 = tmp_class_creation_22__class_dict;

    CHECK_OBJECT( tmp_dict_name_22 );
    tmp_key_name_22 = const_str_plain___metaclass__;
    tmp_assign_source_165 = DICT_GET_ITEM( tmp_dict_name_22, tmp_key_name_22 );
    if ( tmp_assign_source_165 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 866;

        goto try_except_handler_66;
    }
    goto condexpr_end_22;
    condexpr_false_22:;
    tmp_assign_source_165 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_165 );
    condexpr_end_22:;
    assert( tmp_class_creation_22__metaclass == NULL );
    tmp_class_creation_22__metaclass = tmp_assign_source_165;

    tmp_called_name_52 = tmp_class_creation_22__metaclass;

    CHECK_OBJECT( tmp_called_name_52 );
    tmp_args_element_name_89 = const_str_plain_OCSPNoCheck;
    tmp_args_element_name_90 = const_tuple_type_object_tuple;
    tmp_args_element_name_91 = tmp_class_creation_22__class_dict;

    CHECK_OBJECT( tmp_args_element_name_91 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 866;
    {
        PyObject *call_args[] = { tmp_args_element_name_89, tmp_args_element_name_90, tmp_args_element_name_91 };
        tmp_assign_source_166 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_52, call_args );
    }

    if ( tmp_assign_source_166 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 866;

        goto try_except_handler_66;
    }
    assert( tmp_class_creation_22__class == NULL );
    tmp_class_creation_22__class = tmp_assign_source_166;

    tmp_source_name_29 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_29 == NULL ))
    {
        tmp_source_name_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_29 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 865;

        goto try_except_handler_66;
    }

    tmp_called_name_54 = LOOKUP_ATTRIBUTE( tmp_source_name_29, const_str_plain_register_interface );
    if ( tmp_called_name_54 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 865;

        goto try_except_handler_66;
    }
    tmp_args_element_name_92 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_92 == NULL ))
    {
        tmp_args_element_name_92 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_92 == NULL )
    {
        Py_DECREF( tmp_called_name_54 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 865;

        goto try_except_handler_66;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 865;
    {
        PyObject *call_args[] = { tmp_args_element_name_92 };
        tmp_called_name_53 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_54, call_args );
    }

    Py_DECREF( tmp_called_name_54 );
    if ( tmp_called_name_53 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 865;

        goto try_except_handler_66;
    }
    tmp_args_element_name_93 = tmp_class_creation_22__class;

    CHECK_OBJECT( tmp_args_element_name_93 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 865;
    {
        PyObject *call_args[] = { tmp_args_element_name_93 };
        tmp_assign_source_167 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_53, call_args );
    }

    Py_DECREF( tmp_called_name_53 );
    if ( tmp_assign_source_167 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 865;

        goto try_except_handler_66;
    }
    {
        PyObject *old = tmp_class_creation_22__class;
        assert( old != NULL );
        tmp_class_creation_22__class = tmp_assign_source_167;
        Py_DECREF( old );
    }

    goto try_end_39;
    // Exception handler code:
    try_except_handler_66:;
    exception_keeper_type_61 = exception_type;
    exception_keeper_value_61 = exception_value;
    exception_keeper_tb_61 = exception_tb;
    exception_keeper_lineno_61 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_22__class );
    tmp_class_creation_22__class = NULL;

    Py_XDECREF( tmp_class_creation_22__class_dict );
    tmp_class_creation_22__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_22__metaclass );
    tmp_class_creation_22__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_61;
    exception_value = exception_keeper_value_61;
    exception_tb = exception_keeper_tb_61;
    exception_lineno = exception_keeper_lineno_61;

    goto frame_exception_exit_1;
    // End of try:
    try_end_39:;
    tmp_assign_source_168 = tmp_class_creation_22__class;

    CHECK_OBJECT( tmp_assign_source_168 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OCSPNoCheck, tmp_assign_source_168 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_22__class );
    Py_DECREF( tmp_class_creation_22__class );
    tmp_class_creation_22__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_22__class_dict );
    Py_DECREF( tmp_class_creation_22__class_dict );
    tmp_class_creation_22__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_22__metaclass );
    Py_DECREF( tmp_class_creation_22__metaclass );
    tmp_class_creation_22__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_PrecertPoison_886 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_PrecertPoison_886, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21, codeobj_31d6ad167a415ca40a0d9b8ab50a7ba8, module_cryptography$x509$extensions, 0 );
    frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21 = cache_frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_30 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_30 == NULL ))
    {
        tmp_source_name_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_30 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 887;

        goto frame_exception_exit_21;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_30, const_str_plain_PRECERT_POISON );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 887;

        goto frame_exception_exit_21;
    }
    tmp_res = PyDict_SetItem( locals_PrecertPoison_886, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 887;

        goto frame_exception_exit_21;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_20;

    frame_exception_exit_21:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21,
        type_description_2
    );


    // Release cached frame.
    if ( frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21 == cache_frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21 )
    {
        Py_DECREF( frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21 );
    }
    cache_frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21 = NULL;

    assertFrameObject( frame_31d6ad167a415ca40a0d9b8ab50a7ba8_21 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_20;

    frame_no_exception_20:;

    goto skip_nested_handling_20;
    nested_frame_exit_20:;

    goto try_except_handler_69;
    skip_nested_handling_20:;
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_97___eq__(  );
    tmp_res = PyDict_SetItem( locals_PrecertPoison_886, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_98___ne__(  );
    tmp_res = PyDict_SetItem( locals_PrecertPoison_886, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_99___hash__(  );
    tmp_res = PyDict_SetItem( locals_PrecertPoison_886, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_100___repr__(  );
    tmp_res = PyDict_SetItem( locals_PrecertPoison_886, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_26 = locals_PrecertPoison_886;
    Py_INCREF( tmp_outline_return_value_26 );
    goto try_return_handler_69;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_69:;
    Py_DECREF( locals_PrecertPoison_886 );
    locals_PrecertPoison_886 = NULL;
    goto outline_result_26;
    // Exception handler code:
    try_except_handler_69:;
    exception_keeper_type_62 = exception_type;
    exception_keeper_value_62 = exception_value;
    exception_keeper_tb_62 = exception_tb;
    exception_keeper_lineno_62 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PrecertPoison_886 );
    locals_PrecertPoison_886 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_62;
    exception_value = exception_keeper_value_62;
    exception_tb = exception_keeper_tb_62;
    exception_lineno = exception_keeper_lineno_62;

    goto outline_exception_20;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_20:;
    exception_lineno = 886;
    goto try_except_handler_68;
    outline_result_26:;
    tmp_assign_source_169 = tmp_outline_return_value_26;
    assert( tmp_class_creation_23__class_dict == NULL );
    tmp_class_creation_23__class_dict = tmp_assign_source_169;

    tmp_compare_left_23 = const_str_plain___metaclass__;
    tmp_compare_right_23 = tmp_class_creation_23__class_dict;

    CHECK_OBJECT( tmp_compare_right_23 );
    tmp_cmp_In_23 = PySequence_Contains( tmp_compare_right_23, tmp_compare_left_23 );
    assert( !(tmp_cmp_In_23 == -1) );
    if ( tmp_cmp_In_23 == 1 )
    {
        goto condexpr_true_23;
    }
    else
    {
        goto condexpr_false_23;
    }
    condexpr_true_23:;
    tmp_dict_name_23 = tmp_class_creation_23__class_dict;

    CHECK_OBJECT( tmp_dict_name_23 );
    tmp_key_name_23 = const_str_plain___metaclass__;
    tmp_assign_source_170 = DICT_GET_ITEM( tmp_dict_name_23, tmp_key_name_23 );
    if ( tmp_assign_source_170 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 886;

        goto try_except_handler_68;
    }
    goto condexpr_end_23;
    condexpr_false_23:;
    tmp_assign_source_170 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_170 );
    condexpr_end_23:;
    assert( tmp_class_creation_23__metaclass == NULL );
    tmp_class_creation_23__metaclass = tmp_assign_source_170;

    tmp_called_name_55 = tmp_class_creation_23__metaclass;

    CHECK_OBJECT( tmp_called_name_55 );
    tmp_args_element_name_94 = const_str_plain_PrecertPoison;
    tmp_args_element_name_95 = const_tuple_type_object_tuple;
    tmp_args_element_name_96 = tmp_class_creation_23__class_dict;

    CHECK_OBJECT( tmp_args_element_name_96 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 886;
    {
        PyObject *call_args[] = { tmp_args_element_name_94, tmp_args_element_name_95, tmp_args_element_name_96 };
        tmp_assign_source_171 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_55, call_args );
    }

    if ( tmp_assign_source_171 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 886;

        goto try_except_handler_68;
    }
    assert( tmp_class_creation_23__class == NULL );
    tmp_class_creation_23__class = tmp_assign_source_171;

    tmp_source_name_31 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_31 == NULL ))
    {
        tmp_source_name_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_31 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 885;

        goto try_except_handler_68;
    }

    tmp_called_name_57 = LOOKUP_ATTRIBUTE( tmp_source_name_31, const_str_plain_register_interface );
    if ( tmp_called_name_57 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 885;

        goto try_except_handler_68;
    }
    tmp_args_element_name_97 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_97 == NULL ))
    {
        tmp_args_element_name_97 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_97 == NULL )
    {
        Py_DECREF( tmp_called_name_57 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 885;

        goto try_except_handler_68;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 885;
    {
        PyObject *call_args[] = { tmp_args_element_name_97 };
        tmp_called_name_56 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_57, call_args );
    }

    Py_DECREF( tmp_called_name_57 );
    if ( tmp_called_name_56 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 885;

        goto try_except_handler_68;
    }
    tmp_args_element_name_98 = tmp_class_creation_23__class;

    CHECK_OBJECT( tmp_args_element_name_98 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 885;
    {
        PyObject *call_args[] = { tmp_args_element_name_98 };
        tmp_assign_source_172 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_56, call_args );
    }

    Py_DECREF( tmp_called_name_56 );
    if ( tmp_assign_source_172 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 885;

        goto try_except_handler_68;
    }
    {
        PyObject *old = tmp_class_creation_23__class;
        assert( old != NULL );
        tmp_class_creation_23__class = tmp_assign_source_172;
        Py_DECREF( old );
    }

    goto try_end_40;
    // Exception handler code:
    try_except_handler_68:;
    exception_keeper_type_63 = exception_type;
    exception_keeper_value_63 = exception_value;
    exception_keeper_tb_63 = exception_tb;
    exception_keeper_lineno_63 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_23__class );
    tmp_class_creation_23__class = NULL;

    Py_XDECREF( tmp_class_creation_23__class_dict );
    tmp_class_creation_23__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_23__metaclass );
    tmp_class_creation_23__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_63;
    exception_value = exception_keeper_value_63;
    exception_tb = exception_keeper_tb_63;
    exception_lineno = exception_keeper_lineno_63;

    goto frame_exception_exit_1;
    // End of try:
    try_end_40:;
    tmp_assign_source_173 = tmp_class_creation_23__class;

    CHECK_OBJECT( tmp_assign_source_173 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PrecertPoison, tmp_assign_source_173 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_23__class );
    Py_DECREF( tmp_class_creation_23__class );
    tmp_class_creation_23__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_23__class_dict );
    Py_DECREF( tmp_class_creation_23__class_dict );
    tmp_class_creation_23__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_23__metaclass );
    Py_DECREF( tmp_class_creation_23__metaclass );
    tmp_class_creation_23__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_TLSFeature_906 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_TLSFeature_906, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22, codeobj_ee4b5c168c4ba5f7c4d2952f125f81bb, module_cryptography$x509$extensions, 0 );
    frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22 = cache_frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_32 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_32 == NULL ))
    {
        tmp_source_name_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_32 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 907;

        goto frame_exception_exit_22;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_32, const_str_plain_TLS_FEATURE );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 907;

        goto frame_exception_exit_22;
    }
    tmp_res = PyDict_SetItem( locals_TLSFeature_906, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 907;

        goto frame_exception_exit_22;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_101___init__(  );
    tmp_res = PyDict_SetItem( locals_TLSFeature_906, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_called_name_58 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );

    if (unlikely( tmp_called_name_58 == NULL ))
    {
        tmp_called_name_58 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );
    }

    if ( tmp_called_name_58 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_sequence_methods" );
        exception_tb = NULL;

        exception_lineno = 922;

        goto try_except_handler_72;
    }

    frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22->m_frame.f_lineno = 922;
    tmp_iter_arg_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_58, &PyTuple_GET_ITEM( const_tuple_str_plain__features_tuple, 0 ) );

    if ( tmp_iter_arg_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 922;

        goto try_except_handler_72;
    }
    tmp_assign_source_175 = MAKE_ITERATOR( tmp_iter_arg_7 );
    Py_DECREF( tmp_iter_arg_7 );
    if ( tmp_assign_source_175 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 922;

        goto try_except_handler_72;
    }
    assert( tmp_TLSFeature$tuple_unpack_1__source_iter == NULL );
    tmp_TLSFeature$tuple_unpack_1__source_iter = tmp_assign_source_175;

    // Tried code:
    tmp_unpack_19 = tmp_TLSFeature$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_19 );
    tmp_assign_source_176 = UNPACK_NEXT( tmp_unpack_19, 0 );
    if ( tmp_assign_source_176 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 922;
        goto try_except_handler_73;
    }
    assert( tmp_TLSFeature$tuple_unpack_1__element_1 == NULL );
    tmp_TLSFeature$tuple_unpack_1__element_1 = tmp_assign_source_176;

    tmp_unpack_20 = tmp_TLSFeature$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_20 );
    tmp_assign_source_177 = UNPACK_NEXT( tmp_unpack_20, 1 );
    if ( tmp_assign_source_177 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 922;
        goto try_except_handler_73;
    }
    assert( tmp_TLSFeature$tuple_unpack_1__element_2 == NULL );
    tmp_TLSFeature$tuple_unpack_1__element_2 = tmp_assign_source_177;

    tmp_unpack_21 = tmp_TLSFeature$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_21 );
    tmp_assign_source_178 = UNPACK_NEXT( tmp_unpack_21, 2 );
    if ( tmp_assign_source_178 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 922;
        goto try_except_handler_73;
    }
    assert( tmp_TLSFeature$tuple_unpack_1__element_3 == NULL );
    tmp_TLSFeature$tuple_unpack_1__element_3 = tmp_assign_source_178;

    tmp_iterator_name_7 = tmp_TLSFeature$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_7 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_7 ); assert( HAS_ITERNEXT( tmp_iterator_name_7 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_7 )->tp_iternext)( tmp_iterator_name_7 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 922;
                goto try_except_handler_73;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 922;
        goto try_except_handler_73;
    }
    goto try_end_41;
    // Exception handler code:
    try_except_handler_73:;
    exception_keeper_type_64 = exception_type;
    exception_keeper_value_64 = exception_value;
    exception_keeper_tb_64 = exception_tb;
    exception_keeper_lineno_64 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_TLSFeature$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_TLSFeature$tuple_unpack_1__source_iter );
    tmp_TLSFeature$tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_64;
    exception_value = exception_keeper_value_64;
    exception_tb = exception_keeper_tb_64;
    exception_lineno = exception_keeper_lineno_64;

    goto try_except_handler_72;
    // End of try:
    try_end_41:;
    goto try_end_42;
    // Exception handler code:
    try_except_handler_72:;
    exception_keeper_type_65 = exception_type;
    exception_keeper_value_65 = exception_value;
    exception_keeper_tb_65 = exception_tb;
    exception_keeper_lineno_65 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_TLSFeature$tuple_unpack_1__element_1 );
    tmp_TLSFeature$tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_TLSFeature$tuple_unpack_1__element_2 );
    tmp_TLSFeature$tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_TLSFeature$tuple_unpack_1__element_3 );
    tmp_TLSFeature$tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_65;
    exception_value = exception_keeper_value_65;
    exception_tb = exception_keeper_tb_65;
    exception_lineno = exception_keeper_lineno_65;

    goto frame_exception_exit_22;
    // End of try:
    try_end_42:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_21;

    frame_exception_exit_22:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22,
        type_description_2
    );


    // Release cached frame.
    if ( frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22 == cache_frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22 )
    {
        Py_DECREF( frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22 );
    }
    cache_frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22 = NULL;

    assertFrameObject( frame_ee4b5c168c4ba5f7c4d2952f125f81bb_22 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_21;

    frame_no_exception_21:;

    goto skip_nested_handling_21;
    nested_frame_exit_21:;

    goto try_except_handler_71;
    skip_nested_handling_21:;
    CHECK_OBJECT( (PyObject *)tmp_TLSFeature$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_TLSFeature$tuple_unpack_1__source_iter );
    tmp_TLSFeature$tuple_unpack_1__source_iter = NULL;

    tmp_dictset_value = tmp_TLSFeature$tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_TLSFeature_906, const_str_plain___len__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_TLSFeature$tuple_unpack_1__element_1 );
    tmp_TLSFeature$tuple_unpack_1__element_1 = NULL;

    tmp_dictset_value = tmp_TLSFeature$tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_TLSFeature_906, const_str_plain___iter__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_TLSFeature$tuple_unpack_1__element_2 );
    tmp_TLSFeature$tuple_unpack_1__element_2 = NULL;

    tmp_dictset_value = tmp_TLSFeature$tuple_unpack_1__element_3;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_TLSFeature_906, const_str_plain___getitem__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_TLSFeature$tuple_unpack_1__element_3 );
    tmp_TLSFeature$tuple_unpack_1__element_3 = NULL;

    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_102___repr__(  );
    tmp_res = PyDict_SetItem( locals_TLSFeature_906, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_103___eq__(  );
    tmp_res = PyDict_SetItem( locals_TLSFeature_906, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_104___ne__(  );
    tmp_res = PyDict_SetItem( locals_TLSFeature_906, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_105___hash__(  );
    tmp_res = PyDict_SetItem( locals_TLSFeature_906, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_27 = locals_TLSFeature_906;
    Py_INCREF( tmp_outline_return_value_27 );
    goto try_return_handler_71;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_71:;
    Py_DECREF( locals_TLSFeature_906 );
    locals_TLSFeature_906 = NULL;
    goto outline_result_27;
    // Exception handler code:
    try_except_handler_71:;
    exception_keeper_type_66 = exception_type;
    exception_keeper_value_66 = exception_value;
    exception_keeper_tb_66 = exception_tb;
    exception_keeper_lineno_66 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_TLSFeature_906 );
    locals_TLSFeature_906 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_66;
    exception_value = exception_keeper_value_66;
    exception_tb = exception_keeper_tb_66;
    exception_lineno = exception_keeper_lineno_66;

    goto outline_exception_21;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_21:;
    exception_lineno = 906;
    goto try_except_handler_70;
    outline_result_27:;
    tmp_assign_source_174 = tmp_outline_return_value_27;
    assert( tmp_class_creation_24__class_dict == NULL );
    tmp_class_creation_24__class_dict = tmp_assign_source_174;

    tmp_compare_left_24 = const_str_plain___metaclass__;
    tmp_compare_right_24 = tmp_class_creation_24__class_dict;

    CHECK_OBJECT( tmp_compare_right_24 );
    tmp_cmp_In_24 = PySequence_Contains( tmp_compare_right_24, tmp_compare_left_24 );
    assert( !(tmp_cmp_In_24 == -1) );
    if ( tmp_cmp_In_24 == 1 )
    {
        goto condexpr_true_24;
    }
    else
    {
        goto condexpr_false_24;
    }
    condexpr_true_24:;
    tmp_dict_name_24 = tmp_class_creation_24__class_dict;

    CHECK_OBJECT( tmp_dict_name_24 );
    tmp_key_name_24 = const_str_plain___metaclass__;
    tmp_assign_source_179 = DICT_GET_ITEM( tmp_dict_name_24, tmp_key_name_24 );
    if ( tmp_assign_source_179 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 906;

        goto try_except_handler_70;
    }
    goto condexpr_end_24;
    condexpr_false_24:;
    tmp_assign_source_179 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_179 );
    condexpr_end_24:;
    assert( tmp_class_creation_24__metaclass == NULL );
    tmp_class_creation_24__metaclass = tmp_assign_source_179;

    tmp_called_name_59 = tmp_class_creation_24__metaclass;

    CHECK_OBJECT( tmp_called_name_59 );
    tmp_args_element_name_99 = const_str_plain_TLSFeature;
    tmp_args_element_name_100 = const_tuple_type_object_tuple;
    tmp_args_element_name_101 = tmp_class_creation_24__class_dict;

    CHECK_OBJECT( tmp_args_element_name_101 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 906;
    {
        PyObject *call_args[] = { tmp_args_element_name_99, tmp_args_element_name_100, tmp_args_element_name_101 };
        tmp_assign_source_180 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_59, call_args );
    }

    if ( tmp_assign_source_180 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 906;

        goto try_except_handler_70;
    }
    assert( tmp_class_creation_24__class == NULL );
    tmp_class_creation_24__class = tmp_assign_source_180;

    tmp_source_name_33 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_33 == NULL ))
    {
        tmp_source_name_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_33 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 905;

        goto try_except_handler_70;
    }

    tmp_called_name_61 = LOOKUP_ATTRIBUTE( tmp_source_name_33, const_str_plain_register_interface );
    if ( tmp_called_name_61 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 905;

        goto try_except_handler_70;
    }
    tmp_args_element_name_102 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_102 == NULL ))
    {
        tmp_args_element_name_102 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_102 == NULL )
    {
        Py_DECREF( tmp_called_name_61 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 905;

        goto try_except_handler_70;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 905;
    {
        PyObject *call_args[] = { tmp_args_element_name_102 };
        tmp_called_name_60 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_61, call_args );
    }

    Py_DECREF( tmp_called_name_61 );
    if ( tmp_called_name_60 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 905;

        goto try_except_handler_70;
    }
    tmp_args_element_name_103 = tmp_class_creation_24__class;

    CHECK_OBJECT( tmp_args_element_name_103 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 905;
    {
        PyObject *call_args[] = { tmp_args_element_name_103 };
        tmp_assign_source_181 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_60, call_args );
    }

    Py_DECREF( tmp_called_name_60 );
    if ( tmp_assign_source_181 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 905;

        goto try_except_handler_70;
    }
    {
        PyObject *old = tmp_class_creation_24__class;
        assert( old != NULL );
        tmp_class_creation_24__class = tmp_assign_source_181;
        Py_DECREF( old );
    }

    goto try_end_43;
    // Exception handler code:
    try_except_handler_70:;
    exception_keeper_type_67 = exception_type;
    exception_keeper_value_67 = exception_value;
    exception_keeper_tb_67 = exception_tb;
    exception_keeper_lineno_67 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_24__class );
    tmp_class_creation_24__class = NULL;

    Py_XDECREF( tmp_class_creation_24__class_dict );
    tmp_class_creation_24__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_24__metaclass );
    tmp_class_creation_24__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_67;
    exception_value = exception_keeper_value_67;
    exception_tb = exception_keeper_tb_67;
    exception_lineno = exception_keeper_lineno_67;

    goto frame_exception_exit_1;
    // End of try:
    try_end_43:;
    tmp_assign_source_182 = tmp_class_creation_24__class;

    CHECK_OBJECT( tmp_assign_source_182 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_TLSFeature, tmp_assign_source_182 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_24__class );
    Py_DECREF( tmp_class_creation_24__class );
    tmp_class_creation_24__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_24__class_dict );
    Py_DECREF( tmp_class_creation_24__class_dict );
    tmp_class_creation_24__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_24__metaclass );
    Py_DECREF( tmp_class_creation_24__metaclass );
    tmp_class_creation_24__metaclass = NULL;

    // Tried code:
    tmp_assign_source_183 = PyTuple_New( 1 );
    tmp_tuple_element_4 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_Enum );

    if (unlikely( tmp_tuple_element_4 == NULL ))
    {
        tmp_tuple_element_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Enum );
    }

    if ( tmp_tuple_element_4 == NULL )
    {
        Py_DECREF( tmp_assign_source_183 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Enum" );
        exception_tb = NULL;

        exception_lineno = 940;

        goto try_except_handler_74;
    }

    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_assign_source_183, 0, tmp_tuple_element_4 );
    assert( tmp_class_creation_25__bases == NULL );
    tmp_class_creation_25__bases = tmp_assign_source_183;

    tmp_set_locals = PyDict_New();
    locals_TLSFeatureType_940 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_TLSFeatureType_940, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_int_pos_5;
    tmp_res = PyDict_SetItem( locals_TLSFeatureType_940, const_str_plain_status_request, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_int_pos_17;
    tmp_res = PyDict_SetItem( locals_TLSFeatureType_940, const_str_plain_status_request_v2, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_28 = locals_TLSFeatureType_940;
    Py_INCREF( tmp_outline_return_value_28 );
    goto try_return_handler_75;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_75:;
    Py_DECREF( locals_TLSFeatureType_940 );
    locals_TLSFeatureType_940 = NULL;
    goto outline_result_28;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_result_28:;
    tmp_assign_source_184 = tmp_outline_return_value_28;
    assert( tmp_class_creation_25__class_dict == NULL );
    tmp_class_creation_25__class_dict = tmp_assign_source_184;

    tmp_compare_left_25 = const_str_plain___metaclass__;
    tmp_compare_right_25 = tmp_class_creation_25__class_dict;

    CHECK_OBJECT( tmp_compare_right_25 );
    tmp_cmp_In_25 = PySequence_Contains( tmp_compare_right_25, tmp_compare_left_25 );
    assert( !(tmp_cmp_In_25 == -1) );
    if ( tmp_cmp_In_25 == 1 )
    {
        goto condexpr_true_25;
    }
    else
    {
        goto condexpr_false_25;
    }
    condexpr_true_25:;
    tmp_dict_name_25 = tmp_class_creation_25__class_dict;

    CHECK_OBJECT( tmp_dict_name_25 );
    tmp_key_name_25 = const_str_plain___metaclass__;
    tmp_assign_source_185 = DICT_GET_ITEM( tmp_dict_name_25, tmp_key_name_25 );
    if ( tmp_assign_source_185 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 940;

        goto try_except_handler_74;
    }
    goto condexpr_end_25;
    condexpr_false_25:;
    tmp_subscribed_name_4 = tmp_class_creation_25__bases;

    CHECK_OBJECT( tmp_subscribed_name_4 );
    tmp_subscript_name_4 = const_int_0;
    tmp_assign_source_186 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_assign_source_186 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 940;

        goto try_except_handler_74;
    }
    assert( tmp_select_metaclass_25__base == NULL );
    tmp_select_metaclass_25__base = tmp_assign_source_186;

    // Tried code:
    // Tried code:
    tmp_source_name_34 = tmp_select_metaclass_25__base;

    CHECK_OBJECT( tmp_source_name_34 );
    tmp_outline_return_value_29 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_34 );
    if ( tmp_outline_return_value_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 940;

        goto try_except_handler_77;
    }
    goto try_return_handler_76;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_77:;
    exception_keeper_type_68 = exception_type;
    exception_keeper_value_68 = exception_value;
    exception_keeper_tb_68 = exception_tb;
    exception_keeper_lineno_68 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_68 );
    Py_XDECREF( exception_keeper_value_68 );
    Py_XDECREF( exception_keeper_tb_68 );
    tmp_type_arg_4 = tmp_select_metaclass_25__base;

    CHECK_OBJECT( tmp_type_arg_4 );
    tmp_outline_return_value_29 = BUILTIN_TYPE1( tmp_type_arg_4 );
    assert( tmp_outline_return_value_29 != NULL );
    goto try_return_handler_76;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_76:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_25__base );
    Py_DECREF( tmp_select_metaclass_25__base );
    tmp_select_metaclass_25__base = NULL;

    goto outline_result_29;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_25__base );
    Py_DECREF( tmp_select_metaclass_25__base );
    tmp_select_metaclass_25__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_result_29:;
    tmp_assign_source_185 = tmp_outline_return_value_29;
    condexpr_end_25:;
    assert( tmp_class_creation_25__metaclass == NULL );
    tmp_class_creation_25__metaclass = tmp_assign_source_185;

    tmp_called_name_62 = tmp_class_creation_25__metaclass;

    CHECK_OBJECT( tmp_called_name_62 );
    tmp_args_element_name_104 = const_str_plain_TLSFeatureType;
    tmp_args_element_name_105 = tmp_class_creation_25__bases;

    CHECK_OBJECT( tmp_args_element_name_105 );
    tmp_args_element_name_106 = tmp_class_creation_25__class_dict;

    CHECK_OBJECT( tmp_args_element_name_106 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 940;
    {
        PyObject *call_args[] = { tmp_args_element_name_104, tmp_args_element_name_105, tmp_args_element_name_106 };
        tmp_assign_source_187 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_62, call_args );
    }

    if ( tmp_assign_source_187 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 940;

        goto try_except_handler_74;
    }
    assert( tmp_class_creation_25__class == NULL );
    tmp_class_creation_25__class = tmp_assign_source_187;

    goto try_end_44;
    // Exception handler code:
    try_except_handler_74:;
    exception_keeper_type_69 = exception_type;
    exception_keeper_value_69 = exception_value;
    exception_keeper_tb_69 = exception_tb;
    exception_keeper_lineno_69 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_25__bases );
    tmp_class_creation_25__bases = NULL;

    Py_XDECREF( tmp_class_creation_25__class_dict );
    tmp_class_creation_25__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_25__metaclass );
    tmp_class_creation_25__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_69;
    exception_value = exception_keeper_value_69;
    exception_tb = exception_keeper_tb_69;
    exception_lineno = exception_keeper_lineno_69;

    goto frame_exception_exit_1;
    // End of try:
    try_end_44:;
    tmp_assign_source_188 = tmp_class_creation_25__class;

    CHECK_OBJECT( tmp_assign_source_188 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_TLSFeatureType, tmp_assign_source_188 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_25__class );
    Py_DECREF( tmp_class_creation_25__class );
    tmp_class_creation_25__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_25__bases );
    Py_DECREF( tmp_class_creation_25__bases );
    tmp_class_creation_25__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_25__class_dict );
    Py_DECREF( tmp_class_creation_25__class_dict );
    tmp_class_creation_25__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_25__metaclass );
    Py_DECREF( tmp_class_creation_25__metaclass );
    tmp_class_creation_25__metaclass = NULL;

    tmp_iter_arg_8 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_TLSFeatureType );

    if (unlikely( tmp_iter_arg_8 == NULL ))
    {
        tmp_iter_arg_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSFeatureType );
    }

    if ( tmp_iter_arg_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "TLSFeatureType" );
        exception_tb = NULL;

        exception_lineno = 951;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_190 = MAKE_ITERATOR( tmp_iter_arg_8 );
    if ( tmp_assign_source_190 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 951;

        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_190;

    // Tried code:
    tmp_outline_return_value_30 = Nuitka_Generator_New(
        cryptography$x509$extensions$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_e3704f3371b37ff098d623844cfbee1e,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_30)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_30 ) >= 1 ); 


    goto try_return_handler_78;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_78:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_30;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_result_30:;
    tmp_dict_seq_1 = tmp_outline_return_value_30;
    tmp_assign_source_189 = TO_DICT( tmp_dict_seq_1, NULL );
    Py_DECREF( tmp_dict_seq_1 );
    if ( tmp_assign_source_189 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 951;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__TLS_FEATURE_TYPE_TO_ENUM, tmp_assign_source_189 );
    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_InhibitAnyPolicy_955 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_InhibitAnyPolicy_955, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_91766bb581ac47f3950cf4363ddf6101_23, codeobj_91766bb581ac47f3950cf4363ddf6101, module_cryptography$x509$extensions, 0 );
    frame_91766bb581ac47f3950cf4363ddf6101_23 = cache_frame_91766bb581ac47f3950cf4363ddf6101_23;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_91766bb581ac47f3950cf4363ddf6101_23 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_91766bb581ac47f3950cf4363ddf6101_23 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_35 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_35 == NULL ))
    {
        tmp_source_name_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_35 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 956;

        goto frame_exception_exit_23;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_35, const_str_plain_INHIBIT_ANY_POLICY );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 956;

        goto frame_exception_exit_23;
    }
    tmp_res = PyDict_SetItem( locals_InhibitAnyPolicy_955, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 956;

        goto frame_exception_exit_23;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_106___init__(  );
    tmp_res = PyDict_SetItem( locals_InhibitAnyPolicy_955, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_107___repr__(  );
    tmp_res = PyDict_SetItem( locals_InhibitAnyPolicy_955, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_108___eq__(  );
    tmp_res = PyDict_SetItem( locals_InhibitAnyPolicy_955, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_109___ne__(  );
    tmp_res = PyDict_SetItem( locals_InhibitAnyPolicy_955, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_110___hash__(  );
    tmp_res = PyDict_SetItem( locals_InhibitAnyPolicy_955, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_instance_24 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_24 == NULL ))
    {
        tmp_called_instance_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_24 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 982;

        goto frame_exception_exit_23;
    }

    frame_91766bb581ac47f3950cf4363ddf6101_23->m_frame.f_lineno = 982;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_24, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__skip_certs_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 982;

        goto frame_exception_exit_23;
    }
    tmp_res = PyDict_SetItem( locals_InhibitAnyPolicy_955, const_str_plain_skip_certs, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 982;

        goto frame_exception_exit_23;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_91766bb581ac47f3950cf4363ddf6101_23 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_22;

    frame_exception_exit_23:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_91766bb581ac47f3950cf4363ddf6101_23 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_91766bb581ac47f3950cf4363ddf6101_23, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_91766bb581ac47f3950cf4363ddf6101_23->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_91766bb581ac47f3950cf4363ddf6101_23, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_91766bb581ac47f3950cf4363ddf6101_23,
        type_description_2
    );


    // Release cached frame.
    if ( frame_91766bb581ac47f3950cf4363ddf6101_23 == cache_frame_91766bb581ac47f3950cf4363ddf6101_23 )
    {
        Py_DECREF( frame_91766bb581ac47f3950cf4363ddf6101_23 );
    }
    cache_frame_91766bb581ac47f3950cf4363ddf6101_23 = NULL;

    assertFrameObject( frame_91766bb581ac47f3950cf4363ddf6101_23 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_22;

    frame_no_exception_22:;

    goto skip_nested_handling_22;
    nested_frame_exit_22:;

    goto try_except_handler_80;
    skip_nested_handling_22:;
    tmp_outline_return_value_31 = locals_InhibitAnyPolicy_955;
    Py_INCREF( tmp_outline_return_value_31 );
    goto try_return_handler_80;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_80:;
    Py_DECREF( locals_InhibitAnyPolicy_955 );
    locals_InhibitAnyPolicy_955 = NULL;
    goto outline_result_31;
    // Exception handler code:
    try_except_handler_80:;
    exception_keeper_type_70 = exception_type;
    exception_keeper_value_70 = exception_value;
    exception_keeper_tb_70 = exception_tb;
    exception_keeper_lineno_70 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_InhibitAnyPolicy_955 );
    locals_InhibitAnyPolicy_955 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_70;
    exception_value = exception_keeper_value_70;
    exception_tb = exception_keeper_tb_70;
    exception_lineno = exception_keeper_lineno_70;

    goto outline_exception_22;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_22:;
    exception_lineno = 955;
    goto try_except_handler_79;
    outline_result_31:;
    tmp_assign_source_191 = tmp_outline_return_value_31;
    assert( tmp_class_creation_26__class_dict == NULL );
    tmp_class_creation_26__class_dict = tmp_assign_source_191;

    tmp_compare_left_26 = const_str_plain___metaclass__;
    tmp_compare_right_26 = tmp_class_creation_26__class_dict;

    CHECK_OBJECT( tmp_compare_right_26 );
    tmp_cmp_In_26 = PySequence_Contains( tmp_compare_right_26, tmp_compare_left_26 );
    assert( !(tmp_cmp_In_26 == -1) );
    if ( tmp_cmp_In_26 == 1 )
    {
        goto condexpr_true_26;
    }
    else
    {
        goto condexpr_false_26;
    }
    condexpr_true_26:;
    tmp_dict_name_26 = tmp_class_creation_26__class_dict;

    CHECK_OBJECT( tmp_dict_name_26 );
    tmp_key_name_26 = const_str_plain___metaclass__;
    tmp_assign_source_192 = DICT_GET_ITEM( tmp_dict_name_26, tmp_key_name_26 );
    if ( tmp_assign_source_192 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 955;

        goto try_except_handler_79;
    }
    goto condexpr_end_26;
    condexpr_false_26:;
    tmp_assign_source_192 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_192 );
    condexpr_end_26:;
    assert( tmp_class_creation_26__metaclass == NULL );
    tmp_class_creation_26__metaclass = tmp_assign_source_192;

    tmp_called_name_63 = tmp_class_creation_26__metaclass;

    CHECK_OBJECT( tmp_called_name_63 );
    tmp_args_element_name_107 = const_str_plain_InhibitAnyPolicy;
    tmp_args_element_name_108 = const_tuple_type_object_tuple;
    tmp_args_element_name_109 = tmp_class_creation_26__class_dict;

    CHECK_OBJECT( tmp_args_element_name_109 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 955;
    {
        PyObject *call_args[] = { tmp_args_element_name_107, tmp_args_element_name_108, tmp_args_element_name_109 };
        tmp_assign_source_193 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_63, call_args );
    }

    if ( tmp_assign_source_193 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 955;

        goto try_except_handler_79;
    }
    assert( tmp_class_creation_26__class == NULL );
    tmp_class_creation_26__class = tmp_assign_source_193;

    tmp_source_name_36 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_36 == NULL ))
    {
        tmp_source_name_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_36 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 954;

        goto try_except_handler_79;
    }

    tmp_called_name_65 = LOOKUP_ATTRIBUTE( tmp_source_name_36, const_str_plain_register_interface );
    if ( tmp_called_name_65 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 954;

        goto try_except_handler_79;
    }
    tmp_args_element_name_110 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_110 == NULL ))
    {
        tmp_args_element_name_110 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_110 == NULL )
    {
        Py_DECREF( tmp_called_name_65 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 954;

        goto try_except_handler_79;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 954;
    {
        PyObject *call_args[] = { tmp_args_element_name_110 };
        tmp_called_name_64 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_65, call_args );
    }

    Py_DECREF( tmp_called_name_65 );
    if ( tmp_called_name_64 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 954;

        goto try_except_handler_79;
    }
    tmp_args_element_name_111 = tmp_class_creation_26__class;

    CHECK_OBJECT( tmp_args_element_name_111 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 954;
    {
        PyObject *call_args[] = { tmp_args_element_name_111 };
        tmp_assign_source_194 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_64, call_args );
    }

    Py_DECREF( tmp_called_name_64 );
    if ( tmp_assign_source_194 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 954;

        goto try_except_handler_79;
    }
    {
        PyObject *old = tmp_class_creation_26__class;
        assert( old != NULL );
        tmp_class_creation_26__class = tmp_assign_source_194;
        Py_DECREF( old );
    }

    goto try_end_45;
    // Exception handler code:
    try_except_handler_79:;
    exception_keeper_type_71 = exception_type;
    exception_keeper_value_71 = exception_value;
    exception_keeper_tb_71 = exception_tb;
    exception_keeper_lineno_71 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_26__class );
    tmp_class_creation_26__class = NULL;

    Py_XDECREF( tmp_class_creation_26__class_dict );
    tmp_class_creation_26__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_26__metaclass );
    tmp_class_creation_26__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_71;
    exception_value = exception_keeper_value_71;
    exception_tb = exception_keeper_tb_71;
    exception_lineno = exception_keeper_lineno_71;

    goto frame_exception_exit_1;
    // End of try:
    try_end_45:;
    tmp_assign_source_195 = tmp_class_creation_26__class;

    CHECK_OBJECT( tmp_assign_source_195 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_InhibitAnyPolicy, tmp_assign_source_195 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_26__class );
    Py_DECREF( tmp_class_creation_26__class );
    tmp_class_creation_26__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_26__class_dict );
    Py_DECREF( tmp_class_creation_26__class_dict );
    tmp_class_creation_26__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_26__metaclass );
    Py_DECREF( tmp_class_creation_26__metaclass );
    tmp_class_creation_26__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_KeyUsage_986 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d7dc6886ba34e40cd7ef252f6e349251_24, codeobj_d7dc6886ba34e40cd7ef252f6e349251, module_cryptography$x509$extensions, 0 );
    frame_d7dc6886ba34e40cd7ef252f6e349251_24 = cache_frame_d7dc6886ba34e40cd7ef252f6e349251_24;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d7dc6886ba34e40cd7ef252f6e349251_24 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d7dc6886ba34e40cd7ef252f6e349251_24 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_37 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_37 == NULL ))
    {
        tmp_source_name_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_37 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 987;

        goto frame_exception_exit_24;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_37, const_str_plain_KEY_USAGE );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 987;

        goto frame_exception_exit_24;
    }
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 987;

        goto frame_exception_exit_24;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_111___init__(  );
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_instance_25 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_25 == NULL ))
    {
        tmp_called_instance_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_25 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1008;

        goto frame_exception_exit_24;
    }

    frame_d7dc6886ba34e40cd7ef252f6e349251_24->m_frame.f_lineno = 1008;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_25, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__digital_signature_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1008;

        goto frame_exception_exit_24;
    }
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain_digital_signature, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1008;

        goto frame_exception_exit_24;
    }
    tmp_called_instance_26 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_26 == NULL ))
    {
        tmp_called_instance_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_26 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1009;

        goto frame_exception_exit_24;
    }

    frame_d7dc6886ba34e40cd7ef252f6e349251_24->m_frame.f_lineno = 1009;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_26, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__content_commitment_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1009;

        goto frame_exception_exit_24;
    }
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain_content_commitment, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1009;

        goto frame_exception_exit_24;
    }
    tmp_called_instance_27 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_27 == NULL ))
    {
        tmp_called_instance_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_27 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1010;

        goto frame_exception_exit_24;
    }

    frame_d7dc6886ba34e40cd7ef252f6e349251_24->m_frame.f_lineno = 1010;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_27, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__key_encipherment_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1010;

        goto frame_exception_exit_24;
    }
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain_key_encipherment, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1010;

        goto frame_exception_exit_24;
    }
    tmp_called_instance_28 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_28 == NULL ))
    {
        tmp_called_instance_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_28 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1011;

        goto frame_exception_exit_24;
    }

    frame_d7dc6886ba34e40cd7ef252f6e349251_24->m_frame.f_lineno = 1011;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_28, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__data_encipherment_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1011;

        goto frame_exception_exit_24;
    }
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain_data_encipherment, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1011;

        goto frame_exception_exit_24;
    }
    tmp_called_instance_29 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_29 == NULL ))
    {
        tmp_called_instance_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_29 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1012;

        goto frame_exception_exit_24;
    }

    frame_d7dc6886ba34e40cd7ef252f6e349251_24->m_frame.f_lineno = 1012;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_29, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__key_agreement_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1012;

        goto frame_exception_exit_24;
    }
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain_key_agreement, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1012;

        goto frame_exception_exit_24;
    }
    tmp_called_instance_30 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_30 == NULL ))
    {
        tmp_called_instance_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_30 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1013;

        goto frame_exception_exit_24;
    }

    frame_d7dc6886ba34e40cd7ef252f6e349251_24->m_frame.f_lineno = 1013;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_30, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__key_cert_sign_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1013;

        goto frame_exception_exit_24;
    }
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain_key_cert_sign, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1013;

        goto frame_exception_exit_24;
    }
    tmp_called_instance_31 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_31 == NULL ))
    {
        tmp_called_instance_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_31 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1014;

        goto frame_exception_exit_24;
    }

    frame_d7dc6886ba34e40cd7ef252f6e349251_24->m_frame.f_lineno = 1014;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_31, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__crl_sign_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1014;

        goto frame_exception_exit_24;
    }
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain_crl_sign, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1014;

        goto frame_exception_exit_24;
    }
    tmp_called_name_66 = (PyObject *)&PyProperty_Type;
    tmp_args_element_name_112 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_112_encipher_only(  );
    frame_d7dc6886ba34e40cd7ef252f6e349251_24->m_frame.f_lineno = 1016;
    {
        PyObject *call_args[] = { tmp_args_element_name_112 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_66, call_args );
    }

    Py_DECREF( tmp_args_element_name_112 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1016;

        goto frame_exception_exit_24;
    }
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain_encipher_only, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1016;

        goto frame_exception_exit_24;
    }
    tmp_called_name_67 = (PyObject *)&PyProperty_Type;
    tmp_args_element_name_113 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_113_decipher_only(  );
    frame_d7dc6886ba34e40cd7ef252f6e349251_24->m_frame.f_lineno = 1025;
    {
        PyObject *call_args[] = { tmp_args_element_name_113 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_67, call_args );
    }

    Py_DECREF( tmp_args_element_name_113 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1025;

        goto frame_exception_exit_24;
    }
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain_decipher_only, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1025;

        goto frame_exception_exit_24;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d7dc6886ba34e40cd7ef252f6e349251_24 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_23;

    frame_exception_exit_24:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d7dc6886ba34e40cd7ef252f6e349251_24 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d7dc6886ba34e40cd7ef252f6e349251_24, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d7dc6886ba34e40cd7ef252f6e349251_24->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d7dc6886ba34e40cd7ef252f6e349251_24, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d7dc6886ba34e40cd7ef252f6e349251_24,
        type_description_2
    );


    // Release cached frame.
    if ( frame_d7dc6886ba34e40cd7ef252f6e349251_24 == cache_frame_d7dc6886ba34e40cd7ef252f6e349251_24 )
    {
        Py_DECREF( frame_d7dc6886ba34e40cd7ef252f6e349251_24 );
    }
    cache_frame_d7dc6886ba34e40cd7ef252f6e349251_24 = NULL;

    assertFrameObject( frame_d7dc6886ba34e40cd7ef252f6e349251_24 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_23;

    frame_no_exception_23:;

    goto skip_nested_handling_23;
    nested_frame_exit_23:;

    goto try_except_handler_82;
    skip_nested_handling_23:;
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_114___repr__(  );
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_115___eq__(  );
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_116___ne__(  );
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_117___hash__(  );
    tmp_res = PyDict_SetItem( locals_KeyUsage_986, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_32 = locals_KeyUsage_986;
    Py_INCREF( tmp_outline_return_value_32 );
    goto try_return_handler_82;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_82:;
    Py_DECREF( locals_KeyUsage_986 );
    locals_KeyUsage_986 = NULL;
    goto outline_result_32;
    // Exception handler code:
    try_except_handler_82:;
    exception_keeper_type_72 = exception_type;
    exception_keeper_value_72 = exception_value;
    exception_keeper_tb_72 = exception_tb;
    exception_keeper_lineno_72 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_KeyUsage_986 );
    locals_KeyUsage_986 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_72;
    exception_value = exception_keeper_value_72;
    exception_tb = exception_keeper_tb_72;
    exception_lineno = exception_keeper_lineno_72;

    goto outline_exception_23;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_23:;
    exception_lineno = 986;
    goto try_except_handler_81;
    outline_result_32:;
    tmp_assign_source_196 = tmp_outline_return_value_32;
    assert( tmp_class_creation_27__class_dict == NULL );
    tmp_class_creation_27__class_dict = tmp_assign_source_196;

    tmp_compare_left_27 = const_str_plain___metaclass__;
    tmp_compare_right_27 = tmp_class_creation_27__class_dict;

    CHECK_OBJECT( tmp_compare_right_27 );
    tmp_cmp_In_27 = PySequence_Contains( tmp_compare_right_27, tmp_compare_left_27 );
    assert( !(tmp_cmp_In_27 == -1) );
    if ( tmp_cmp_In_27 == 1 )
    {
        goto condexpr_true_27;
    }
    else
    {
        goto condexpr_false_27;
    }
    condexpr_true_27:;
    tmp_dict_name_27 = tmp_class_creation_27__class_dict;

    CHECK_OBJECT( tmp_dict_name_27 );
    tmp_key_name_27 = const_str_plain___metaclass__;
    tmp_assign_source_197 = DICT_GET_ITEM( tmp_dict_name_27, tmp_key_name_27 );
    if ( tmp_assign_source_197 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 986;

        goto try_except_handler_81;
    }
    goto condexpr_end_27;
    condexpr_false_27:;
    tmp_assign_source_197 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_197 );
    condexpr_end_27:;
    assert( tmp_class_creation_27__metaclass == NULL );
    tmp_class_creation_27__metaclass = tmp_assign_source_197;

    tmp_called_name_68 = tmp_class_creation_27__metaclass;

    CHECK_OBJECT( tmp_called_name_68 );
    tmp_args_element_name_114 = const_str_plain_KeyUsage;
    tmp_args_element_name_115 = const_tuple_type_object_tuple;
    tmp_args_element_name_116 = tmp_class_creation_27__class_dict;

    CHECK_OBJECT( tmp_args_element_name_116 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 986;
    {
        PyObject *call_args[] = { tmp_args_element_name_114, tmp_args_element_name_115, tmp_args_element_name_116 };
        tmp_assign_source_198 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_68, call_args );
    }

    if ( tmp_assign_source_198 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 986;

        goto try_except_handler_81;
    }
    assert( tmp_class_creation_27__class == NULL );
    tmp_class_creation_27__class = tmp_assign_source_198;

    tmp_source_name_38 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_38 == NULL ))
    {
        tmp_source_name_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_38 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 985;

        goto try_except_handler_81;
    }

    tmp_called_name_70 = LOOKUP_ATTRIBUTE( tmp_source_name_38, const_str_plain_register_interface );
    if ( tmp_called_name_70 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 985;

        goto try_except_handler_81;
    }
    tmp_args_element_name_117 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_117 == NULL ))
    {
        tmp_args_element_name_117 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_117 == NULL )
    {
        Py_DECREF( tmp_called_name_70 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 985;

        goto try_except_handler_81;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 985;
    {
        PyObject *call_args[] = { tmp_args_element_name_117 };
        tmp_called_name_69 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_70, call_args );
    }

    Py_DECREF( tmp_called_name_70 );
    if ( tmp_called_name_69 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 985;

        goto try_except_handler_81;
    }
    tmp_args_element_name_118 = tmp_class_creation_27__class;

    CHECK_OBJECT( tmp_args_element_name_118 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 985;
    {
        PyObject *call_args[] = { tmp_args_element_name_118 };
        tmp_assign_source_199 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_69, call_args );
    }

    Py_DECREF( tmp_called_name_69 );
    if ( tmp_assign_source_199 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 985;

        goto try_except_handler_81;
    }
    {
        PyObject *old = tmp_class_creation_27__class;
        assert( old != NULL );
        tmp_class_creation_27__class = tmp_assign_source_199;
        Py_DECREF( old );
    }

    goto try_end_46;
    // Exception handler code:
    try_except_handler_81:;
    exception_keeper_type_73 = exception_type;
    exception_keeper_value_73 = exception_value;
    exception_keeper_tb_73 = exception_tb;
    exception_keeper_lineno_73 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_27__class );
    tmp_class_creation_27__class = NULL;

    Py_XDECREF( tmp_class_creation_27__class_dict );
    tmp_class_creation_27__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_27__metaclass );
    tmp_class_creation_27__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_73;
    exception_value = exception_keeper_value_73;
    exception_tb = exception_keeper_tb_73;
    exception_lineno = exception_keeper_lineno_73;

    goto frame_exception_exit_1;
    // End of try:
    try_end_46:;
    tmp_assign_source_200 = tmp_class_creation_27__class;

    CHECK_OBJECT( tmp_assign_source_200 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_KeyUsage, tmp_assign_source_200 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_27__class );
    Py_DECREF( tmp_class_creation_27__class );
    tmp_class_creation_27__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_27__class_dict );
    Py_DECREF( tmp_class_creation_27__class_dict );
    tmp_class_creation_27__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_27__metaclass );
    Py_DECREF( tmp_class_creation_27__metaclass );
    tmp_class_creation_27__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_NameConstraints_1081 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_NameConstraints_1081, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d1c2e4d7460a8ac2798c7a347fc9360d_25, codeobj_d1c2e4d7460a8ac2798c7a347fc9360d, module_cryptography$x509$extensions, 0 );
    frame_d1c2e4d7460a8ac2798c7a347fc9360d_25 = cache_frame_d1c2e4d7460a8ac2798c7a347fc9360d_25;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d1c2e4d7460a8ac2798c7a347fc9360d_25 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d1c2e4d7460a8ac2798c7a347fc9360d_25 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_39 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_39 == NULL ))
    {
        tmp_source_name_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_39 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 1082;

        goto frame_exception_exit_25;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_39, const_str_plain_NAME_CONSTRAINTS );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1082;

        goto frame_exception_exit_25;
    }
    tmp_res = PyDict_SetItem( locals_NameConstraints_1081, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1082;

        goto frame_exception_exit_25;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_118___init__(  );
    tmp_res = PyDict_SetItem( locals_NameConstraints_1081, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_119___eq__(  );
    tmp_res = PyDict_SetItem( locals_NameConstraints_1081, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_120___ne__(  );
    tmp_res = PyDict_SetItem( locals_NameConstraints_1081, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_121__validate_ip_name(  );
    tmp_res = PyDict_SetItem( locals_NameConstraints_1081, const_str_plain__validate_ip_name, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_122___repr__(  );
    tmp_res = PyDict_SetItem( locals_NameConstraints_1081, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_123___hash__(  );
    tmp_res = PyDict_SetItem( locals_NameConstraints_1081, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_instance_32 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_32 == NULL ))
    {
        tmp_called_instance_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_32 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1158;

        goto frame_exception_exit_25;
    }

    frame_d1c2e4d7460a8ac2798c7a347fc9360d_25->m_frame.f_lineno = 1158;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_32, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__permitted_subtrees_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1158;

        goto frame_exception_exit_25;
    }
    tmp_res = PyDict_SetItem( locals_NameConstraints_1081, const_str_plain_permitted_subtrees, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1158;

        goto frame_exception_exit_25;
    }
    tmp_called_instance_33 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_33 == NULL ))
    {
        tmp_called_instance_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_33 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1159;

        goto frame_exception_exit_25;
    }

    frame_d1c2e4d7460a8ac2798c7a347fc9360d_25->m_frame.f_lineno = 1159;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_33, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__excluded_subtrees_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto frame_exception_exit_25;
    }
    tmp_res = PyDict_SetItem( locals_NameConstraints_1081, const_str_plain_excluded_subtrees, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto frame_exception_exit_25;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d1c2e4d7460a8ac2798c7a347fc9360d_25 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_24;

    frame_exception_exit_25:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d1c2e4d7460a8ac2798c7a347fc9360d_25 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d1c2e4d7460a8ac2798c7a347fc9360d_25, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d1c2e4d7460a8ac2798c7a347fc9360d_25->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d1c2e4d7460a8ac2798c7a347fc9360d_25, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d1c2e4d7460a8ac2798c7a347fc9360d_25,
        type_description_2
    );


    // Release cached frame.
    if ( frame_d1c2e4d7460a8ac2798c7a347fc9360d_25 == cache_frame_d1c2e4d7460a8ac2798c7a347fc9360d_25 )
    {
        Py_DECREF( frame_d1c2e4d7460a8ac2798c7a347fc9360d_25 );
    }
    cache_frame_d1c2e4d7460a8ac2798c7a347fc9360d_25 = NULL;

    assertFrameObject( frame_d1c2e4d7460a8ac2798c7a347fc9360d_25 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_24;

    frame_no_exception_24:;

    goto skip_nested_handling_24;
    nested_frame_exit_24:;

    goto try_except_handler_84;
    skip_nested_handling_24:;
    tmp_outline_return_value_33 = locals_NameConstraints_1081;
    Py_INCREF( tmp_outline_return_value_33 );
    goto try_return_handler_84;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_84:;
    Py_DECREF( locals_NameConstraints_1081 );
    locals_NameConstraints_1081 = NULL;
    goto outline_result_33;
    // Exception handler code:
    try_except_handler_84:;
    exception_keeper_type_74 = exception_type;
    exception_keeper_value_74 = exception_value;
    exception_keeper_tb_74 = exception_tb;
    exception_keeper_lineno_74 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_NameConstraints_1081 );
    locals_NameConstraints_1081 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_74;
    exception_value = exception_keeper_value_74;
    exception_tb = exception_keeper_tb_74;
    exception_lineno = exception_keeper_lineno_74;

    goto outline_exception_24;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_24:;
    exception_lineno = 1081;
    goto try_except_handler_83;
    outline_result_33:;
    tmp_assign_source_201 = tmp_outline_return_value_33;
    assert( tmp_class_creation_28__class_dict == NULL );
    tmp_class_creation_28__class_dict = tmp_assign_source_201;

    tmp_compare_left_28 = const_str_plain___metaclass__;
    tmp_compare_right_28 = tmp_class_creation_28__class_dict;

    CHECK_OBJECT( tmp_compare_right_28 );
    tmp_cmp_In_28 = PySequence_Contains( tmp_compare_right_28, tmp_compare_left_28 );
    assert( !(tmp_cmp_In_28 == -1) );
    if ( tmp_cmp_In_28 == 1 )
    {
        goto condexpr_true_28;
    }
    else
    {
        goto condexpr_false_28;
    }
    condexpr_true_28:;
    tmp_dict_name_28 = tmp_class_creation_28__class_dict;

    CHECK_OBJECT( tmp_dict_name_28 );
    tmp_key_name_28 = const_str_plain___metaclass__;
    tmp_assign_source_202 = DICT_GET_ITEM( tmp_dict_name_28, tmp_key_name_28 );
    if ( tmp_assign_source_202 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1081;

        goto try_except_handler_83;
    }
    goto condexpr_end_28;
    condexpr_false_28:;
    tmp_assign_source_202 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_202 );
    condexpr_end_28:;
    assert( tmp_class_creation_28__metaclass == NULL );
    tmp_class_creation_28__metaclass = tmp_assign_source_202;

    tmp_called_name_71 = tmp_class_creation_28__metaclass;

    CHECK_OBJECT( tmp_called_name_71 );
    tmp_args_element_name_119 = const_str_plain_NameConstraints;
    tmp_args_element_name_120 = const_tuple_type_object_tuple;
    tmp_args_element_name_121 = tmp_class_creation_28__class_dict;

    CHECK_OBJECT( tmp_args_element_name_121 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1081;
    {
        PyObject *call_args[] = { tmp_args_element_name_119, tmp_args_element_name_120, tmp_args_element_name_121 };
        tmp_assign_source_203 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_71, call_args );
    }

    if ( tmp_assign_source_203 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1081;

        goto try_except_handler_83;
    }
    assert( tmp_class_creation_28__class == NULL );
    tmp_class_creation_28__class = tmp_assign_source_203;

    tmp_source_name_40 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_40 == NULL ))
    {
        tmp_source_name_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_40 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1080;

        goto try_except_handler_83;
    }

    tmp_called_name_73 = LOOKUP_ATTRIBUTE( tmp_source_name_40, const_str_plain_register_interface );
    if ( tmp_called_name_73 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1080;

        goto try_except_handler_83;
    }
    tmp_args_element_name_122 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_122 == NULL ))
    {
        tmp_args_element_name_122 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_122 == NULL )
    {
        Py_DECREF( tmp_called_name_73 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 1080;

        goto try_except_handler_83;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1080;
    {
        PyObject *call_args[] = { tmp_args_element_name_122 };
        tmp_called_name_72 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_73, call_args );
    }

    Py_DECREF( tmp_called_name_73 );
    if ( tmp_called_name_72 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1080;

        goto try_except_handler_83;
    }
    tmp_args_element_name_123 = tmp_class_creation_28__class;

    CHECK_OBJECT( tmp_args_element_name_123 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1080;
    {
        PyObject *call_args[] = { tmp_args_element_name_123 };
        tmp_assign_source_204 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_72, call_args );
    }

    Py_DECREF( tmp_called_name_72 );
    if ( tmp_assign_source_204 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1080;

        goto try_except_handler_83;
    }
    {
        PyObject *old = tmp_class_creation_28__class;
        assert( old != NULL );
        tmp_class_creation_28__class = tmp_assign_source_204;
        Py_DECREF( old );
    }

    goto try_end_47;
    // Exception handler code:
    try_except_handler_83:;
    exception_keeper_type_75 = exception_type;
    exception_keeper_value_75 = exception_value;
    exception_keeper_tb_75 = exception_tb;
    exception_keeper_lineno_75 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_28__class );
    tmp_class_creation_28__class = NULL;

    Py_XDECREF( tmp_class_creation_28__class_dict );
    tmp_class_creation_28__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_28__metaclass );
    tmp_class_creation_28__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_75;
    exception_value = exception_keeper_value_75;
    exception_tb = exception_keeper_tb_75;
    exception_lineno = exception_keeper_lineno_75;

    goto frame_exception_exit_1;
    // End of try:
    try_end_47:;
    tmp_assign_source_205 = tmp_class_creation_28__class;

    CHECK_OBJECT( tmp_assign_source_205 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_NameConstraints, tmp_assign_source_205 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_28__class );
    Py_DECREF( tmp_class_creation_28__class );
    tmp_class_creation_28__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_28__class_dict );
    Py_DECREF( tmp_class_creation_28__class_dict );
    tmp_class_creation_28__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_28__metaclass );
    Py_DECREF( tmp_class_creation_28__metaclass );
    tmp_class_creation_28__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_Extension_1162 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_Extension_1162, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_124___init__(  );
    tmp_res = PyDict_SetItem( locals_Extension_1162, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cf753b2aac21c54581e397ad48de68ce_26, codeobj_cf753b2aac21c54581e397ad48de68ce, module_cryptography$x509$extensions, 0 );
    frame_cf753b2aac21c54581e397ad48de68ce_26 = cache_frame_cf753b2aac21c54581e397ad48de68ce_26;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cf753b2aac21c54581e397ad48de68ce_26 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cf753b2aac21c54581e397ad48de68ce_26 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_34 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_34 == NULL ))
    {
        tmp_called_instance_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_34 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1176;

        goto frame_exception_exit_26;
    }

    frame_cf753b2aac21c54581e397ad48de68ce_26->m_frame.f_lineno = 1176;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_34, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__oid_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1176;

        goto frame_exception_exit_26;
    }
    tmp_res = PyDict_SetItem( locals_Extension_1162, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1176;

        goto frame_exception_exit_26;
    }
    tmp_called_instance_35 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_35 == NULL ))
    {
        tmp_called_instance_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_35 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1177;

        goto frame_exception_exit_26;
    }

    frame_cf753b2aac21c54581e397ad48de68ce_26->m_frame.f_lineno = 1177;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_35, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__critical_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1177;

        goto frame_exception_exit_26;
    }
    tmp_res = PyDict_SetItem( locals_Extension_1162, const_str_plain_critical, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1177;

        goto frame_exception_exit_26;
    }
    tmp_called_instance_36 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_36 == NULL ))
    {
        tmp_called_instance_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_36 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1178;

        goto frame_exception_exit_26;
    }

    frame_cf753b2aac21c54581e397ad48de68ce_26->m_frame.f_lineno = 1178;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_36, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__value_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1178;

        goto frame_exception_exit_26;
    }
    tmp_res = PyDict_SetItem( locals_Extension_1162, const_str_plain_value, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1178;

        goto frame_exception_exit_26;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cf753b2aac21c54581e397ad48de68ce_26 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_25;

    frame_exception_exit_26:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cf753b2aac21c54581e397ad48de68ce_26 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cf753b2aac21c54581e397ad48de68ce_26, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cf753b2aac21c54581e397ad48de68ce_26->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cf753b2aac21c54581e397ad48de68ce_26, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cf753b2aac21c54581e397ad48de68ce_26,
        type_description_2
    );


    // Release cached frame.
    if ( frame_cf753b2aac21c54581e397ad48de68ce_26 == cache_frame_cf753b2aac21c54581e397ad48de68ce_26 )
    {
        Py_DECREF( frame_cf753b2aac21c54581e397ad48de68ce_26 );
    }
    cache_frame_cf753b2aac21c54581e397ad48de68ce_26 = NULL;

    assertFrameObject( frame_cf753b2aac21c54581e397ad48de68ce_26 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_25;

    frame_no_exception_25:;

    goto skip_nested_handling_25;
    nested_frame_exit_25:;

    goto try_except_handler_86;
    skip_nested_handling_25:;
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_125___repr__(  );
    tmp_res = PyDict_SetItem( locals_Extension_1162, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_126___eq__(  );
    tmp_res = PyDict_SetItem( locals_Extension_1162, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_127___ne__(  );
    tmp_res = PyDict_SetItem( locals_Extension_1162, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_128___hash__(  );
    tmp_res = PyDict_SetItem( locals_Extension_1162, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_34 = locals_Extension_1162;
    Py_INCREF( tmp_outline_return_value_34 );
    goto try_return_handler_86;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_86:;
    Py_DECREF( locals_Extension_1162 );
    locals_Extension_1162 = NULL;
    goto outline_result_34;
    // Exception handler code:
    try_except_handler_86:;
    exception_keeper_type_76 = exception_type;
    exception_keeper_value_76 = exception_value;
    exception_keeper_tb_76 = exception_tb;
    exception_keeper_lineno_76 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_Extension_1162 );
    locals_Extension_1162 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_76;
    exception_value = exception_keeper_value_76;
    exception_tb = exception_keeper_tb_76;
    exception_lineno = exception_keeper_lineno_76;

    goto outline_exception_25;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_25:;
    exception_lineno = 1162;
    goto try_except_handler_85;
    outline_result_34:;
    tmp_assign_source_206 = tmp_outline_return_value_34;
    assert( tmp_class_creation_29__class_dict == NULL );
    tmp_class_creation_29__class_dict = tmp_assign_source_206;

    tmp_compare_left_29 = const_str_plain___metaclass__;
    tmp_compare_right_29 = tmp_class_creation_29__class_dict;

    CHECK_OBJECT( tmp_compare_right_29 );
    tmp_cmp_In_29 = PySequence_Contains( tmp_compare_right_29, tmp_compare_left_29 );
    assert( !(tmp_cmp_In_29 == -1) );
    if ( tmp_cmp_In_29 == 1 )
    {
        goto condexpr_true_29;
    }
    else
    {
        goto condexpr_false_29;
    }
    condexpr_true_29:;
    tmp_dict_name_29 = tmp_class_creation_29__class_dict;

    CHECK_OBJECT( tmp_dict_name_29 );
    tmp_key_name_29 = const_str_plain___metaclass__;
    tmp_assign_source_207 = DICT_GET_ITEM( tmp_dict_name_29, tmp_key_name_29 );
    if ( tmp_assign_source_207 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1162;

        goto try_except_handler_85;
    }
    goto condexpr_end_29;
    condexpr_false_29:;
    tmp_assign_source_207 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_207 );
    condexpr_end_29:;
    assert( tmp_class_creation_29__metaclass == NULL );
    tmp_class_creation_29__metaclass = tmp_assign_source_207;

    tmp_called_name_74 = tmp_class_creation_29__metaclass;

    CHECK_OBJECT( tmp_called_name_74 );
    tmp_args_element_name_124 = const_str_plain_Extension;
    tmp_args_element_name_125 = const_tuple_type_object_tuple;
    tmp_args_element_name_126 = tmp_class_creation_29__class_dict;

    CHECK_OBJECT( tmp_args_element_name_126 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1162;
    {
        PyObject *call_args[] = { tmp_args_element_name_124, tmp_args_element_name_125, tmp_args_element_name_126 };
        tmp_assign_source_208 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_74, call_args );
    }

    if ( tmp_assign_source_208 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1162;

        goto try_except_handler_85;
    }
    assert( tmp_class_creation_29__class == NULL );
    tmp_class_creation_29__class = tmp_assign_source_208;

    goto try_end_48;
    // Exception handler code:
    try_except_handler_85:;
    exception_keeper_type_77 = exception_type;
    exception_keeper_value_77 = exception_value;
    exception_keeper_tb_77 = exception_tb;
    exception_keeper_lineno_77 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_29__class_dict );
    tmp_class_creation_29__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_29__metaclass );
    tmp_class_creation_29__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_77;
    exception_value = exception_keeper_value_77;
    exception_tb = exception_keeper_tb_77;
    exception_lineno = exception_keeper_lineno_77;

    goto frame_exception_exit_1;
    // End of try:
    try_end_48:;
    tmp_assign_source_209 = tmp_class_creation_29__class;

    CHECK_OBJECT( tmp_assign_source_209 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_Extension, tmp_assign_source_209 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_29__class );
    Py_DECREF( tmp_class_creation_29__class );
    tmp_class_creation_29__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_29__class_dict );
    Py_DECREF( tmp_class_creation_29__class_dict );
    tmp_class_creation_29__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_29__metaclass );
    Py_DECREF( tmp_class_creation_29__metaclass );
    tmp_class_creation_29__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_GeneralNames_1201 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_GeneralNames_1201, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_129___init__(  );
    tmp_res = PyDict_SetItem( locals_GeneralNames_1201, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f6cb175ee3c5700aba57c91b105c56e0_27, codeobj_f6cb175ee3c5700aba57c91b105c56e0, module_cryptography$x509$extensions, 0 );
    frame_f6cb175ee3c5700aba57c91b105c56e0_27 = cache_frame_f6cb175ee3c5700aba57c91b105c56e0_27;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f6cb175ee3c5700aba57c91b105c56e0_27 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f6cb175ee3c5700aba57c91b105c56e0_27 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_called_name_75 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );

    if (unlikely( tmp_called_name_75 == NULL ))
    {
        tmp_called_name_75 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );
    }

    if ( tmp_called_name_75 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_sequence_methods" );
        exception_tb = NULL;

        exception_lineno = 1211;

        goto try_except_handler_89;
    }

    frame_f6cb175ee3c5700aba57c91b105c56e0_27->m_frame.f_lineno = 1211;
    tmp_iter_arg_9 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_75, &PyTuple_GET_ITEM( const_tuple_str_plain__general_names_tuple, 0 ) );

    if ( tmp_iter_arg_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1211;

        goto try_except_handler_89;
    }
    tmp_assign_source_211 = MAKE_ITERATOR( tmp_iter_arg_9 );
    Py_DECREF( tmp_iter_arg_9 );
    if ( tmp_assign_source_211 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1211;

        goto try_except_handler_89;
    }
    assert( tmp_GeneralNames$tuple_unpack_1__source_iter == NULL );
    tmp_GeneralNames$tuple_unpack_1__source_iter = tmp_assign_source_211;

    // Tried code:
    tmp_unpack_22 = tmp_GeneralNames$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_22 );
    tmp_assign_source_212 = UNPACK_NEXT( tmp_unpack_22, 0 );
    if ( tmp_assign_source_212 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1211;
        goto try_except_handler_90;
    }
    assert( tmp_GeneralNames$tuple_unpack_1__element_1 == NULL );
    tmp_GeneralNames$tuple_unpack_1__element_1 = tmp_assign_source_212;

    tmp_unpack_23 = tmp_GeneralNames$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_23 );
    tmp_assign_source_213 = UNPACK_NEXT( tmp_unpack_23, 1 );
    if ( tmp_assign_source_213 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1211;
        goto try_except_handler_90;
    }
    assert( tmp_GeneralNames$tuple_unpack_1__element_2 == NULL );
    tmp_GeneralNames$tuple_unpack_1__element_2 = tmp_assign_source_213;

    tmp_unpack_24 = tmp_GeneralNames$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_24 );
    tmp_assign_source_214 = UNPACK_NEXT( tmp_unpack_24, 2 );
    if ( tmp_assign_source_214 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1211;
        goto try_except_handler_90;
    }
    assert( tmp_GeneralNames$tuple_unpack_1__element_3 == NULL );
    tmp_GeneralNames$tuple_unpack_1__element_3 = tmp_assign_source_214;

    tmp_iterator_name_8 = tmp_GeneralNames$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_8 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_8 ); assert( HAS_ITERNEXT( tmp_iterator_name_8 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_8 )->tp_iternext)( tmp_iterator_name_8 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1211;
                goto try_except_handler_90;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1211;
        goto try_except_handler_90;
    }
    goto try_end_49;
    // Exception handler code:
    try_except_handler_90:;
    exception_keeper_type_78 = exception_type;
    exception_keeper_value_78 = exception_value;
    exception_keeper_tb_78 = exception_tb;
    exception_keeper_lineno_78 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_GeneralNames$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_GeneralNames$tuple_unpack_1__source_iter );
    tmp_GeneralNames$tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_78;
    exception_value = exception_keeper_value_78;
    exception_tb = exception_keeper_tb_78;
    exception_lineno = exception_keeper_lineno_78;

    goto try_except_handler_89;
    // End of try:
    try_end_49:;
    goto try_end_50;
    // Exception handler code:
    try_except_handler_89:;
    exception_keeper_type_79 = exception_type;
    exception_keeper_value_79 = exception_value;
    exception_keeper_tb_79 = exception_tb;
    exception_keeper_lineno_79 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_GeneralNames$tuple_unpack_1__element_1 );
    tmp_GeneralNames$tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_GeneralNames$tuple_unpack_1__element_2 );
    tmp_GeneralNames$tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_GeneralNames$tuple_unpack_1__element_3 );
    tmp_GeneralNames$tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_79;
    exception_value = exception_keeper_value_79;
    exception_tb = exception_keeper_tb_79;
    exception_lineno = exception_keeper_lineno_79;

    goto frame_exception_exit_27;
    // End of try:
    try_end_50:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f6cb175ee3c5700aba57c91b105c56e0_27 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_26;

    frame_exception_exit_27:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f6cb175ee3c5700aba57c91b105c56e0_27 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f6cb175ee3c5700aba57c91b105c56e0_27, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f6cb175ee3c5700aba57c91b105c56e0_27->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f6cb175ee3c5700aba57c91b105c56e0_27, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f6cb175ee3c5700aba57c91b105c56e0_27,
        type_description_2
    );


    // Release cached frame.
    if ( frame_f6cb175ee3c5700aba57c91b105c56e0_27 == cache_frame_f6cb175ee3c5700aba57c91b105c56e0_27 )
    {
        Py_DECREF( frame_f6cb175ee3c5700aba57c91b105c56e0_27 );
    }
    cache_frame_f6cb175ee3c5700aba57c91b105c56e0_27 = NULL;

    assertFrameObject( frame_f6cb175ee3c5700aba57c91b105c56e0_27 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_26;

    frame_no_exception_26:;

    goto skip_nested_handling_26;
    nested_frame_exit_26:;

    goto try_except_handler_88;
    skip_nested_handling_26:;
    CHECK_OBJECT( (PyObject *)tmp_GeneralNames$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_GeneralNames$tuple_unpack_1__source_iter );
    tmp_GeneralNames$tuple_unpack_1__source_iter = NULL;

    tmp_dictset_value = tmp_GeneralNames$tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_GeneralNames_1201, const_str_plain___len__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_GeneralNames$tuple_unpack_1__element_1 );
    tmp_GeneralNames$tuple_unpack_1__element_1 = NULL;

    tmp_dictset_value = tmp_GeneralNames$tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_GeneralNames_1201, const_str_plain___iter__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_GeneralNames$tuple_unpack_1__element_2 );
    tmp_GeneralNames$tuple_unpack_1__element_2 = NULL;

    tmp_dictset_value = tmp_GeneralNames$tuple_unpack_1__element_3;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_GeneralNames_1201, const_str_plain___getitem__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_GeneralNames$tuple_unpack_1__element_3 );
    tmp_GeneralNames$tuple_unpack_1__element_3 = NULL;

    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_130_get_values_for_type(  );
    tmp_res = PyDict_SetItem( locals_GeneralNames_1201, const_str_plain_get_values_for_type, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_131___repr__(  );
    tmp_res = PyDict_SetItem( locals_GeneralNames_1201, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_132___eq__(  );
    tmp_res = PyDict_SetItem( locals_GeneralNames_1201, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_133___ne__(  );
    tmp_res = PyDict_SetItem( locals_GeneralNames_1201, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_134___hash__(  );
    tmp_res = PyDict_SetItem( locals_GeneralNames_1201, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_35 = locals_GeneralNames_1201;
    Py_INCREF( tmp_outline_return_value_35 );
    goto try_return_handler_88;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_88:;
    Py_DECREF( locals_GeneralNames_1201 );
    locals_GeneralNames_1201 = NULL;
    goto outline_result_35;
    // Exception handler code:
    try_except_handler_88:;
    exception_keeper_type_80 = exception_type;
    exception_keeper_value_80 = exception_value;
    exception_keeper_tb_80 = exception_tb;
    exception_keeper_lineno_80 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_GeneralNames_1201 );
    locals_GeneralNames_1201 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_80;
    exception_value = exception_keeper_value_80;
    exception_tb = exception_keeper_tb_80;
    exception_lineno = exception_keeper_lineno_80;

    goto outline_exception_26;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_26:;
    exception_lineno = 1201;
    goto try_except_handler_87;
    outline_result_35:;
    tmp_assign_source_210 = tmp_outline_return_value_35;
    assert( tmp_class_creation_30__class_dict == NULL );
    tmp_class_creation_30__class_dict = tmp_assign_source_210;

    tmp_compare_left_30 = const_str_plain___metaclass__;
    tmp_compare_right_30 = tmp_class_creation_30__class_dict;

    CHECK_OBJECT( tmp_compare_right_30 );
    tmp_cmp_In_30 = PySequence_Contains( tmp_compare_right_30, tmp_compare_left_30 );
    assert( !(tmp_cmp_In_30 == -1) );
    if ( tmp_cmp_In_30 == 1 )
    {
        goto condexpr_true_30;
    }
    else
    {
        goto condexpr_false_30;
    }
    condexpr_true_30:;
    tmp_dict_name_30 = tmp_class_creation_30__class_dict;

    CHECK_OBJECT( tmp_dict_name_30 );
    tmp_key_name_30 = const_str_plain___metaclass__;
    tmp_assign_source_215 = DICT_GET_ITEM( tmp_dict_name_30, tmp_key_name_30 );
    if ( tmp_assign_source_215 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1201;

        goto try_except_handler_87;
    }
    goto condexpr_end_30;
    condexpr_false_30:;
    tmp_assign_source_215 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_215 );
    condexpr_end_30:;
    assert( tmp_class_creation_30__metaclass == NULL );
    tmp_class_creation_30__metaclass = tmp_assign_source_215;

    tmp_called_name_76 = tmp_class_creation_30__metaclass;

    CHECK_OBJECT( tmp_called_name_76 );
    tmp_args_element_name_127 = const_str_plain_GeneralNames;
    tmp_args_element_name_128 = const_tuple_type_object_tuple;
    tmp_args_element_name_129 = tmp_class_creation_30__class_dict;

    CHECK_OBJECT( tmp_args_element_name_129 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1201;
    {
        PyObject *call_args[] = { tmp_args_element_name_127, tmp_args_element_name_128, tmp_args_element_name_129 };
        tmp_assign_source_216 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_76, call_args );
    }

    if ( tmp_assign_source_216 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1201;

        goto try_except_handler_87;
    }
    assert( tmp_class_creation_30__class == NULL );
    tmp_class_creation_30__class = tmp_assign_source_216;

    goto try_end_51;
    // Exception handler code:
    try_except_handler_87:;
    exception_keeper_type_81 = exception_type;
    exception_keeper_value_81 = exception_value;
    exception_keeper_tb_81 = exception_tb;
    exception_keeper_lineno_81 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_30__class_dict );
    tmp_class_creation_30__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_30__metaclass );
    tmp_class_creation_30__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_81;
    exception_value = exception_keeper_value_81;
    exception_tb = exception_keeper_tb_81;
    exception_lineno = exception_keeper_lineno_81;

    goto frame_exception_exit_1;
    // End of try:
    try_end_51:;
    tmp_assign_source_217 = tmp_class_creation_30__class;

    CHECK_OBJECT( tmp_assign_source_217 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralNames, tmp_assign_source_217 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_30__class );
    Py_DECREF( tmp_class_creation_30__class );
    tmp_class_creation_30__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_30__class_dict );
    Py_DECREF( tmp_class_creation_30__class_dict );
    tmp_class_creation_30__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_30__metaclass );
    Py_DECREF( tmp_class_creation_30__metaclass );
    tmp_class_creation_30__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_SubjectAlternativeName_1239 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_SubjectAlternativeName_1239, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28, codeobj_e048cd6d0ea6ce193f5d3d78a092fb7e, module_cryptography$x509$extensions, 0 );
    frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28 = cache_frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_41 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_41 == NULL ))
    {
        tmp_source_name_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_41 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 1240;

        goto frame_exception_exit_28;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_41, const_str_plain_SUBJECT_ALTERNATIVE_NAME );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1240;

        goto frame_exception_exit_28;
    }
    tmp_res = PyDict_SetItem( locals_SubjectAlternativeName_1239, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1240;

        goto frame_exception_exit_28;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_135___init__(  );
    tmp_res = PyDict_SetItem( locals_SubjectAlternativeName_1239, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_called_name_77 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );

    if (unlikely( tmp_called_name_77 == NULL ))
    {
        tmp_called_name_77 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );
    }

    if ( tmp_called_name_77 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_sequence_methods" );
        exception_tb = NULL;

        exception_lineno = 1245;

        goto try_except_handler_93;
    }

    frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28->m_frame.f_lineno = 1245;
    tmp_iter_arg_10 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_77, &PyTuple_GET_ITEM( const_tuple_str_plain__general_names_tuple, 0 ) );

    if ( tmp_iter_arg_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1245;

        goto try_except_handler_93;
    }
    tmp_assign_source_219 = MAKE_ITERATOR( tmp_iter_arg_10 );
    Py_DECREF( tmp_iter_arg_10 );
    if ( tmp_assign_source_219 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1245;

        goto try_except_handler_93;
    }
    assert( tmp_SubjectAlternativeName$tuple_unpack_1__source_iter == NULL );
    tmp_SubjectAlternativeName$tuple_unpack_1__source_iter = tmp_assign_source_219;

    // Tried code:
    tmp_unpack_25 = tmp_SubjectAlternativeName$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_25 );
    tmp_assign_source_220 = UNPACK_NEXT( tmp_unpack_25, 0 );
    if ( tmp_assign_source_220 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1245;
        goto try_except_handler_94;
    }
    assert( tmp_SubjectAlternativeName$tuple_unpack_1__element_1 == NULL );
    tmp_SubjectAlternativeName$tuple_unpack_1__element_1 = tmp_assign_source_220;

    tmp_unpack_26 = tmp_SubjectAlternativeName$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_26 );
    tmp_assign_source_221 = UNPACK_NEXT( tmp_unpack_26, 1 );
    if ( tmp_assign_source_221 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1245;
        goto try_except_handler_94;
    }
    assert( tmp_SubjectAlternativeName$tuple_unpack_1__element_2 == NULL );
    tmp_SubjectAlternativeName$tuple_unpack_1__element_2 = tmp_assign_source_221;

    tmp_unpack_27 = tmp_SubjectAlternativeName$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_27 );
    tmp_assign_source_222 = UNPACK_NEXT( tmp_unpack_27, 2 );
    if ( tmp_assign_source_222 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1245;
        goto try_except_handler_94;
    }
    assert( tmp_SubjectAlternativeName$tuple_unpack_1__element_3 == NULL );
    tmp_SubjectAlternativeName$tuple_unpack_1__element_3 = tmp_assign_source_222;

    tmp_iterator_name_9 = tmp_SubjectAlternativeName$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_9 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_9 ); assert( HAS_ITERNEXT( tmp_iterator_name_9 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_9 )->tp_iternext)( tmp_iterator_name_9 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1245;
                goto try_except_handler_94;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1245;
        goto try_except_handler_94;
    }
    goto try_end_52;
    // Exception handler code:
    try_except_handler_94:;
    exception_keeper_type_82 = exception_type;
    exception_keeper_value_82 = exception_value;
    exception_keeper_tb_82 = exception_tb;
    exception_keeper_lineno_82 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_SubjectAlternativeName$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_SubjectAlternativeName$tuple_unpack_1__source_iter );
    tmp_SubjectAlternativeName$tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_82;
    exception_value = exception_keeper_value_82;
    exception_tb = exception_keeper_tb_82;
    exception_lineno = exception_keeper_lineno_82;

    goto try_except_handler_93;
    // End of try:
    try_end_52:;
    goto try_end_53;
    // Exception handler code:
    try_except_handler_93:;
    exception_keeper_type_83 = exception_type;
    exception_keeper_value_83 = exception_value;
    exception_keeper_tb_83 = exception_tb;
    exception_keeper_lineno_83 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_SubjectAlternativeName$tuple_unpack_1__element_1 );
    tmp_SubjectAlternativeName$tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_SubjectAlternativeName$tuple_unpack_1__element_2 );
    tmp_SubjectAlternativeName$tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_SubjectAlternativeName$tuple_unpack_1__element_3 );
    tmp_SubjectAlternativeName$tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_83;
    exception_value = exception_keeper_value_83;
    exception_tb = exception_keeper_tb_83;
    exception_lineno = exception_keeper_lineno_83;

    goto frame_exception_exit_28;
    // End of try:
    try_end_53:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_27;

    frame_exception_exit_28:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28,
        type_description_2
    );


    // Release cached frame.
    if ( frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28 == cache_frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28 )
    {
        Py_DECREF( frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28 );
    }
    cache_frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28 = NULL;

    assertFrameObject( frame_e048cd6d0ea6ce193f5d3d78a092fb7e_28 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_27;

    frame_no_exception_27:;

    goto skip_nested_handling_27;
    nested_frame_exit_27:;

    goto try_except_handler_92;
    skip_nested_handling_27:;
    CHECK_OBJECT( (PyObject *)tmp_SubjectAlternativeName$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_SubjectAlternativeName$tuple_unpack_1__source_iter );
    tmp_SubjectAlternativeName$tuple_unpack_1__source_iter = NULL;

    tmp_dictset_value = tmp_SubjectAlternativeName$tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_SubjectAlternativeName_1239, const_str_plain___len__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_SubjectAlternativeName$tuple_unpack_1__element_1 );
    tmp_SubjectAlternativeName$tuple_unpack_1__element_1 = NULL;

    tmp_dictset_value = tmp_SubjectAlternativeName$tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_SubjectAlternativeName_1239, const_str_plain___iter__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_SubjectAlternativeName$tuple_unpack_1__element_2 );
    tmp_SubjectAlternativeName$tuple_unpack_1__element_2 = NULL;

    tmp_dictset_value = tmp_SubjectAlternativeName$tuple_unpack_1__element_3;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_SubjectAlternativeName_1239, const_str_plain___getitem__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_SubjectAlternativeName$tuple_unpack_1__element_3 );
    tmp_SubjectAlternativeName$tuple_unpack_1__element_3 = NULL;

    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_136_get_values_for_type(  );
    tmp_res = PyDict_SetItem( locals_SubjectAlternativeName_1239, const_str_plain_get_values_for_type, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_137___repr__(  );
    tmp_res = PyDict_SetItem( locals_SubjectAlternativeName_1239, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_138___eq__(  );
    tmp_res = PyDict_SetItem( locals_SubjectAlternativeName_1239, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_139___ne__(  );
    tmp_res = PyDict_SetItem( locals_SubjectAlternativeName_1239, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_140___hash__(  );
    tmp_res = PyDict_SetItem( locals_SubjectAlternativeName_1239, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_36 = locals_SubjectAlternativeName_1239;
    Py_INCREF( tmp_outline_return_value_36 );
    goto try_return_handler_92;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_92:;
    Py_DECREF( locals_SubjectAlternativeName_1239 );
    locals_SubjectAlternativeName_1239 = NULL;
    goto outline_result_36;
    // Exception handler code:
    try_except_handler_92:;
    exception_keeper_type_84 = exception_type;
    exception_keeper_value_84 = exception_value;
    exception_keeper_tb_84 = exception_tb;
    exception_keeper_lineno_84 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_SubjectAlternativeName_1239 );
    locals_SubjectAlternativeName_1239 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_84;
    exception_value = exception_keeper_value_84;
    exception_tb = exception_keeper_tb_84;
    exception_lineno = exception_keeper_lineno_84;

    goto outline_exception_27;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_27:;
    exception_lineno = 1239;
    goto try_except_handler_91;
    outline_result_36:;
    tmp_assign_source_218 = tmp_outline_return_value_36;
    assert( tmp_class_creation_31__class_dict == NULL );
    tmp_class_creation_31__class_dict = tmp_assign_source_218;

    tmp_compare_left_31 = const_str_plain___metaclass__;
    tmp_compare_right_31 = tmp_class_creation_31__class_dict;

    CHECK_OBJECT( tmp_compare_right_31 );
    tmp_cmp_In_31 = PySequence_Contains( tmp_compare_right_31, tmp_compare_left_31 );
    assert( !(tmp_cmp_In_31 == -1) );
    if ( tmp_cmp_In_31 == 1 )
    {
        goto condexpr_true_31;
    }
    else
    {
        goto condexpr_false_31;
    }
    condexpr_true_31:;
    tmp_dict_name_31 = tmp_class_creation_31__class_dict;

    CHECK_OBJECT( tmp_dict_name_31 );
    tmp_key_name_31 = const_str_plain___metaclass__;
    tmp_assign_source_223 = DICT_GET_ITEM( tmp_dict_name_31, tmp_key_name_31 );
    if ( tmp_assign_source_223 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1239;

        goto try_except_handler_91;
    }
    goto condexpr_end_31;
    condexpr_false_31:;
    tmp_assign_source_223 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_223 );
    condexpr_end_31:;
    assert( tmp_class_creation_31__metaclass == NULL );
    tmp_class_creation_31__metaclass = tmp_assign_source_223;

    tmp_called_name_78 = tmp_class_creation_31__metaclass;

    CHECK_OBJECT( tmp_called_name_78 );
    tmp_args_element_name_130 = const_str_plain_SubjectAlternativeName;
    tmp_args_element_name_131 = const_tuple_type_object_tuple;
    tmp_args_element_name_132 = tmp_class_creation_31__class_dict;

    CHECK_OBJECT( tmp_args_element_name_132 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1239;
    {
        PyObject *call_args[] = { tmp_args_element_name_130, tmp_args_element_name_131, tmp_args_element_name_132 };
        tmp_assign_source_224 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_78, call_args );
    }

    if ( tmp_assign_source_224 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1239;

        goto try_except_handler_91;
    }
    assert( tmp_class_creation_31__class == NULL );
    tmp_class_creation_31__class = tmp_assign_source_224;

    tmp_source_name_42 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_42 == NULL ))
    {
        tmp_source_name_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_42 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1238;

        goto try_except_handler_91;
    }

    tmp_called_name_80 = LOOKUP_ATTRIBUTE( tmp_source_name_42, const_str_plain_register_interface );
    if ( tmp_called_name_80 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1238;

        goto try_except_handler_91;
    }
    tmp_args_element_name_133 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_133 == NULL ))
    {
        tmp_args_element_name_133 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_133 == NULL )
    {
        Py_DECREF( tmp_called_name_80 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 1238;

        goto try_except_handler_91;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1238;
    {
        PyObject *call_args[] = { tmp_args_element_name_133 };
        tmp_called_name_79 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_80, call_args );
    }

    Py_DECREF( tmp_called_name_80 );
    if ( tmp_called_name_79 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1238;

        goto try_except_handler_91;
    }
    tmp_args_element_name_134 = tmp_class_creation_31__class;

    CHECK_OBJECT( tmp_args_element_name_134 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1238;
    {
        PyObject *call_args[] = { tmp_args_element_name_134 };
        tmp_assign_source_225 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_79, call_args );
    }

    Py_DECREF( tmp_called_name_79 );
    if ( tmp_assign_source_225 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1238;

        goto try_except_handler_91;
    }
    {
        PyObject *old = tmp_class_creation_31__class;
        assert( old != NULL );
        tmp_class_creation_31__class = tmp_assign_source_225;
        Py_DECREF( old );
    }

    goto try_end_54;
    // Exception handler code:
    try_except_handler_91:;
    exception_keeper_type_85 = exception_type;
    exception_keeper_value_85 = exception_value;
    exception_keeper_tb_85 = exception_tb;
    exception_keeper_lineno_85 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_31__class );
    tmp_class_creation_31__class = NULL;

    Py_XDECREF( tmp_class_creation_31__class_dict );
    tmp_class_creation_31__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_31__metaclass );
    tmp_class_creation_31__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_85;
    exception_value = exception_keeper_value_85;
    exception_tb = exception_keeper_tb_85;
    exception_lineno = exception_keeper_lineno_85;

    goto frame_exception_exit_1;
    // End of try:
    try_end_54:;
    tmp_assign_source_226 = tmp_class_creation_31__class;

    CHECK_OBJECT( tmp_assign_source_226 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SubjectAlternativeName, tmp_assign_source_226 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_31__class );
    Py_DECREF( tmp_class_creation_31__class );
    tmp_class_creation_31__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_31__class_dict );
    Py_DECREF( tmp_class_creation_31__class_dict );
    tmp_class_creation_31__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_31__metaclass );
    Py_DECREF( tmp_class_creation_31__metaclass );
    tmp_class_creation_31__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_IssuerAlternativeName_1267 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_IssuerAlternativeName_1267, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_729253a47ed1776955e8d27ecd2e7328_29, codeobj_729253a47ed1776955e8d27ecd2e7328, module_cryptography$x509$extensions, 0 );
    frame_729253a47ed1776955e8d27ecd2e7328_29 = cache_frame_729253a47ed1776955e8d27ecd2e7328_29;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_729253a47ed1776955e8d27ecd2e7328_29 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_729253a47ed1776955e8d27ecd2e7328_29 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_43 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_43 == NULL ))
    {
        tmp_source_name_43 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_43 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 1268;

        goto frame_exception_exit_29;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_43, const_str_plain_ISSUER_ALTERNATIVE_NAME );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1268;

        goto frame_exception_exit_29;
    }
    tmp_res = PyDict_SetItem( locals_IssuerAlternativeName_1267, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1268;

        goto frame_exception_exit_29;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_141___init__(  );
    tmp_res = PyDict_SetItem( locals_IssuerAlternativeName_1267, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_called_name_81 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );

    if (unlikely( tmp_called_name_81 == NULL ))
    {
        tmp_called_name_81 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );
    }

    if ( tmp_called_name_81 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_sequence_methods" );
        exception_tb = NULL;

        exception_lineno = 1273;

        goto try_except_handler_97;
    }

    frame_729253a47ed1776955e8d27ecd2e7328_29->m_frame.f_lineno = 1273;
    tmp_iter_arg_11 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_81, &PyTuple_GET_ITEM( const_tuple_str_plain__general_names_tuple, 0 ) );

    if ( tmp_iter_arg_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1273;

        goto try_except_handler_97;
    }
    tmp_assign_source_228 = MAKE_ITERATOR( tmp_iter_arg_11 );
    Py_DECREF( tmp_iter_arg_11 );
    if ( tmp_assign_source_228 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1273;

        goto try_except_handler_97;
    }
    assert( tmp_IssuerAlternativeName$tuple_unpack_1__source_iter == NULL );
    tmp_IssuerAlternativeName$tuple_unpack_1__source_iter = tmp_assign_source_228;

    // Tried code:
    tmp_unpack_28 = tmp_IssuerAlternativeName$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_28 );
    tmp_assign_source_229 = UNPACK_NEXT( tmp_unpack_28, 0 );
    if ( tmp_assign_source_229 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1273;
        goto try_except_handler_98;
    }
    assert( tmp_IssuerAlternativeName$tuple_unpack_1__element_1 == NULL );
    tmp_IssuerAlternativeName$tuple_unpack_1__element_1 = tmp_assign_source_229;

    tmp_unpack_29 = tmp_IssuerAlternativeName$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_29 );
    tmp_assign_source_230 = UNPACK_NEXT( tmp_unpack_29, 1 );
    if ( tmp_assign_source_230 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1273;
        goto try_except_handler_98;
    }
    assert( tmp_IssuerAlternativeName$tuple_unpack_1__element_2 == NULL );
    tmp_IssuerAlternativeName$tuple_unpack_1__element_2 = tmp_assign_source_230;

    tmp_unpack_30 = tmp_IssuerAlternativeName$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_30 );
    tmp_assign_source_231 = UNPACK_NEXT( tmp_unpack_30, 2 );
    if ( tmp_assign_source_231 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1273;
        goto try_except_handler_98;
    }
    assert( tmp_IssuerAlternativeName$tuple_unpack_1__element_3 == NULL );
    tmp_IssuerAlternativeName$tuple_unpack_1__element_3 = tmp_assign_source_231;

    tmp_iterator_name_10 = tmp_IssuerAlternativeName$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_10 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_10 ); assert( HAS_ITERNEXT( tmp_iterator_name_10 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_10 )->tp_iternext)( tmp_iterator_name_10 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1273;
                goto try_except_handler_98;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1273;
        goto try_except_handler_98;
    }
    goto try_end_55;
    // Exception handler code:
    try_except_handler_98:;
    exception_keeper_type_86 = exception_type;
    exception_keeper_value_86 = exception_value;
    exception_keeper_tb_86 = exception_tb;
    exception_keeper_lineno_86 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_IssuerAlternativeName$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_IssuerAlternativeName$tuple_unpack_1__source_iter );
    tmp_IssuerAlternativeName$tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_86;
    exception_value = exception_keeper_value_86;
    exception_tb = exception_keeper_tb_86;
    exception_lineno = exception_keeper_lineno_86;

    goto try_except_handler_97;
    // End of try:
    try_end_55:;
    goto try_end_56;
    // Exception handler code:
    try_except_handler_97:;
    exception_keeper_type_87 = exception_type;
    exception_keeper_value_87 = exception_value;
    exception_keeper_tb_87 = exception_tb;
    exception_keeper_lineno_87 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_IssuerAlternativeName$tuple_unpack_1__element_1 );
    tmp_IssuerAlternativeName$tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_IssuerAlternativeName$tuple_unpack_1__element_2 );
    tmp_IssuerAlternativeName$tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_IssuerAlternativeName$tuple_unpack_1__element_3 );
    tmp_IssuerAlternativeName$tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_87;
    exception_value = exception_keeper_value_87;
    exception_tb = exception_keeper_tb_87;
    exception_lineno = exception_keeper_lineno_87;

    goto frame_exception_exit_29;
    // End of try:
    try_end_56:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_729253a47ed1776955e8d27ecd2e7328_29 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_28;

    frame_exception_exit_29:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_729253a47ed1776955e8d27ecd2e7328_29 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_729253a47ed1776955e8d27ecd2e7328_29, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_729253a47ed1776955e8d27ecd2e7328_29->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_729253a47ed1776955e8d27ecd2e7328_29, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_729253a47ed1776955e8d27ecd2e7328_29,
        type_description_2
    );


    // Release cached frame.
    if ( frame_729253a47ed1776955e8d27ecd2e7328_29 == cache_frame_729253a47ed1776955e8d27ecd2e7328_29 )
    {
        Py_DECREF( frame_729253a47ed1776955e8d27ecd2e7328_29 );
    }
    cache_frame_729253a47ed1776955e8d27ecd2e7328_29 = NULL;

    assertFrameObject( frame_729253a47ed1776955e8d27ecd2e7328_29 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_28;

    frame_no_exception_28:;

    goto skip_nested_handling_28;
    nested_frame_exit_28:;

    goto try_except_handler_96;
    skip_nested_handling_28:;
    CHECK_OBJECT( (PyObject *)tmp_IssuerAlternativeName$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_IssuerAlternativeName$tuple_unpack_1__source_iter );
    tmp_IssuerAlternativeName$tuple_unpack_1__source_iter = NULL;

    tmp_dictset_value = tmp_IssuerAlternativeName$tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_IssuerAlternativeName_1267, const_str_plain___len__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_IssuerAlternativeName$tuple_unpack_1__element_1 );
    tmp_IssuerAlternativeName$tuple_unpack_1__element_1 = NULL;

    tmp_dictset_value = tmp_IssuerAlternativeName$tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_IssuerAlternativeName_1267, const_str_plain___iter__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_IssuerAlternativeName$tuple_unpack_1__element_2 );
    tmp_IssuerAlternativeName$tuple_unpack_1__element_2 = NULL;

    tmp_dictset_value = tmp_IssuerAlternativeName$tuple_unpack_1__element_3;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_IssuerAlternativeName_1267, const_str_plain___getitem__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_IssuerAlternativeName$tuple_unpack_1__element_3 );
    tmp_IssuerAlternativeName$tuple_unpack_1__element_3 = NULL;

    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_142_get_values_for_type(  );
    tmp_res = PyDict_SetItem( locals_IssuerAlternativeName_1267, const_str_plain_get_values_for_type, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_143___repr__(  );
    tmp_res = PyDict_SetItem( locals_IssuerAlternativeName_1267, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_144___eq__(  );
    tmp_res = PyDict_SetItem( locals_IssuerAlternativeName_1267, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_145___ne__(  );
    tmp_res = PyDict_SetItem( locals_IssuerAlternativeName_1267, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_146___hash__(  );
    tmp_res = PyDict_SetItem( locals_IssuerAlternativeName_1267, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_37 = locals_IssuerAlternativeName_1267;
    Py_INCREF( tmp_outline_return_value_37 );
    goto try_return_handler_96;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_96:;
    Py_DECREF( locals_IssuerAlternativeName_1267 );
    locals_IssuerAlternativeName_1267 = NULL;
    goto outline_result_37;
    // Exception handler code:
    try_except_handler_96:;
    exception_keeper_type_88 = exception_type;
    exception_keeper_value_88 = exception_value;
    exception_keeper_tb_88 = exception_tb;
    exception_keeper_lineno_88 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_IssuerAlternativeName_1267 );
    locals_IssuerAlternativeName_1267 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_88;
    exception_value = exception_keeper_value_88;
    exception_tb = exception_keeper_tb_88;
    exception_lineno = exception_keeper_lineno_88;

    goto outline_exception_28;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_28:;
    exception_lineno = 1267;
    goto try_except_handler_95;
    outline_result_37:;
    tmp_assign_source_227 = tmp_outline_return_value_37;
    assert( tmp_class_creation_32__class_dict == NULL );
    tmp_class_creation_32__class_dict = tmp_assign_source_227;

    tmp_compare_left_32 = const_str_plain___metaclass__;
    tmp_compare_right_32 = tmp_class_creation_32__class_dict;

    CHECK_OBJECT( tmp_compare_right_32 );
    tmp_cmp_In_32 = PySequence_Contains( tmp_compare_right_32, tmp_compare_left_32 );
    assert( !(tmp_cmp_In_32 == -1) );
    if ( tmp_cmp_In_32 == 1 )
    {
        goto condexpr_true_32;
    }
    else
    {
        goto condexpr_false_32;
    }
    condexpr_true_32:;
    tmp_dict_name_32 = tmp_class_creation_32__class_dict;

    CHECK_OBJECT( tmp_dict_name_32 );
    tmp_key_name_32 = const_str_plain___metaclass__;
    tmp_assign_source_232 = DICT_GET_ITEM( tmp_dict_name_32, tmp_key_name_32 );
    if ( tmp_assign_source_232 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1267;

        goto try_except_handler_95;
    }
    goto condexpr_end_32;
    condexpr_false_32:;
    tmp_assign_source_232 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_232 );
    condexpr_end_32:;
    assert( tmp_class_creation_32__metaclass == NULL );
    tmp_class_creation_32__metaclass = tmp_assign_source_232;

    tmp_called_name_82 = tmp_class_creation_32__metaclass;

    CHECK_OBJECT( tmp_called_name_82 );
    tmp_args_element_name_135 = const_str_plain_IssuerAlternativeName;
    tmp_args_element_name_136 = const_tuple_type_object_tuple;
    tmp_args_element_name_137 = tmp_class_creation_32__class_dict;

    CHECK_OBJECT( tmp_args_element_name_137 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1267;
    {
        PyObject *call_args[] = { tmp_args_element_name_135, tmp_args_element_name_136, tmp_args_element_name_137 };
        tmp_assign_source_233 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_82, call_args );
    }

    if ( tmp_assign_source_233 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1267;

        goto try_except_handler_95;
    }
    assert( tmp_class_creation_32__class == NULL );
    tmp_class_creation_32__class = tmp_assign_source_233;

    tmp_source_name_44 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_44 == NULL ))
    {
        tmp_source_name_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_44 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1266;

        goto try_except_handler_95;
    }

    tmp_called_name_84 = LOOKUP_ATTRIBUTE( tmp_source_name_44, const_str_plain_register_interface );
    if ( tmp_called_name_84 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1266;

        goto try_except_handler_95;
    }
    tmp_args_element_name_138 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_138 == NULL ))
    {
        tmp_args_element_name_138 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_138 == NULL )
    {
        Py_DECREF( tmp_called_name_84 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 1266;

        goto try_except_handler_95;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1266;
    {
        PyObject *call_args[] = { tmp_args_element_name_138 };
        tmp_called_name_83 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_84, call_args );
    }

    Py_DECREF( tmp_called_name_84 );
    if ( tmp_called_name_83 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1266;

        goto try_except_handler_95;
    }
    tmp_args_element_name_139 = tmp_class_creation_32__class;

    CHECK_OBJECT( tmp_args_element_name_139 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1266;
    {
        PyObject *call_args[] = { tmp_args_element_name_139 };
        tmp_assign_source_234 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_83, call_args );
    }

    Py_DECREF( tmp_called_name_83 );
    if ( tmp_assign_source_234 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1266;

        goto try_except_handler_95;
    }
    {
        PyObject *old = tmp_class_creation_32__class;
        assert( old != NULL );
        tmp_class_creation_32__class = tmp_assign_source_234;
        Py_DECREF( old );
    }

    goto try_end_57;
    // Exception handler code:
    try_except_handler_95:;
    exception_keeper_type_89 = exception_type;
    exception_keeper_value_89 = exception_value;
    exception_keeper_tb_89 = exception_tb;
    exception_keeper_lineno_89 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_32__class );
    tmp_class_creation_32__class = NULL;

    Py_XDECREF( tmp_class_creation_32__class_dict );
    tmp_class_creation_32__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_32__metaclass );
    tmp_class_creation_32__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_89;
    exception_value = exception_keeper_value_89;
    exception_tb = exception_keeper_tb_89;
    exception_lineno = exception_keeper_lineno_89;

    goto frame_exception_exit_1;
    // End of try:
    try_end_57:;
    tmp_assign_source_235 = tmp_class_creation_32__class;

    CHECK_OBJECT( tmp_assign_source_235 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_IssuerAlternativeName, tmp_assign_source_235 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_32__class );
    Py_DECREF( tmp_class_creation_32__class );
    tmp_class_creation_32__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_32__class_dict );
    Py_DECREF( tmp_class_creation_32__class_dict );
    tmp_class_creation_32__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_32__metaclass );
    Py_DECREF( tmp_class_creation_32__metaclass );
    tmp_class_creation_32__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_CertificateIssuer_1295 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_CertificateIssuer_1295, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_34264ca058405cbbc64ede36ef24ba67_30, codeobj_34264ca058405cbbc64ede36ef24ba67, module_cryptography$x509$extensions, 0 );
    frame_34264ca058405cbbc64ede36ef24ba67_30 = cache_frame_34264ca058405cbbc64ede36ef24ba67_30;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_34264ca058405cbbc64ede36ef24ba67_30 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_34264ca058405cbbc64ede36ef24ba67_30 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_45 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID );

    if (unlikely( tmp_source_name_45 == NULL ))
    {
        tmp_source_name_45 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID );
    }

    if ( tmp_source_name_45 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "CRLEntryExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 1296;

        goto frame_exception_exit_30;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_45, const_str_plain_CERTIFICATE_ISSUER );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1296;

        goto frame_exception_exit_30;
    }
    tmp_res = PyDict_SetItem( locals_CertificateIssuer_1295, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1296;

        goto frame_exception_exit_30;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_147___init__(  );
    tmp_res = PyDict_SetItem( locals_CertificateIssuer_1295, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_called_name_85 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );

    if (unlikely( tmp_called_name_85 == NULL ))
    {
        tmp_called_name_85 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );
    }

    if ( tmp_called_name_85 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_sequence_methods" );
        exception_tb = NULL;

        exception_lineno = 1301;

        goto try_except_handler_101;
    }

    frame_34264ca058405cbbc64ede36ef24ba67_30->m_frame.f_lineno = 1301;
    tmp_iter_arg_12 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_85, &PyTuple_GET_ITEM( const_tuple_str_plain__general_names_tuple, 0 ) );

    if ( tmp_iter_arg_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1301;

        goto try_except_handler_101;
    }
    tmp_assign_source_237 = MAKE_ITERATOR( tmp_iter_arg_12 );
    Py_DECREF( tmp_iter_arg_12 );
    if ( tmp_assign_source_237 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1301;

        goto try_except_handler_101;
    }
    assert( tmp_CertificateIssuer$tuple_unpack_1__source_iter == NULL );
    tmp_CertificateIssuer$tuple_unpack_1__source_iter = tmp_assign_source_237;

    // Tried code:
    tmp_unpack_31 = tmp_CertificateIssuer$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_31 );
    tmp_assign_source_238 = UNPACK_NEXT( tmp_unpack_31, 0 );
    if ( tmp_assign_source_238 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1301;
        goto try_except_handler_102;
    }
    assert( tmp_CertificateIssuer$tuple_unpack_1__element_1 == NULL );
    tmp_CertificateIssuer$tuple_unpack_1__element_1 = tmp_assign_source_238;

    tmp_unpack_32 = tmp_CertificateIssuer$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_32 );
    tmp_assign_source_239 = UNPACK_NEXT( tmp_unpack_32, 1 );
    if ( tmp_assign_source_239 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1301;
        goto try_except_handler_102;
    }
    assert( tmp_CertificateIssuer$tuple_unpack_1__element_2 == NULL );
    tmp_CertificateIssuer$tuple_unpack_1__element_2 = tmp_assign_source_239;

    tmp_unpack_33 = tmp_CertificateIssuer$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_33 );
    tmp_assign_source_240 = UNPACK_NEXT( tmp_unpack_33, 2 );
    if ( tmp_assign_source_240 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1301;
        goto try_except_handler_102;
    }
    assert( tmp_CertificateIssuer$tuple_unpack_1__element_3 == NULL );
    tmp_CertificateIssuer$tuple_unpack_1__element_3 = tmp_assign_source_240;

    tmp_iterator_name_11 = tmp_CertificateIssuer$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_11 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_11 ); assert( HAS_ITERNEXT( tmp_iterator_name_11 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_11 )->tp_iternext)( tmp_iterator_name_11 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1301;
                goto try_except_handler_102;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1301;
        goto try_except_handler_102;
    }
    goto try_end_58;
    // Exception handler code:
    try_except_handler_102:;
    exception_keeper_type_90 = exception_type;
    exception_keeper_value_90 = exception_value;
    exception_keeper_tb_90 = exception_tb;
    exception_keeper_lineno_90 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_CertificateIssuer$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_CertificateIssuer$tuple_unpack_1__source_iter );
    tmp_CertificateIssuer$tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_90;
    exception_value = exception_keeper_value_90;
    exception_tb = exception_keeper_tb_90;
    exception_lineno = exception_keeper_lineno_90;

    goto try_except_handler_101;
    // End of try:
    try_end_58:;
    goto try_end_59;
    // Exception handler code:
    try_except_handler_101:;
    exception_keeper_type_91 = exception_type;
    exception_keeper_value_91 = exception_value;
    exception_keeper_tb_91 = exception_tb;
    exception_keeper_lineno_91 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_CertificateIssuer$tuple_unpack_1__element_1 );
    tmp_CertificateIssuer$tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_CertificateIssuer$tuple_unpack_1__element_2 );
    tmp_CertificateIssuer$tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_CertificateIssuer$tuple_unpack_1__element_3 );
    tmp_CertificateIssuer$tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_91;
    exception_value = exception_keeper_value_91;
    exception_tb = exception_keeper_tb_91;
    exception_lineno = exception_keeper_lineno_91;

    goto frame_exception_exit_30;
    // End of try:
    try_end_59:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_34264ca058405cbbc64ede36ef24ba67_30 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_29;

    frame_exception_exit_30:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_34264ca058405cbbc64ede36ef24ba67_30 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_34264ca058405cbbc64ede36ef24ba67_30, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_34264ca058405cbbc64ede36ef24ba67_30->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_34264ca058405cbbc64ede36ef24ba67_30, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_34264ca058405cbbc64ede36ef24ba67_30,
        type_description_2
    );


    // Release cached frame.
    if ( frame_34264ca058405cbbc64ede36ef24ba67_30 == cache_frame_34264ca058405cbbc64ede36ef24ba67_30 )
    {
        Py_DECREF( frame_34264ca058405cbbc64ede36ef24ba67_30 );
    }
    cache_frame_34264ca058405cbbc64ede36ef24ba67_30 = NULL;

    assertFrameObject( frame_34264ca058405cbbc64ede36ef24ba67_30 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_29;

    frame_no_exception_29:;

    goto skip_nested_handling_29;
    nested_frame_exit_29:;

    goto try_except_handler_100;
    skip_nested_handling_29:;
    CHECK_OBJECT( (PyObject *)tmp_CertificateIssuer$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_CertificateIssuer$tuple_unpack_1__source_iter );
    tmp_CertificateIssuer$tuple_unpack_1__source_iter = NULL;

    tmp_dictset_value = tmp_CertificateIssuer$tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_CertificateIssuer_1295, const_str_plain___len__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_CertificateIssuer$tuple_unpack_1__element_1 );
    tmp_CertificateIssuer$tuple_unpack_1__element_1 = NULL;

    tmp_dictset_value = tmp_CertificateIssuer$tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_CertificateIssuer_1295, const_str_plain___iter__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_CertificateIssuer$tuple_unpack_1__element_2 );
    tmp_CertificateIssuer$tuple_unpack_1__element_2 = NULL;

    tmp_dictset_value = tmp_CertificateIssuer$tuple_unpack_1__element_3;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_CertificateIssuer_1295, const_str_plain___getitem__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_CertificateIssuer$tuple_unpack_1__element_3 );
    tmp_CertificateIssuer$tuple_unpack_1__element_3 = NULL;

    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_148_get_values_for_type(  );
    tmp_res = PyDict_SetItem( locals_CertificateIssuer_1295, const_str_plain_get_values_for_type, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_149___repr__(  );
    tmp_res = PyDict_SetItem( locals_CertificateIssuer_1295, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_150___eq__(  );
    tmp_res = PyDict_SetItem( locals_CertificateIssuer_1295, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_151___ne__(  );
    tmp_res = PyDict_SetItem( locals_CertificateIssuer_1295, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_152___hash__(  );
    tmp_res = PyDict_SetItem( locals_CertificateIssuer_1295, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_38 = locals_CertificateIssuer_1295;
    Py_INCREF( tmp_outline_return_value_38 );
    goto try_return_handler_100;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_100:;
    Py_DECREF( locals_CertificateIssuer_1295 );
    locals_CertificateIssuer_1295 = NULL;
    goto outline_result_38;
    // Exception handler code:
    try_except_handler_100:;
    exception_keeper_type_92 = exception_type;
    exception_keeper_value_92 = exception_value;
    exception_keeper_tb_92 = exception_tb;
    exception_keeper_lineno_92 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_CertificateIssuer_1295 );
    locals_CertificateIssuer_1295 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_92;
    exception_value = exception_keeper_value_92;
    exception_tb = exception_keeper_tb_92;
    exception_lineno = exception_keeper_lineno_92;

    goto outline_exception_29;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_29:;
    exception_lineno = 1295;
    goto try_except_handler_99;
    outline_result_38:;
    tmp_assign_source_236 = tmp_outline_return_value_38;
    assert( tmp_class_creation_33__class_dict == NULL );
    tmp_class_creation_33__class_dict = tmp_assign_source_236;

    tmp_compare_left_33 = const_str_plain___metaclass__;
    tmp_compare_right_33 = tmp_class_creation_33__class_dict;

    CHECK_OBJECT( tmp_compare_right_33 );
    tmp_cmp_In_33 = PySequence_Contains( tmp_compare_right_33, tmp_compare_left_33 );
    assert( !(tmp_cmp_In_33 == -1) );
    if ( tmp_cmp_In_33 == 1 )
    {
        goto condexpr_true_33;
    }
    else
    {
        goto condexpr_false_33;
    }
    condexpr_true_33:;
    tmp_dict_name_33 = tmp_class_creation_33__class_dict;

    CHECK_OBJECT( tmp_dict_name_33 );
    tmp_key_name_33 = const_str_plain___metaclass__;
    tmp_assign_source_241 = DICT_GET_ITEM( tmp_dict_name_33, tmp_key_name_33 );
    if ( tmp_assign_source_241 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1295;

        goto try_except_handler_99;
    }
    goto condexpr_end_33;
    condexpr_false_33:;
    tmp_assign_source_241 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_241 );
    condexpr_end_33:;
    assert( tmp_class_creation_33__metaclass == NULL );
    tmp_class_creation_33__metaclass = tmp_assign_source_241;

    tmp_called_name_86 = tmp_class_creation_33__metaclass;

    CHECK_OBJECT( tmp_called_name_86 );
    tmp_args_element_name_140 = const_str_plain_CertificateIssuer;
    tmp_args_element_name_141 = const_tuple_type_object_tuple;
    tmp_args_element_name_142 = tmp_class_creation_33__class_dict;

    CHECK_OBJECT( tmp_args_element_name_142 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1295;
    {
        PyObject *call_args[] = { tmp_args_element_name_140, tmp_args_element_name_141, tmp_args_element_name_142 };
        tmp_assign_source_242 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_86, call_args );
    }

    if ( tmp_assign_source_242 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1295;

        goto try_except_handler_99;
    }
    assert( tmp_class_creation_33__class == NULL );
    tmp_class_creation_33__class = tmp_assign_source_242;

    tmp_source_name_46 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_46 == NULL ))
    {
        tmp_source_name_46 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_46 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1294;

        goto try_except_handler_99;
    }

    tmp_called_name_88 = LOOKUP_ATTRIBUTE( tmp_source_name_46, const_str_plain_register_interface );
    if ( tmp_called_name_88 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1294;

        goto try_except_handler_99;
    }
    tmp_args_element_name_143 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_143 == NULL ))
    {
        tmp_args_element_name_143 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_143 == NULL )
    {
        Py_DECREF( tmp_called_name_88 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 1294;

        goto try_except_handler_99;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1294;
    {
        PyObject *call_args[] = { tmp_args_element_name_143 };
        tmp_called_name_87 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_88, call_args );
    }

    Py_DECREF( tmp_called_name_88 );
    if ( tmp_called_name_87 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1294;

        goto try_except_handler_99;
    }
    tmp_args_element_name_144 = tmp_class_creation_33__class;

    CHECK_OBJECT( tmp_args_element_name_144 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1294;
    {
        PyObject *call_args[] = { tmp_args_element_name_144 };
        tmp_assign_source_243 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_87, call_args );
    }

    Py_DECREF( tmp_called_name_87 );
    if ( tmp_assign_source_243 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1294;

        goto try_except_handler_99;
    }
    {
        PyObject *old = tmp_class_creation_33__class;
        assert( old != NULL );
        tmp_class_creation_33__class = tmp_assign_source_243;
        Py_DECREF( old );
    }

    goto try_end_60;
    // Exception handler code:
    try_except_handler_99:;
    exception_keeper_type_93 = exception_type;
    exception_keeper_value_93 = exception_value;
    exception_keeper_tb_93 = exception_tb;
    exception_keeper_lineno_93 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_33__class );
    tmp_class_creation_33__class = NULL;

    Py_XDECREF( tmp_class_creation_33__class_dict );
    tmp_class_creation_33__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_33__metaclass );
    tmp_class_creation_33__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_93;
    exception_value = exception_keeper_value_93;
    exception_tb = exception_keeper_tb_93;
    exception_lineno = exception_keeper_lineno_93;

    goto frame_exception_exit_1;
    // End of try:
    try_end_60:;
    tmp_assign_source_244 = tmp_class_creation_33__class;

    CHECK_OBJECT( tmp_assign_source_244 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CertificateIssuer, tmp_assign_source_244 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_33__class );
    Py_DECREF( tmp_class_creation_33__class );
    tmp_class_creation_33__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_33__class_dict );
    Py_DECREF( tmp_class_creation_33__class_dict );
    tmp_class_creation_33__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_33__metaclass );
    Py_DECREF( tmp_class_creation_33__metaclass );
    tmp_class_creation_33__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_CRLReason_1323 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_CRLReason_1323, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a4a29737b836789d950c2cc5c6053ad4_31, codeobj_a4a29737b836789d950c2cc5c6053ad4, module_cryptography$x509$extensions, 0 );
    frame_a4a29737b836789d950c2cc5c6053ad4_31 = cache_frame_a4a29737b836789d950c2cc5c6053ad4_31;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a4a29737b836789d950c2cc5c6053ad4_31 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a4a29737b836789d950c2cc5c6053ad4_31 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_47 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID );

    if (unlikely( tmp_source_name_47 == NULL ))
    {
        tmp_source_name_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID );
    }

    if ( tmp_source_name_47 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "CRLEntryExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 1324;

        goto frame_exception_exit_31;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_47, const_str_plain_CRL_REASON );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1324;

        goto frame_exception_exit_31;
    }
    tmp_res = PyDict_SetItem( locals_CRLReason_1323, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1324;

        goto frame_exception_exit_31;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_153___init__(  );
    tmp_res = PyDict_SetItem( locals_CRLReason_1323, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_154___repr__(  );
    tmp_res = PyDict_SetItem( locals_CRLReason_1323, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_155___eq__(  );
    tmp_res = PyDict_SetItem( locals_CRLReason_1323, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_156___ne__(  );
    tmp_res = PyDict_SetItem( locals_CRLReason_1323, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_157___hash__(  );
    tmp_res = PyDict_SetItem( locals_CRLReason_1323, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_instance_37 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_37 == NULL ))
    {
        tmp_called_instance_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_37 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1347;

        goto frame_exception_exit_31;
    }

    frame_a4a29737b836789d950c2cc5c6053ad4_31->m_frame.f_lineno = 1347;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_37, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__reason_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1347;

        goto frame_exception_exit_31;
    }
    tmp_res = PyDict_SetItem( locals_CRLReason_1323, const_str_plain_reason, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1347;

        goto frame_exception_exit_31;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a4a29737b836789d950c2cc5c6053ad4_31 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_30;

    frame_exception_exit_31:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a4a29737b836789d950c2cc5c6053ad4_31 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a4a29737b836789d950c2cc5c6053ad4_31, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a4a29737b836789d950c2cc5c6053ad4_31->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a4a29737b836789d950c2cc5c6053ad4_31, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a4a29737b836789d950c2cc5c6053ad4_31,
        type_description_2
    );


    // Release cached frame.
    if ( frame_a4a29737b836789d950c2cc5c6053ad4_31 == cache_frame_a4a29737b836789d950c2cc5c6053ad4_31 )
    {
        Py_DECREF( frame_a4a29737b836789d950c2cc5c6053ad4_31 );
    }
    cache_frame_a4a29737b836789d950c2cc5c6053ad4_31 = NULL;

    assertFrameObject( frame_a4a29737b836789d950c2cc5c6053ad4_31 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_30;

    frame_no_exception_30:;

    goto skip_nested_handling_30;
    nested_frame_exit_30:;

    goto try_except_handler_104;
    skip_nested_handling_30:;
    tmp_outline_return_value_39 = locals_CRLReason_1323;
    Py_INCREF( tmp_outline_return_value_39 );
    goto try_return_handler_104;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_104:;
    Py_DECREF( locals_CRLReason_1323 );
    locals_CRLReason_1323 = NULL;
    goto outline_result_39;
    // Exception handler code:
    try_except_handler_104:;
    exception_keeper_type_94 = exception_type;
    exception_keeper_value_94 = exception_value;
    exception_keeper_tb_94 = exception_tb;
    exception_keeper_lineno_94 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_CRLReason_1323 );
    locals_CRLReason_1323 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_94;
    exception_value = exception_keeper_value_94;
    exception_tb = exception_keeper_tb_94;
    exception_lineno = exception_keeper_lineno_94;

    goto outline_exception_30;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_30:;
    exception_lineno = 1323;
    goto try_except_handler_103;
    outline_result_39:;
    tmp_assign_source_245 = tmp_outline_return_value_39;
    assert( tmp_class_creation_34__class_dict == NULL );
    tmp_class_creation_34__class_dict = tmp_assign_source_245;

    tmp_compare_left_34 = const_str_plain___metaclass__;
    tmp_compare_right_34 = tmp_class_creation_34__class_dict;

    CHECK_OBJECT( tmp_compare_right_34 );
    tmp_cmp_In_34 = PySequence_Contains( tmp_compare_right_34, tmp_compare_left_34 );
    assert( !(tmp_cmp_In_34 == -1) );
    if ( tmp_cmp_In_34 == 1 )
    {
        goto condexpr_true_34;
    }
    else
    {
        goto condexpr_false_34;
    }
    condexpr_true_34:;
    tmp_dict_name_34 = tmp_class_creation_34__class_dict;

    CHECK_OBJECT( tmp_dict_name_34 );
    tmp_key_name_34 = const_str_plain___metaclass__;
    tmp_assign_source_246 = DICT_GET_ITEM( tmp_dict_name_34, tmp_key_name_34 );
    if ( tmp_assign_source_246 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1323;

        goto try_except_handler_103;
    }
    goto condexpr_end_34;
    condexpr_false_34:;
    tmp_assign_source_246 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_246 );
    condexpr_end_34:;
    assert( tmp_class_creation_34__metaclass == NULL );
    tmp_class_creation_34__metaclass = tmp_assign_source_246;

    tmp_called_name_89 = tmp_class_creation_34__metaclass;

    CHECK_OBJECT( tmp_called_name_89 );
    tmp_args_element_name_145 = const_str_plain_CRLReason;
    tmp_args_element_name_146 = const_tuple_type_object_tuple;
    tmp_args_element_name_147 = tmp_class_creation_34__class_dict;

    CHECK_OBJECT( tmp_args_element_name_147 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1323;
    {
        PyObject *call_args[] = { tmp_args_element_name_145, tmp_args_element_name_146, tmp_args_element_name_147 };
        tmp_assign_source_247 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_89, call_args );
    }

    if ( tmp_assign_source_247 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1323;

        goto try_except_handler_103;
    }
    assert( tmp_class_creation_34__class == NULL );
    tmp_class_creation_34__class = tmp_assign_source_247;

    tmp_source_name_48 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_48 == NULL ))
    {
        tmp_source_name_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_48 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1322;

        goto try_except_handler_103;
    }

    tmp_called_name_91 = LOOKUP_ATTRIBUTE( tmp_source_name_48, const_str_plain_register_interface );
    if ( tmp_called_name_91 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1322;

        goto try_except_handler_103;
    }
    tmp_args_element_name_148 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_148 == NULL ))
    {
        tmp_args_element_name_148 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_148 == NULL )
    {
        Py_DECREF( tmp_called_name_91 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 1322;

        goto try_except_handler_103;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1322;
    {
        PyObject *call_args[] = { tmp_args_element_name_148 };
        tmp_called_name_90 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_91, call_args );
    }

    Py_DECREF( tmp_called_name_91 );
    if ( tmp_called_name_90 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1322;

        goto try_except_handler_103;
    }
    tmp_args_element_name_149 = tmp_class_creation_34__class;

    CHECK_OBJECT( tmp_args_element_name_149 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1322;
    {
        PyObject *call_args[] = { tmp_args_element_name_149 };
        tmp_assign_source_248 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_90, call_args );
    }

    Py_DECREF( tmp_called_name_90 );
    if ( tmp_assign_source_248 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1322;

        goto try_except_handler_103;
    }
    {
        PyObject *old = tmp_class_creation_34__class;
        assert( old != NULL );
        tmp_class_creation_34__class = tmp_assign_source_248;
        Py_DECREF( old );
    }

    goto try_end_61;
    // Exception handler code:
    try_except_handler_103:;
    exception_keeper_type_95 = exception_type;
    exception_keeper_value_95 = exception_value;
    exception_keeper_tb_95 = exception_tb;
    exception_keeper_lineno_95 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_34__class );
    tmp_class_creation_34__class = NULL;

    Py_XDECREF( tmp_class_creation_34__class_dict );
    tmp_class_creation_34__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_34__metaclass );
    tmp_class_creation_34__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_95;
    exception_value = exception_keeper_value_95;
    exception_tb = exception_keeper_tb_95;
    exception_lineno = exception_keeper_lineno_95;

    goto frame_exception_exit_1;
    // End of try:
    try_end_61:;
    tmp_assign_source_249 = tmp_class_creation_34__class;

    CHECK_OBJECT( tmp_assign_source_249 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLReason, tmp_assign_source_249 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_34__class );
    Py_DECREF( tmp_class_creation_34__class );
    tmp_class_creation_34__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_34__class_dict );
    Py_DECREF( tmp_class_creation_34__class_dict );
    tmp_class_creation_34__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_34__metaclass );
    Py_DECREF( tmp_class_creation_34__metaclass );
    tmp_class_creation_34__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_InvalidityDate_1351 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_InvalidityDate_1351, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bd5df53feaf3918c5d9af33cf2bcef94_32, codeobj_bd5df53feaf3918c5d9af33cf2bcef94, module_cryptography$x509$extensions, 0 );
    frame_bd5df53feaf3918c5d9af33cf2bcef94_32 = cache_frame_bd5df53feaf3918c5d9af33cf2bcef94_32;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bd5df53feaf3918c5d9af33cf2bcef94_32 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bd5df53feaf3918c5d9af33cf2bcef94_32 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_49 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID );

    if (unlikely( tmp_source_name_49 == NULL ))
    {
        tmp_source_name_49 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID );
    }

    if ( tmp_source_name_49 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "CRLEntryExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 1352;

        goto frame_exception_exit_32;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_49, const_str_plain_INVALIDITY_DATE );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1352;

        goto frame_exception_exit_32;
    }
    tmp_res = PyDict_SetItem( locals_InvalidityDate_1351, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1352;

        goto frame_exception_exit_32;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_158___init__(  );
    tmp_res = PyDict_SetItem( locals_InvalidityDate_1351, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_159___repr__(  );
    tmp_res = PyDict_SetItem( locals_InvalidityDate_1351, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_160___eq__(  );
    tmp_res = PyDict_SetItem( locals_InvalidityDate_1351, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_161___ne__(  );
    tmp_res = PyDict_SetItem( locals_InvalidityDate_1351, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_162___hash__(  );
    tmp_res = PyDict_SetItem( locals_InvalidityDate_1351, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_instance_38 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_38 == NULL ))
    {
        tmp_called_instance_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_38 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1377;

        goto frame_exception_exit_32;
    }

    frame_bd5df53feaf3918c5d9af33cf2bcef94_32->m_frame.f_lineno = 1377;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_38, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__invalidity_date_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1377;

        goto frame_exception_exit_32;
    }
    tmp_res = PyDict_SetItem( locals_InvalidityDate_1351, const_str_plain_invalidity_date, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1377;

        goto frame_exception_exit_32;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bd5df53feaf3918c5d9af33cf2bcef94_32 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_31;

    frame_exception_exit_32:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bd5df53feaf3918c5d9af33cf2bcef94_32 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bd5df53feaf3918c5d9af33cf2bcef94_32, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bd5df53feaf3918c5d9af33cf2bcef94_32->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bd5df53feaf3918c5d9af33cf2bcef94_32, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bd5df53feaf3918c5d9af33cf2bcef94_32,
        type_description_2
    );


    // Release cached frame.
    if ( frame_bd5df53feaf3918c5d9af33cf2bcef94_32 == cache_frame_bd5df53feaf3918c5d9af33cf2bcef94_32 )
    {
        Py_DECREF( frame_bd5df53feaf3918c5d9af33cf2bcef94_32 );
    }
    cache_frame_bd5df53feaf3918c5d9af33cf2bcef94_32 = NULL;

    assertFrameObject( frame_bd5df53feaf3918c5d9af33cf2bcef94_32 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_31;

    frame_no_exception_31:;

    goto skip_nested_handling_31;
    nested_frame_exit_31:;

    goto try_except_handler_106;
    skip_nested_handling_31:;
    tmp_outline_return_value_40 = locals_InvalidityDate_1351;
    Py_INCREF( tmp_outline_return_value_40 );
    goto try_return_handler_106;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_106:;
    Py_DECREF( locals_InvalidityDate_1351 );
    locals_InvalidityDate_1351 = NULL;
    goto outline_result_40;
    // Exception handler code:
    try_except_handler_106:;
    exception_keeper_type_96 = exception_type;
    exception_keeper_value_96 = exception_value;
    exception_keeper_tb_96 = exception_tb;
    exception_keeper_lineno_96 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_InvalidityDate_1351 );
    locals_InvalidityDate_1351 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_96;
    exception_value = exception_keeper_value_96;
    exception_tb = exception_keeper_tb_96;
    exception_lineno = exception_keeper_lineno_96;

    goto outline_exception_31;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_31:;
    exception_lineno = 1351;
    goto try_except_handler_105;
    outline_result_40:;
    tmp_assign_source_250 = tmp_outline_return_value_40;
    assert( tmp_class_creation_35__class_dict == NULL );
    tmp_class_creation_35__class_dict = tmp_assign_source_250;

    tmp_compare_left_35 = const_str_plain___metaclass__;
    tmp_compare_right_35 = tmp_class_creation_35__class_dict;

    CHECK_OBJECT( tmp_compare_right_35 );
    tmp_cmp_In_35 = PySequence_Contains( tmp_compare_right_35, tmp_compare_left_35 );
    assert( !(tmp_cmp_In_35 == -1) );
    if ( tmp_cmp_In_35 == 1 )
    {
        goto condexpr_true_35;
    }
    else
    {
        goto condexpr_false_35;
    }
    condexpr_true_35:;
    tmp_dict_name_35 = tmp_class_creation_35__class_dict;

    CHECK_OBJECT( tmp_dict_name_35 );
    tmp_key_name_35 = const_str_plain___metaclass__;
    tmp_assign_source_251 = DICT_GET_ITEM( tmp_dict_name_35, tmp_key_name_35 );
    if ( tmp_assign_source_251 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1351;

        goto try_except_handler_105;
    }
    goto condexpr_end_35;
    condexpr_false_35:;
    tmp_assign_source_251 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_251 );
    condexpr_end_35:;
    assert( tmp_class_creation_35__metaclass == NULL );
    tmp_class_creation_35__metaclass = tmp_assign_source_251;

    tmp_called_name_92 = tmp_class_creation_35__metaclass;

    CHECK_OBJECT( tmp_called_name_92 );
    tmp_args_element_name_150 = const_str_plain_InvalidityDate;
    tmp_args_element_name_151 = const_tuple_type_object_tuple;
    tmp_args_element_name_152 = tmp_class_creation_35__class_dict;

    CHECK_OBJECT( tmp_args_element_name_152 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1351;
    {
        PyObject *call_args[] = { tmp_args_element_name_150, tmp_args_element_name_151, tmp_args_element_name_152 };
        tmp_assign_source_252 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_92, call_args );
    }

    if ( tmp_assign_source_252 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1351;

        goto try_except_handler_105;
    }
    assert( tmp_class_creation_35__class == NULL );
    tmp_class_creation_35__class = tmp_assign_source_252;

    tmp_source_name_50 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_50 == NULL ))
    {
        tmp_source_name_50 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_50 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1350;

        goto try_except_handler_105;
    }

    tmp_called_name_94 = LOOKUP_ATTRIBUTE( tmp_source_name_50, const_str_plain_register_interface );
    if ( tmp_called_name_94 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1350;

        goto try_except_handler_105;
    }
    tmp_args_element_name_153 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_153 == NULL ))
    {
        tmp_args_element_name_153 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_153 == NULL )
    {
        Py_DECREF( tmp_called_name_94 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 1350;

        goto try_except_handler_105;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1350;
    {
        PyObject *call_args[] = { tmp_args_element_name_153 };
        tmp_called_name_93 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_94, call_args );
    }

    Py_DECREF( tmp_called_name_94 );
    if ( tmp_called_name_93 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1350;

        goto try_except_handler_105;
    }
    tmp_args_element_name_154 = tmp_class_creation_35__class;

    CHECK_OBJECT( tmp_args_element_name_154 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1350;
    {
        PyObject *call_args[] = { tmp_args_element_name_154 };
        tmp_assign_source_253 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_93, call_args );
    }

    Py_DECREF( tmp_called_name_93 );
    if ( tmp_assign_source_253 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1350;

        goto try_except_handler_105;
    }
    {
        PyObject *old = tmp_class_creation_35__class;
        assert( old != NULL );
        tmp_class_creation_35__class = tmp_assign_source_253;
        Py_DECREF( old );
    }

    goto try_end_62;
    // Exception handler code:
    try_except_handler_105:;
    exception_keeper_type_97 = exception_type;
    exception_keeper_value_97 = exception_value;
    exception_keeper_tb_97 = exception_tb;
    exception_keeper_lineno_97 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_35__class );
    tmp_class_creation_35__class = NULL;

    Py_XDECREF( tmp_class_creation_35__class_dict );
    tmp_class_creation_35__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_35__metaclass );
    tmp_class_creation_35__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_97;
    exception_value = exception_keeper_value_97;
    exception_tb = exception_keeper_tb_97;
    exception_lineno = exception_keeper_lineno_97;

    goto frame_exception_exit_1;
    // End of try:
    try_end_62:;
    tmp_assign_source_254 = tmp_class_creation_35__class;

    CHECK_OBJECT( tmp_assign_source_254 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_InvalidityDate, tmp_assign_source_254 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_35__class );
    Py_DECREF( tmp_class_creation_35__class );
    tmp_class_creation_35__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_35__class_dict );
    Py_DECREF( tmp_class_creation_35__class_dict );
    tmp_class_creation_35__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_35__metaclass );
    Py_DECREF( tmp_class_creation_35__metaclass );
    tmp_class_creation_35__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_PrecertificateSignedCertificateTimestamps_1381 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_PrecertificateSignedCertificateTimestamps_1381, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_223717f5f7d37ac0eeb879531047bfcf_33, codeobj_223717f5f7d37ac0eeb879531047bfcf, module_cryptography$x509$extensions, 0 );
    frame_223717f5f7d37ac0eeb879531047bfcf_33 = cache_frame_223717f5f7d37ac0eeb879531047bfcf_33;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_223717f5f7d37ac0eeb879531047bfcf_33 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_223717f5f7d37ac0eeb879531047bfcf_33 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_51 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_51 == NULL ))
    {
        tmp_source_name_51 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_51 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 1382;

        goto frame_exception_exit_33;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_51, const_str_plain_PRECERT_SIGNED_CERTIFICATE_TIMESTAMPS );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1382;

        goto frame_exception_exit_33;
    }
    tmp_res = PyDict_SetItem( locals_PrecertificateSignedCertificateTimestamps_1381, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1382;

        goto frame_exception_exit_33;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_163___init__(  );
    tmp_res = PyDict_SetItem( locals_PrecertificateSignedCertificateTimestamps_1381, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_called_name_95 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );

    if (unlikely( tmp_called_name_95 == NULL ))
    {
        tmp_called_name_95 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_sequence_methods );
    }

    if ( tmp_called_name_95 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_sequence_methods" );
        exception_tb = NULL;

        exception_lineno = 1396;

        goto try_except_handler_109;
    }

    frame_223717f5f7d37ac0eeb879531047bfcf_33->m_frame.f_lineno = 1396;
    tmp_iter_arg_13 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_95, &PyTuple_GET_ITEM( const_tuple_str_plain__signed_certificate_timestamps_tuple, 0 ) );

    if ( tmp_iter_arg_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1396;

        goto try_except_handler_109;
    }
    tmp_assign_source_256 = MAKE_ITERATOR( tmp_iter_arg_13 );
    Py_DECREF( tmp_iter_arg_13 );
    if ( tmp_assign_source_256 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1396;

        goto try_except_handler_109;
    }
    assert( tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__source_iter == NULL );
    tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__source_iter = tmp_assign_source_256;

    // Tried code:
    tmp_unpack_34 = tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_34 );
    tmp_assign_source_257 = UNPACK_NEXT( tmp_unpack_34, 0 );
    if ( tmp_assign_source_257 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1396;
        goto try_except_handler_110;
    }
    assert( tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_1 == NULL );
    tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_1 = tmp_assign_source_257;

    tmp_unpack_35 = tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_35 );
    tmp_assign_source_258 = UNPACK_NEXT( tmp_unpack_35, 1 );
    if ( tmp_assign_source_258 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1396;
        goto try_except_handler_110;
    }
    assert( tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_2 == NULL );
    tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_2 = tmp_assign_source_258;

    tmp_unpack_36 = tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_36 );
    tmp_assign_source_259 = UNPACK_NEXT( tmp_unpack_36, 2 );
    if ( tmp_assign_source_259 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 1396;
        goto try_except_handler_110;
    }
    assert( tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_3 == NULL );
    tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_3 = tmp_assign_source_259;

    tmp_iterator_name_12 = tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_12 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_12 ); assert( HAS_ITERNEXT( tmp_iterator_name_12 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_12 )->tp_iternext)( tmp_iterator_name_12 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1396;
                goto try_except_handler_110;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1396;
        goto try_except_handler_110;
    }
    goto try_end_63;
    // Exception handler code:
    try_except_handler_110:;
    exception_keeper_type_98 = exception_type;
    exception_keeper_value_98 = exception_value;
    exception_keeper_tb_98 = exception_tb;
    exception_keeper_lineno_98 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__source_iter );
    tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_98;
    exception_value = exception_keeper_value_98;
    exception_tb = exception_keeper_tb_98;
    exception_lineno = exception_keeper_lineno_98;

    goto try_except_handler_109;
    // End of try:
    try_end_63:;
    goto try_end_64;
    // Exception handler code:
    try_except_handler_109:;
    exception_keeper_type_99 = exception_type;
    exception_keeper_value_99 = exception_value;
    exception_keeper_tb_99 = exception_tb;
    exception_keeper_lineno_99 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_1 );
    tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_2 );
    tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_3 );
    tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_99;
    exception_value = exception_keeper_value_99;
    exception_tb = exception_keeper_tb_99;
    exception_lineno = exception_keeper_lineno_99;

    goto frame_exception_exit_33;
    // End of try:
    try_end_64:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_223717f5f7d37ac0eeb879531047bfcf_33 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_32;

    frame_exception_exit_33:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_223717f5f7d37ac0eeb879531047bfcf_33 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_223717f5f7d37ac0eeb879531047bfcf_33, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_223717f5f7d37ac0eeb879531047bfcf_33->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_223717f5f7d37ac0eeb879531047bfcf_33, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_223717f5f7d37ac0eeb879531047bfcf_33,
        type_description_2
    );


    // Release cached frame.
    if ( frame_223717f5f7d37ac0eeb879531047bfcf_33 == cache_frame_223717f5f7d37ac0eeb879531047bfcf_33 )
    {
        Py_DECREF( frame_223717f5f7d37ac0eeb879531047bfcf_33 );
    }
    cache_frame_223717f5f7d37ac0eeb879531047bfcf_33 = NULL;

    assertFrameObject( frame_223717f5f7d37ac0eeb879531047bfcf_33 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_32;

    frame_no_exception_32:;

    goto skip_nested_handling_32;
    nested_frame_exit_32:;

    goto try_except_handler_108;
    skip_nested_handling_32:;
    CHECK_OBJECT( (PyObject *)tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__source_iter );
    Py_DECREF( tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__source_iter );
    tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__source_iter = NULL;

    tmp_dictset_value = tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_PrecertificateSignedCertificateTimestamps_1381, const_str_plain___len__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_1 );
    tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_1 = NULL;

    tmp_dictset_value = tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_PrecertificateSignedCertificateTimestamps_1381, const_str_plain___iter__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_2 );
    tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_2 = NULL;

    tmp_dictset_value = tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_3;

    CHECK_OBJECT( tmp_dictset_value );
    tmp_res = PyDict_SetItem( locals_PrecertificateSignedCertificateTimestamps_1381, const_str_plain___getitem__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    Py_XDECREF( tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_3 );
    tmp_PrecertificateSignedCertificateTimestamps$tuple_unpack_1__element_3 = NULL;

    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_164___repr__(  );
    tmp_res = PyDict_SetItem( locals_PrecertificateSignedCertificateTimestamps_1381, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_165___hash__(  );
    tmp_res = PyDict_SetItem( locals_PrecertificateSignedCertificateTimestamps_1381, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_166___eq__(  );
    tmp_res = PyDict_SetItem( locals_PrecertificateSignedCertificateTimestamps_1381, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_167___ne__(  );
    tmp_res = PyDict_SetItem( locals_PrecertificateSignedCertificateTimestamps_1381, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_41 = locals_PrecertificateSignedCertificateTimestamps_1381;
    Py_INCREF( tmp_outline_return_value_41 );
    goto try_return_handler_108;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_108:;
    Py_DECREF( locals_PrecertificateSignedCertificateTimestamps_1381 );
    locals_PrecertificateSignedCertificateTimestamps_1381 = NULL;
    goto outline_result_41;
    // Exception handler code:
    try_except_handler_108:;
    exception_keeper_type_100 = exception_type;
    exception_keeper_value_100 = exception_value;
    exception_keeper_tb_100 = exception_tb;
    exception_keeper_lineno_100 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PrecertificateSignedCertificateTimestamps_1381 );
    locals_PrecertificateSignedCertificateTimestamps_1381 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_100;
    exception_value = exception_keeper_value_100;
    exception_tb = exception_keeper_tb_100;
    exception_lineno = exception_keeper_lineno_100;

    goto outline_exception_32;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_32:;
    exception_lineno = 1381;
    goto try_except_handler_107;
    outline_result_41:;
    tmp_assign_source_255 = tmp_outline_return_value_41;
    assert( tmp_class_creation_36__class_dict == NULL );
    tmp_class_creation_36__class_dict = tmp_assign_source_255;

    tmp_compare_left_36 = const_str_plain___metaclass__;
    tmp_compare_right_36 = tmp_class_creation_36__class_dict;

    CHECK_OBJECT( tmp_compare_right_36 );
    tmp_cmp_In_36 = PySequence_Contains( tmp_compare_right_36, tmp_compare_left_36 );
    assert( !(tmp_cmp_In_36 == -1) );
    if ( tmp_cmp_In_36 == 1 )
    {
        goto condexpr_true_36;
    }
    else
    {
        goto condexpr_false_36;
    }
    condexpr_true_36:;
    tmp_dict_name_36 = tmp_class_creation_36__class_dict;

    CHECK_OBJECT( tmp_dict_name_36 );
    tmp_key_name_36 = const_str_plain___metaclass__;
    tmp_assign_source_260 = DICT_GET_ITEM( tmp_dict_name_36, tmp_key_name_36 );
    if ( tmp_assign_source_260 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1381;

        goto try_except_handler_107;
    }
    goto condexpr_end_36;
    condexpr_false_36:;
    tmp_assign_source_260 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_260 );
    condexpr_end_36:;
    assert( tmp_class_creation_36__metaclass == NULL );
    tmp_class_creation_36__metaclass = tmp_assign_source_260;

    tmp_called_name_96 = tmp_class_creation_36__metaclass;

    CHECK_OBJECT( tmp_called_name_96 );
    tmp_args_element_name_155 = const_str_digest_97ac982b098bfd0facb64df38773c335;
    tmp_args_element_name_156 = const_tuple_type_object_tuple;
    tmp_args_element_name_157 = tmp_class_creation_36__class_dict;

    CHECK_OBJECT( tmp_args_element_name_157 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1381;
    {
        PyObject *call_args[] = { tmp_args_element_name_155, tmp_args_element_name_156, tmp_args_element_name_157 };
        tmp_assign_source_261 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_96, call_args );
    }

    if ( tmp_assign_source_261 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1381;

        goto try_except_handler_107;
    }
    assert( tmp_class_creation_36__class == NULL );
    tmp_class_creation_36__class = tmp_assign_source_261;

    tmp_source_name_52 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_52 == NULL ))
    {
        tmp_source_name_52 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_52 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1380;

        goto try_except_handler_107;
    }

    tmp_called_name_98 = LOOKUP_ATTRIBUTE( tmp_source_name_52, const_str_plain_register_interface );
    if ( tmp_called_name_98 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1380;

        goto try_except_handler_107;
    }
    tmp_args_element_name_158 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_158 == NULL ))
    {
        tmp_args_element_name_158 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_158 == NULL )
    {
        Py_DECREF( tmp_called_name_98 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 1380;

        goto try_except_handler_107;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1380;
    {
        PyObject *call_args[] = { tmp_args_element_name_158 };
        tmp_called_name_97 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_98, call_args );
    }

    Py_DECREF( tmp_called_name_98 );
    if ( tmp_called_name_97 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1380;

        goto try_except_handler_107;
    }
    tmp_args_element_name_159 = tmp_class_creation_36__class;

    CHECK_OBJECT( tmp_args_element_name_159 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1380;
    {
        PyObject *call_args[] = { tmp_args_element_name_159 };
        tmp_assign_source_262 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_97, call_args );
    }

    Py_DECREF( tmp_called_name_97 );
    if ( tmp_assign_source_262 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1380;

        goto try_except_handler_107;
    }
    {
        PyObject *old = tmp_class_creation_36__class;
        assert( old != NULL );
        tmp_class_creation_36__class = tmp_assign_source_262;
        Py_DECREF( old );
    }

    goto try_end_65;
    // Exception handler code:
    try_except_handler_107:;
    exception_keeper_type_101 = exception_type;
    exception_keeper_value_101 = exception_value;
    exception_keeper_tb_101 = exception_tb;
    exception_keeper_lineno_101 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_36__class );
    tmp_class_creation_36__class = NULL;

    Py_XDECREF( tmp_class_creation_36__class_dict );
    tmp_class_creation_36__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_36__metaclass );
    tmp_class_creation_36__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_101;
    exception_value = exception_keeper_value_101;
    exception_tb = exception_keeper_tb_101;
    exception_lineno = exception_keeper_lineno_101;

    goto frame_exception_exit_1;
    // End of try:
    try_end_65:;
    tmp_assign_source_263 = tmp_class_creation_36__class;

    CHECK_OBJECT( tmp_assign_source_263 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_digest_97ac982b098bfd0facb64df38773c335, tmp_assign_source_263 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_36__class );
    Py_DECREF( tmp_class_creation_36__class );
    tmp_class_creation_36__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_36__class_dict );
    Py_DECREF( tmp_class_creation_36__class_dict );
    tmp_class_creation_36__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_36__metaclass );
    Py_DECREF( tmp_class_creation_36__metaclass );
    tmp_class_creation_36__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_OCSPNonce_1424 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_OCSPNonce_1424, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a0dcedc74a44194c715350024de9064f_34, codeobj_a0dcedc74a44194c715350024de9064f, module_cryptography$x509$extensions, 0 );
    frame_a0dcedc74a44194c715350024de9064f_34 = cache_frame_a0dcedc74a44194c715350024de9064f_34;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a0dcedc74a44194c715350024de9064f_34 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a0dcedc74a44194c715350024de9064f_34 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_53 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OCSPExtensionOID );

    if (unlikely( tmp_source_name_53 == NULL ))
    {
        tmp_source_name_53 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OCSPExtensionOID );
    }

    if ( tmp_source_name_53 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "OCSPExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 1425;

        goto frame_exception_exit_34;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_53, const_str_plain_NONCE );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1425;

        goto frame_exception_exit_34;
    }
    tmp_res = PyDict_SetItem( locals_OCSPNonce_1424, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1425;

        goto frame_exception_exit_34;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_168___init__(  );
    tmp_res = PyDict_SetItem( locals_OCSPNonce_1424, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_169___eq__(  );
    tmp_res = PyDict_SetItem( locals_OCSPNonce_1424, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_170___ne__(  );
    tmp_res = PyDict_SetItem( locals_OCSPNonce_1424, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_171___hash__(  );
    tmp_res = PyDict_SetItem( locals_OCSPNonce_1424, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_172___repr__(  );
    tmp_res = PyDict_SetItem( locals_OCSPNonce_1424, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_instance_39 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_39 == NULL ))
    {
        tmp_called_instance_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_39 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1448;

        goto frame_exception_exit_34;
    }

    frame_a0dcedc74a44194c715350024de9064f_34->m_frame.f_lineno = 1448;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_39, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__nonce_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1448;

        goto frame_exception_exit_34;
    }
    tmp_res = PyDict_SetItem( locals_OCSPNonce_1424, const_str_plain_nonce, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1448;

        goto frame_exception_exit_34;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0dcedc74a44194c715350024de9064f_34 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_33;

    frame_exception_exit_34:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0dcedc74a44194c715350024de9064f_34 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a0dcedc74a44194c715350024de9064f_34, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a0dcedc74a44194c715350024de9064f_34->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a0dcedc74a44194c715350024de9064f_34, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a0dcedc74a44194c715350024de9064f_34,
        type_description_2
    );


    // Release cached frame.
    if ( frame_a0dcedc74a44194c715350024de9064f_34 == cache_frame_a0dcedc74a44194c715350024de9064f_34 )
    {
        Py_DECREF( frame_a0dcedc74a44194c715350024de9064f_34 );
    }
    cache_frame_a0dcedc74a44194c715350024de9064f_34 = NULL;

    assertFrameObject( frame_a0dcedc74a44194c715350024de9064f_34 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_33;

    frame_no_exception_33:;

    goto skip_nested_handling_33;
    nested_frame_exit_33:;

    goto try_except_handler_112;
    skip_nested_handling_33:;
    tmp_outline_return_value_42 = locals_OCSPNonce_1424;
    Py_INCREF( tmp_outline_return_value_42 );
    goto try_return_handler_112;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_112:;
    Py_DECREF( locals_OCSPNonce_1424 );
    locals_OCSPNonce_1424 = NULL;
    goto outline_result_42;
    // Exception handler code:
    try_except_handler_112:;
    exception_keeper_type_102 = exception_type;
    exception_keeper_value_102 = exception_value;
    exception_keeper_tb_102 = exception_tb;
    exception_keeper_lineno_102 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_OCSPNonce_1424 );
    locals_OCSPNonce_1424 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_102;
    exception_value = exception_keeper_value_102;
    exception_tb = exception_keeper_tb_102;
    exception_lineno = exception_keeper_lineno_102;

    goto outline_exception_33;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_33:;
    exception_lineno = 1424;
    goto try_except_handler_111;
    outline_result_42:;
    tmp_assign_source_264 = tmp_outline_return_value_42;
    assert( tmp_class_creation_37__class_dict == NULL );
    tmp_class_creation_37__class_dict = tmp_assign_source_264;

    tmp_compare_left_37 = const_str_plain___metaclass__;
    tmp_compare_right_37 = tmp_class_creation_37__class_dict;

    CHECK_OBJECT( tmp_compare_right_37 );
    tmp_cmp_In_37 = PySequence_Contains( tmp_compare_right_37, tmp_compare_left_37 );
    assert( !(tmp_cmp_In_37 == -1) );
    if ( tmp_cmp_In_37 == 1 )
    {
        goto condexpr_true_37;
    }
    else
    {
        goto condexpr_false_37;
    }
    condexpr_true_37:;
    tmp_dict_name_37 = tmp_class_creation_37__class_dict;

    CHECK_OBJECT( tmp_dict_name_37 );
    tmp_key_name_37 = const_str_plain___metaclass__;
    tmp_assign_source_265 = DICT_GET_ITEM( tmp_dict_name_37, tmp_key_name_37 );
    if ( tmp_assign_source_265 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1424;

        goto try_except_handler_111;
    }
    goto condexpr_end_37;
    condexpr_false_37:;
    tmp_assign_source_265 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_265 );
    condexpr_end_37:;
    assert( tmp_class_creation_37__metaclass == NULL );
    tmp_class_creation_37__metaclass = tmp_assign_source_265;

    tmp_called_name_99 = tmp_class_creation_37__metaclass;

    CHECK_OBJECT( tmp_called_name_99 );
    tmp_args_element_name_160 = const_str_plain_OCSPNonce;
    tmp_args_element_name_161 = const_tuple_type_object_tuple;
    tmp_args_element_name_162 = tmp_class_creation_37__class_dict;

    CHECK_OBJECT( tmp_args_element_name_162 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1424;
    {
        PyObject *call_args[] = { tmp_args_element_name_160, tmp_args_element_name_161, tmp_args_element_name_162 };
        tmp_assign_source_266 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_99, call_args );
    }

    if ( tmp_assign_source_266 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1424;

        goto try_except_handler_111;
    }
    assert( tmp_class_creation_37__class == NULL );
    tmp_class_creation_37__class = tmp_assign_source_266;

    tmp_source_name_54 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_54 == NULL ))
    {
        tmp_source_name_54 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_54 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1423;

        goto try_except_handler_111;
    }

    tmp_called_name_101 = LOOKUP_ATTRIBUTE( tmp_source_name_54, const_str_plain_register_interface );
    if ( tmp_called_name_101 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1423;

        goto try_except_handler_111;
    }
    tmp_args_element_name_163 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_163 == NULL ))
    {
        tmp_args_element_name_163 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_163 == NULL )
    {
        Py_DECREF( tmp_called_name_101 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 1423;

        goto try_except_handler_111;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1423;
    {
        PyObject *call_args[] = { tmp_args_element_name_163 };
        tmp_called_name_100 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_101, call_args );
    }

    Py_DECREF( tmp_called_name_101 );
    if ( tmp_called_name_100 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1423;

        goto try_except_handler_111;
    }
    tmp_args_element_name_164 = tmp_class_creation_37__class;

    CHECK_OBJECT( tmp_args_element_name_164 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1423;
    {
        PyObject *call_args[] = { tmp_args_element_name_164 };
        tmp_assign_source_267 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_100, call_args );
    }

    Py_DECREF( tmp_called_name_100 );
    if ( tmp_assign_source_267 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1423;

        goto try_except_handler_111;
    }
    {
        PyObject *old = tmp_class_creation_37__class;
        assert( old != NULL );
        tmp_class_creation_37__class = tmp_assign_source_267;
        Py_DECREF( old );
    }

    goto try_end_66;
    // Exception handler code:
    try_except_handler_111:;
    exception_keeper_type_103 = exception_type;
    exception_keeper_value_103 = exception_value;
    exception_keeper_tb_103 = exception_tb;
    exception_keeper_lineno_103 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_37__class );
    tmp_class_creation_37__class = NULL;

    Py_XDECREF( tmp_class_creation_37__class_dict );
    tmp_class_creation_37__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_37__metaclass );
    tmp_class_creation_37__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_103;
    exception_value = exception_keeper_value_103;
    exception_tb = exception_keeper_tb_103;
    exception_lineno = exception_keeper_lineno_103;

    goto frame_exception_exit_1;
    // End of try:
    try_end_66:;
    tmp_assign_source_268 = tmp_class_creation_37__class;

    CHECK_OBJECT( tmp_assign_source_268 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OCSPNonce, tmp_assign_source_268 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_37__class );
    Py_DECREF( tmp_class_creation_37__class );
    tmp_class_creation_37__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_37__class_dict );
    Py_DECREF( tmp_class_creation_37__class_dict );
    tmp_class_creation_37__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_37__metaclass );
    Py_DECREF( tmp_class_creation_37__metaclass );
    tmp_class_creation_37__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_IssuingDistributionPoint_1452 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2db8e09794d5a59d04ae35a3fa1b13f2_35, codeobj_2db8e09794d5a59d04ae35a3fa1b13f2, module_cryptography$x509$extensions, 0 );
    frame_2db8e09794d5a59d04ae35a3fa1b13f2_35 = cache_frame_2db8e09794d5a59d04ae35a3fa1b13f2_35;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2db8e09794d5a59d04ae35a3fa1b13f2_35 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2db8e09794d5a59d04ae35a3fa1b13f2_35 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_55 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID );

    if (unlikely( tmp_source_name_55 == NULL ))
    {
        tmp_source_name_55 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID );
    }

    if ( tmp_source_name_55 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionOID" );
        exception_tb = NULL;

        exception_lineno = 1453;

        goto frame_exception_exit_35;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_55, const_str_plain_ISSUING_DISTRIBUTION_POINT );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1453;

        goto frame_exception_exit_35;
    }
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1453;

        goto frame_exception_exit_35;
    }
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_173___init__(  );
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_174___repr__(  );
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_175___eq__(  );
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_176___ne__(  );
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_177___hash__(  );
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_instance_40 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_40 == NULL ))
    {
        tmp_called_instance_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_40 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1566;

        goto frame_exception_exit_35;
    }

    frame_2db8e09794d5a59d04ae35a3fa1b13f2_35->m_frame.f_lineno = 1566;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_40, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__full_name_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1566;

        goto frame_exception_exit_35;
    }
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain_full_name, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1566;

        goto frame_exception_exit_35;
    }
    tmp_called_instance_41 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_41 == NULL ))
    {
        tmp_called_instance_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_41 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1567;

        goto frame_exception_exit_35;
    }

    frame_2db8e09794d5a59d04ae35a3fa1b13f2_35->m_frame.f_lineno = 1567;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_41, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__relative_name_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1567;

        goto frame_exception_exit_35;
    }
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain_relative_name, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1567;

        goto frame_exception_exit_35;
    }
    tmp_called_instance_42 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_42 == NULL ))
    {
        tmp_called_instance_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_42 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1568;

        goto frame_exception_exit_35;
    }

    frame_2db8e09794d5a59d04ae35a3fa1b13f2_35->m_frame.f_lineno = 1568;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_42, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__only_contains_user_certs_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1568;

        goto frame_exception_exit_35;
    }
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain_only_contains_user_certs, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1568;

        goto frame_exception_exit_35;
    }
    tmp_called_instance_43 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_43 == NULL ))
    {
        tmp_called_instance_43 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_43 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1571;

        goto frame_exception_exit_35;
    }

    frame_2db8e09794d5a59d04ae35a3fa1b13f2_35->m_frame.f_lineno = 1571;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_43, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__only_contains_ca_certs_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1571;

        goto frame_exception_exit_35;
    }
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain_only_contains_ca_certs, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1571;

        goto frame_exception_exit_35;
    }
    tmp_called_instance_44 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_44 == NULL ))
    {
        tmp_called_instance_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_44 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1574;

        goto frame_exception_exit_35;
    }

    frame_2db8e09794d5a59d04ae35a3fa1b13f2_35->m_frame.f_lineno = 1574;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_44, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__only_some_reasons_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1574;

        goto frame_exception_exit_35;
    }
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain_only_some_reasons, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1574;

        goto frame_exception_exit_35;
    }
    tmp_called_instance_45 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_45 == NULL ))
    {
        tmp_called_instance_45 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_45 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1575;

        goto frame_exception_exit_35;
    }

    frame_2db8e09794d5a59d04ae35a3fa1b13f2_35->m_frame.f_lineno = 1575;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_45, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__indirect_crl_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1575;

        goto frame_exception_exit_35;
    }
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain_indirect_crl, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1575;

        goto frame_exception_exit_35;
    }
    tmp_called_instance_46 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_46 == NULL ))
    {
        tmp_called_instance_46 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_46 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1576;

        goto frame_exception_exit_35;
    }

    frame_2db8e09794d5a59d04ae35a3fa1b13f2_35->m_frame.f_lineno = 1576;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_46, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__only_contains_attribute_certs_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1576;

        goto frame_exception_exit_35;
    }
    tmp_res = PyDict_SetItem( locals_IssuingDistributionPoint_1452, const_str_plain_only_contains_attribute_certs, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1576;

        goto frame_exception_exit_35;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2db8e09794d5a59d04ae35a3fa1b13f2_35 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_34;

    frame_exception_exit_35:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2db8e09794d5a59d04ae35a3fa1b13f2_35 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2db8e09794d5a59d04ae35a3fa1b13f2_35, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2db8e09794d5a59d04ae35a3fa1b13f2_35->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2db8e09794d5a59d04ae35a3fa1b13f2_35, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2db8e09794d5a59d04ae35a3fa1b13f2_35,
        type_description_2
    );


    // Release cached frame.
    if ( frame_2db8e09794d5a59d04ae35a3fa1b13f2_35 == cache_frame_2db8e09794d5a59d04ae35a3fa1b13f2_35 )
    {
        Py_DECREF( frame_2db8e09794d5a59d04ae35a3fa1b13f2_35 );
    }
    cache_frame_2db8e09794d5a59d04ae35a3fa1b13f2_35 = NULL;

    assertFrameObject( frame_2db8e09794d5a59d04ae35a3fa1b13f2_35 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_34;

    frame_no_exception_34:;

    goto skip_nested_handling_34;
    nested_frame_exit_34:;

    goto try_except_handler_114;
    skip_nested_handling_34:;
    tmp_outline_return_value_43 = locals_IssuingDistributionPoint_1452;
    Py_INCREF( tmp_outline_return_value_43 );
    goto try_return_handler_114;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_114:;
    Py_DECREF( locals_IssuingDistributionPoint_1452 );
    locals_IssuingDistributionPoint_1452 = NULL;
    goto outline_result_43;
    // Exception handler code:
    try_except_handler_114:;
    exception_keeper_type_104 = exception_type;
    exception_keeper_value_104 = exception_value;
    exception_keeper_tb_104 = exception_tb;
    exception_keeper_lineno_104 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_IssuingDistributionPoint_1452 );
    locals_IssuingDistributionPoint_1452 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_104;
    exception_value = exception_keeper_value_104;
    exception_tb = exception_keeper_tb_104;
    exception_lineno = exception_keeper_lineno_104;

    goto outline_exception_34;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_34:;
    exception_lineno = 1452;
    goto try_except_handler_113;
    outline_result_43:;
    tmp_assign_source_269 = tmp_outline_return_value_43;
    assert( tmp_class_creation_38__class_dict == NULL );
    tmp_class_creation_38__class_dict = tmp_assign_source_269;

    tmp_compare_left_38 = const_str_plain___metaclass__;
    tmp_compare_right_38 = tmp_class_creation_38__class_dict;

    CHECK_OBJECT( tmp_compare_right_38 );
    tmp_cmp_In_38 = PySequence_Contains( tmp_compare_right_38, tmp_compare_left_38 );
    assert( !(tmp_cmp_In_38 == -1) );
    if ( tmp_cmp_In_38 == 1 )
    {
        goto condexpr_true_38;
    }
    else
    {
        goto condexpr_false_38;
    }
    condexpr_true_38:;
    tmp_dict_name_38 = tmp_class_creation_38__class_dict;

    CHECK_OBJECT( tmp_dict_name_38 );
    tmp_key_name_38 = const_str_plain___metaclass__;
    tmp_assign_source_270 = DICT_GET_ITEM( tmp_dict_name_38, tmp_key_name_38 );
    if ( tmp_assign_source_270 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1452;

        goto try_except_handler_113;
    }
    goto condexpr_end_38;
    condexpr_false_38:;
    tmp_assign_source_270 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_270 );
    condexpr_end_38:;
    assert( tmp_class_creation_38__metaclass == NULL );
    tmp_class_creation_38__metaclass = tmp_assign_source_270;

    tmp_called_name_102 = tmp_class_creation_38__metaclass;

    CHECK_OBJECT( tmp_called_name_102 );
    tmp_args_element_name_165 = const_str_plain_IssuingDistributionPoint;
    tmp_args_element_name_166 = const_tuple_type_object_tuple;
    tmp_args_element_name_167 = tmp_class_creation_38__class_dict;

    CHECK_OBJECT( tmp_args_element_name_167 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1452;
    {
        PyObject *call_args[] = { tmp_args_element_name_165, tmp_args_element_name_166, tmp_args_element_name_167 };
        tmp_assign_source_271 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_102, call_args );
    }

    if ( tmp_assign_source_271 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1452;

        goto try_except_handler_113;
    }
    assert( tmp_class_creation_38__class == NULL );
    tmp_class_creation_38__class = tmp_assign_source_271;

    tmp_source_name_56 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_56 == NULL ))
    {
        tmp_source_name_56 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_56 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1451;

        goto try_except_handler_113;
    }

    tmp_called_name_104 = LOOKUP_ATTRIBUTE( tmp_source_name_56, const_str_plain_register_interface );
    if ( tmp_called_name_104 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1451;

        goto try_except_handler_113;
    }
    tmp_args_element_name_168 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_168 == NULL ))
    {
        tmp_args_element_name_168 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_168 == NULL )
    {
        Py_DECREF( tmp_called_name_104 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 1451;

        goto try_except_handler_113;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1451;
    {
        PyObject *call_args[] = { tmp_args_element_name_168 };
        tmp_called_name_103 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_104, call_args );
    }

    Py_DECREF( tmp_called_name_104 );
    if ( tmp_called_name_103 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1451;

        goto try_except_handler_113;
    }
    tmp_args_element_name_169 = tmp_class_creation_38__class;

    CHECK_OBJECT( tmp_args_element_name_169 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1451;
    {
        PyObject *call_args[] = { tmp_args_element_name_169 };
        tmp_assign_source_272 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_103, call_args );
    }

    Py_DECREF( tmp_called_name_103 );
    if ( tmp_assign_source_272 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1451;

        goto try_except_handler_113;
    }
    {
        PyObject *old = tmp_class_creation_38__class;
        assert( old != NULL );
        tmp_class_creation_38__class = tmp_assign_source_272;
        Py_DECREF( old );
    }

    goto try_end_67;
    // Exception handler code:
    try_except_handler_113:;
    exception_keeper_type_105 = exception_type;
    exception_keeper_value_105 = exception_value;
    exception_keeper_tb_105 = exception_tb;
    exception_keeper_lineno_105 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_38__class );
    tmp_class_creation_38__class = NULL;

    Py_XDECREF( tmp_class_creation_38__class_dict );
    tmp_class_creation_38__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_38__metaclass );
    tmp_class_creation_38__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_105;
    exception_value = exception_keeper_value_105;
    exception_tb = exception_keeper_tb_105;
    exception_lineno = exception_keeper_lineno_105;

    goto frame_exception_exit_1;
    // End of try:
    try_end_67:;
    tmp_assign_source_273 = tmp_class_creation_38__class;

    CHECK_OBJECT( tmp_assign_source_273 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_IssuingDistributionPoint, tmp_assign_source_273 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_38__class );
    Py_DECREF( tmp_class_creation_38__class );
    tmp_class_creation_38__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_38__class_dict );
    Py_DECREF( tmp_class_creation_38__class_dict );
    tmp_class_creation_38__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_38__metaclass );
    Py_DECREF( tmp_class_creation_38__metaclass );
    tmp_class_creation_38__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_UnrecognizedExtension_1582 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
    tmp_res = PyDict_SetItem( locals_UnrecognizedExtension_1582, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_178___init__(  );
    tmp_res = PyDict_SetItem( locals_UnrecognizedExtension_1582, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_97f6035c4dcab8dd27ed5558d571757a_36, codeobj_97f6035c4dcab8dd27ed5558d571757a, module_cryptography$x509$extensions, 0 );
    frame_97f6035c4dcab8dd27ed5558d571757a_36 = cache_frame_97f6035c4dcab8dd27ed5558d571757a_36;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_97f6035c4dcab8dd27ed5558d571757a_36 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_97f6035c4dcab8dd27ed5558d571757a_36 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_47 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_47 == NULL ))
    {
        tmp_called_instance_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_47 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1589;

        goto frame_exception_exit_36;
    }

    frame_97f6035c4dcab8dd27ed5558d571757a_36->m_frame.f_lineno = 1589;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_47, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__oid_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1589;

        goto frame_exception_exit_36;
    }
    tmp_res = PyDict_SetItem( locals_UnrecognizedExtension_1582, const_str_plain_oid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1589;

        goto frame_exception_exit_36;
    }
    tmp_called_instance_48 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_called_instance_48 == NULL ))
    {
        tmp_called_instance_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_called_instance_48 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1590;

        goto frame_exception_exit_36;
    }

    frame_97f6035c4dcab8dd27ed5558d571757a_36->m_frame.f_lineno = 1590;
    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_48, const_str_plain_read_only_property, &PyTuple_GET_ITEM( const_tuple_str_plain__value_tuple, 0 ) );

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1590;

        goto frame_exception_exit_36;
    }
    tmp_res = PyDict_SetItem( locals_UnrecognizedExtension_1582, const_str_plain_value, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1590;

        goto frame_exception_exit_36;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_97f6035c4dcab8dd27ed5558d571757a_36 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_35;

    frame_exception_exit_36:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_97f6035c4dcab8dd27ed5558d571757a_36 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_97f6035c4dcab8dd27ed5558d571757a_36, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_97f6035c4dcab8dd27ed5558d571757a_36->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_97f6035c4dcab8dd27ed5558d571757a_36, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_97f6035c4dcab8dd27ed5558d571757a_36,
        type_description_2
    );


    // Release cached frame.
    if ( frame_97f6035c4dcab8dd27ed5558d571757a_36 == cache_frame_97f6035c4dcab8dd27ed5558d571757a_36 )
    {
        Py_DECREF( frame_97f6035c4dcab8dd27ed5558d571757a_36 );
    }
    cache_frame_97f6035c4dcab8dd27ed5558d571757a_36 = NULL;

    assertFrameObject( frame_97f6035c4dcab8dd27ed5558d571757a_36 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_35;

    frame_no_exception_35:;

    goto skip_nested_handling_35;
    nested_frame_exit_35:;

    goto try_except_handler_116;
    skip_nested_handling_35:;
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_179___repr__(  );
    tmp_res = PyDict_SetItem( locals_UnrecognizedExtension_1582, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_180___eq__(  );
    tmp_res = PyDict_SetItem( locals_UnrecognizedExtension_1582, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_181___ne__(  );
    tmp_res = PyDict_SetItem( locals_UnrecognizedExtension_1582, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_182___hash__(  );
    tmp_res = PyDict_SetItem( locals_UnrecognizedExtension_1582, const_str_plain___hash__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_44 = locals_UnrecognizedExtension_1582;
    Py_INCREF( tmp_outline_return_value_44 );
    goto try_return_handler_116;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_116:;
    Py_DECREF( locals_UnrecognizedExtension_1582 );
    locals_UnrecognizedExtension_1582 = NULL;
    goto outline_result_44;
    // Exception handler code:
    try_except_handler_116:;
    exception_keeper_type_106 = exception_type;
    exception_keeper_value_106 = exception_value;
    exception_keeper_tb_106 = exception_tb;
    exception_keeper_lineno_106 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_UnrecognizedExtension_1582 );
    locals_UnrecognizedExtension_1582 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_106;
    exception_value = exception_keeper_value_106;
    exception_tb = exception_keeper_tb_106;
    exception_lineno = exception_keeper_lineno_106;

    goto outline_exception_35;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( cryptography$x509$extensions );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_35:;
    exception_lineno = 1582;
    goto try_except_handler_115;
    outline_result_44:;
    tmp_assign_source_274 = tmp_outline_return_value_44;
    assert( tmp_class_creation_39__class_dict == NULL );
    tmp_class_creation_39__class_dict = tmp_assign_source_274;

    tmp_compare_left_39 = const_str_plain___metaclass__;
    tmp_compare_right_39 = tmp_class_creation_39__class_dict;

    CHECK_OBJECT( tmp_compare_right_39 );
    tmp_cmp_In_39 = PySequence_Contains( tmp_compare_right_39, tmp_compare_left_39 );
    assert( !(tmp_cmp_In_39 == -1) );
    if ( tmp_cmp_In_39 == 1 )
    {
        goto condexpr_true_39;
    }
    else
    {
        goto condexpr_false_39;
    }
    condexpr_true_39:;
    tmp_dict_name_39 = tmp_class_creation_39__class_dict;

    CHECK_OBJECT( tmp_dict_name_39 );
    tmp_key_name_39 = const_str_plain___metaclass__;
    tmp_assign_source_275 = DICT_GET_ITEM( tmp_dict_name_39, tmp_key_name_39 );
    if ( tmp_assign_source_275 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1582;

        goto try_except_handler_115;
    }
    goto condexpr_end_39;
    condexpr_false_39:;
    tmp_assign_source_275 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_275 );
    condexpr_end_39:;
    assert( tmp_class_creation_39__metaclass == NULL );
    tmp_class_creation_39__metaclass = tmp_assign_source_275;

    tmp_called_name_105 = tmp_class_creation_39__metaclass;

    CHECK_OBJECT( tmp_called_name_105 );
    tmp_args_element_name_170 = const_str_plain_UnrecognizedExtension;
    tmp_args_element_name_171 = const_tuple_type_object_tuple;
    tmp_args_element_name_172 = tmp_class_creation_39__class_dict;

    CHECK_OBJECT( tmp_args_element_name_172 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1582;
    {
        PyObject *call_args[] = { tmp_args_element_name_170, tmp_args_element_name_171, tmp_args_element_name_172 };
        tmp_assign_source_276 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_105, call_args );
    }

    if ( tmp_assign_source_276 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1582;

        goto try_except_handler_115;
    }
    assert( tmp_class_creation_39__class == NULL );
    tmp_class_creation_39__class = tmp_assign_source_276;

    tmp_source_name_57 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_57 == NULL ))
    {
        tmp_source_name_57 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_57 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 1581;

        goto try_except_handler_115;
    }

    tmp_called_name_107 = LOOKUP_ATTRIBUTE( tmp_source_name_57, const_str_plain_register_interface );
    if ( tmp_called_name_107 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1581;

        goto try_except_handler_115;
    }
    tmp_args_element_name_173 = GET_STRING_DICT_VALUE( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType );

    if (unlikely( tmp_args_element_name_173 == NULL ))
    {
        tmp_args_element_name_173 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType );
    }

    if ( tmp_args_element_name_173 == NULL )
    {
        Py_DECREF( tmp_called_name_107 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ExtensionType" );
        exception_tb = NULL;

        exception_lineno = 1581;

        goto try_except_handler_115;
    }

    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1581;
    {
        PyObject *call_args[] = { tmp_args_element_name_173 };
        tmp_called_name_106 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_107, call_args );
    }

    Py_DECREF( tmp_called_name_107 );
    if ( tmp_called_name_106 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1581;

        goto try_except_handler_115;
    }
    tmp_args_element_name_174 = tmp_class_creation_39__class;

    CHECK_OBJECT( tmp_args_element_name_174 );
    frame_80de6067447f8063ab4895e4ecf97af8->m_frame.f_lineno = 1581;
    {
        PyObject *call_args[] = { tmp_args_element_name_174 };
        tmp_assign_source_277 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_106, call_args );
    }

    Py_DECREF( tmp_called_name_106 );
    if ( tmp_assign_source_277 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1581;

        goto try_except_handler_115;
    }
    {
        PyObject *old = tmp_class_creation_39__class;
        assert( old != NULL );
        tmp_class_creation_39__class = tmp_assign_source_277;
        Py_DECREF( old );
    }

    goto try_end_68;
    // Exception handler code:
    try_except_handler_115:;
    exception_keeper_type_107 = exception_type;
    exception_keeper_value_107 = exception_value;
    exception_keeper_tb_107 = exception_tb;
    exception_keeper_lineno_107 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_39__class );
    tmp_class_creation_39__class = NULL;

    Py_XDECREF( tmp_class_creation_39__class_dict );
    tmp_class_creation_39__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_39__metaclass );
    tmp_class_creation_39__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_107;
    exception_value = exception_keeper_value_107;
    exception_tb = exception_keeper_tb_107;
    exception_lineno = exception_keeper_lineno_107;

    goto frame_exception_exit_1;
    // End of try:
    try_end_68:;

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION( frame_80de6067447f8063ab4895e4ecf97af8 );
#endif
    popFrameStack();

    assertFrameObject( frame_80de6067447f8063ab4895e4ecf97af8 );

    goto frame_no_exception_36;
    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_80de6067447f8063ab4895e4ecf97af8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_80de6067447f8063ab4895e4ecf97af8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_80de6067447f8063ab4895e4ecf97af8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_80de6067447f8063ab4895e4ecf97af8, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;
    frame_no_exception_36:;
    tmp_assign_source_278 = tmp_class_creation_39__class;

    CHECK_OBJECT( tmp_assign_source_278 );
    UPDATE_STRING_DICT0( moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_UnrecognizedExtension, tmp_assign_source_278 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_39__class );
    Py_DECREF( tmp_class_creation_39__class );
    tmp_class_creation_39__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_39__class_dict );
    Py_DECREF( tmp_class_creation_39__class_dict );
    tmp_class_creation_39__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_39__metaclass );
    Py_DECREF( tmp_class_creation_39__metaclass );
    tmp_class_creation_39__metaclass = NULL;


    return MOD_RETURN_VALUE( module_cryptography$x509$extensions );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
