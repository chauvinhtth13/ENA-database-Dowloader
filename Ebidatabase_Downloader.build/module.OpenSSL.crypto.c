/* Generated code for Python source for module 'OpenSSL.crypto'
 * created by Nuitka version 0.5.30
 *
 * This code is in part copyright 2018 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The _module_OpenSSL$crypto is a Python object pointer of module type. */

/* Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_OpenSSL$crypto;
PyDictObject *moduledict_OpenSSL$crypto;

/* The module constants used, if any. */
static PyObject *const_str_plain_set_lastUpdate;
static PyObject *const_str_plain__nid;
static PyObject *const_str_plain_OBJ_nid2ln;
static PyObject *const_str_digest_340717166d8c6af86f5d8a6e35ed5a7f;
static PyObject *const_str_digest_014a797afcc3e1ad4f3e6e9aa4631a8a;
static PyObject *const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple;
static PyObject *const_str_digest_73f7a7ef7b02ca8c5d7fdfe1049be561;
extern PyObject *const_str_plain_data;
static PyObject *const_str_plain__truncate;
static PyObject *const_str_plain_X509StoreContext;
extern PyObject *const_str_plain_X509_CRL_get_nextUpdate;
extern PyObject *const_str_plain_EVP_PKEY_id;
static PyObject *const_str_plain_issuer_key;
static PyObject *const_str_digest_7163953ad9ff69e46167d396f5625cf7;
static PyObject *const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple;
extern PyObject *const_str_plain_PEM_write_bio_X509;
extern PyObject *const_str_plain_EVP_MAX_MD_SIZE;
static PyObject *const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple;
static PyObject *const_str_plain_X509_V_FLAG_POLICY_CHECK;
static PyObject *const_str_digest_b52a484c26b348bfec0a17217a58ad7e;
extern PyObject *const_str_plain_sk_X509_EXTENSION_pop_free;
static PyObject *const_str_digest_a9bcf1af78e6d912e13685d8a606fe30;
static PyObject *const_str_digest_8fda740163dc7d07c78736dc2ebb17b1;
extern PyObject *const_str_plain_X509_set_subject_name;
static PyObject *const_str_plain_all_reasons;
static PyObject *const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple;
static PyObject *const_str_digest_90de967a5219b9210479f7eac5c285c8;
static PyObject *const_str_digest_e335a7c8a0dd4d8ab6096b1597d79143;
static PyObject *const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple;
extern PyObject *const_str_plain_UNSPECIFIED;
extern PyObject *const_str_plain_ret;
static PyObject *const_str_plain_TYPE_RSA;
static PyObject *const_str_plain_X509_VERIFY_PARAM_free;
static PyObject *const_str_digest_52cbe8d655a10e46907a30970ef9889a;
static PyObject *const_str_plain_sk_X509_EXTENSION_free;
extern PyObject *const_str_plain_PKCS12_free;
static PyObject *const_str_digest_435662c26b2c422edb954b82c85c55d9;
static PyObject *const_str_digest_f737de4a45174195dc1e46101235dc35;
static PyObject *const_str_plain_get_rev_date;
extern PyObject *const_str_plain_pkey;
static PyObject *const_str_plain_utcnow;
static PyObject *const_str_plain_sometime;
extern PyObject *const_str_plain_get_certificate;
static PyObject *const_tuple_str_plain_cls_str_plain_lib_tuple;
static PyObject *const_str_plain_RSA_check_key;
extern PyObject *const_str_digest_c075052d723d6707083e869a0e3659bb;
extern PyObject *const_tuple_str_plain_self_str_plain_version_tuple;
extern PyObject *const_str_plain__CertificateRevocationList;
static PyObject *const_str_plain__get_elliptic_curves;
extern PyObject *const_str_plain_X509_REQ_get_pubkey;
extern PyObject *const_str_plain__problems;
extern PyObject *const_str_plain_stack;
extern PyObject *const_str_digest_bc7a2d385ac0b4ca6f6caa64ccb6a3b9;
extern PyObject *const_str_plain_cipher;
static PyObject *const_str_plain_string_type;
static PyObject *const_tuple_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339_tuple;
extern PyObject *const_str_plain_X509_REVOKED_get0_revocationDate;
static PyObject *const_str_plain_X509_STORE_CTX_get1_chain;
extern PyObject *const_str_plain_d;
static PyObject *const_tuple_str_plain_utf8only_tuple;
static PyObject *const_str_plain_EVP_SignInit;
static PyObject *const_str_digest_169aa7f0589e4a3c83203d48f57770af;
static PyObject *const_str_plain_X509_V_FLAG_IGNORE_CRITICAL;
extern PyObject *const_str_plain_BIO_new_mem_buf;
extern PyObject *const_str_plain_X509_getm_notBefore;
static PyObject *const_tuple_str_plain_bio_str_plain_ref_tuple;
extern PyObject *const_str_plain_Cryptography_EVP_MD_CTX_new;
static PyObject *const_str_digest_1565887baecc678658a50e7d1f245653;
extern PyObject *const_str_plain_X509_set_pubkey;
static PyObject *const_str_digest_d546905f9a7fd3b3fc24a90a7432aa72;
extern PyObject *const_str_plain_calendar;
static PyObject *const_str_plain_X509_REVOKED_add1_ext_i2d;
extern PyObject *const_str_plain__path_string;
static PyObject *const_str_plain_string_result;
static PyObject *const_str_digest_dc44ec2c02bcac7fac23b8eea57aa5d6;
extern PyObject *const_str_plain_X509_NAME_get_entry;
extern PyObject *const_str_plain_X509Name;
static PyObject *const_str_digest_a658b60d9bffa55a9bdfb85ba96aec98;
extern PyObject *const_str_plain_sign;
extern PyObject *const_int_neg_1;
static PyObject *const_str_plain_NOTIFY_POLICY;
extern PyObject *const_str_plain_ASN1_STRING_to_UTF8;
extern PyObject *const_str_plain_text_type;
static PyObject *const_str_digest_1f681e9f80c6df652cbc3a085be49171;
static PyObject *const_str_digest_b69ad7457b37f0df18af9a38324a8007;
static PyObject *const_str_plain_PKCS7_type_is_data;
static PyObject *const_str_digest_670c62a34c6767f6ecd5db6f969b2f34;
static PyObject *const_str_plain_pkcs12;
static PyObject *const_str_plain__chain;
static PyObject *const_str_plain_results;
extern PyObject *const_str_plain_X509_CRL_set_issuer_name;
static PyObject *const_str_plain_FILETYPE_TEXT;
extern PyObject *const_str_plain_dump_certificate;
static PyObject *const_str_plain_ALLOW_PROXY_CERTS;
extern PyObject *const_str_plain__crl;
static PyObject *const_str_plain_get_short_name;
static PyObject *const_str_plain_digest_obj;
static PyObject *const_str_plain_op;
static PyObject *const_str_plain_type_is_enveloped;
static PyObject *const_str_digest_03f3989a7f0f1ec9623bd001f5a005a7;
static PyObject *const_str_digest_782fa7272fdd3d3abdc1a0298e5e83fc;
extern PyObject *const_str_plain__text_to_bytes_and_warn;
static PyObject *const_str_plain_utf8only;
extern PyObject *const_str_plain_X509_STORE_CTX_get_current_cert;
extern PyObject *const_str_plain_s;
extern PyObject *const_str_plain_X509_get_ext_count;
extern PyObject *const_str_plain_i2d_X509_NAME;
extern PyObject *const_str_plain_PEM_read_bio_X509_REQ;
static PyObject *const_str_plain_PKCS12_create;
extern PyObject *const_str_plain_dt;
static PyObject *const_str_digest_152d11f8848fac60442a26592ab3da87;
static PyObject *const_str_digest_0632ce6142bf9815370c626f0fb1235a;
extern PyObject *const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple;
extern PyObject *const_str_plain_Certificate;
static PyObject *const_str_plain_char_result;
static PyObject *const_str_plain_string_timestamp;
static PyObject *const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple;
static PyObject *const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple;
extern PyObject *const_str_plain__from_raw_x509_ptr;
static PyObject *const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple;
static PyObject *const_str_digest_3c5d018dd809b9a6147c1b47d39e8d31;
static PyObject *const_str_plain_X509_STORE_CTX_cleanup;
static PyObject *const_str_digest_50f07d7dbc7dc060eb5685744b92c007;
static PyObject *const_str_digest_44f664275c70041c9ae4bef2565506f3;
extern PyObject *const_str_plain_X509_EXTENSION_get_data;
static PyObject *const_str_plain_sk_X509_push;
static PyObject *const_str_digest_6a19008e8f9a834793cf38dcba68883a;
extern PyObject *const_int_pos_2048;
static PyObject *const_str_plain_CRL_CHECK;
static PyObject *const_str_plain_free;
static PyObject *const_str_plain_spki;
extern PyObject *const_tuple_str_plain_self_str_plain_ret_tuple;
static PyObject *const_str_plain_pypkcs7;
static PyObject *const_str_digest_624de773f1e3dc72be54266a02c1df41;
static PyObject *const_str_plain_set_subject;
static PyObject *const_str_plain_type_name;
extern PyObject *const_str_plain___init__;
extern PyObject *const_str_plain_dsa;
static PyObject *const_str_digest_f35548e1d45f67292233a83f1d0adcce;
extern PyObject *const_str_plain_bits;
extern PyObject *const_str_plain_DSAPrivateKey;
static PyObject *const_str_digest_5a3f7f69104a4ed1267a21c950d94463;
static PyObject *const_tuple_str_plain_self_str_plain_flags_tuple;
extern PyObject *const_tuple_str_plain_ascii_tuple;
static PyObject *const_str_plain_X509_V_FLAG_ALLOW_PROXY_CERTS;
static PyObject *const_str_digest_4d14f6e4d6647c6573e3ca9449c2b51f;
extern PyObject *const_str_plain_new;
static PyObject *const_str_digest_7e62ce69c000886ecc0ae0b3e8ae9e79;
static PyObject *const_str_digest_7de17ac920010129977e4280610f275c;
static PyObject *const_str_plain_EVP_SignFinal;
static PyObject *const_str_plain_NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
static PyObject *const_str_plain__get_name;
extern PyObject *const_str_plain_text_to_bytes_and_warn;
static PyObject *const_str_plain_b64_encode;
extern PyObject *const_str_plain_X509_REVOKED_set_serialNumber;
extern PyObject *const_str_plain_store;
extern PyObject *const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
static PyObject *const_str_plain_ASN1_STRING_set_default_mask_asc;
extern PyObject *const_str_plain_X509_EXTENSION_get_critical;
static PyObject *const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple;
static PyObject *const_str_digest_9acbe023ce14d1d2ba528bd23b2423a0;
extern PyObject *const_str_plain___name__;
static PyObject *const_str_plain_EVP_VerifyUpdate;
static PyObject *const_str_digest_603c60edaf58a8746faa757f20f3f938;
static PyObject *const_str_digest_32726a73c20427f70712d109be7712b4;
static PyObject *const_str_plain__crl_reasons;
extern PyObject *const_str_plain_X509_set_version;
static PyObject *const_str_plain__passphrase;
extern PyObject *const_str_plain_X509_CRL_set_nextUpdate;
extern PyObject *const_str_plain__raise_current_error;
static PyObject *const_str_plain__revoked;
static PyObject *const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple;
static PyObject *const_str_plain_fname;
extern PyObject *const_str_plain_issuer;
static PyObject *const_str_digest_60cf4d81fa4ac0fb8a6d16cafc145b24;
static PyObject *const_str_plain_pycacert;
static PyObject *const_str_digest_40e46351c3b918f338d6e675fea0b1ca;
static PyObject *const_str_plain_get_signature_algorithm;
static PyObject *const_str_plain_ent_nid;
extern PyObject *const_str_plain_add;
static PyObject *const_str_digest_a9fcf3ea8b3ff05d45964d00ac386113;
extern PyObject *const_tuple_str_plain_partial_tuple;
extern PyObject *const_str_plain_DSA_generate_parameters_ex;
static PyObject *const_str_digest_c384f9f99d5890cd2aae342c30dbaa14;
static PyObject *const_str_plain_load_crl;
static PyObject *const_str_plain_i2d_PKCS12_bio;
static PyObject *const_str_digest_5bd123cbe57a454c8d9d37867b598cb2;
extern PyObject *const_str_plain_X509_set_issuer_name;
extern PyObject *const_str_plain_PEM_read_bio_X509;
extern PyObject *const_str_plain_res;
extern PyObject *const_str_plain_PEM_read_bio_PrivateKey;
extern PyObject *const_str_plain_req;
static PyObject *const_str_plain_crypto_req;
static PyObject *const_str_plain_CHECK_SS_SIGNATURE;
static PyObject *const_str_plain_X509_V_FLAG_NOTIFY_POLICY;
static PyObject *const_str_plain_set_version;
static PyObject *const_tuple_str_plain_s_str_plain_i_str_plain_x_tuple;
static PyObject *const_str_plain_d2i_PKCS7_bio;
extern PyObject *const_str_plain_X509_REVOKED_free;
static PyObject *const_str_digest_0807c1b9c5bc0ac3cc25375c4a9ebb2e;
static PyObject *const_str_plain_EVP_PKEY_assign_RSA;
extern PyObject *const_str_plain_sk_X509_EXTENSION_new_null;
extern PyObject *const_str_plain_certificates;
extern PyObject *const_str_plain_check;
extern PyObject *const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple;
extern PyObject *const_str_plain_integer_types;
static PyObject *const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple;
extern PyObject *const_str_plain_asn1_int;
extern PyObject *const_tuple_str_plain_self_str_plain_other_tuple;
static PyObject *const_str_plain_generalized_timestamp;
static PyObject *const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple;
static PyObject *const_str_plain_get_pubkey;
static PyObject *const_str_plain_get_components;
static PyObject *const_str_digest_35f6b1c1261cd55e34a5b00d6cb8d5ea;
static PyObject *const_str_plain_set_privatekey;
static PyObject *const_str_plain_EVP_VerifyFinal;
static PyObject *const_str_digest_26a65c58106d086427e37cb87b0bc3b3;
extern PyObject *const_str_plain_x509;
static PyObject *const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple;
static PyObject *const_str_plain_get_notBefore;
static PyObject *const_str_plain_X509V3_set_ctx_nodb;
static PyObject *const_str_plain_cleanup;
extern PyObject *const_str_plain__pkey;
static PyObject *const_str_digest_8db7448b8246dd51f74c33bda58590bd;
extern PyObject *const_str_plain_clear;
extern PyObject *const_str_plain_der;
static PyObject *const_str_plain_i2d_PrivateKey_bio;
static PyObject *const_str_digest_05b2bb16e6ee73fd972536e52cc4cabf;
static PyObject *const_str_plain_pkcs7;
static PyObject *const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY2_tuple;
static PyObject *const_str_digest_542816c377b6c750acf5d24f0edc02b0;
static PyObject *const_str_digest_1ca413f5b66374db6a573ac0926a99ae;
static PyObject *const_str_plain_exponent;
extern PyObject *const_tuple_str_plain_self_str_plain_subject_tuple;
static PyObject *const_str_plain_friendlyname;
static PyObject *const_str_plain_CRL_CHECK_ALL;
static PyObject *const_str_digest_c7bf9684574689f7d764ff6fbd5eab60;
static PyObject *const_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339;
static PyObject *const_tuple_str_plain_op_str_plain_f_tuple;
extern PyObject *const_str_digest_c804b213c384a15865e18bf31cfff70e;
static PyObject *const_str_digest_2f591e55cc116ed5223c119e2f7da344;
extern PyObject *const_str_plain_more_args;
static PyObject *const_str_plain__build_certificate_stack;
extern PyObject *const_str_plain_subject;
static PyObject *const_str_plain_vfy_time;
static PyObject *const_str_plain_sk_X509_EXTENSION_push;
extern PyObject *const_str_plain_timegm;
extern PyObject *const_str_plain_critical;
static PyObject *const_str_plain_days;
extern PyObject *const_str_plain_DSAPublicKey;
static PyObject *const_str_plain_get_extension_count;
static PyObject *const_str_digest_12c1bc175ad6309f9cfc24942b8c76ac;
static PyObject *const_str_plain_load_certificate_request;
static PyObject *const_tuple_str_plain_self_str_plain_when_tuple;
static PyObject *const_str_plain_X509V3_EXT_print;
static PyObject *const_str_plain_which;
static PyObject *const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple;
static PyObject *const_str_digest_f979ae5e9b0a9a41a05276169a44e7e9;
static PyObject *const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple;
static PyObject *const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple;
static PyObject *const_str_plain_i2a_ASN1_INTEGER;
extern PyObject *const_str_plain__evp_pkey_to_public_key;
static PyObject *const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple;
static PyObject *const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple;
extern PyObject *const_str_plain_X509_REQ_new;
extern PyObject *const_str_plain_addressof;
extern PyObject *const_str_plain__native;
static PyObject *const_str_digest_3d684470d9353bc1a1e8d63a3aab4679;
extern PyObject *const_str_plain__ffi;
extern PyObject *const_str_plain_X509_NAME_entry_count;
static PyObject *const_str_plain_not_after;
static PyObject *const_str_plain_X509_NAME_delete_entry;
static PyObject *const_str_digest_8aae826f04ca2a5df2a0de1a103a1f13;
static PyObject *const_str_plain_X509_REQ_get_version;
extern PyObject *const_str_plain_operator;
static PyObject *const_str_digest_333948d9e51f0e161201a16305959930;
static PyObject *const_str_plain_native_exts_obj;
static PyObject *const_str_digest_9cb57ebafd0926d1746d2e66a6198efe;
static PyObject *const_str_plain_X509_STRICT;
static PyObject *const_tuple_str_digest_e2d15f7f418fdd55a54be9ea476feee3_tuple;
static PyObject *const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple;
static PyObject *const_str_plain_time_string;
static PyObject *const_str_digest_5339fa8ff3df372e54ef7b09078767aa;
static PyObject *const_tuple_86464d9c162f01af99141e0a5b804d71_tuple;
static PyObject *const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple;
extern PyObject *const_str_plain_EVP_PKEY_EC;
extern PyObject *const_str_plain___getattr__;
static PyObject *const_str_plain_NID_subject_alt_name;
static PyObject *const_str_plain_add_cert;
static PyObject *const_tuple_str_digest_70b987f75825a6c2ffe2c8fe53d85a21_tuple;
static PyObject *const_str_plain_load_certificate;
extern PyObject *const_str_plain_X509_STORE_CTX_get_error;
extern PyObject *const_str_plain_X509_free;
extern PyObject *const_str_plain_BIO_get_mem_data;
static PyObject *const_str_digest_5cb0319d0378026eb0ef49838e525520;
extern PyObject *const_str_plain_signature;
static PyObject *const_str_plain_builtin_curves;
static PyObject *const_str_digest_62c9c3f244d467c166be64cd38a755a7;
static PyObject *const_str_digest_f41f911aba33894e1da796354264d96a;
static PyObject *const_str_plain_subject_name_hash;
extern PyObject *const_str_digest_426349c7e201b358f2086eb3f7fb6f47;
extern PyObject *const_str_plain_ctx;
static PyObject *const_str_plain_subject_cert;
extern PyObject *const_str_plain_encode;
static PyObject *const_str_plain_set_pubkey;
extern PyObject *const_str_plain_X509_NAME_free;
static PyObject *const_str_digest_e69f89000e2dc720ec6a70b8f9cb0cac;
static PyObject *const_str_plain_ASN1_STRING_type;
static PyObject *const_str_digest_61dbd227935e54cb40eecc7de8b8596b;
static PyObject *const_str_digest_1d608c98cc8048d3f7b439059ee29b66;
static PyObject *const_str_digest_79b48b443a4edf88bd64a278e98529d3;
static PyObject *const_str_plain_from_nid;
extern PyObject *const_str_plain_PEM_write_bio_X509_REQ;
static PyObject *const_str_digest_11dbf726734533c622c12e725d15648e;
static PyObject *const_str_plain__spki;
static PyObject *const_str_plain_from_cryptography;
static PyObject *const_str_digest_f56881bccbbc40c6643f9603628e7a5c;
static PyObject *const_str_plain_X509Req;
extern PyObject *const_str_plain_DNS;
extern PyObject *const_str_plain_curve;
extern PyObject *const_tuple_empty;
static PyObject *const_str_plain_load_pkcs7_data;
static PyObject *const_str_plain_pycacerts;
static PyObject *const_str_plain_cacerts;
static PyObject *const_str_digest_95aba6f0be0722dff4a715f251a45159;
static PyObject *const_str_plain_signature_buffer;
static PyObject *const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple;
extern PyObject *const_str_plain_EC_KEY_new_by_curve_name;
static PyObject *const_str_digest_117006b03ff8e10f330ac900a6cd41e8;
static PyObject *const_str_digest_70b987f75825a6c2ffe2c8fe53d85a21;
static PyObject *const_str_digest_9781f115d6516693d922717b11376a73;
extern PyObject *const_str_plain_result;
static PyObject *const_str_plain_POLICY_CHECK;
static PyObject *const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e;
extern PyObject *const_str_plain_EVP_PKEY_new;
static PyObject *const_str_plain__new_mem_buf;
static PyObject *const_str_plain_X509_verify_cert_error_string;
extern PyObject *const_str_plain_p12;
static PyObject *const_str_digest_686e4f9f1c51b7038afe792590c33346;
static PyObject *const_str_plain_X509_CRL_print;
extern PyObject *const_str_plain_rsa;
extern PyObject *const_str_plain_path_string;
extern PyObject *const_str_plain_X509_sign;
static PyObject *const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple;
extern PyObject *const_str_digest_9abb9f40508debfa3aae6d9135753f7e;
extern PyObject *const_str_plain_helper;
static PyObject *const_str_digest_0a3eb1716e7caaaf09c8582b572bcb60;
extern PyObject *const_str_plain_OpenSSL_add_all_algorithms;
static PyObject *const_str_digest_d03be6fc9f3e6729b366e69e0856a450;
static PyObject *const_str_digest_458f07858808d53330e13a12d5e50e24;
extern PyObject *const_tuple_str_plain_self_str_plain_issuer_tuple;
static PyObject *const_str_plain_bignum_ptr;
static PyObject *const_str_plain_export;
static PyObject *const_tuple_none_int_pos_2048_int_pos_1_tuple;
extern PyObject *const_str_plain_upper;
extern PyObject *const_str_plain_X509_up_ref;
static PyObject *const_str_digest_4fd5a0c1d1fb7366c52acc7b3ac0b5b1;
static PyObject *const_tuple_str_digest_8e9fba48e24a08144a915d52e31f6d23_tuple;
extern PyObject *const_str_plain__issuer;
static PyObject *const_str_digest_9ae52cddf69d053d9518f458a81ffa1b;
extern PyObject *const_str_plain_ASN1_ENUMERATED_free;
static PyObject *const_str_plain_X509_EXTENSION_dup;
static PyObject *const_str_digest_978cd476d4acffdfb043e6a5e0ebae26;
static PyObject *const_str_plain__pkcs7;
static PyObject *const_str_plain_SSL_FILETYPE_ASN1;
extern PyObject *const_str_plain_d2i_PrivateKey_bio;
static PyObject *const_tuple_76984bb103279dcce095840ed073cae5_tuple;
extern PyObject *const_tuple_str_plain_x_tuple;
extern PyObject *const_tuple_str_plain_where_tuple;
extern PyObject *const_str_plain_lib;
static PyObject *const_str_plain_X509_V_FLAG_EXPLICIT_POLICY;
static PyObject *const_str_plain_callback_args;
extern PyObject *const_str_plain_datetime;
extern PyObject *const_str_plain_digest;
static PyObject *const_str_plain_set_store;
extern PyObject *const_str_plain__UNSPECIFIED;
extern PyObject *const_str_plain___file__;
static PyObject *const_str_digest_5f245d1740d80da82563e21c9c4f4fbf;
extern PyObject *const_str_plain_append;
static PyObject *const_str_plain_parse_result;
static PyObject *const_str_plain_reason_code;
static PyObject *const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple;
extern PyObject *const_str_plain_verify;
extern PyObject *const_str_plain_d2i_X509_bio;
static PyObject *const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple;
static PyObject *const_str_digest_cf86a9123926465ab14a7bd2861326f6;
static PyObject *const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple;
static PyObject *const_str_digest_11e1356f3459cf012eb88d7288e20e85;
static PyObject *const_str_plain_get_elliptic_curves;
extern PyObject *const_str_plain_where;
static PyObject *const_str_plain__text_type;
extern PyObject *const_str_plain_truncate;
static PyObject *const_str_plain__friendlyname;
static PyObject *const_tuple_str_plain_self_str_plain_exceptionType_tuple;
static PyObject *const_str_plain_RSA_print;
static PyObject *const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple;
extern PyObject *const_str_plain_RSA_free;
extern PyObject *const_str_plain___metaclass__;
static PyObject *const_str_plain_result_code;
extern PyObject *const_str_plain_d2i_PUBKEY_bio;
extern PyObject *const_int_pos_60;
extern PyObject *const_str_plain_callable;
static PyObject *const_str_plain_X509_subject_name_hash;
extern PyObject *const_str_plain_userdata;
extern PyObject *const_str_plain_X509_NAME_dup;
static PyObject *const_str_digest_68e309761e6d5dc5f5c1e53801284f3a;
static PyObject *const_str_plain_set_serial;
extern PyObject *const_str_plain_chain;
static PyObject *const_str_plain_X509_NAME_hash;
static PyObject *const_str_digest_1f7559cec53c5da336c35128000e1652;
extern PyObject *const_tuple_none_none_tuple;
static PyObject *const_str_plain_Revoked;
static PyObject *const_str_digest_a12e23c82fcdd4004653da2260294f18;
extern PyObject *const_str_plain__evp_pkey_to_private_key;
static PyObject *const_str_plain__curves;
extern PyObject *const_str_plain_replace;
static PyObject *const_str_plain_set_notBefore;
static PyObject *const_str_plain_from_cryptography_key;
extern PyObject *const_str_digest_e33a7f733650e687efe98e5491512b82;
extern PyObject *const_str_plain_make_assert;
extern PyObject *const_str_plain___lt__;
static PyObject *const_str_digest_7db2dd03172a07cae912434bb4ced82e;
static PyObject *const_str_plain__cacerts;
static PyObject *const_str_plain_entry_index;
extern PyObject *const_str_plain__evp_pkey;
static PyObject *const_str_digest_80438074180d95b1a2291874613077b5;
static PyObject *const_str_digest_40ce736ad6e52bc3df10a00233b89318;
extern PyObject *const_str_plain_revoked;
static PyObject *const_str_plain_sign_result;
static PyObject *const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple;
extern PyObject *const_str_plain_self;
static PyObject *const_tuple_str_plain_self_str_plain_spki_tuple;
static PyObject *const_str_digest_141cd36b231fb1bf7caa692f86984b7e;
static PyObject *const_str_plain_NetscapeSPKI;
static PyObject *const_str_digest_866d2e2176ccb47ef7515cbc6c993151;
extern PyObject *const_str_plain__PassphraseHelper;
static PyObject *const_str_plain_friendlyname_length;
static PyObject *const_str_digest_5e37d069c5e76ee6d50c7e91b7181934;
extern PyObject *const_str_plain_EVP_PKEY_DSA;
extern PyObject *const_str_plain_ASN1_TIME_to_generalizedtime;
static PyObject *const_str_plain_NETSCAPE_SPKI_get_pubkey;
static PyObject *const_str_plain_URI;
static PyObject *const_str_plain_octet_result;
static PyObject *const_str_plain_X509_CRL_sort;
static PyObject *const_str_digest_3910fdd1c3b683a0988d08f77454ce47;
static PyObject *const_str_digest_463cb3c7dbe7753c6683d3195629dca3;
static PyObject *const_tuple_str_digest_016ce3807ea72a262d921fa7d1804717_tuple;
extern PyObject *const_str_empty;
static PyObject *const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple;
extern PyObject *const_tuple_str_plain_utils_str_plain_x509_tuple;
extern PyObject *const_str_plain_param;
extern PyObject *const_str_plain___setattr__;
static PyObject *const_str_plain_X509_NAME_add_entry_by_NID;
static PyObject *const_str_plain_get_ca_certificates;
static PyObject *const_str_plain_INHIBIT_MAP;
static PyObject *const_str_digest_a078d66f5fc281c4117a5e5c24749809;
static PyObject *const_str_digest_1691c1bfd96a22cfc48aca410da45814;
static PyObject *const_str_plain_set_time;
extern PyObject *const_str_plain_X509_CRL_set_lastUpdate;
extern PyObject *const_str_plain_DSA_new;
extern PyObject *const_str_plain_DeprecationWarning;
extern PyObject *const_str_digest_2c0accc407028fbaba46fefdee9c6c06;
extern PyObject *const_str_plain_PEM_write_bio_X509_CRL;
static PyObject *const_tuple_da33f491cad89fe7f4a10b4791a01172_tuple;
extern PyObject *const_str_plain_name;
extern PyObject *const_tuple_str_digest_bc7a2d385ac0b4ca6f6caa64ccb6a3b9_int_pos_1_tuple;
static PyObject *const_str_digest_74b73fd54833bfb6b761307c477c0a28;
extern PyObject *const_str_plain_ASN1_TIME_new;
extern PyObject *const_str_plain_RSA_new;
static PyObject *const_list_b8e29824b436479d358fd3771a611e70_list;
static PyObject *const_str_digest_ac089bdfaafc466d410fc6ffe7dfee50;
extern PyObject *const_str_plain_ch;
static PyObject *const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple;
extern PyObject *const_str_plain_X509_CRL_get_issuer;
static PyObject *const_str_digest_3121be4a855650e38916196ca238bf2b;
static PyObject *const_str_plain_md_ctx;
static PyObject *const_str_digest_39641ea33feffed70915f1c391cc979e;
static PyObject *const_tuple_false_false_tuple;
static PyObject *const_str_digest_2f350f536232587387680a9435c758f6;
static PyObject *const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple;
extern PyObject *const_str_plain_Error;
extern PyObject *const_str_plain__set_asn1_time;
static PyObject *const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple;
extern PyObject *const_str_plain_X509_add_ext;
extern PyObject *const_str_plain_X509_REQ_add_extensions;
static PyObject *const_str_plain_get_type_name;
extern PyObject *const_str_plain__init;
static PyObject *const_str_plain__cmp;
extern PyObject *const_str_plain_boundary;
static PyObject *const_str_digest_d7980f3a0e05fb43bc9ed0fa0707a2f9;
extern PyObject *const_str_plain_EVP_PKEY_free;
extern PyObject *const_str_plain__;
static PyObject *const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple;
static PyObject *const_str_plain_new_reason_ext;
extern PyObject *const_str_plain_BIO_free;
static PyObject *const_str_plain_X509_V_FLAG_CB_ISSUER_CHECK;
static PyObject *const_str_digest_7d6056c968d1eebfab898757e6f3054e;
extern PyObject *const_str_plain_X509_REVOKED_get_ext;
extern PyObject *const_str_plain_x;
static PyObject *const_str_digest_f583009b639aad56f3c96c175e595626;
static PyObject *const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple;
static PyObject *const_str_plain__more_args;
extern PyObject *const_str_plain_ffi;
static PyObject *const_str_plain_IGNORE_CRITICAL;
static PyObject *const_str_digest_a7eaace656db47cf2975484b27c818e9;
static PyObject *const_str_plain_friendlyname_buffer;
static PyObject *const_str_plain__initialized;
static PyObject *const_str_plain_RSA_F4;
static PyObject *const_str_plain__read_passphrase;
static PyObject *const_tuple_85794016896eca55eb5b3d7e4628b724_tuple;
extern PyObject *const_tuple_str_plain___tuple;
static PyObject *const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple;
static PyObject *const_str_plain_maciter;
extern PyObject *const_str_plain_PKey;
extern PyObject *const_str_plain_PEM_read_bio_X509_CRL;
extern PyObject *const_str_plain_ext;
static PyObject *const_str_plain__set_name;
extern PyObject *const_str_plain_ASN1_INTEGER_to_BN;
extern PyObject *const_str_plain_OBJ_txt2nid;
static PyObject *const_str_plain_dump_privatekey;
extern PyObject *const_int_pos_65535;
extern PyObject *const_str_plain_PY2;
static PyObject *const_str_plain_set_ca_certificates;
static PyObject *const_str_digest_0b708bb28192f1a165c843c47343f35a;
extern PyObject *const_str_plain_e;
static PyObject *const_str_digest_193e0ef9a8bffd6c41bf909f2da817bd;
extern PyObject *const_str_plain_ASN1_TIME_set_string;
static PyObject *const_str_digest_ffd290e8bf49a587d94041b1fd6c3c55;
extern PyObject *const_str_plain_raise_if_problem;
static PyObject *const_str_digest_ce96dba31c9fcf5052c236b4a8160f7f;
extern PyObject *const_str_plain_label;
static PyObject *const_str_plain_get_reason;
static PyObject *const_str_plain_answer;
static PyObject *const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple;
extern PyObject *const_str_plain__lib;
static PyObject *const_str_plain__delete_reason;
extern PyObject *const_str_plain_X509_get_subject_name;
static PyObject *const_str_digest_f3b04f8993b30e664e4afacb3d64cdc4;
static PyObject *const_str_digest_2e4273bc9cbcc16bcfe5bca70ee1b585;
static PyObject *const_str_plain_X509_REVOKED_delete_ext;
extern PyObject *const_str_plain_generate_key;
extern PyObject *const_tuple_str_plain_self_str_plain_backend_tuple;
extern PyObject *const_str_plain_partial;
extern PyObject *const_tuple_str_plain_self_tuple;
static PyObject *const_str_plain_dump_publickey;
extern PyObject *const_tuple_type_object_tuple;
extern PyObject *const_int_pos_100;
extern PyObject *const_str_plain_EC_KEY_free;
extern PyObject *const_str_plain__exception_from_error_queue;
static PyObject *const_str_plain_PKCS12;
static PyObject *const_str_digest_fb60d21f52ae521da77e61851d566364;
static PyObject *const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple;
static PyObject *const_str_plain_get_extension;
extern PyObject *const_str_plain_type;
extern PyObject *const_str_plain_ASN1_GENERALIZEDTIME_free;
static PyObject *const_str_digest_d0137950921f709b6c00a3276a078e5f;
static PyObject *const_str_digest_016ce3807ea72a262d921fa7d1804717;
static PyObject *const_str_digest_de1d9872d12371b2ead20f3aa79dc834;
extern PyObject *const_str_plain_decode;
static PyObject *const_str_plain_x509req;
extern PyObject *const_str_plain_to_cryptography;
static PyObject *const_str_digest_685b3ded6e482839a3710e6a448d8669;
extern PyObject *const_str_plain_cls;
extern PyObject *const_str_plain_strptime;
static PyObject *const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9;
extern PyObject *const_str_plain_sk_X509_num;
static PyObject *const_str_plain_get_serial;
static PyObject *const_str_digest_9a71d9e6319c409dff859e67083fc41c;
static PyObject *const_str_digest_3a45faa244ca861d389c340b29a28988;
extern PyObject *const_tuple_str_plain_self_str_plain_revoked_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_cert_str_plain_res_tuple;
extern PyObject *const_str_plain_base64;
static PyObject *const_str_plain_X509_STORE_free;
static PyObject *const_str_plain_hex_serial;
static PyObject *const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
extern PyObject *const_str_plain__CertificateSigningRequest;
extern PyObject *const_str_plain_backend;
static PyObject *const_str_plain_SSL_FILETYPE_PEM;
static PyObject *const_str_plain__X509NameInvalidator;
extern PyObject *const_str_plain_key;
extern PyObject *const_str_plain_cast;
extern PyObject *const_tuple_str_space_str_empty_tuple;
extern PyObject *const_str_plain_size;
static PyObject *const_tuple_str_plain_b16encode_tuple;
extern PyObject *const_str_plain___ne__;
extern PyObject *const_str_plain_pop;
extern PyObject *const_str_plain_d2i_PKCS12_bio;
extern PyObject *const_tuple_str_plain_self_str_plain_cert_tuple;
static PyObject *const_str_plain_TYPE_DH;
extern PyObject *const_str_plain__make_assert;
static PyObject *const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple;
static PyObject *const_str_plain_PKCS7_type_is_signed;
extern PyObject *const_str_plain_i2d_X509_CRL_bio;
extern PyObject *const_str_plain_obj;
static PyObject *const_str_plain_X509_V_FLAG_CRL_CHECK_ALL;
static PyObject *const_tuple_str_plain_dsa_str_plain_rsa_tuple;
static PyObject *const_str_plain_PKCS7_type_is_signedAndEnveloped;
extern PyObject *const_str_plain__cert;
static PyObject *const_str_digest_f68048107421fed17c8f1bc19be3ec03;
extern PyObject *const_str_plain_cafile;
static PyObject *const_str_digest_8e9fba48e24a08144a915d52e31f6d23;
static PyObject *const_str_plain_X509_digest;
static PyObject *const_str_plain_OBJ_obj2nid;
static PyObject *const_str_digest_5997506aef8ffc5e12c453030416acc6;
static PyObject *const_str_plain_X509_V_FLAG_X509_STRICT;
static PyObject *const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple;
static PyObject *const_str_plain_passphrase;
extern PyObject *const_str_plain_flags;
extern PyObject *const_str_plain_EVP_PKEY_DH;
static PyObject *const_str_plain_revoked_copy;
static PyObject *const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple;
static PyObject *const_str_digest_7b5d428ebb9708d902c18ce8ddfb3cbc;
static PyObject *const_str_plain_X509V3_set_ctx;
static PyObject *const_str_plain_bignum_serial;
extern PyObject *const_str_plain_value;
static PyObject *const_str_plain_load_locations;
extern PyObject *const_str_plain_store_ctx;
extern PyObject *const_str_plain_extension;
extern PyObject *const_str_plain_certificateHold;
extern PyObject *const_str_plain_X509_CRL_set_version;
static PyObject *const_str_digest_c71c443223c73b253b21961ef3bd7c9e;
static PyObject *const_str_digest_a643e6a1050d6f3782a0d190235d80a7;
extern PyObject *const_str_plain_email;
static PyObject *const_str_digest_35e2a27cee76091329550405e1cb7dc4;
static PyObject *const_str_plain_NETSCAPE_SPKI_free;
extern PyObject *const_str_plain_PEM_write_bio_PUBKEY;
static PyObject *const_str_plain_get_privatekey;
static PyObject *const_str_plain_X509_print_ex;
static PyObject *const_str_digest_b3f225987bb27e065a500d7fe8bd7c70;
extern PyObject *const_str_plain_X509_EXTENSION_get_object;
extern PyObject *const_str_plain_i2d_X509_REQ_bio;
static PyObject *const_str_plain__extension;
static PyObject *const_str_digest_c0aedec8dc85440d3dace529a9d9050e;
static PyObject *const_str_plain_fval;
extern PyObject *const_str_plain__original_lib;
static PyObject *const_str_digest_5699814601a04aa972bd2f18de396c39;
extern PyObject *const_str_plain_capath;
static PyObject *const_str_digest_48639cf22fbd4e6b3714265dae0dbed8;
static PyObject *const_str_plain_string_data;
extern PyObject *const_str_plain_serial;
extern PyObject *const_int_pos_16;
static PyObject *const_str_plain_NETSCAPE_SPKI_verify;
static PyObject *const_str_digest_d6b3262f79e4b59cd83ab54699c92117;
extern PyObject *const_str_plain_message;
static PyObject *const_str_digest_1a7a898c4490dd89b305492a40bf2633;
static PyObject *const_str_plain_format_result;
extern PyObject *const_tuple_str_plain__Certificate_tuple;
extern PyObject *const_int_pos_24;
extern PyObject *const_str_plain_NULL;
extern PyObject *const_str_plain_X509_CRL_free;
static PyObject *const_str_plain_X509_STORE_CTX_init;
static PyObject *const_str_plain_dump_crl;
static PyObject *const_tuple_str_plain_self_str_plain_x509_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple;
extern PyObject *const_str_plain_errors;
static PyObject *const_str_plain_X509_STORE_new;
static PyObject *const_str_digest_1548dadd592ed9bc13702fc15d573dfd;
static PyObject *const_str_plain_EVP_PKEY_bits;
extern PyObject *const_int_pos_1;
extern PyObject *const_str_plain_EVP_get_cipherbyname;
static PyObject *const_str_plain_set_flags;
static PyObject *const_str_plain__store_ctx;
extern PyObject *const_str_plain_X509_NAME_ENTRY_get_data;
extern PyObject *const_str_plain_RSAPrivateKey;
extern PyObject *const_str_plain_add_result;
extern PyObject *const_str_plain_X509_EXTENSION_free;
extern PyObject *const_str_plain_ia5;
extern PyObject *const_str_plain_load_result;
static PyObject *const_str_plain_X509V3_EXT_nconf;
extern PyObject *const_str_plain_cert;
static PyObject *const_str_plain_encode_result;
static PyObject *const_tuple_48ab3cdc7d6d88da8bc682675f6a64b7_tuple;
extern PyObject *const_str_plain_RSA_generate_key_ex;
extern PyObject *const_str_plain_X509_REQ_sign;
extern PyObject *const_str_plain_copy;
static PyObject *const_tuple_80a9571108770bd34772239ad97225a5_tuple;
static PyObject *const_str_digest_213346f5e36f3faf7ff7a566deec4adb;
extern PyObject *const_str_digest_c561652c58984ec0e9541542aa405594;
extern PyObject *const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple;
extern PyObject *const_str_plain_CertificateRevocationList;
static PyObject *const_str_plain_set_nextUpdate;
static PyObject *const_str_plain_CRL;
static PyObject *const_str_plain_EVP_SignUpdate;
static PyObject *const_str_plain__cleanup;
static PyObject *const_str_plain__exception_from_context;
static PyObject *const_str_digest_6b975dcb77568b31c2312e045b6c638c;
static PyObject *const_str_plain__bio_to_string;
static PyObject *const_str_digest_cac81eaf46e08badbc89f13fa3bbdf6b;
extern PyObject *const_str_plain_X509_REQ_get_extensions;
static PyObject *const_tuple_str_plain_self_str_plain_crl_tuple;
static PyObject *const_str_plain_X509_verify_cert;
extern PyObject *const_str_plain_sk_X509_value;
static PyObject *const_str_plain__get_asn1_time;
static PyObject *const_str_digest_3f7d687efa133ae490fe62a28c3c2584;
static PyObject *const_str_plain_cipher_obj;
extern PyObject *const_str_plain_join;
static PyObject *const_str_plain_X509_NAME_get_index_by_NID;
extern PyObject *const_str_plain_EVP_PKEY_size;
extern PyObject *const_str_plain_EVP_get_digestbyname;
static PyObject *const_str_digest_e4c79524acf8a72de25c6c6491f370a8;
static PyObject *const_str_plain_set_rev_date;
static PyObject *const_str_plain_set_notAfter;
extern PyObject *const_str_plain_DSA_generate_key;
extern PyObject *const_tuple_str_plain_self_str_plain_pkey_tuple;
static PyObject *const_tuple_str_plain__CertificateSigningRequest_tuple;
extern PyObject *const_str_plain_Cryptography_EVP_MD_CTX_free;
extern PyObject *const_str_plain_version;
extern PyObject *const_str_plain_GEN_EMAIL;
extern PyObject *const_str_plain_timestamp;
extern PyObject *const_str_plain_X509_REQ_set_version;
extern PyObject *const_str_plain_functools;
static PyObject *const_str_digest_719137938e890576c1050ba31a668078;
static PyObject *const_str_digest_500f278b67471fc0f770fccc80d65d95;
static PyObject *const_str_plain_notBefore;
static PyObject *const_str_digest_ab9563b0fc32f09cfde9a1636d8d2b80;
static PyObject *const_str_digest_b6dd846b2ed8a994f97bac91e216f368;
extern PyObject *const_str_plain___ge__;
static PyObject *const_str_plain_X509Extension;
extern PyObject *const_str_plain_PEM_read_bio_PUBKEY;
extern PyObject *const_str_plain___eq__;
extern PyObject *const_str_plain___le__;
static PyObject *const_str_digest_6ef28169edd3cfe530885f6f9d09c390;
extern PyObject *const_str_plain_EVP_PKEY_RSA;
static PyObject *const_str_plain_X509_V_FLAG_CHECK_SS_SIGNATURE;
static PyObject *const_str_plain_X509_VERIFY_PARAM_new;
extern PyObject *const_str_plain_GEN_DNS;
static PyObject *const_str_digest_c237653198d1acecae3452511968b22e;
static PyObject *const_str_plain_type_is_signed;
static PyObject *const_str_digest_af63c2663b0a5e83daac69d308dcb1d6;
extern PyObject *const_str_plain_FILETYPE_ASN1;
extern PyObject *const_str_plain_BIO_new;
static PyObject *const_str_plain_get_friendlyname;
extern PyObject *const_str_plain_X509_get_issuer_name;
static PyObject *const_str_plain_set_friendlyname;
static PyObject *const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple;
static PyObject *const_str_plain_load_publickey;
extern PyObject *const_str_plain_i;
extern PyObject *const_str_plain__openssl_assert;
static PyObject *const_str_digest_713d8c2afef94db133cda1bff1cb496f;
static PyObject *const_str_plain_X509_STORE_load_locations;
extern PyObject *const_str_plain_f;
extern PyObject *const_str_plain_crl;
extern PyObject *const_str_plain_hex_str;
static PyObject *const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple;
extern PyObject *const_str_plain_c;
static PyObject *const_str_digest_1dbb147d3e039266688c4d87287eaaad;
static PyObject *const_str_digest_0d3c537bf958e2cc2494cf1be5c283dd;
static PyObject *const_tuple_53b63b794c8b8f328f3f365985abd328_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple;
static PyObject *const_str_plain_X509_STORE_set_flags;
extern PyObject *const_str_plain_buffer;
static PyObject *const_str_plain_get_elliptic_curve;
extern PyObject *const_str_plain_X509_NAME_ENTRY_get_object;
static PyObject *const_tuple_7e58e160edb2d3137d6df595cad17d36_tuple;
extern PyObject *const_str_plain_X509_CRL_sign;
static PyObject *const_str_digest_4097a084fab55cf5c5baa1b785e7c82a;
extern PyObject *const_str_plain_r;
static PyObject *const_str_plain_add_crl;
static PyObject *const_str_plain_get_extensions;
static PyObject *const_str_plain_algor;
static PyObject *const_str_digest_92b8d1a7fa93b4e7d2fab02e37bc15f8;
extern PyObject *const_str_plain_X509_set_serialNumber;
extern PyObject *const_str_plain__x509_crl;
extern PyObject *const_str_plain_X509Store;
extern PyObject *const_str_plain_names;
extern PyObject *const_str_plain_write_bio;
extern PyObject *const_str_plain_cryptography;
static PyObject *const_str_plain_get_notAfter;
extern PyObject *const_str_plain_EVP_PKEY_get1_RSA;
static PyObject *const_str_plain__set_boundary_time;
static PyObject *const_str_digest_1a3a564060f5ebd53d44f6035495ba48;
static PyObject *const_str_plain_get_issuer;
static PyObject *const_str_plain_X509_STORE_set1_param;
extern PyObject *const_str_plain_iter;
extern PyObject *const_str_plain_FILETYPE_PEM;
extern PyObject *const_str_plain_DSA_free;
extern PyObject *const_str_plain_superseded;
extern PyObject *const_str_plain_native;
static PyObject *const_str_plain_CB_ISSUER_CHECK;
static PyObject *const_str_plain__issuer_invalidator;
static PyObject *const_str_plain_get_serial_number;
static PyObject *const_str_plain__PY2;
static PyObject *const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple;
static PyObject *const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple;
extern PyObject *const_str_plain___all__;
extern PyObject *const_int_0;
static PyObject *const_str_digest_221848055f0a545c7ef1969a37bb78a5;
static PyObject *const_str_plain_EC_get_builtin_curves;
static PyObject *const_str_plain_asn1_serial;
extern PyObject *const_str_plain_six;
extern PyObject *const_str_plain_X509_REVOKED_get_ext_count;
extern PyObject *const_str_plain_GENERAL_NAMES_free;
static PyObject *const_str_plain_encoded;
extern PyObject *const_str_plain_X509_get_serialNumber;
extern PyObject *const_str_plain_sk_X509_EXTENSION_num;
static PyObject *const_str_plain_set_certificate;
extern PyObject *const_str_plain_sk_GENERAL_NAME_value;
extern PyObject *const_str_plain_callback;
static PyObject *const_str_digest_0226e12d6e09b849c37787a1a7ec35a4;
static PyObject *const_str_plain_pyrev;
extern PyObject *const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
static PyObject *const_str_plain_set_serial_number;
static PyObject *const_str_digest_bbde1e297eda38e770b8fce1d06c225b;
static PyObject *const_str_digest_3b5fd85224219fd172d589ec8f98a12a;
static PyObject *const_tuple_8110525d9a52cec647809d72afbc7239_tuple;
static PyObject *const_str_digest_4560cdf69c017b7cd264323295e708cb;
static PyObject *const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple;
static PyObject *const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple;
static PyObject *const_str_digest_75a631b53fc267af68d162051a06411c;
extern PyObject *const_str_plain___gt__;
static PyObject *const_str_plain_b16encode;
static PyObject *const_str_plain_PKCS7_type_is_enveloped;
static PyObject *const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple;
static PyObject *const_str_digest_c85d62bfc2af2f3c2202464fd6374ea7;
static PyObject *const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple;
static PyObject *const_str_digest_721230a42e287d5632d061ff8f0376d6;
static PyObject *const_str_plain_digest_name;
extern PyObject *const_str_plain_X509_get_ext;
static PyObject *const_str_digest_0b9d4db9119537682a1f5302a9cbcc57;
extern PyObject *const_str_plain_X509_REQ_verify;
static PyObject *const_tuple_str_plain_self_str_plain_store_tuple;
extern PyObject *const_str_angle_lambda;
static PyObject *const_str_plain_PKCS7_free;
static PyObject *const_str_digest_1d1fec7c0642196df296efbe43db1801;
static PyObject *const_str_plain_exts;
static PyObject *const_str_plain_TYPE_EC;
static PyObject *const_str_plain_rwflag;
static PyObject *const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple;
static PyObject *const_tuple_str_digest_4560cdf69c017b7cd264323295e708cb_tuple;
static PyObject *const_str_digest_d85051204198165c5d51e35c1e5d5077;
static PyObject *const_str_digest_a2b9bb33a11d02b696dfc736bf45c56d;
static PyObject *const_str_plain_TYPE_DSA;
extern PyObject *const_str_plain_pycert;
static PyObject *const_str_plain_M_ASN1_OCTET_STRING_print;
static PyObject *const_str_digest_07697dd6fa4854473fa24b52569d5636;
static PyObject *const_str_plain_has_expired;
extern PyObject *const_str_plain_OBJ_nid2sn;
extern PyObject *const_str_plain_extensions;
static PyObject *const_str_plain__EllipticCurve;
static PyObject *const_str_digest_007f81c06fa49e709fd9306cc6c26627;
static PyObject *const_str_digest_7a5005a2e44b5258634f5b2837cd8b81;
extern PyObject *const_dict_empty;
extern PyObject *const_str_plain_BN_free;
extern PyObject *const_str_plain_CertificateSigningRequest;
static PyObject *const_str_plain_small_serial;
static PyObject *const_str_plain_X509_STORE_add_cert;
static PyObject *const_str_plain_revoked_stack;
extern PyObject *const_str_plain_nid;
extern PyObject *const_str_plain_utils;
static PyObject *const_str_plain_X509_STORE_CTX_new;
extern PyObject *const_str_plain_X509_dup;
static PyObject *const_str_plain_digest_result;
static PyObject *const_str_plain_BN_new;
static PyObject *const_tuple_str_plain__CertificateRevocationList_tuple;
extern PyObject *const_str_plain_RSAPublicKey;
extern PyObject *const_str_plain_BN_to_ASN1_INTEGER;
extern PyObject *const_str_plain_X509_REVOKED_new;
static PyObject *const_str_plain_issuer_cert;
static PyObject *const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple;
extern PyObject *const_str_digest_9838c39bdf9fdb401c17b0106d8660a3;
static PyObject *const_str_digest_9c28b2ef32679900c21c54152be8ce03;
extern PyObject *const_str_plain_Cryptography_X509_REVOKED_dup;
extern PyObject *const_str_plain__name;
extern PyObject *const_str_plain_X509_NAME_ENTRY_free;
extern PyObject *const_str_plain_get_verified_chain;
extern PyObject *const_str_plain___repr__;
static PyObject *const_str_plain_get_critical;
static PyObject *const_str_plain_print_result;
extern PyObject *const_str_plain_length;
static PyObject *const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple;
static PyObject *const_tuple_2a726d59ade46c77b6bfd95ed66c5a12_tuple;
static PyObject *const_str_plain__req;
extern PyObject *const_str_plain_get_version;
extern PyObject *const_str_plain_sk_X509_EXTENSION_value;
extern PyObject *const_str_plain_NID_undef;
static PyObject *const_str_plain__prefixes;
static PyObject *const_tuple_5209455ecbb28249752027c3a839ae1c_tuple;
static PyObject *const_str_plain_gmtime_adj_notAfter;
extern PyObject *const_str_plain_d2i_X509_REQ_bio;
extern PyObject *const_str_plain_ASN1_INTEGER_free;
static PyObject *const_tuple_str_plain_self_str_plain_req_tuple;
static PyObject *const_str_plain_PEM_write_bio_PrivateKey;
static PyObject *const_str_plain_PEM_read_bio_PKCS7;
static PyObject *const_str_digest_6674ab14e1178de501dfb968278a50b9;
static PyObject *const_tuple_str_plain_self_str_plain_which_tuple;
static PyObject *const_str_digest_0ba82c04a076f46925a74539c2a8ba40;
static PyObject *const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple;
static PyObject *const_str_plain_to_cryptography_key;
extern PyObject *const_str_plain_GEN_URI;
static PyObject *const_str_digest_97388c7ddfea4f913fec5c846dd26ef1;
static PyObject *const_tuple_79603f0465bd62773d6ec6c98e743896_tuple;
static PyObject *const_str_digest_e2d15f7f418fdd55a54be9ea476feee3;
static PyObject *const_str_plain_NETSCAPE_SPKI_sign;
static PyObject *const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple;
static PyObject *const_str_digest_61d70cefdce1472400ab8a06d64ef78a;
extern PyObject *const_str_plain_parts;
static PyObject *const_str_plain_load_privatekey;
static PyObject *const_tuple_str_digest_f3b04f8993b30e664e4afacb3d64cdc4_tuple;
static PyObject *const_str_plain_buffer_length;
static PyObject *const_str_plain_bn_result;
static PyObject *const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple;
static PyObject *const_str_digest_e19f4eaf61167e65441aca909fe75b36;
static PyObject *const_str_plain_MBSTRING_UTF8;
extern PyObject *const_str_plain__Certificate;
extern PyObject *const_int_pos_512;
extern PyObject *const_str_plain___str__;
static PyObject *const_str_plain_hexstring_serial;
extern PyObject *const_str_plain_PKCS12_parse;
static PyObject *const_str_plain__only_public;
static PyObject *const_tuple_str_plain_self_str_plain_dt_tuple;
extern PyObject *const_str_plain_affiliationChanged;
extern PyObject *const_str_plain_evp_md;
extern PyObject *const_str_plain_algorithm;
static PyObject *const_str_digest_1dad1cec7e14813a999c9dcf96c8f89f;
static PyObject *const_str_plain_GENERAL_NAME_print;
static PyObject *const_str_plain__names;
static PyObject *const_str_digest_c57795fb6a9ac3d47e928f9a8b608571;
extern PyObject *const_str_plain_ascii;
extern PyObject *const_str_plain_cert_stack;
static PyObject *const_str_plain_CACompromise;
static PyObject *const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple;
static PyObject *const_str_plain_set_reason;
static PyObject *const_str_plain_add_extensions;
static PyObject *const_str_plain_EVP_VerifyInit;
static PyObject *const_str_digest_880f67f2b28115a7ad1d1bfb533fc6bc;
static PyObject *const_str_plain_NID_crl_reason;
static PyObject *const_str_plain_result_buffer;
extern PyObject *const_str_digest_b9c4baf879ebd882d40843df3a4dead7;
static PyObject *const_str_plain_ent_obj;
extern PyObject *const_tuple_int_0_tuple;
static PyObject *const_str_plain_X509StoreContextError;
static PyObject *const_str_digest_b2d5bbfa3f949ddcc231b89e71aa8d92;
extern PyObject *const_str_plain_X509_REQ_set_pubkey;
static PyObject *const_tuple_str_plain_name_str_plain_curve_tuple;
extern PyObject *const_str_plain_X509_get_version;
static PyObject *const_str_plain_notAfter;
static PyObject *const_str_plain_X509_V_FLAG_INHIBIT_MAP;
static PyObject *const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple;
static PyObject *const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple;
extern PyObject *const_str_plain_sk_X509_free;
static PyObject *const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple;
static PyObject *const_str_plain__owner;
static PyObject *const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple;
extern PyObject *const_str_plain_X509_REQ_get_subject_name;
static PyObject *const_str_plain_exceptionType;
static PyObject *const_str_plain_ASN1_STRING_data;
extern PyObject *const_str_plain___module__;
extern PyObject *const_str_plain__to_EC_KEY;
static PyObject *const_str_digest_819566a56c114d5ab553db6b3a965184;
static PyObject *const_str_plain_sk_X509_new_null;
extern PyObject *const_str_plain_lower;
static PyObject *const_str_plain_ASN1_STRING_length;
static PyObject *const_str_plain__subject_invalidator;
static PyObject *const_str_plain_type_is_signedAndEnveloped;
static PyObject *const_str_plain_X509_NAME_oneline;
static PyObject *const_str_plain_hash;
extern PyObject *const_str_plain_X509_get_pubkey;
extern PyObject *const_str_plain__x509_req;
static PyObject *const_str_digest_c623dd0c947983ab2cfcbe4c53400720;
extern PyObject *const_str_plain_startswith;
extern PyObject *const_str_angle_genexpr;
static PyObject *const_str_plain_certificate;
extern PyObject *const_str_plain_exception_from_error_queue;
extern PyObject *const_str_digest_499043b9b2da602637f07b1aa101ddfb;
extern PyObject *const_str_plain_SSL_load_error_strings;
static PyObject *const_str_plain_EVP_PKEY_type;
extern PyObject *const_str_plain__x509;
static PyObject *const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple;
static PyObject *const_str_plain_verify_result;
static PyObject *const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple;
static PyObject *const_str_digest_f76c1a90d81cc9627b0b6df42991dbc9;
extern PyObject *const_str_plain_string;
extern PyObject *const_tuple_str_plain_self_str_plain_key_tuple;
static PyObject *const_str_plain_gmtime_adj_notBefore;
static PyObject *const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple;
static PyObject *const_str_digest_c4a5d29f3ecd810d59e3d04a7a935f38;
static PyObject *const_str_digest_79dac080796da8f8fc9c66ebe460ce2f;
static PyObject *const_str_plain_amount;
static PyObject *const_str_digest_0d8911e895179dcd467b4e9de2f411d4;
static PyObject *const_str_plain__load_elliptic_curves;
static PyObject *const_str_plain_pykey;
extern PyObject *const_str_plain_X509_CRL_new;
extern PyObject *const_str_plain_EVP_PKEY_set1_DSA;
static PyObject *const_str_plain__get_boundary_time;
extern PyObject *const_str_plain_sk_GENERAL_NAME_num;
static PyObject *const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple;
static PyObject *const_tuple_str_plain_ASN1_TIME_to_generalizedtime_tuple;
static PyObject *const_str_plain_pem_password_cb;
static PyObject *const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple;
static PyObject *const_str_digest_4a193fbd1ccf06765e0cb44620b7d74a;
static PyObject *const_str_plain_X509_STORE_add_crl;
static PyObject *const_str_plain_PKCS7;
static PyObject *const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple;
extern PyObject *const_str_plain_cessationOfOperation;
static PyObject *const_str_plain_X509_STORE_CTX_free;
extern PyObject *const_str_plain_X509_CRL_add0_revoked;
static PyObject *const_str_digest_c47cfcedcc7803c0a6ef28b85213e16f;
static PyObject *const_str_plain_final_result;
static PyObject *const_str_plain_X509_V_FLAG_CRL_CHECK;
static PyObject *const_str_plain_X509_get0_tbs_sigalg;
extern PyObject *const_str_plain_keyCompromise;
static PyObject *const_tuple_d959e8503cbe0fd15122162c0da60661_tuple;
extern PyObject *const_str_plain_byte_string;
static PyObject *const_str_plain__byte_string;
static PyObject *const_str_plain_X509_alias_get0;
static PyObject *const_str_digest_517da8fff62752bad266dd317b6fd3d1;
static PyObject *const_str_plain_crypto_crl;
static PyObject *const_str_plain_X509_NAME_cmp;
static PyObject *const_str_plain__integer_types;
extern PyObject *const_str_plain_other;
static PyObject *const_str_plain_EXPLICIT_POLICY;
extern PyObject *const_str_plain_sk_X509_REVOKED_value;
extern PyObject *const_str_plain__store;
static PyObject *const_str_plain_signature_length;
extern PyObject *const_str_plain_i2d_PUBKEY_bio;
static PyObject *const_str_plain_set_issuer;
static PyObject *const_str_plain_ASN1_INTEGER_set;
static PyObject *const_str_plain_when;
extern PyObject *const_str_plain_BN_bn2hex;
static PyObject *const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple;
extern PyObject *const_str_plain_OPENSSL_free;
static PyObject *const_str_digest_2dbcbe3e7da77178b4a9da40244d072a;
extern PyObject *const_str_plain_unspecified;
static PyObject *const_list_298f4a46a008df82aecc87d37443e76b_list;
static PyObject *const_str_digest_0d925750cb36e0c0e5f47f40c47790e6;
static PyObject *const_str_plain_type_is_data;
extern PyObject *const_str_plain_deprecated;
static PyObject *const_str_digest_66b2a3b8e35254752e96fbbddc255dfd;
static PyObject *const_str_digest_998fe297d663eb0475d60a56d2b84182;
static PyObject *const_str_digest_859c7c43c5cf3124cdd58374d6e7359e;
static PyObject *const_str_plain_BN_set_word;
extern PyObject *const_str_plain_BIO_s_mem;
extern PyObject *const_str_plain_X509_REVOKED_get0_serialNumber;
static PyObject *const_str_digest_3c820c2fc1d76f73132dab0e4e8d3a14;
static PyObject *const_str_digest_bb334a0dc943b8e820be149d2c515af0;
static PyObject *const_tuple_57dca116533b0d6d636b268e7001e41b_tuple;
static PyObject *const_str_plain_crypto_key;
extern PyObject *const_str_plain_bio;
extern PyObject *const_str_space;
static PyObject *const_str_plain__get_backend;
static PyObject *const_str_plain_X509StoreFlags;
static PyObject *const_str_digest_6b664ec0d0974a050be8b09b84bd0a5d;
extern PyObject *const_tuple_str_plain_self_str_plain_name_tuple;
extern PyObject *const_str_digest_2b6a6c0099f1f1dd77d2725acd0722df;
static PyObject *const_str_digest_4b3673d04a6e4a628e29457d54d43c0d;
extern PyObject *const_str_plain_set_result;
static PyObject *const_str_plain__untested_error;
static PyObject *const_str_plain_V_ASN1_GENERALIZEDTIME;
extern PyObject *const_tuple_str_plain_backend_tuple;
extern PyObject *const_str_plain_sk_X509_REVOKED_num;
extern PyObject *const_str_plain_evp_pkey;
static PyObject *const_str_plain_get_revoked;
static PyObject *const_str_plain_dump_certificate_request;
extern PyObject *const_str_plain_buf;
static PyObject *const_str_plain_data_length;
static PyObject *const_str_plain_X509_gmtime_adj;
extern PyObject *const_str_plain_get_subject;
static PyObject *const_str_plain_ref;
static PyObject *const_str_plain_NETSCAPE_SPKI_set_pubkey;
static PyObject *const_str_digest_6b6b180b644052fa34c3e81151f6ea0a;
static PyObject *const_str_plain_num_curves;
extern PyObject *const_str_chr_58;
extern PyObject *const_str_plain_entry;
extern PyObject *const_str_plain_X509_CRL_get_REVOKED;
static PyObject *const_str_digest_b1f5a355e1403668d0044e1a65ec29ce;
extern PyObject *const_str_plain_X509_new;
extern PyObject *const_str_plain_index;
static PyObject *const_str_plain_load_pkcs12;
extern PyObject *const_str_plain_X509V3_EXT_d2i;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_plain_X509_VERIFY_PARAM_set_time;
extern PyObject *const_str_plain_gc;
extern PyObject *const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
static PyObject *const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple;
static PyObject *const_str_plain_verify_certificate;
static PyObject *const_str_digest_8ad6e418a1b04e7939cf7e738b8257d2;
static PyObject *const_str_digest_11c225ccbab9acffc38107dee9691702;
static PyObject *const_tuple_13745beac221529fe5d89135e9b648d3_tuple;
static PyObject *const_str_plain_NETSCAPE_SPKI_b64_encode;
extern PyObject *const_str_plain_timetuple;
static PyObject *const_tuple_788a505d6e43a02df061e74659415d8f_tuple;
extern PyObject *const_str_plain_BN_hex2bn;
static PyObject *const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple;
static PyObject *const_str_digest_cd7d7b6c262cf257f5bafa26f39b567e;
extern PyObject *const_str_plain_X509_REQ_free;
static PyObject *const_str_plain_NETSCAPE_SPKI_new;
static PyObject *const_str_digest_1c1759444507dc6d4c0d7b4ce6b62611;
extern PyObject *const_str_plain_X509_CRL_get_lastUpdate;
static PyObject *const_str_plain_result_length;
extern PyObject *const_str_plain___new__;
static PyObject *const_str_digest_2cf9e4c7f607857df636a128997ff3fc;
static PyObject *const_str_plain_crypto_cert;
extern PyObject *const_str_plain_X509_getm_notAfter;
static PyObject *const_str_plain__subjectAltNameString;
extern PyObject *const_str_plain_i2d_X509_bio;
static PyObject *const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple;
static PyObject *const_tuple_e0284b4dc341731363d45f065b316e64_tuple;
static PyObject *const_str_plain_get_data;
static PyObject *const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple;
extern PyObject *const_str_plain_reason;
static PyObject *const_str_digest_9226325aac109a91f8326c1a26ede065;
static PyObject *const_tuple_str_digest_0d925750cb36e0c0e5f47f40c47790e6_tuple;
static PyObject *const_str_digest_4357c956c1f3628f437632877b5d8593;
static PyObject *const_str_digest_b16563a844474e8eed4710209909ab32;
static PyObject *const_str_digest_8bcf6e6fbaf96377cbe58ba9960c9d58;
extern PyObject *const_str_plain_X509_STORE_CTX_get_error_depth;
extern PyObject *const_str_plain_ASN1_ENUMERATED_new;
static PyObject *const_str_plain_X509_REQ_print_ex;
static PyObject *const_str_digest_e2d5c2f473553b6759cc455da987e04a;
static PyObject *const_str_plain_ent;
extern PyObject *const_str_plain_X509;
static PyObject *const_str_plain_add_revoked;
extern PyObject *const_tuple_none_tuple;
static PyObject *const_str_digest_290681512f72ca11cbf3e4827987aabb;
extern PyObject *const_str_plain_d2i_X509_CRL_bio;
extern PyObject *const_str_plain_ASN1_ENUMERATED_set;
static PyObject *module_filename_obj;

static bool constants_created = false;

static void createModuleConstants( void )
{
    const_str_plain_set_lastUpdate = UNSTREAM_STRING( &constant_bin[ 43103 ], 14, 1 );
    const_str_plain__nid = UNSTREAM_STRING( &constant_bin[ 43117 ], 4, 1 );
    const_str_plain_OBJ_nid2ln = UNSTREAM_STRING( &constant_bin[ 43121 ], 10, 1 );
    const_str_digest_340717166d8c6af86f5d8a6e35ed5a7f = UNSTREAM_STRING( &constant_bin[ 43131 ], 14, 0 );
    const_str_digest_014a797afcc3e1ad4f3e6e9aa4631a8a = UNSTREAM_STRING( &constant_bin[ 43145 ], 68, 0 );
    const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_cacerts = UNSTREAM_STRING( &constant_bin[ 43213 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple, 1, const_str_plain_cacerts ); Py_INCREF( const_str_plain_cacerts );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple, 2, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    const_str_digest_73f7a7ef7b02ca8c5d7fdfe1049be561 = UNSTREAM_STRING( &constant_bin[ 43220 ], 18, 0 );
    const_str_plain__truncate = UNSTREAM_STRING( &constant_bin[ 43238 ], 9, 1 );
    const_str_plain_X509StoreContext = UNSTREAM_STRING( &constant_bin[ 43247 ], 16, 1 );
    const_str_plain_issuer_key = UNSTREAM_STRING( &constant_bin[ 43263 ], 10, 1 );
    const_str_digest_7163953ad9ff69e46167d396f5625cf7 = UNSTREAM_STRING( &constant_bin[ 43273 ], 31, 0 );
    const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 1, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    const_str_plain_builtin_curves = UNSTREAM_STRING( &constant_bin[ 43304 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 2, const_str_plain_builtin_curves ); Py_INCREF( const_str_plain_builtin_curves );
    const_str_plain_num_curves = UNSTREAM_STRING( &constant_bin[ 43318 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 3, const_str_plain_num_curves ); Py_INCREF( const_str_plain_num_curves );
    const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple, 1, const_str_plain__CertificateRevocationList ); Py_INCREF( const_str_plain__CertificateRevocationList );
    PyTuple_SET_ITEM( const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple, 2, const_str_plain_backend ); Py_INCREF( const_str_plain_backend );
    const_str_plain_X509_V_FLAG_POLICY_CHECK = UNSTREAM_STRING( &constant_bin[ 43328 ], 24, 1 );
    const_str_digest_b52a484c26b348bfec0a17217a58ad7e = UNSTREAM_STRING( &constant_bin[ 43352 ], 44, 0 );
    const_str_digest_a9bcf1af78e6d912e13685d8a606fe30 = UNSTREAM_STRING( &constant_bin[ 43396 ], 170, 0 );
    const_str_digest_8fda740163dc7d07c78736dc2ebb17b1 = UNSTREAM_STRING( &constant_bin[ 43566 ], 250, 0 );
    const_str_plain_all_reasons = UNSTREAM_STRING( &constant_bin[ 43816 ], 11, 1 );
    const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_which = UNSTREAM_STRING( &constant_bin[ 3426 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple, 1, const_str_plain_which ); Py_INCREF( const_str_plain_which );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_digest_90de967a5219b9210479f7eac5c285c8 = UNSTREAM_STRING( &constant_bin[ 43827 ], 105, 0 );
    const_str_digest_e335a7c8a0dd4d8ab6096b1597d79143 = UNSTREAM_STRING( &constant_bin[ 43932 ], 237, 0 );
    const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 1, const_str_plain_which ); Py_INCREF( const_str_plain_which );
    const_str_plain_when = UNSTREAM_STRING( &constant_bin[ 1745 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 2, const_str_plain_when ); Py_INCREF( const_str_plain_when );
    const_str_plain_TYPE_RSA = UNSTREAM_STRING( &constant_bin[ 44169 ], 8, 1 );
    const_str_plain_X509_VERIFY_PARAM_free = UNSTREAM_STRING( &constant_bin[ 44177 ], 22, 1 );
    const_str_digest_52cbe8d655a10e46907a30970ef9889a = UNSTREAM_STRING( &constant_bin[ 44199 ], 215, 0 );
    const_str_plain_sk_X509_EXTENSION_free = UNSTREAM_STRING( &constant_bin[ 44414 ], 22, 1 );
    const_str_digest_435662c26b2c422edb954b82c85c55d9 = UNSTREAM_STRING( &constant_bin[ 44436 ], 288, 0 );
    const_str_digest_f737de4a45174195dc1e46101235dc35 = UNSTREAM_STRING( &constant_bin[ 44724 ], 144, 0 );
    const_str_plain_get_rev_date = UNSTREAM_STRING( &constant_bin[ 44868 ], 12, 1 );
    const_str_plain_utcnow = UNSTREAM_STRING( &constant_bin[ 44880 ], 6, 1 );
    const_str_plain_sometime = UNSTREAM_STRING( &constant_bin[ 44886 ], 8, 1 );
    const_tuple_str_plain_cls_str_plain_lib_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_lib_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_lib_tuple, 1, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    const_str_plain_RSA_check_key = UNSTREAM_STRING( &constant_bin[ 44894 ], 13, 1 );
    const_str_plain__get_elliptic_curves = UNSTREAM_STRING( &constant_bin[ 44907 ], 20, 1 );
    const_str_plain_string_type = UNSTREAM_STRING( &constant_bin[ 44927 ], 11, 1 );
    const_tuple_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339_tuple = PyTuple_New( 1 );
    const_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339 = UNSTREAM_STRING( &constant_bin[ 44938 ], 6, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339_tuple, 0, const_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339 ); Py_INCREF( const_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339 );
    const_str_plain_X509_STORE_CTX_get1_chain = UNSTREAM_STRING( &constant_bin[ 44944 ], 25, 1 );
    const_tuple_str_plain_utf8only_tuple = PyTuple_New( 1 );
    const_str_plain_utf8only = UNSTREAM_STRING( &constant_bin[ 44969 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_utf8only_tuple, 0, const_str_plain_utf8only ); Py_INCREF( const_str_plain_utf8only );
    const_str_plain_EVP_SignInit = UNSTREAM_STRING( &constant_bin[ 44977 ], 12, 1 );
    const_str_digest_169aa7f0589e4a3c83203d48f57770af = UNSTREAM_STRING( &constant_bin[ 44989 ], 22, 0 );
    const_str_plain_X509_V_FLAG_IGNORE_CRITICAL = UNSTREAM_STRING( &constant_bin[ 45011 ], 27, 1 );
    const_tuple_str_plain_bio_str_plain_ref_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_bio_str_plain_ref_tuple, 0, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_str_plain_ref = UNSTREAM_STRING( &constant_bin[ 8128 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_bio_str_plain_ref_tuple, 1, const_str_plain_ref ); Py_INCREF( const_str_plain_ref );
    const_str_digest_1565887baecc678658a50e7d1f245653 = UNSTREAM_STRING( &constant_bin[ 45038 ], 236, 0 );
    const_str_digest_d546905f9a7fd3b3fc24a90a7432aa72 = UNSTREAM_STRING( &constant_bin[ 45274 ], 48, 0 );
    const_str_plain_X509_REVOKED_add1_ext_i2d = UNSTREAM_STRING( &constant_bin[ 45322 ], 25, 1 );
    const_str_plain_string_result = UNSTREAM_STRING( &constant_bin[ 45347 ], 13, 1 );
    const_str_digest_dc44ec2c02bcac7fac23b8eea57aa5d6 = UNSTREAM_STRING( &constant_bin[ 45360 ], 24, 0 );
    const_str_digest_a658b60d9bffa55a9bdfb85ba96aec98 = UNSTREAM_STRING( &constant_bin[ 45384 ], 104, 0 );
    const_str_plain_NOTIFY_POLICY = UNSTREAM_STRING( &constant_bin[ 45488 ], 13, 1 );
    const_str_digest_1f681e9f80c6df652cbc3a085be49171 = UNSTREAM_STRING( &constant_bin[ 45501 ], 252, 0 );
    const_str_digest_b69ad7457b37f0df18af9a38324a8007 = UNSTREAM_STRING( &constant_bin[ 45753 ], 248, 0 );
    const_str_plain_PKCS7_type_is_data = UNSTREAM_STRING( &constant_bin[ 46001 ], 18, 1 );
    const_str_digest_670c62a34c6767f6ecd5db6f969b2f34 = UNSTREAM_STRING( &constant_bin[ 46019 ], 500, 0 );
    const_str_plain_pkcs12 = UNSTREAM_STRING( &constant_bin[ 46519 ], 6, 1 );
    const_str_plain__chain = UNSTREAM_STRING( &constant_bin[ 4136 ], 6, 1 );
    const_str_plain_results = UNSTREAM_STRING( &constant_bin[ 46525 ], 7, 1 );
    const_str_plain_FILETYPE_TEXT = UNSTREAM_STRING( &constant_bin[ 46532 ], 13, 1 );
    const_str_plain_ALLOW_PROXY_CERTS = UNSTREAM_STRING( &constant_bin[ 46545 ], 17, 1 );
    const_str_plain_get_short_name = UNSTREAM_STRING( &constant_bin[ 46562 ], 14, 1 );
    const_str_plain_digest_obj = UNSTREAM_STRING( &constant_bin[ 46576 ], 10, 1 );
    const_str_plain_op = UNSTREAM_STRING( &constant_bin[ 2213 ], 2, 1 );
    const_str_plain_type_is_enveloped = UNSTREAM_STRING( &constant_bin[ 46586 ], 17, 1 );
    const_str_digest_03f3989a7f0f1ec9623bd001f5a005a7 = UNSTREAM_STRING( &constant_bin[ 46603 ], 284, 0 );
    const_str_digest_782fa7272fdd3d3abdc1a0298e5e83fc = UNSTREAM_STRING( &constant_bin[ 46887 ], 107, 0 );
    const_str_plain_PKCS12_create = UNSTREAM_STRING( &constant_bin[ 46994 ], 13, 1 );
    const_str_digest_152d11f8848fac60442a26592ab3da87 = UNSTREAM_STRING( &constant_bin[ 47007 ], 688, 0 );
    const_str_digest_0632ce6142bf9815370c626f0fb1235a = UNSTREAM_STRING( &constant_bin[ 47695 ], 26, 0 );
    const_str_plain_char_result = UNSTREAM_STRING( &constant_bin[ 47721 ], 11, 1 );
    const_str_plain_string_timestamp = UNSTREAM_STRING( &constant_bin[ 47732 ], 16, 1 );
    const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 1, const_str_plain_extensions ); Py_INCREF( const_str_plain_extensions );
    PyTuple_SET_ITEM( const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 2, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    PyTuple_SET_ITEM( const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 3, const_str_plain_stack ); Py_INCREF( const_str_plain_stack );
    PyTuple_SET_ITEM( const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 4, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_str_plain_pypkcs7 = UNSTREAM_STRING( &constant_bin[ 47748 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 3, const_str_plain_pypkcs7 ); Py_INCREF( const_str_plain_pypkcs7 );
    const_str_plain_pkcs7 = UNSTREAM_STRING( &constant_bin[ 43854 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 4, const_str_plain_pkcs7 ); Py_INCREF( const_str_plain_pkcs7 );
    const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_not_after = UNSTREAM_STRING( &constant_bin[ 47755 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple, 1, const_str_plain_not_after ); Py_INCREF( const_str_plain_not_after );
    const_str_plain_time_string = UNSTREAM_STRING( &constant_bin[ 47764 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple, 2, const_str_plain_time_string ); Py_INCREF( const_str_plain_time_string );
    const_str_digest_3c5d018dd809b9a6147c1b47d39e8d31 = UNSTREAM_STRING( &constant_bin[ 47775 ], 9, 0 );
    const_str_plain_X509_STORE_CTX_cleanup = UNSTREAM_STRING( &constant_bin[ 47784 ], 22, 1 );
    const_str_digest_50f07d7dbc7dc060eb5685744b92c007 = UNSTREAM_STRING( &constant_bin[ 36977 ], 23, 0 );
    const_str_digest_44f664275c70041c9ae4bef2565506f3 = UNSTREAM_STRING( &constant_bin[ 47806 ], 640, 0 );
    const_str_plain_sk_X509_push = UNSTREAM_STRING( &constant_bin[ 48446 ], 12, 1 );
    const_str_digest_6a19008e8f9a834793cf38dcba68883a = UNSTREAM_STRING( &constant_bin[ 48458 ], 442, 0 );
    const_str_plain_CRL_CHECK = UNSTREAM_STRING( &constant_bin[ 48900 ], 9, 1 );
    const_str_plain_free = UNSTREAM_STRING( &constant_bin[ 20724 ], 4, 1 );
    const_str_plain_spki = UNSTREAM_STRING( &constant_bin[ 48909 ], 4, 1 );
    const_str_digest_624de773f1e3dc72be54266a02c1df41 = UNSTREAM_STRING( &constant_bin[ 48913 ], 43, 0 );
    const_str_plain_set_subject = UNSTREAM_STRING( &constant_bin[ 48956 ], 11, 1 );
    const_str_plain_type_name = UNSTREAM_STRING( &constant_bin[ 47063 ], 9, 1 );
    const_str_digest_f35548e1d45f67292233a83f1d0adcce = UNSTREAM_STRING( &constant_bin[ 48967 ], 238, 0 );
    const_str_digest_5a3f7f69104a4ed1267a21c950d94463 = UNSTREAM_STRING( &constant_bin[ 49205 ], 773, 0 );
    const_tuple_str_plain_self_str_plain_flags_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_flags_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_flags_tuple, 1, const_str_plain_flags ); Py_INCREF( const_str_plain_flags );
    const_str_plain_X509_V_FLAG_ALLOW_PROXY_CERTS = UNSTREAM_STRING( &constant_bin[ 49978 ], 29, 1 );
    const_str_digest_4d14f6e4d6647c6573e3ca9449c2b51f = UNSTREAM_STRING( &constant_bin[ 50007 ], 199, 0 );
    const_str_digest_7e62ce69c000886ecc0ae0b3e8ae9e79 = UNSTREAM_STRING( &constant_bin[ 50206 ], 188, 0 );
    const_str_digest_7de17ac920010129977e4280610f275c = UNSTREAM_STRING( &constant_bin[ 50394 ], 271, 0 );
    const_str_plain_EVP_SignFinal = UNSTREAM_STRING( &constant_bin[ 50665 ], 13, 1 );
    const_str_plain_NID_pbe_WithSHA1And3_Key_TripleDES_CBC = UNSTREAM_STRING( &constant_bin[ 50678 ], 38, 1 );
    const_str_plain__get_name = UNSTREAM_STRING( &constant_bin[ 18521 ], 9, 1 );
    const_str_plain_b64_encode = UNSTREAM_STRING( &constant_bin[ 50716 ], 10, 1 );
    const_str_plain_ASN1_STRING_set_default_mask_asc = UNSTREAM_STRING( &constant_bin[ 50726 ], 32, 1 );
    const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 1, const_str_plain_crl ); Py_INCREF( const_str_plain_crl );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 3, const_str_plain_ret ); Py_INCREF( const_str_plain_ret );
    const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 3, const_str_plain_op ); Py_INCREF( const_str_plain_op );
    const_str_digest_9acbe023ce14d1d2ba528bd23b2423a0 = UNSTREAM_STRING( &constant_bin[ 50758 ], 415, 0 );
    const_str_plain_EVP_VerifyUpdate = UNSTREAM_STRING( &constant_bin[ 51173 ], 16, 1 );
    const_str_digest_603c60edaf58a8746faa757f20f3f938 = UNSTREAM_STRING( &constant_bin[ 51189 ], 265, 0 );
    const_str_digest_32726a73c20427f70712d109be7712b4 = UNSTREAM_STRING( &constant_bin[ 51454 ], 192, 0 );
    const_str_plain__crl_reasons = UNSTREAM_STRING( &constant_bin[ 51646 ], 12, 1 );
    const_str_plain__passphrase = UNSTREAM_STRING( &constant_bin[ 31404 ], 11, 1 );
    const_str_plain__revoked = UNSTREAM_STRING( &constant_bin[ 51658 ], 8, 1 );
    const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 0, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 1, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 2, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    const_str_plain_final_result = UNSTREAM_STRING( &constant_bin[ 51666 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 3, const_str_plain_final_result ); Py_INCREF( const_str_plain_final_result );
    const_str_plain_signature_length = UNSTREAM_STRING( &constant_bin[ 51678 ], 16, 1 );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 4, const_str_plain_signature_length ); Py_INCREF( const_str_plain_signature_length );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 5, const_str_plain_length ); Py_INCREF( const_str_plain_length );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 6, const_str_plain_digest_obj ); Py_INCREF( const_str_plain_digest_obj );
    const_str_plain_signature_buffer = UNSTREAM_STRING( &constant_bin[ 51694 ], 16, 1 );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 7, const_str_plain_signature_buffer ); Py_INCREF( const_str_plain_signature_buffer );
    const_str_plain_md_ctx = UNSTREAM_STRING( &constant_bin[ 51710 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 8, const_str_plain_md_ctx ); Py_INCREF( const_str_plain_md_ctx );
    const_str_plain_fname = UNSTREAM_STRING( &constant_bin[ 51716 ], 5, 1 );
    const_str_digest_60cf4d81fa4ac0fb8a6d16cafc145b24 = UNSTREAM_STRING( &constant_bin[ 51721 ], 266, 0 );
    const_str_plain_pycacert = UNSTREAM_STRING( &constant_bin[ 51987 ], 8, 1 );
    const_str_digest_40e46351c3b918f338d6e675fea0b1ca = UNSTREAM_STRING( &constant_bin[ 51995 ], 421, 0 );
    const_str_plain_get_signature_algorithm = UNSTREAM_STRING( &constant_bin[ 52416 ], 23, 1 );
    const_str_plain_ent_nid = UNSTREAM_STRING( &constant_bin[ 52439 ], 7, 1 );
    const_str_digest_a9fcf3ea8b3ff05d45964d00ac386113 = UNSTREAM_STRING( &constant_bin[ 52446 ], 249, 0 );
    const_str_digest_c384f9f99d5890cd2aae342c30dbaa14 = UNSTREAM_STRING( &constant_bin[ 52695 ], 109, 0 );
    const_str_plain_load_crl = UNSTREAM_STRING( &constant_bin[ 52804 ], 8, 1 );
    const_str_plain_i2d_PKCS12_bio = UNSTREAM_STRING( &constant_bin[ 52812 ], 14, 1 );
    const_str_digest_5bd123cbe57a454c8d9d37867b598cb2 = UNSTREAM_STRING( &constant_bin[ 52826 ], 70, 0 );
    const_str_plain_crypto_req = UNSTREAM_STRING( &constant_bin[ 52896 ], 10, 1 );
    const_str_plain_CHECK_SS_SIGNATURE = UNSTREAM_STRING( &constant_bin[ 52906 ], 18, 1 );
    const_str_plain_X509_V_FLAG_NOTIFY_POLICY = UNSTREAM_STRING( &constant_bin[ 52924 ], 25, 1 );
    const_str_plain_set_version = UNSTREAM_STRING( &constant_bin[ 52949 ], 11, 1 );
    const_tuple_str_plain_s_str_plain_i_str_plain_x_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_s_str_plain_i_str_plain_x_tuple, 0, const_str_plain_s ); Py_INCREF( const_str_plain_s );
    PyTuple_SET_ITEM( const_tuple_str_plain_s_str_plain_i_str_plain_x_tuple, 1, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_str_plain_s_str_plain_i_str_plain_x_tuple, 2, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    const_str_plain_d2i_PKCS7_bio = UNSTREAM_STRING( &constant_bin[ 52960 ], 13, 1 );
    const_str_digest_0807c1b9c5bc0ac3cc25375c4a9ebb2e = UNSTREAM_STRING( &constant_bin[ 52973 ], 189, 0 );
    const_str_plain_EVP_PKEY_assign_RSA = UNSTREAM_STRING( &constant_bin[ 53162 ], 19, 1 );
    const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple = PyTuple_New( 18 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 0, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    const_str_plain_passphrase = UNSTREAM_STRING( &constant_bin[ 8746 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 1, const_str_plain_passphrase ); Py_INCREF( const_str_plain_passphrase );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_str_plain_pykey = UNSTREAM_STRING( &constant_bin[ 53181 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 3, const_str_plain_pykey ); Py_INCREF( const_str_plain_pykey );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 4, const_str_plain_x509 ); Py_INCREF( const_str_plain_x509 );
    const_str_plain_friendlyname_buffer = UNSTREAM_STRING( &constant_bin[ 53186 ], 19, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 5, const_str_plain_friendlyname_buffer ); Py_INCREF( const_str_plain_friendlyname_buffer );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 6, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 7, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 8, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 9, const_str_plain_cacerts ); Py_INCREF( const_str_plain_cacerts );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 10, const_str_plain_pycert ); Py_INCREF( const_str_plain_pycert );
    const_str_plain_friendlyname_length = UNSTREAM_STRING( &constant_bin[ 53205 ], 19, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 11, const_str_plain_friendlyname_length ); Py_INCREF( const_str_plain_friendlyname_length );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 12, const_str_plain_p12 ); Py_INCREF( const_str_plain_p12 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 13, const_str_plain_pycacert ); Py_INCREF( const_str_plain_pycacert );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 14, const_str_plain_pkcs12 ); Py_INCREF( const_str_plain_pkcs12 );
    const_str_plain_friendlyname = UNSTREAM_STRING( &constant_bin[ 53186 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 15, const_str_plain_friendlyname ); Py_INCREF( const_str_plain_friendlyname );
    const_str_plain_pycacerts = UNSTREAM_STRING( &constant_bin[ 53224 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 16, const_str_plain_pycacerts ); Py_INCREF( const_str_plain_pycacerts );
    const_str_plain_parse_result = UNSTREAM_STRING( &constant_bin[ 53233 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 17, const_str_plain_parse_result ); Py_INCREF( const_str_plain_parse_result );
    const_str_plain_generalized_timestamp = UNSTREAM_STRING( &constant_bin[ 53245 ], 21, 1 );
    const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 1, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 3, const_str_plain_asn1_int ); Py_INCREF( const_str_plain_asn1_int );
    const_str_plain_get_pubkey = UNSTREAM_STRING( &constant_bin[ 53266 ], 10, 1 );
    const_str_plain_get_components = UNSTREAM_STRING( &constant_bin[ 53276 ], 14, 1 );
    const_str_digest_35f6b1c1261cd55e34a5b00d6cb8d5ea = UNSTREAM_STRING( &constant_bin[ 53290 ], 37, 0 );
    const_str_plain_set_privatekey = UNSTREAM_STRING( &constant_bin[ 53327 ], 14, 1 );
    const_str_plain_EVP_VerifyFinal = UNSTREAM_STRING( &constant_bin[ 53341 ], 15, 1 );
    const_str_digest_26a65c58106d086427e37cb87b0bc3b3 = UNSTREAM_STRING( &constant_bin[ 53356 ], 271, 0 );
    const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple, 1, const_str_plain__Certificate ); Py_INCREF( const_str_plain__Certificate );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple, 2, const_str_plain_backend ); Py_INCREF( const_str_plain_backend );
    const_str_plain_get_notBefore = UNSTREAM_STRING( &constant_bin[ 53627 ], 13, 1 );
    const_str_plain_X509V3_set_ctx_nodb = UNSTREAM_STRING( &constant_bin[ 53640 ], 19, 1 );
    const_str_plain_cleanup = UNSTREAM_STRING( &constant_bin[ 47799 ], 7, 1 );
    const_str_digest_8db7448b8246dd51f74c33bda58590bd = UNSTREAM_STRING( &constant_bin[ 53659 ], 376, 0 );
    const_str_plain_i2d_PrivateKey_bio = UNSTREAM_STRING( &constant_bin[ 54035 ], 18, 1 );
    const_str_digest_05b2bb16e6ee73fd972536e52cc4cabf = UNSTREAM_STRING( &constant_bin[ 54053 ], 270, 0 );
    const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY2_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY2_tuple, 0, const_str_plain_integer_types ); Py_INCREF( const_str_plain_integer_types );
    PyTuple_SET_ITEM( const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY2_tuple, 1, const_str_plain_text_type ); Py_INCREF( const_str_plain_text_type );
    PyTuple_SET_ITEM( const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY2_tuple, 2, const_str_plain_PY2 ); Py_INCREF( const_str_plain_PY2 );
    const_str_digest_542816c377b6c750acf5d24f0edc02b0 = UNSTREAM_STRING( &constant_bin[ 54323 ], 84, 0 );
    const_str_digest_1ca413f5b66374db6a573ac0926a99ae = UNSTREAM_STRING( &constant_bin[ 54407 ], 135, 0 );
    const_str_plain_exponent = UNSTREAM_STRING( &constant_bin[ 54542 ], 8, 1 );
    const_str_plain_CRL_CHECK_ALL = UNSTREAM_STRING( &constant_bin[ 54550 ], 13, 1 );
    const_str_digest_c7bf9684574689f7d764ff6fbd5eab60 = UNSTREAM_STRING( &constant_bin[ 54563 ], 266, 0 );
    const_tuple_str_plain_op_str_plain_f_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_op_str_plain_f_tuple, 0, const_str_plain_op ); Py_INCREF( const_str_plain_op );
    PyTuple_SET_ITEM( const_tuple_str_plain_op_str_plain_f_tuple, 1, const_str_plain_f ); Py_INCREF( const_str_plain_f );
    const_str_digest_2f591e55cc116ed5223c119e2f7da344 = UNSTREAM_STRING( &constant_bin[ 54829 ], 150, 0 );
    const_str_plain__build_certificate_stack = UNSTREAM_STRING( &constant_bin[ 54979 ], 24, 1 );
    const_str_plain_vfy_time = UNSTREAM_STRING( &constant_bin[ 55003 ], 8, 1 );
    const_str_plain_sk_X509_EXTENSION_push = UNSTREAM_STRING( &constant_bin[ 55011 ], 22, 1 );
    const_str_plain_days = UNSTREAM_STRING( &constant_bin[ 55033 ], 4, 1 );
    const_str_plain_get_extension_count = UNSTREAM_STRING( &constant_bin[ 55037 ], 19, 1 );
    const_str_digest_12c1bc175ad6309f9cfc24942b8c76ac = UNSTREAM_STRING( &constant_bin[ 55056 ], 158, 0 );
    const_str_plain_load_certificate_request = UNSTREAM_STRING( &constant_bin[ 55214 ], 24, 1 );
    const_tuple_str_plain_self_str_plain_when_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_when_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_when_tuple, 1, const_str_plain_when ); Py_INCREF( const_str_plain_when );
    const_str_plain_X509V3_EXT_print = UNSTREAM_STRING( &constant_bin[ 55238 ], 16, 1 );
    const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 1, const_str_plain_type_name ); Py_INCREF( const_str_plain_type_name );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 2, const_str_plain_critical ); Py_INCREF( const_str_plain_critical );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 3, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 4, const_str_plain_subject ); Py_INCREF( const_str_plain_subject );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 5, const_str_plain_issuer ); Py_INCREF( const_str_plain_issuer );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 6, const_str_plain_extension ); Py_INCREF( const_str_plain_extension );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 7, const_str_plain_ctx ); Py_INCREF( const_str_plain_ctx );
    const_str_digest_f979ae5e9b0a9a41a05276169a44e7e9 = UNSTREAM_STRING( &constant_bin[ 55254 ], 259, 0 );
    const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple, 1, const_str_plain_obj ); Py_INCREF( const_str_plain_obj );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple, 2, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 1, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_str_plain_result_code = UNSTREAM_STRING( &constant_bin[ 55513 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 3, const_str_plain_result_code ); Py_INCREF( const_str_plain_result_code );
    const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple, 1, const_str_plain_version ); Py_INCREF( const_str_plain_version );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple, 2, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_str_plain_i2a_ASN1_INTEGER = UNSTREAM_STRING( &constant_bin[ 55524 ], 16, 1 );
    const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_algor = UNSTREAM_STRING( &constant_bin[ 52430 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple, 1, const_str_plain_algor ); Py_INCREF( const_str_plain_algor );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple, 2, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple, 0, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_str_plain_buffer_length = UNSTREAM_STRING( &constant_bin[ 55540 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple, 1, const_str_plain_buffer_length ); Py_INCREF( const_str_plain_buffer_length );
    const_str_plain_result_buffer = UNSTREAM_STRING( &constant_bin[ 55553 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple, 2, const_str_plain_result_buffer ); Py_INCREF( const_str_plain_result_buffer );
    const_str_digest_3d684470d9353bc1a1e8d63a3aab4679 = UNSTREAM_STRING( &constant_bin[ 55566 ], 15, 0 );
    const_str_plain_X509_NAME_delete_entry = UNSTREAM_STRING( &constant_bin[ 55581 ], 22, 1 );
    const_str_digest_8aae826f04ca2a5df2a0de1a103a1f13 = UNSTREAM_STRING( &constant_bin[ 55603 ], 24, 0 );
    const_str_plain_X509_REQ_get_version = UNSTREAM_STRING( &constant_bin[ 55627 ], 20, 1 );
    const_str_digest_333948d9e51f0e161201a16305959930 = UNSTREAM_STRING( &constant_bin[ 55647 ], 244, 0 );
    const_str_plain_native_exts_obj = UNSTREAM_STRING( &constant_bin[ 55891 ], 15, 1 );
    const_str_digest_9cb57ebafd0926d1746d2e66a6198efe = UNSTREAM_STRING( &constant_bin[ 55906 ], 43, 0 );
    const_str_plain_X509_STRICT = UNSTREAM_STRING( &constant_bin[ 55949 ], 11, 1 );
    const_tuple_str_digest_e2d15f7f418fdd55a54be9ea476feee3_tuple = PyTuple_New( 1 );
    const_str_digest_e2d15f7f418fdd55a54be9ea476feee3 = UNSTREAM_STRING( &constant_bin[ 55960 ], 16, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_e2d15f7f418fdd55a54be9ea476feee3_tuple, 0, const_str_digest_e2d15f7f418fdd55a54be9ea476feee3 ); Py_INCREF( const_str_digest_e2d15f7f418fdd55a54be9ea476feee3 );
    const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_plain_crypto_cert = UNSTREAM_STRING( &constant_bin[ 45549 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple, 1, const_str_plain_crypto_cert ); Py_INCREF( const_str_plain_crypto_cert );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple, 2, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    const_str_digest_5339fa8ff3df372e54ef7b09078767aa = UNSTREAM_STRING( &constant_bin[ 55976 ], 15, 0 );
    const_tuple_86464d9c162f01af99141e0a5b804d71_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 2, const_str_plain_write_bio ); Py_INCREF( const_str_plain_write_bio );
    PyTuple_SET_ITEM( const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 3, const_str_plain_result_code ); Py_INCREF( const_str_plain_result_code );
    PyTuple_SET_ITEM( const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 4, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 1, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 2, const_str_plain_obj ); Py_INCREF( const_str_plain_obj );
    const_str_plain_print_result = UNSTREAM_STRING( &constant_bin[ 55991 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 3, const_str_plain_print_result ); Py_INCREF( const_str_plain_print_result );
    PyTuple_SET_ITEM( const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 4, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 5, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    const_str_plain_NID_subject_alt_name = UNSTREAM_STRING( &constant_bin[ 56003 ], 20, 1 );
    const_str_plain_add_cert = UNSTREAM_STRING( &constant_bin[ 56023 ], 8, 1 );
    const_tuple_str_digest_70b987f75825a6c2ffe2c8fe53d85a21_tuple = PyTuple_New( 1 );
    const_str_digest_70b987f75825a6c2ffe2c8fe53d85a21 = UNSTREAM_STRING( &constant_bin[ 55985 ], 6, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_70b987f75825a6c2ffe2c8fe53d85a21_tuple, 0, const_str_digest_70b987f75825a6c2ffe2c8fe53d85a21 ); Py_INCREF( const_str_digest_70b987f75825a6c2ffe2c8fe53d85a21 );
    const_str_plain_load_certificate = UNSTREAM_STRING( &constant_bin[ 55214 ], 16, 1 );
    const_str_digest_5cb0319d0378026eb0ef49838e525520 = UNSTREAM_STRING( &constant_bin[ 56031 ], 311, 0 );
    const_str_digest_62c9c3f244d467c166be64cd38a755a7 = UNSTREAM_STRING( &constant_bin[ 56342 ], 224, 0 );
    const_str_digest_f41f911aba33894e1da796354264d96a = UNSTREAM_STRING( &constant_bin[ 56566 ], 435, 0 );
    const_str_plain_subject_name_hash = UNSTREAM_STRING( &constant_bin[ 57001 ], 17, 1 );
    const_str_plain_subject_cert = UNSTREAM_STRING( &constant_bin[ 57018 ], 12, 1 );
    const_str_plain_set_pubkey = UNSTREAM_STRING( &constant_bin[ 57030 ], 10, 1 );
    const_str_digest_e69f89000e2dc720ec6a70b8f9cb0cac = UNSTREAM_STRING( &constant_bin[ 57040 ], 131, 0 );
    const_str_plain_ASN1_STRING_type = UNSTREAM_STRING( &constant_bin[ 57171 ], 16, 1 );
    const_str_digest_61dbd227935e54cb40eecc7de8b8596b = UNSTREAM_STRING( &constant_bin[ 57187 ], 137, 0 );
    const_str_digest_1d608c98cc8048d3f7b439059ee29b66 = UNSTREAM_STRING( &constant_bin[ 57324 ], 420, 0 );
    const_str_digest_79b48b443a4edf88bd64a278e98529d3 = UNSTREAM_STRING( &constant_bin[ 57744 ], 254, 0 );
    const_str_plain_from_nid = UNSTREAM_STRING( &constant_bin[ 57998 ], 8, 1 );
    const_str_digest_11dbf726734533c622c12e725d15648e = UNSTREAM_STRING( &constant_bin[ 58006 ], 123, 0 );
    const_str_plain__spki = UNSTREAM_STRING( &constant_bin[ 58129 ], 5, 1 );
    const_str_plain_from_cryptography = UNSTREAM_STRING( &constant_bin[ 58134 ], 17, 1 );
    const_str_digest_f56881bccbbc40c6643f9603628e7a5c = UNSTREAM_STRING( &constant_bin[ 58151 ], 273, 0 );
    const_str_plain_X509Req = UNSTREAM_STRING( &constant_bin[ 58424 ], 7, 1 );
    const_str_plain_load_pkcs7_data = UNSTREAM_STRING( &constant_bin[ 58431 ], 15, 1 );
    const_str_digest_95aba6f0be0722dff4a715f251a45159 = UNSTREAM_STRING( &constant_bin[ 58446 ], 18, 0 );
    const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 1, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 2, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 3, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_digest_117006b03ff8e10f330ac900a6cd41e8 = UNSTREAM_STRING( &constant_bin[ 58464 ], 25, 0 );
    const_str_digest_9781f115d6516693d922717b11376a73 = UNSTREAM_STRING( &constant_bin[ 58489 ], 277, 0 );
    const_str_plain_POLICY_CHECK = UNSTREAM_STRING( &constant_bin[ 43340 ], 12, 1 );
    const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e = UNSTREAM_STRING( &constant_bin[ 58766 ], 20, 0 );
    const_str_plain__new_mem_buf = UNSTREAM_STRING( &constant_bin[ 58786 ], 12, 1 );
    const_str_plain_X509_verify_cert_error_string = UNSTREAM_STRING( &constant_bin[ 58798 ], 29, 1 );
    const_str_digest_686e4f9f1c51b7038afe792590c33346 = UNSTREAM_STRING( &constant_bin[ 58827 ], 118, 0 );
    const_str_plain_X509_CRL_print = UNSTREAM_STRING( &constant_bin[ 58945 ], 14, 1 );
    const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 1, const_str_plain_errors ); Py_INCREF( const_str_plain_errors );
    PyTuple_SET_ITEM( const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 2, const_str_plain__cert ); Py_INCREF( const_str_plain__cert );
    PyTuple_SET_ITEM( const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 3, const_str_plain_pycert ); Py_INCREF( const_str_plain_pycert );
    PyTuple_SET_ITEM( const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 4, const_str_plain__x509 ); Py_INCREF( const_str_plain__x509 );
    const_str_digest_0a3eb1716e7caaaf09c8582b572bcb60 = UNSTREAM_STRING( &constant_bin[ 58959 ], 316, 0 );
    const_str_digest_d03be6fc9f3e6729b366e69e0856a450 = UNSTREAM_STRING( &constant_bin[ 59275 ], 368, 0 );
    const_str_digest_458f07858808d53330e13a12d5e50e24 = UNSTREAM_STRING( &constant_bin[ 59643 ], 338, 0 );
    const_str_plain_bignum_ptr = UNSTREAM_STRING( &constant_bin[ 59981 ], 10, 1 );
    const_str_plain_export = UNSTREAM_STRING( &constant_bin[ 3959 ], 6, 1 );
    const_tuple_none_int_pos_2048_int_pos_1_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_none_int_pos_2048_int_pos_1_tuple, 0, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_int_pos_2048_int_pos_1_tuple, 1, const_int_pos_2048 ); Py_INCREF( const_int_pos_2048 );
    PyTuple_SET_ITEM( const_tuple_none_int_pos_2048_int_pos_1_tuple, 2, const_int_pos_1 ); Py_INCREF( const_int_pos_1 );
    const_str_digest_4fd5a0c1d1fb7366c52acc7b3ac0b5b1 = UNSTREAM_STRING( &constant_bin[ 59991 ], 22, 0 );
    const_tuple_str_digest_8e9fba48e24a08144a915d52e31f6d23_tuple = PyTuple_New( 1 );
    const_str_digest_8e9fba48e24a08144a915d52e31f6d23 = UNSTREAM_STRING( &constant_bin[ 60013 ], 4, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_8e9fba48e24a08144a915d52e31f6d23_tuple, 0, const_str_digest_8e9fba48e24a08144a915d52e31f6d23 ); Py_INCREF( const_str_digest_8e9fba48e24a08144a915d52e31f6d23 );
    const_str_digest_9ae52cddf69d053d9518f458a81ffa1b = UNSTREAM_STRING( &constant_bin[ 60017 ], 36, 0 );
    const_str_plain_X509_EXTENSION_dup = UNSTREAM_STRING( &constant_bin[ 60053 ], 18, 1 );
    const_str_digest_978cd476d4acffdfb043e6a5e0ebae26 = UNSTREAM_STRING( &constant_bin[ 60071 ], 258, 0 );
    const_str_plain__pkcs7 = UNSTREAM_STRING( &constant_bin[ 43853 ], 6, 1 );
    const_str_plain_SSL_FILETYPE_ASN1 = UNSTREAM_STRING( &constant_bin[ 60329 ], 17, 1 );
    const_tuple_76984bb103279dcce095840ed073cae5_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 2, const_str_plain_passphrase ); Py_INCREF( const_str_plain_passphrase );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 3, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 4, const_str_plain_helper ); Py_INCREF( const_str_plain_helper );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 5, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 6, const_str_plain_evp_pkey ); Py_INCREF( const_str_plain_evp_pkey );
    const_str_plain_X509_V_FLAG_EXPLICIT_POLICY = UNSTREAM_STRING( &constant_bin[ 60346 ], 27, 1 );
    const_str_plain_callback_args = UNSTREAM_STRING( &constant_bin[ 4590 ], 13, 1 );
    const_str_plain_set_store = UNSTREAM_STRING( &constant_bin[ 60373 ], 9, 1 );
    const_str_digest_5f245d1740d80da82563e21c9c4f4fbf = UNSTREAM_STRING( &constant_bin[ 60382 ], 107, 0 );
    const_str_plain_reason_code = UNSTREAM_STRING( &constant_bin[ 60489 ], 11, 1 );
    const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 0, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 1, const_str_plain_signature ); Py_INCREF( const_str_plain_signature );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 2, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 3, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 4, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 5, const_str_plain_digest_obj ); Py_INCREF( const_str_plain_digest_obj );
    const_str_plain_verify_result = UNSTREAM_STRING( &constant_bin[ 60500 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 6, const_str_plain_verify_result ); Py_INCREF( const_str_plain_verify_result );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 7, const_str_plain_md_ctx ); Py_INCREF( const_str_plain_md_ctx );
    const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 1, const_str_plain_revoked ); Py_INCREF( const_str_plain_revoked );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 2, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    const_str_plain_pyrev = UNSTREAM_STRING( &constant_bin[ 60513 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 3, const_str_plain_pyrev ); Py_INCREF( const_str_plain_pyrev );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 4, const_str_plain_results ); Py_INCREF( const_str_plain_results );
    const_str_plain_revoked_stack = UNSTREAM_STRING( &constant_bin[ 60518 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 5, const_str_plain_revoked_stack ); Py_INCREF( const_str_plain_revoked_stack );
    const_str_plain_revoked_copy = UNSTREAM_STRING( &constant_bin[ 60531 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 6, const_str_plain_revoked_copy ); Py_INCREF( const_str_plain_revoked_copy );
    const_str_digest_cf86a9123926465ab14a7bd2861326f6 = UNSTREAM_STRING( &constant_bin[ 60543 ], 571, 0 );
    const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple, 1, const_str_plain_rsa ); Py_INCREF( const_str_plain_rsa );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_11e1356f3459cf012eb88d7288e20e85 = UNSTREAM_STRING( &constant_bin[ 61114 ], 161, 0 );
    const_str_plain_get_elliptic_curves = UNSTREAM_STRING( &constant_bin[ 12489 ], 19, 1 );
    const_str_plain__text_type = UNSTREAM_STRING( &constant_bin[ 61275 ], 10, 1 );
    const_str_plain__friendlyname = UNSTREAM_STRING( &constant_bin[ 61285 ], 13, 1 );
    const_tuple_str_plain_self_str_plain_exceptionType_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_exceptionType_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_exceptionType = UNSTREAM_STRING( &constant_bin[ 61298 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_exceptionType_tuple, 1, const_str_plain_exceptionType ); Py_INCREF( const_str_plain_exceptionType );
    const_str_plain_RSA_print = UNSTREAM_STRING( &constant_bin[ 61311 ], 9, 1 );
    const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 1, const_str_plain_hex_str ); Py_INCREF( const_str_plain_hex_str );
    const_str_plain_bignum_serial = UNSTREAM_STRING( &constant_bin[ 61320 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 2, const_str_plain_bignum_serial ); Py_INCREF( const_str_plain_bignum_serial );
    const_str_plain_asn1_serial = UNSTREAM_STRING( &constant_bin[ 61333 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 3, const_str_plain_asn1_serial ); Py_INCREF( const_str_plain_asn1_serial );
    const_str_plain_bn_result = UNSTREAM_STRING( &constant_bin[ 61344 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 4, const_str_plain_bn_result ); Py_INCREF( const_str_plain_bn_result );
    PyTuple_SET_ITEM( const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 5, const_str_plain_bignum_ptr ); Py_INCREF( const_str_plain_bignum_ptr );
    const_str_plain_X509_subject_name_hash = UNSTREAM_STRING( &constant_bin[ 61353 ], 22, 1 );
    const_str_digest_68e309761e6d5dc5f5c1e53801284f3a = UNSTREAM_STRING( &constant_bin[ 61375 ], 55, 0 );
    const_str_plain_set_serial = UNSTREAM_STRING( &constant_bin[ 61430 ], 10, 1 );
    const_str_plain_X509_NAME_hash = UNSTREAM_STRING( &constant_bin[ 61440 ], 14, 1 );
    const_str_digest_1f7559cec53c5da336c35128000e1652 = UNSTREAM_STRING( &constant_bin[ 61454 ], 23, 0 );
    const_str_plain_Revoked = UNSTREAM_STRING( &constant_bin[ 61477 ], 7, 1 );
    const_str_digest_a12e23c82fcdd4004653da2260294f18 = UNSTREAM_STRING( &constant_bin[ 61484 ], 400, 0 );
    const_str_plain__curves = UNSTREAM_STRING( &constant_bin[ 12501 ], 7, 1 );
    const_str_plain_set_notBefore = UNSTREAM_STRING( &constant_bin[ 61884 ], 13, 1 );
    const_str_plain_from_cryptography_key = UNSTREAM_STRING( &constant_bin[ 61897 ], 21, 1 );
    const_str_digest_7db2dd03172a07cae912434bb4ced82e = UNSTREAM_STRING( &constant_bin[ 61918 ], 50, 0 );
    const_str_plain__cacerts = UNSTREAM_STRING( &constant_bin[ 61968 ], 8, 1 );
    const_str_plain_entry_index = UNSTREAM_STRING( &constant_bin[ 61976 ], 11, 1 );
    const_str_digest_80438074180d95b1a2291874613077b5 = UNSTREAM_STRING( &constant_bin[ 61987 ], 8, 0 );
    const_str_digest_40ce736ad6e52bc3df10a00233b89318 = UNSTREAM_STRING( &constant_bin[ 61995 ], 116, 0 );
    const_str_plain_sign_result = UNSTREAM_STRING( &constant_bin[ 62111 ], 11, 1 );
    const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_amount = UNSTREAM_STRING( &constant_bin[ 53064 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple, 1, const_str_plain_amount ); Py_INCREF( const_str_plain_amount );
    const_str_plain_notAfter = UNSTREAM_STRING( &constant_bin[ 62122 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple, 2, const_str_plain_notAfter ); Py_INCREF( const_str_plain_notAfter );
    const_tuple_str_plain_self_str_plain_spki_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_spki_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_spki_tuple, 1, const_str_plain_spki ); Py_INCREF( const_str_plain_spki );
    const_str_digest_141cd36b231fb1bf7caa692f86984b7e = UNSTREAM_STRING( &constant_bin[ 62130 ], 205, 0 );
    const_str_plain_NetscapeSPKI = UNSTREAM_STRING( &constant_bin[ 62335 ], 12, 1 );
    const_str_digest_866d2e2176ccb47ef7515cbc6c993151 = UNSTREAM_STRING( &constant_bin[ 62347 ], 468, 0 );
    const_str_digest_5e37d069c5e76ee6d50c7e91b7181934 = UNSTREAM_STRING( &constant_bin[ 62815 ], 232, 0 );
    const_str_plain_NETSCAPE_SPKI_get_pubkey = UNSTREAM_STRING( &constant_bin[ 63047 ], 24, 1 );
    const_str_plain_URI = UNSTREAM_STRING( &constant_bin[ 63071 ], 3, 1 );
    const_str_plain_octet_result = UNSTREAM_STRING( &constant_bin[ 63074 ], 12, 1 );
    const_str_plain_X509_CRL_sort = UNSTREAM_STRING( &constant_bin[ 63086 ], 13, 1 );
    const_str_digest_3910fdd1c3b683a0988d08f77454ce47 = UNSTREAM_STRING( &constant_bin[ 63099 ], 23, 0 );
    const_str_digest_463cb3c7dbe7753c6683d3195629dca3 = UNSTREAM_STRING( &constant_bin[ 63122 ], 54, 0 );
    const_tuple_str_digest_016ce3807ea72a262d921fa7d1804717_tuple = PyTuple_New( 1 );
    const_str_digest_016ce3807ea72a262d921fa7d1804717 = UNSTREAM_STRING( &constant_bin[ 63176 ], 10, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_016ce3807ea72a262d921fa7d1804717_tuple, 0, const_str_digest_016ce3807ea72a262d921fa7d1804717 ); Py_INCREF( const_str_digest_016ce3807ea72a262d921fa7d1804717 );
    const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple, 0, const_str_digest_80438074180d95b1a2291874613077b5 ); Py_INCREF( const_str_digest_80438074180d95b1a2291874613077b5 );
    const_str_plain_X509_NAME_add_entry_by_NID = UNSTREAM_STRING( &constant_bin[ 63186 ], 26, 1 );
    const_str_plain_get_ca_certificates = UNSTREAM_STRING( &constant_bin[ 63212 ], 19, 1 );
    const_str_plain_INHIBIT_MAP = UNSTREAM_STRING( &constant_bin[ 63231 ], 11, 1 );
    const_str_digest_a078d66f5fc281c4117a5e5c24749809 = UNSTREAM_STRING( &constant_bin[ 63242 ], 134, 0 );
    const_str_digest_1691c1bfd96a22cfc48aca410da45814 = UNSTREAM_STRING( &constant_bin[ 63376 ], 41, 0 );
    const_str_plain_set_time = UNSTREAM_STRING( &constant_bin[ 2650 ], 8, 1 );
    const_tuple_da33f491cad89fe7f4a10b4791a01172_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_da33f491cad89fe7f4a10b4791a01172_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_da33f491cad89fe7f4a10b4791a01172_tuple, 1, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_da33f491cad89fe7f4a10b4791a01172_tuple, 2, const_str_plain_cert_stack ); Py_INCREF( const_str_plain_cert_stack );
    PyTuple_SET_ITEM( const_tuple_da33f491cad89fe7f4a10b4791a01172_tuple, 3, const_str_plain_pycert ); Py_INCREF( const_str_plain_pycert );
    PyTuple_SET_ITEM( const_tuple_da33f491cad89fe7f4a10b4791a01172_tuple, 4, const_str_plain_ret ); Py_INCREF( const_str_plain_ret );
    PyTuple_SET_ITEM( const_tuple_da33f491cad89fe7f4a10b4791a01172_tuple, 5, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_da33f491cad89fe7f4a10b4791a01172_tuple, 6, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_74b73fd54833bfb6b761307c477c0a28 = UNSTREAM_STRING( &constant_bin[ 63417 ], 252, 0 );
    const_list_b8e29824b436479d358fd3771a611e70_list = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 63669 ], 600 );
    const_str_digest_ac089bdfaafc466d410fc6ffe7dfee50 = UNSTREAM_STRING( &constant_bin[ 64269 ], 191, 0 );
    const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple, 0, const_str_digest_c561652c58984ec0e9541542aa405594 ); Py_INCREF( const_str_digest_c561652c58984ec0e9541542aa405594 );
    PyTuple_SET_ITEM( const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple, 1, const_int_pos_512 ); Py_INCREF( const_int_pos_512 );
    const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple, 1, const_str_plain_when ); Py_INCREF( const_str_plain_when );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple, 2, const_str_plain_dt ); Py_INCREF( const_str_plain_dt );
    const_str_digest_3121be4a855650e38916196ca238bf2b = UNSTREAM_STRING( &constant_bin[ 64460 ], 403, 0 );
    const_str_digest_39641ea33feffed70915f1c391cc979e = UNSTREAM_STRING( &constant_bin[ 64863 ], 37, 0 );
    const_tuple_false_false_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_false_false_tuple, 0, Py_False ); Py_INCREF( Py_False );
    PyTuple_SET_ITEM( const_tuple_false_false_tuple, 1, Py_False ); Py_INCREF( Py_False );
    const_str_digest_2f350f536232587387680a9435c758f6 = UNSTREAM_STRING( &constant_bin[ 64900 ], 425, 0 );
    const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 3, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 4, const_str_plain_evp_pkey ); Py_INCREF( const_str_plain_evp_pkey );
    const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple, 1, const_str_plain__CertificateSigningRequest ); Py_INCREF( const_str_plain__CertificateSigningRequest );
    PyTuple_SET_ITEM( const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple, 2, const_str_plain_backend ); Py_INCREF( const_str_plain_backend );
    const_str_plain_get_type_name = UNSTREAM_STRING( &constant_bin[ 65325 ], 13, 1 );
    const_str_plain__cmp = UNSTREAM_STRING( &constant_bin[ 65338 ], 4, 1 );
    const_str_digest_d7980f3a0e05fb43bc9ed0fa0707a2f9 = UNSTREAM_STRING( &constant_bin[ 65342 ], 43, 0 );
    const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 0, const_str_plain___eq__ ); Py_INCREF( const_str_plain___eq__ );
    PyTuple_SET_ITEM( const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 1, const_str_plain___ne__ ); Py_INCREF( const_str_plain___ne__ );
    PyTuple_SET_ITEM( const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 2, const_str_plain___lt__ ); Py_INCREF( const_str_plain___lt__ );
    PyTuple_SET_ITEM( const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 3, const_str_plain___le__ ); Py_INCREF( const_str_plain___le__ );
    PyTuple_SET_ITEM( const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 4, const_str_plain___gt__ ); Py_INCREF( const_str_plain___gt__ );
    PyTuple_SET_ITEM( const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 5, const_str_plain___ge__ ); Py_INCREF( const_str_plain___ge__ );
    const_str_plain_new_reason_ext = UNSTREAM_STRING( &constant_bin[ 65385 ], 14, 1 );
    const_str_plain_X509_V_FLAG_CB_ISSUER_CHECK = UNSTREAM_STRING( &constant_bin[ 65399 ], 27, 1 );
    const_str_digest_7d6056c968d1eebfab898757e6f3054e = UNSTREAM_STRING( &constant_bin[ 65426 ], 120, 0 );
    const_str_digest_f583009b639aad56f3c96c175e595626 = UNSTREAM_STRING( &constant_bin[ 65546 ], 340, 0 );
    const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 2, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    PyTuple_SET_ITEM( const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 3, const_str_plain_sign_result ); Py_INCREF( const_str_plain_sign_result );
    PyTuple_SET_ITEM( const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 4, const_str_plain_evp_md ); Py_INCREF( const_str_plain_evp_md );
    const_str_plain__more_args = UNSTREAM_STRING( &constant_bin[ 65886 ], 10, 1 );
    const_str_plain_IGNORE_CRITICAL = UNSTREAM_STRING( &constant_bin[ 45023 ], 15, 1 );
    const_str_digest_a7eaace656db47cf2975484b27c818e9 = UNSTREAM_STRING( &constant_bin[ 65896 ], 165, 0 );
    const_str_plain__initialized = UNSTREAM_STRING( &constant_bin[ 66061 ], 12, 1 );
    const_str_plain_RSA_F4 = UNSTREAM_STRING( &constant_bin[ 66073 ], 6, 1 );
    const_str_plain__read_passphrase = UNSTREAM_STRING( &constant_bin[ 66079 ], 16, 1 );
    const_tuple_85794016896eca55eb5b3d7e4628b724_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_85794016896eca55eb5b3d7e4628b724_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_exts = UNSTREAM_STRING( &constant_bin[ 26621 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_85794016896eca55eb5b3d7e4628b724_tuple, 1, const_str_plain_exts ); Py_INCREF( const_str_plain_exts );
    PyTuple_SET_ITEM( const_tuple_85794016896eca55eb5b3d7e4628b724_tuple, 2, const_str_plain_extension ); Py_INCREF( const_str_plain_extension );
    PyTuple_SET_ITEM( const_tuple_85794016896eca55eb5b3d7e4628b724_tuple, 3, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_85794016896eca55eb5b3d7e4628b724_tuple, 4, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    PyTuple_SET_ITEM( const_tuple_85794016896eca55eb5b3d7e4628b724_tuple, 5, const_str_plain_native_exts_obj ); Py_INCREF( const_str_plain_native_exts_obj );
    const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple, 1, const_str_plain_message ); Py_INCREF( const_str_plain_message );
    const_str_plain_certificate = UNSTREAM_STRING( &constant_bin[ 657 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple, 2, const_str_plain_certificate ); Py_INCREF( const_str_plain_certificate );
    const_str_plain_maciter = UNSTREAM_STRING( &constant_bin[ 48264 ], 7, 1 );
    const_str_plain__set_name = UNSTREAM_STRING( &constant_bin[ 66095 ], 9, 1 );
    const_str_plain_dump_privatekey = UNSTREAM_STRING( &constant_bin[ 64017 ], 15, 1 );
    const_str_plain_set_ca_certificates = UNSTREAM_STRING( &constant_bin[ 66104 ], 19, 1 );
    const_str_digest_0b708bb28192f1a165c843c47343f35a = UNSTREAM_STRING( &constant_bin[ 66123 ], 151, 0 );
    const_str_digest_193e0ef9a8bffd6c41bf909f2da817bd = UNSTREAM_STRING( &constant_bin[ 66274 ], 283, 0 );
    const_str_digest_ffd290e8bf49a587d94041b1fd6c3c55 = UNSTREAM_STRING( &constant_bin[ 66557 ], 248, 0 );
    const_str_digest_ce96dba31c9fcf5052c236b4a8160f7f = UNSTREAM_STRING( &constant_bin[ 66805 ], 1160, 0 );
    const_str_plain_get_reason = UNSTREAM_STRING( &constant_bin[ 67965 ], 10, 1 );
    const_str_plain_answer = UNSTREAM_STRING( &constant_bin[ 67975 ], 6, 1 );
    const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_encoded = UNSTREAM_STRING( &constant_bin[ 1232 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple, 1, const_str_plain_encoded ); Py_INCREF( const_str_plain_encoded );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain__delete_reason = UNSTREAM_STRING( &constant_bin[ 67981 ], 14, 1 );
    const_str_digest_f3b04f8993b30e664e4afacb3d64cdc4 = UNSTREAM_STRING( &constant_bin[ 67995 ], 11, 0 );
    const_str_digest_2e4273bc9cbcc16bcfe5bca70ee1b585 = UNSTREAM_STRING( &constant_bin[ 68006 ], 233, 0 );
    const_str_plain_X509_REVOKED_delete_ext = UNSTREAM_STRING( &constant_bin[ 68239 ], 23, 1 );
    const_str_plain_dump_publickey = UNSTREAM_STRING( &constant_bin[ 63998 ], 14, 1 );
    const_str_plain_PKCS12 = UNSTREAM_STRING( &constant_bin[ 46994 ], 6, 1 );
    const_str_digest_fb60d21f52ae521da77e61851d566364 = UNSTREAM_STRING( &constant_bin[ 68262 ], 19, 0 );
    const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 1, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 2, const_str_plain_obj ); Py_INCREF( const_str_plain_obj );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 3, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    const_str_plain_get_extension = UNSTREAM_STRING( &constant_bin[ 55037 ], 13, 1 );
    const_str_digest_d0137950921f709b6c00a3276a078e5f = UNSTREAM_STRING( &constant_bin[ 68281 ], 463, 0 );
    const_str_digest_de1d9872d12371b2ead20f3aa79dc834 = UNSTREAM_STRING( &constant_bin[ 68744 ], 208, 0 );
    const_str_plain_x509req = UNSTREAM_STRING( &constant_bin[ 68952 ], 7, 1 );
    const_str_digest_685b3ded6e482839a3710e6a448d8669 = UNSTREAM_STRING( &constant_bin[ 68959 ], 287, 0 );
    const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9 = UNSTREAM_STRING( &constant_bin[ 69246 ], 12, 0 );
    const_str_plain_get_serial = UNSTREAM_STRING( &constant_bin[ 69258 ], 10, 1 );
    const_str_digest_9a71d9e6319c409dff859e67083fc41c = UNSTREAM_STRING( &constant_bin[ 69268 ], 563, 0 );
    const_str_digest_3a45faa244ca861d389c340b29a28988 = UNSTREAM_STRING( &constant_bin[ 69831 ], 45, 0 );
    const_tuple_str_plain_self_str_plain_cert_str_plain_res_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cert_str_plain_res_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cert_str_plain_res_tuple, 1, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cert_str_plain_res_tuple, 2, const_str_plain_res ); Py_INCREF( const_str_plain_res );
    const_str_plain_X509_STORE_free = UNSTREAM_STRING( &constant_bin[ 69876 ], 15, 1 );
    const_str_plain_hex_serial = UNSTREAM_STRING( &constant_bin[ 69891 ], 10, 1 );
    const_str_digest_f019d8c1ebbf58631ace92b4423b3aad = UNSTREAM_STRING( &constant_bin[ 69901 ], 51, 0 );
    const_str_plain_SSL_FILETYPE_PEM = UNSTREAM_STRING( &constant_bin[ 69952 ], 16, 1 );
    const_str_plain__X509NameInvalidator = UNSTREAM_STRING( &constant_bin[ 69968 ], 20, 1 );
    const_tuple_str_plain_b16encode_tuple = PyTuple_New( 1 );
    const_str_plain_b16encode = UNSTREAM_STRING( &constant_bin[ 69988 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_b16encode_tuple, 0, const_str_plain_b16encode ); Py_INCREF( const_str_plain_b16encode );
    const_str_plain_TYPE_DH = UNSTREAM_STRING( &constant_bin[ 69997 ], 7, 1 );
    const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 2, const_str_plain_cipher ); Py_INCREF( const_str_plain_cipher );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 3, const_str_plain_passphrase ); Py_INCREF( const_str_plain_passphrase );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 4, const_str_plain_helper ); Py_INCREF( const_str_plain_helper );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 5, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_str_plain_cipher_obj = UNSTREAM_STRING( &constant_bin[ 70004 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 6, const_str_plain_cipher_obj ); Py_INCREF( const_str_plain_cipher_obj );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 7, const_str_plain_rsa ); Py_INCREF( const_str_plain_rsa );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 8, const_str_plain_result_code ); Py_INCREF( const_str_plain_result_code );
    const_str_plain_PKCS7_type_is_signed = UNSTREAM_STRING( &constant_bin[ 70014 ], 20, 1 );
    const_str_plain_X509_V_FLAG_CRL_CHECK_ALL = UNSTREAM_STRING( &constant_bin[ 70034 ], 25, 1 );
    const_tuple_str_plain_dsa_str_plain_rsa_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dsa_str_plain_rsa_tuple, 0, const_str_plain_dsa ); Py_INCREF( const_str_plain_dsa );
    PyTuple_SET_ITEM( const_tuple_str_plain_dsa_str_plain_rsa_tuple, 1, const_str_plain_rsa ); Py_INCREF( const_str_plain_rsa );
    const_str_plain_PKCS7_type_is_signedAndEnveloped = UNSTREAM_STRING( &constant_bin[ 70059 ], 32, 1 );
    const_str_digest_f68048107421fed17c8f1bc19be3ec03 = UNSTREAM_STRING( &constant_bin[ 70091 ], 190, 0 );
    const_str_plain_X509_digest = UNSTREAM_STRING( &constant_bin[ 70281 ], 11, 1 );
    const_str_plain_OBJ_obj2nid = UNSTREAM_STRING( &constant_bin[ 70292 ], 11, 1 );
    const_str_digest_5997506aef8ffc5e12c453030416acc6 = UNSTREAM_STRING( &constant_bin[ 70303 ], 68, 0 );
    const_str_plain_X509_V_FLAG_X509_STRICT = UNSTREAM_STRING( &constant_bin[ 70371 ], 23, 1 );
    const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 1, const_str_plain_req ); Py_INCREF( const_str_plain_req );
    PyTuple_SET_ITEM( const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 3, const_str_plain_result_code ); Py_INCREF( const_str_plain_result_code );
    const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 1, const_str_plain_index ); Py_INCREF( const_str_plain_index );
    PyTuple_SET_ITEM( const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 2, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    PyTuple_SET_ITEM( const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 3, const_str_plain_extension ); Py_INCREF( const_str_plain_extension );
    const_str_digest_7b5d428ebb9708d902c18ce8ddfb3cbc = UNSTREAM_STRING( &constant_bin[ 70394 ], 17, 0 );
    const_str_plain_X509V3_set_ctx = UNSTREAM_STRING( &constant_bin[ 53640 ], 14, 1 );
    const_str_plain_load_locations = UNSTREAM_STRING( &constant_bin[ 70411 ], 14, 1 );
    const_str_digest_c71c443223c73b253b21961ef3bd7c9e = UNSTREAM_STRING( &constant_bin[ 70425 ], 645, 0 );
    const_str_digest_a643e6a1050d6f3782a0d190235d80a7 = UNSTREAM_STRING( &constant_bin[ 71070 ], 205, 0 );
    const_str_digest_35e2a27cee76091329550405e1cb7dc4 = UNSTREAM_STRING( &constant_bin[ 71275 ], 265, 0 );
    const_str_plain_NETSCAPE_SPKI_free = UNSTREAM_STRING( &constant_bin[ 71540 ], 18, 1 );
    const_str_plain_get_privatekey = UNSTREAM_STRING( &constant_bin[ 71558 ], 14, 1 );
    const_str_plain_X509_print_ex = UNSTREAM_STRING( &constant_bin[ 71572 ], 13, 1 );
    const_str_digest_b3f225987bb27e065a500d7fe8bd7c70 = UNSTREAM_STRING( &constant_bin[ 71585 ], 24, 0 );
    const_str_plain__extension = UNSTREAM_STRING( &constant_bin[ 47579 ], 10, 1 );
    const_str_digest_c0aedec8dc85440d3dace529a9d9050e = UNSTREAM_STRING( &constant_bin[ 71609 ], 349, 0 );
    const_str_plain_fval = UNSTREAM_STRING( &constant_bin[ 71958 ], 4, 1 );
    const_str_digest_5699814601a04aa972bd2f18de396c39 = UNSTREAM_STRING( &constant_bin[ 71962 ], 345, 0 );
    const_str_digest_48639cf22fbd4e6b3714265dae0dbed8 = UNSTREAM_STRING( &constant_bin[ 72307 ], 99, 0 );
    const_str_plain_string_data = UNSTREAM_STRING( &constant_bin[ 72406 ], 11, 1 );
    const_str_plain_NETSCAPE_SPKI_verify = UNSTREAM_STRING( &constant_bin[ 72417 ], 20, 1 );
    const_str_digest_d6b3262f79e4b59cd83ab54699c92117 = UNSTREAM_STRING( &constant_bin[ 72437 ], 231, 0 );
    const_str_digest_1a7a898c4490dd89b305492a40bf2633 = UNSTREAM_STRING( &constant_bin[ 72668 ], 217, 0 );
    const_str_plain_format_result = UNSTREAM_STRING( &constant_bin[ 72885 ], 13, 1 );
    const_str_plain_X509_STORE_CTX_init = UNSTREAM_STRING( &constant_bin[ 72898 ], 19, 1 );
    const_str_plain_dump_crl = UNSTREAM_STRING( &constant_bin[ 64212 ], 8, 1 );
    const_tuple_str_plain_self_str_plain_x509_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_x509_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_x509_tuple, 1, const_str_plain_x509 ); Py_INCREF( const_str_plain_x509 );
    const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple, 1, const_str_plain_key ); Py_INCREF( const_str_plain_key );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple, 2, const_str_plain_answer ); Py_INCREF( const_str_plain_answer );
    const_str_plain_X509_STORE_new = UNSTREAM_STRING( &constant_bin[ 72917 ], 14, 1 );
    const_str_digest_1548dadd592ed9bc13702fc15d573dfd = UNSTREAM_STRING( &constant_bin[ 72931 ], 83, 0 );
    const_str_plain_EVP_PKEY_bits = UNSTREAM_STRING( &constant_bin[ 73014 ], 13, 1 );
    const_str_plain_set_flags = UNSTREAM_STRING( &constant_bin[ 73027 ], 9, 1 );
    const_str_plain__store_ctx = UNSTREAM_STRING( &constant_bin[ 73036 ], 10, 1 );
    const_str_plain_X509V3_EXT_nconf = UNSTREAM_STRING( &constant_bin[ 73046 ], 16, 1 );
    const_str_plain_encode_result = UNSTREAM_STRING( &constant_bin[ 73062 ], 13, 1 );
    const_tuple_48ab3cdc7d6d88da8bc682675f6a64b7_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_48ab3cdc7d6d88da8bc682675f6a64b7_tuple, 0, const_str_plain_certificates ); Py_INCREF( const_str_plain_certificates );
    PyTuple_SET_ITEM( const_tuple_48ab3cdc7d6d88da8bc682675f6a64b7_tuple, 1, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_48ab3cdc7d6d88da8bc682675f6a64b7_tuple, 2, const_str_plain_cleanup ); Py_INCREF( const_str_plain_cleanup );
    PyTuple_SET_ITEM( const_tuple_48ab3cdc7d6d88da8bc682675f6a64b7_tuple, 3, const_str_plain_stack ); Py_INCREF( const_str_plain_stack );
    const_tuple_80a9571108770bd34772239ad97225a5_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_80a9571108770bd34772239ad97225a5_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_80a9571108770bd34772239ad97225a5_tuple, 1, const_str_plain_extensions ); Py_INCREF( const_str_plain_extensions );
    PyTuple_SET_ITEM( const_tuple_80a9571108770bd34772239ad97225a5_tuple, 2, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    PyTuple_SET_ITEM( const_tuple_80a9571108770bd34772239ad97225a5_tuple, 3, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    const_str_digest_213346f5e36f3faf7ff7a566deec4adb = UNSTREAM_STRING( &constant_bin[ 73075 ], 252, 0 );
    const_str_plain_set_nextUpdate = UNSTREAM_STRING( &constant_bin[ 73327 ], 14, 1 );
    const_str_plain_CRL = UNSTREAM_STRING( &constant_bin[ 45775 ], 3, 1 );
    const_str_plain_EVP_SignUpdate = UNSTREAM_STRING( &constant_bin[ 73341 ], 14, 1 );
    const_str_plain__cleanup = UNSTREAM_STRING( &constant_bin[ 47798 ], 8, 1 );
    const_str_plain__exception_from_context = UNSTREAM_STRING( &constant_bin[ 73355 ], 23, 1 );
    const_str_digest_6b975dcb77568b31c2312e045b6c638c = UNSTREAM_STRING( &constant_bin[ 73378 ], 35, 0 );
    const_str_plain__bio_to_string = UNSTREAM_STRING( &constant_bin[ 73413 ], 14, 1 );
    const_str_digest_cac81eaf46e08badbc89f13fa3bbdf6b = UNSTREAM_STRING( &constant_bin[ 73427 ], 477, 0 );
    const_tuple_str_plain_self_str_plain_crl_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_crl_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_crl_tuple, 1, const_str_plain_crl ); Py_INCREF( const_str_plain_crl );
    const_str_plain_X509_verify_cert = UNSTREAM_STRING( &constant_bin[ 43695 ], 16, 1 );
    const_str_plain__get_asn1_time = UNSTREAM_STRING( &constant_bin[ 73904 ], 14, 1 );
    const_str_digest_3f7d687efa133ae490fe62a28c3c2584 = UNSTREAM_STRING( &constant_bin[ 73918 ], 175, 0 );
    const_str_plain_X509_NAME_get_index_by_NID = UNSTREAM_STRING( &constant_bin[ 74093 ], 26, 1 );
    const_str_digest_e4c79524acf8a72de25c6c6491f370a8 = UNSTREAM_STRING( &constant_bin[ 74119 ], 294, 0 );
    const_str_plain_set_rev_date = UNSTREAM_STRING( &constant_bin[ 74413 ], 12, 1 );
    const_str_plain_set_notAfter = UNSTREAM_STRING( &constant_bin[ 74425 ], 12, 1 );
    const_tuple_str_plain__CertificateSigningRequest_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__CertificateSigningRequest_tuple, 0, const_str_plain__CertificateSigningRequest ); Py_INCREF( const_str_plain__CertificateSigningRequest );
    const_str_digest_719137938e890576c1050ba31a668078 = UNSTREAM_STRING( &constant_bin[ 74437 ], 205, 0 );
    const_str_digest_500f278b67471fc0f770fccc80d65d95 = UNSTREAM_STRING( &constant_bin[ 74642 ], 21, 0 );
    const_str_plain_notBefore = UNSTREAM_STRING( &constant_bin[ 53631 ], 9, 1 );
    const_str_digest_ab9563b0fc32f09cfde9a1636d8d2b80 = UNSTREAM_STRING( &constant_bin[ 74663 ], 181, 0 );
    const_str_digest_b6dd846b2ed8a994f97bac91e216f368 = UNSTREAM_STRING( &constant_bin[ 74844 ], 499, 0 );
    const_str_plain_X509Extension = UNSTREAM_STRING( &constant_bin[ 44365 ], 13, 1 );
    const_str_digest_6ef28169edd3cfe530885f6f9d09c390 = UNSTREAM_STRING( &constant_bin[ 75343 ], 267, 0 );
    const_str_plain_X509_V_FLAG_CHECK_SS_SIGNATURE = UNSTREAM_STRING( &constant_bin[ 75610 ], 30, 1 );
    const_str_plain_X509_VERIFY_PARAM_new = UNSTREAM_STRING( &constant_bin[ 75640 ], 21, 1 );
    const_str_digest_c237653198d1acecae3452511968b22e = UNSTREAM_STRING( &constant_bin[ 75661 ], 84, 0 );
    const_str_plain_type_is_signed = UNSTREAM_STRING( &constant_bin[ 70020 ], 14, 1 );
    const_str_digest_af63c2663b0a5e83daac69d308dcb1d6 = UNSTREAM_STRING( &constant_bin[ 75745 ], 158, 0 );
    const_str_plain_get_friendlyname = UNSTREAM_STRING( &constant_bin[ 75903 ], 16, 1 );
    const_str_plain_set_friendlyname = UNSTREAM_STRING( &constant_bin[ 75919 ], 16, 1 );
    const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 2, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    PyTuple_SET_ITEM( const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 3, const_str_plain_digest_obj ); Py_INCREF( const_str_plain_digest_obj );
    PyTuple_SET_ITEM( const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 4, const_str_plain_sign_result ); Py_INCREF( const_str_plain_sign_result );
    const_str_plain_load_publickey = UNSTREAM_STRING( &constant_bin[ 64095 ], 14, 1 );
    const_str_digest_713d8c2afef94db133cda1bff1cb496f = UNSTREAM_STRING( &constant_bin[ 75935 ], 33, 0 );
    const_str_plain_X509_STORE_load_locations = UNSTREAM_STRING( &constant_bin[ 75968 ], 25, 1 );
    const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 1, const_str_plain_passphrase ); Py_INCREF( const_str_plain_passphrase );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 2, const_str_plain_iter ); Py_INCREF( const_str_plain_iter );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 3, const_str_plain_maciter ); Py_INCREF( const_str_plain_maciter );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 4, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 5, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 6, const_str_plain_cacerts ); Py_INCREF( const_str_plain_cacerts );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 7, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 8, const_str_plain_friendlyname ); Py_INCREF( const_str_plain_friendlyname );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 9, const_str_plain_pkcs12 ); Py_INCREF( const_str_plain_pkcs12 );
    const_str_digest_1dbb147d3e039266688c4d87287eaaad = UNSTREAM_STRING( &constant_bin[ 75993 ], 14, 0 );
    const_str_digest_0d3c537bf958e2cc2494cf1be5c283dd = UNSTREAM_STRING( &constant_bin[ 76007 ], 320, 0 );
    const_tuple_53b63b794c8b8f328f3f365985abd328_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 3, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 4, const_str_plain_crl ); Py_INCREF( const_str_plain_crl );
    const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_X509_STORE_set_flags = UNSTREAM_STRING( &constant_bin[ 76327 ], 20, 1 );
    const_str_plain_get_elliptic_curve = UNSTREAM_STRING( &constant_bin[ 12432 ], 18, 1 );
    const_tuple_7e58e160edb2d3137d6df595cad17d36_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_7e58e160edb2d3137d6df595cad17d36_tuple, 0, const_str_plain_ffi ); Py_INCREF( const_str_plain_ffi );
    PyTuple_SET_ITEM( const_tuple_7e58e160edb2d3137d6df595cad17d36_tuple, 1, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    PyTuple_SET_ITEM( const_tuple_7e58e160edb2d3137d6df595cad17d36_tuple, 2, const_str_plain_exception_from_error_queue ); Py_INCREF( const_str_plain_exception_from_error_queue );
    PyTuple_SET_ITEM( const_tuple_7e58e160edb2d3137d6df595cad17d36_tuple, 3, const_str_plain_byte_string ); Py_INCREF( const_str_plain_byte_string );
    PyTuple_SET_ITEM( const_tuple_7e58e160edb2d3137d6df595cad17d36_tuple, 4, const_str_plain_native ); Py_INCREF( const_str_plain_native );
    PyTuple_SET_ITEM( const_tuple_7e58e160edb2d3137d6df595cad17d36_tuple, 5, const_str_plain_path_string ); Py_INCREF( const_str_plain_path_string );
    PyTuple_SET_ITEM( const_tuple_7e58e160edb2d3137d6df595cad17d36_tuple, 6, const_str_plain_UNSPECIFIED ); Py_INCREF( const_str_plain_UNSPECIFIED );
    PyTuple_SET_ITEM( const_tuple_7e58e160edb2d3137d6df595cad17d36_tuple, 7, const_str_plain_text_to_bytes_and_warn ); Py_INCREF( const_str_plain_text_to_bytes_and_warn );
    PyTuple_SET_ITEM( const_tuple_7e58e160edb2d3137d6df595cad17d36_tuple, 8, const_str_plain_make_assert ); Py_INCREF( const_str_plain_make_assert );
    const_str_digest_4097a084fab55cf5c5baa1b785e7c82a = UNSTREAM_STRING( &constant_bin[ 76347 ], 257, 0 );
    const_str_plain_add_crl = UNSTREAM_STRING( &constant_bin[ 76604 ], 7, 1 );
    const_str_plain_get_extensions = UNSTREAM_STRING( &constant_bin[ 76611 ], 14, 1 );
    const_str_digest_92b8d1a7fa93b4e7d2fab02e37bc15f8 = UNSTREAM_STRING( &constant_bin[ 76625 ], 159, 0 );
    const_str_plain_get_notAfter = UNSTREAM_STRING( &constant_bin[ 76784 ], 12, 1 );
    const_str_plain__set_boundary_time = UNSTREAM_STRING( &constant_bin[ 76796 ], 18, 1 );
    const_str_digest_1a3a564060f5ebd53d44f6035495ba48 = UNSTREAM_STRING( &constant_bin[ 76814 ], 17, 0 );
    const_str_plain_get_issuer = UNSTREAM_STRING( &constant_bin[ 76831 ], 10, 1 );
    const_str_plain_X509_STORE_set1_param = UNSTREAM_STRING( &constant_bin[ 76841 ], 21, 1 );
    const_str_plain_CB_ISSUER_CHECK = UNSTREAM_STRING( &constant_bin[ 65411 ], 15, 1 );
    const_str_plain__issuer_invalidator = UNSTREAM_STRING( &constant_bin[ 76862 ], 19, 1 );
    const_str_plain_get_serial_number = UNSTREAM_STRING( &constant_bin[ 76881 ], 17, 1 );
    const_str_plain__PY2 = UNSTREAM_STRING( &constant_bin[ 76898 ], 4, 1 );
    const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple, 1, const_str_plain_string_type ); Py_INCREF( const_str_plain_string_type );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple, 2, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple, 1, const_str_plain_x509 ); Py_INCREF( const_str_plain_x509 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple, 2, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    const_str_digest_221848055f0a545c7ef1969a37bb78a5 = UNSTREAM_STRING( &constant_bin[ 76902 ], 10, 0 );
    const_str_plain_EC_get_builtin_curves = UNSTREAM_STRING( &constant_bin[ 76912 ], 21, 1 );
    const_str_plain_set_certificate = UNSTREAM_STRING( &constant_bin[ 76933 ], 15, 1 );
    const_str_digest_0226e12d6e09b849c37787a1a7ec35a4 = UNSTREAM_STRING( &constant_bin[ 76948 ], 27, 0 );
    const_str_plain_set_serial_number = UNSTREAM_STRING( &constant_bin[ 76975 ], 17, 1 );
    const_str_digest_bbde1e297eda38e770b8fce1d06c225b = UNSTREAM_STRING( &constant_bin[ 76992 ], 43, 0 );
    const_str_digest_3b5fd85224219fd172d589ec8f98a12a = UNSTREAM_STRING( &constant_bin[ 77035 ], 124, 0 );
    const_tuple_8110525d9a52cec647809d72afbc7239_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    PyTuple_SET_ITEM( const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 1, const_str_plain_c ); Py_INCREF( const_str_plain_c );
    PyTuple_SET_ITEM( const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 2, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    PyTuple_SET_ITEM( const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 3, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_digest_4560cdf69c017b7cd264323295e708cb = UNSTREAM_STRING( &constant_bin[ 77159 ], 28, 0 );
    const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 1, const_str_plain_serial ); Py_INCREF( const_str_plain_serial );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 2, const_str_plain_asn1_serial ); Py_INCREF( const_str_plain_asn1_serial );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 3, const_str_plain_bignum_serial ); Py_INCREF( const_str_plain_bignum_serial );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 4, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_str_plain_small_serial = UNSTREAM_STRING( &constant_bin[ 77187 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 5, const_str_plain_small_serial ); Py_INCREF( const_str_plain_small_serial );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 6, const_str_plain_hex_serial ); Py_INCREF( const_str_plain_hex_serial );
    const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 1, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 3, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 4, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 5, const_str_plain_fval ); Py_INCREF( const_str_plain_fval );
    const_str_plain_ent = UNSTREAM_STRING( &constant_bin[ 691 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 6, const_str_plain_ent ); Py_INCREF( const_str_plain_ent );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 7, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 8, const_str_plain_fname ); Py_INCREF( const_str_plain_fname );
    const_str_digest_75a631b53fc267af68d162051a06411c = UNSTREAM_STRING( &constant_bin[ 77199 ], 414, 0 );
    const_str_plain_PKCS7_type_is_enveloped = UNSTREAM_STRING( &constant_bin[ 77613 ], 23, 1 );
    const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 2, const_str_plain_result_buffer ); Py_INCREF( const_str_plain_result_buffer );
    const_str_plain_data_length = UNSTREAM_STRING( &constant_bin[ 5450 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 3, const_str_plain_data_length ); Py_INCREF( const_str_plain_data_length );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 4, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 5, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 6, const_str_plain_entry_index ); Py_INCREF( const_str_plain_entry_index );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 7, const_str_plain_entry ); Py_INCREF( const_str_plain_entry );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 8, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    const_str_digest_c85d62bfc2af2f3c2202464fd6374ea7 = UNSTREAM_STRING( &constant_bin[ 77636 ], 20, 0 );
    const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_issuer_cert = UNSTREAM_STRING( &constant_bin[ 60940 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 1, const_str_plain_issuer_cert ); Py_INCREF( const_str_plain_issuer_cert );
    PyTuple_SET_ITEM( const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 2, const_str_plain_issuer_key ); Py_INCREF( const_str_plain_issuer_key );
    PyTuple_SET_ITEM( const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 3, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    PyTuple_SET_ITEM( const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 4, const_str_plain_digest_obj ); Py_INCREF( const_str_plain_digest_obj );
    PyTuple_SET_ITEM( const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 5, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_721230a42e287d5632d061ff8f0376d6 = UNSTREAM_STRING( &constant_bin[ 77656 ], 259, 0 );
    const_str_plain_digest_name = UNSTREAM_STRING( &constant_bin[ 56094 ], 11, 1 );
    const_str_digest_0b9d4db9119537682a1f5302a9cbcc57 = UNSTREAM_STRING( &constant_bin[ 77915 ], 321, 0 );
    const_tuple_str_plain_self_str_plain_store_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_store_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_store_tuple, 1, const_str_plain_store ); Py_INCREF( const_str_plain_store );
    const_str_plain_PKCS7_free = UNSTREAM_STRING( &constant_bin[ 78236 ], 10, 1 );
    const_str_digest_1d1fec7c0642196df296efbe43db1801 = UNSTREAM_STRING( &constant_bin[ 78246 ], 722, 0 );
    const_str_plain_TYPE_EC = UNSTREAM_STRING( &constant_bin[ 78968 ], 7, 1 );
    const_str_plain_rwflag = UNSTREAM_STRING( &constant_bin[ 78975 ], 6, 1 );
    const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 3, const_str_plain_x509 ); Py_INCREF( const_str_plain_x509 );
    const_tuple_str_digest_4560cdf69c017b7cd264323295e708cb_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_4560cdf69c017b7cd264323295e708cb_tuple, 0, const_str_digest_4560cdf69c017b7cd264323295e708cb ); Py_INCREF( const_str_digest_4560cdf69c017b7cd264323295e708cb );
    const_str_digest_d85051204198165c5d51e35c1e5d5077 = UNSTREAM_STRING( &constant_bin[ 78981 ], 214, 0 );
    const_str_digest_a2b9bb33a11d02b696dfc736bf45c56d = UNSTREAM_STRING( &constant_bin[ 79195 ], 290, 0 );
    const_str_plain_TYPE_DSA = UNSTREAM_STRING( &constant_bin[ 63745 ], 8, 1 );
    const_str_plain_M_ASN1_OCTET_STRING_print = UNSTREAM_STRING( &constant_bin[ 79485 ], 25, 1 );
    const_str_digest_07697dd6fa4854473fa24b52569d5636 = UNSTREAM_STRING( &constant_bin[ 79510 ], 139, 0 );
    const_str_plain_has_expired = UNSTREAM_STRING( &constant_bin[ 79649 ], 11, 1 );
    const_str_plain__EllipticCurve = UNSTREAM_STRING( &constant_bin[ 79660 ], 14, 1 );
    const_str_digest_007f81c06fa49e709fd9306cc6c26627 = UNSTREAM_STRING( &constant_bin[ 79674 ], 189, 0 );
    const_str_digest_7a5005a2e44b5258634f5b2837cd8b81 = UNSTREAM_STRING( &constant_bin[ 79863 ], 29, 0 );
    const_str_plain_X509_STORE_add_cert = UNSTREAM_STRING( &constant_bin[ 79892 ], 19, 1 );
    const_str_plain_X509_STORE_CTX_new = UNSTREAM_STRING( &constant_bin[ 79911 ], 18, 1 );
    const_str_plain_digest_result = UNSTREAM_STRING( &constant_bin[ 79929 ], 13, 1 );
    const_str_plain_BN_new = UNSTREAM_STRING( &constant_bin[ 79942 ], 6, 1 );
    const_tuple_str_plain__CertificateRevocationList_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__CertificateRevocationList_tuple, 0, const_str_plain__CertificateRevocationList ); Py_INCREF( const_str_plain__CertificateRevocationList );
    const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple, 1, const_str_plain__issuer ); Py_INCREF( const_str_plain__issuer );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple, 2, const_str_plain_issuer ); Py_INCREF( const_str_plain_issuer );
    const_str_digest_9c28b2ef32679900c21c54152be8ce03 = UNSTREAM_STRING( &constant_bin[ 79948 ], 226, 0 );
    const_str_plain_get_critical = UNSTREAM_STRING( &constant_bin[ 80174 ], 12, 1 );
    const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple, 1, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple, 2, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    const_tuple_2a726d59ade46c77b6bfd95ed66c5a12_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_2a726d59ade46c77b6bfd95ed66c5a12_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_2a726d59ade46c77b6bfd95ed66c5a12_tuple, 1, const_str_plain_store ); Py_INCREF( const_str_plain_store );
    PyTuple_SET_ITEM( const_tuple_2a726d59ade46c77b6bfd95ed66c5a12_tuple, 2, const_str_plain_certificate ); Py_INCREF( const_str_plain_certificate );
    PyTuple_SET_ITEM( const_tuple_2a726d59ade46c77b6bfd95ed66c5a12_tuple, 3, const_str_plain_chain ); Py_INCREF( const_str_plain_chain );
    PyTuple_SET_ITEM( const_tuple_2a726d59ade46c77b6bfd95ed66c5a12_tuple, 4, const_str_plain_store_ctx ); Py_INCREF( const_str_plain_store_ctx );
    const_str_plain__req = UNSTREAM_STRING( &constant_bin[ 5612 ], 4, 1 );
    const_str_plain__prefixes = UNSTREAM_STRING( &constant_bin[ 80186 ], 9, 1 );
    const_tuple_5209455ecbb28249752027c3a839ae1c_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 1, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 2, const_str_plain_size ); Py_INCREF( const_str_plain_size );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 3, const_str_plain_rwflag ); Py_INCREF( const_str_plain_rwflag );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 4, const_str_plain_userdata ); Py_INCREF( const_str_plain_userdata );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 5, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 6, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 7, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_gmtime_adj_notAfter = UNSTREAM_STRING( &constant_bin[ 80195 ], 19, 1 );
    const_tuple_str_plain_self_str_plain_req_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_req_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_req_tuple, 1, const_str_plain_req ); Py_INCREF( const_str_plain_req );
    const_str_plain_PEM_write_bio_PrivateKey = UNSTREAM_STRING( &constant_bin[ 80214 ], 24, 1 );
    const_str_plain_PEM_read_bio_PKCS7 = UNSTREAM_STRING( &constant_bin[ 80238 ], 18, 1 );
    const_str_digest_6674ab14e1178de501dfb968278a50b9 = UNSTREAM_STRING( &constant_bin[ 53290 ], 21, 0 );
    const_tuple_str_plain_self_str_plain_which_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_tuple, 1, const_str_plain_which ); Py_INCREF( const_str_plain_which );
    const_str_digest_0ba82c04a076f46925a74539c2a8ba40 = UNSTREAM_STRING( &constant_bin[ 80256 ], 459, 0 );
    const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple, 1, const_str_plain_amount ); Py_INCREF( const_str_plain_amount );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple, 2, const_str_plain_notBefore ); Py_INCREF( const_str_plain_notBefore );
    const_str_plain_to_cryptography_key = UNSTREAM_STRING( &constant_bin[ 80715 ], 19, 1 );
    const_str_digest_97388c7ddfea4f913fec5c846dd26ef1 = UNSTREAM_STRING( &constant_bin[ 80734 ], 279, 0 );
    const_tuple_79603f0465bd62773d6ec6c98e743896_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 1, const_str_plain_reason ); Py_INCREF( const_str_plain_reason );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 2, const_str_plain_reason_code ); Py_INCREF( const_str_plain_reason_code );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 3, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 4, const_str_plain_r ); Py_INCREF( const_str_plain_r );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 5, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 6, const_str_plain_new_reason_ext ); Py_INCREF( const_str_plain_new_reason_ext );
    const_str_plain_NETSCAPE_SPKI_sign = UNSTREAM_STRING( &constant_bin[ 81013 ], 18, 1 );
    const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple, 1, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple, 2, const_str_plain_print_result ); Py_INCREF( const_str_plain_print_result );
    const_str_digest_61d70cefdce1472400ab8a06d64ef78a = UNSTREAM_STRING( &constant_bin[ 81031 ], 142, 0 );
    const_str_plain_load_privatekey = UNSTREAM_STRING( &constant_bin[ 64114 ], 15, 1 );
    const_tuple_str_digest_f3b04f8993b30e664e4afacb3d64cdc4_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_f3b04f8993b30e664e4afacb3d64cdc4_tuple, 0, const_str_digest_f3b04f8993b30e664e4afacb3d64cdc4 ); Py_INCREF( const_str_digest_f3b04f8993b30e664e4afacb3d64cdc4 );
    const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple, 1, const_str_plain_crypto_req ); Py_INCREF( const_str_plain_crypto_req );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple, 2, const_str_plain_req ); Py_INCREF( const_str_plain_req );
    const_str_digest_e19f4eaf61167e65441aca909fe75b36 = UNSTREAM_STRING( &constant_bin[ 81173 ], 23, 0 );
    const_str_plain_MBSTRING_UTF8 = UNSTREAM_STRING( &constant_bin[ 81196 ], 13, 1 );
    const_str_plain_hexstring_serial = UNSTREAM_STRING( &constant_bin[ 81209 ], 16, 1 );
    const_str_plain__only_public = UNSTREAM_STRING( &constant_bin[ 81225 ], 12, 1 );
    const_tuple_str_plain_self_str_plain_dt_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dt_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dt_tuple, 1, const_str_plain_dt ); Py_INCREF( const_str_plain_dt );
    const_str_digest_1dad1cec7e14813a999c9dcf96c8f89f = UNSTREAM_STRING( &constant_bin[ 81237 ], 921, 0 );
    const_str_plain_GENERAL_NAME_print = UNSTREAM_STRING( &constant_bin[ 82158 ], 18, 1 );
    const_str_plain__names = UNSTREAM_STRING( &constant_bin[ 1132 ], 6, 1 );
    const_str_digest_c57795fb6a9ac3d47e928f9a8b608571 = UNSTREAM_STRING( &constant_bin[ 82176 ], 43, 0 );
    const_str_plain_CACompromise = UNSTREAM_STRING( &constant_bin[ 82219 ], 12, 1 );
    const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple, 1, const_str_plain_vfy_time ); Py_INCREF( const_str_plain_vfy_time );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple, 2, const_str_plain_param ); Py_INCREF( const_str_plain_param );
    const_str_plain_set_reason = UNSTREAM_STRING( &constant_bin[ 82231 ], 10, 1 );
    const_str_plain_add_extensions = UNSTREAM_STRING( &constant_bin[ 82241 ], 14, 1 );
    const_str_plain_EVP_VerifyInit = UNSTREAM_STRING( &constant_bin[ 82255 ], 14, 1 );
    const_str_digest_880f67f2b28115a7ad1d1bfb533fc6bc = UNSTREAM_STRING( &constant_bin[ 82269 ], 313, 0 );
    const_str_plain_NID_crl_reason = UNSTREAM_STRING( &constant_bin[ 82582 ], 14, 1 );
    const_str_plain_ent_obj = UNSTREAM_STRING( &constant_bin[ 82596 ], 7, 1 );
    const_str_plain_X509StoreContextError = UNSTREAM_STRING( &constant_bin[ 59752 ], 21, 1 );
    const_str_digest_b2d5bbfa3f949ddcc231b89e71aa8d92 = UNSTREAM_STRING( &constant_bin[ 82603 ], 181, 0 );
    const_tuple_str_plain_name_str_plain_curve_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_name_str_plain_curve_tuple, 0, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_str_plain_name_str_plain_curve_tuple, 1, const_str_plain_curve ); Py_INCREF( const_str_plain_curve );
    const_str_plain_X509_V_FLAG_INHIBIT_MAP = UNSTREAM_STRING( &constant_bin[ 82784 ], 23, 1 );
    const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_plain_crypto_key = UNSTREAM_STRING( &constant_bin[ 45579 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple, 1, const_str_plain_crypto_key ); Py_INCREF( const_str_plain_crypto_key );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple, 2, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 0, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 1, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 2, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 3, const_str_plain_free ); Py_INCREF( const_str_plain_free );
    const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 2, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_str_plain__owner = UNSTREAM_STRING( &constant_bin[ 82807 ], 6, 1 );
    const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 3, const_str_plain_req ); Py_INCREF( const_str_plain_req );
    PyTuple_SET_ITEM( const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 4, const_str_plain_x509req ); Py_INCREF( const_str_plain_x509req );
    const_str_plain_ASN1_STRING_data = UNSTREAM_STRING( &constant_bin[ 82813 ], 16, 1 );
    const_str_digest_819566a56c114d5ab553db6b3a965184 = UNSTREAM_STRING( &constant_bin[ 82829 ], 18, 0 );
    const_str_plain_sk_X509_new_null = UNSTREAM_STRING( &constant_bin[ 82847 ], 16, 1 );
    const_str_plain_ASN1_STRING_length = UNSTREAM_STRING( &constant_bin[ 82863 ], 18, 1 );
    const_str_plain__subject_invalidator = UNSTREAM_STRING( &constant_bin[ 82881 ], 20, 1 );
    const_str_plain_type_is_signedAndEnveloped = UNSTREAM_STRING( &constant_bin[ 70065 ], 26, 1 );
    const_str_plain_X509_NAME_oneline = UNSTREAM_STRING( &constant_bin[ 82901 ], 17, 1 );
    const_str_plain_hash = UNSTREAM_STRING( &constant_bin[ 20333 ], 4, 1 );
    const_str_digest_c623dd0c947983ab2cfcbe4c53400720 = UNSTREAM_STRING( &constant_bin[ 82918 ], 14, 0 );
    const_str_plain_EVP_PKEY_type = UNSTREAM_STRING( &constant_bin[ 82932 ], 13, 1 );
    const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 1, const_str_plain_char_result ); Py_INCREF( const_str_plain_char_result );
    PyTuple_SET_ITEM( const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 2, const_str_plain_octet_result ); Py_INCREF( const_str_plain_octet_result );
    PyTuple_SET_ITEM( const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 3, const_str_plain_string_result ); Py_INCREF( const_str_plain_string_result );
    const_str_plain_result_length = UNSTREAM_STRING( &constant_bin[ 82945 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 4, const_str_plain_result_length ); Py_INCREF( const_str_plain_result_length );
    const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 1, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 3, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 4, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 5, const_str_plain_label ); Py_INCREF( const_str_plain_label );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 6, const_str_plain_parts ); Py_INCREF( const_str_plain_parts );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 7, const_str_plain_names ); Py_INCREF( const_str_plain_names );
    const_str_digest_f76c1a90d81cc9627b0b6df42991dbc9 = UNSTREAM_STRING( &constant_bin[ 82958 ], 393, 0 );
    const_str_plain_gmtime_adj_notBefore = UNSTREAM_STRING( &constant_bin[ 83351 ], 20, 1 );
    const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 1, const_str_plain_which ); Py_INCREF( const_str_plain_which );
    PyTuple_SET_ITEM( const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 3, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_str_digest_c4a5d29f3ecd810d59e3d04a7a935f38 = UNSTREAM_STRING( &constant_bin[ 83371 ], 197, 0 );
    const_str_digest_79dac080796da8f8fc9c66ebe460ce2f = UNSTREAM_STRING( &constant_bin[ 83568 ], 29, 0 );
    const_str_digest_0d8911e895179dcd467b4e9de2f411d4 = UNSTREAM_STRING( &constant_bin[ 83597 ], 250, 0 );
    const_str_plain__load_elliptic_curves = UNSTREAM_STRING( &constant_bin[ 83847 ], 21, 1 );
    const_str_plain__get_boundary_time = UNSTREAM_STRING( &constant_bin[ 83868 ], 18, 1 );
    const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 1, const_str_plain_result_buffer ); Py_INCREF( const_str_plain_result_buffer );
    PyTuple_SET_ITEM( const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 2, const_str_plain_string_result ); Py_INCREF( const_str_plain_string_result );
    PyTuple_SET_ITEM( const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 3, const_str_plain_encode_result ); Py_INCREF( const_str_plain_encode_result );
    const_tuple_str_plain_ASN1_TIME_to_generalizedtime_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ASN1_TIME_to_generalizedtime_tuple, 0, const_str_plain_ASN1_TIME_to_generalizedtime ); Py_INCREF( const_str_plain_ASN1_TIME_to_generalizedtime );
    const_str_plain_pem_password_cb = UNSTREAM_STRING( &constant_bin[ 83886 ], 15, 1 );
    const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 1, const_str_plain_bignum_serial ); Py_INCREF( const_str_plain_bignum_serial );
    PyTuple_SET_ITEM( const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 2, const_str_plain_hexstring_serial ); Py_INCREF( const_str_plain_hexstring_serial );
    PyTuple_SET_ITEM( const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 3, const_str_plain_asn1_serial ); Py_INCREF( const_str_plain_asn1_serial );
    PyTuple_SET_ITEM( const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 4, const_str_plain_hex_serial ); Py_INCREF( const_str_plain_hex_serial );
    PyTuple_SET_ITEM( const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 5, const_str_plain_serial ); Py_INCREF( const_str_plain_serial );
    const_str_digest_4a193fbd1ccf06765e0cb44620b7d74a = UNSTREAM_STRING( &constant_bin[ 83901 ], 346, 0 );
    const_str_plain_X509_STORE_add_crl = UNSTREAM_STRING( &constant_bin[ 84247 ], 18, 1 );
    const_str_plain_PKCS7 = UNSTREAM_STRING( &constant_bin[ 43902 ], 5, 1 );
    const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_plain_crypto_crl = UNSTREAM_STRING( &constant_bin[ 58199 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple, 1, const_str_plain_crypto_crl ); Py_INCREF( const_str_plain_crypto_crl );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple, 2, const_str_plain_crl ); Py_INCREF( const_str_plain_crl );
    const_str_plain_X509_STORE_CTX_free = UNSTREAM_STRING( &constant_bin[ 84265 ], 19, 1 );
    const_str_digest_c47cfcedcc7803c0a6ef28b85213e16f = UNSTREAM_STRING( &constant_bin[ 84284 ], 152, 0 );
    const_str_plain_X509_V_FLAG_CRL_CHECK = UNSTREAM_STRING( &constant_bin[ 70034 ], 21, 1 );
    const_str_plain_X509_get0_tbs_sigalg = UNSTREAM_STRING( &constant_bin[ 84436 ], 20, 1 );
    const_tuple_d959e8503cbe0fd15122162c0da60661_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 0, const_str_plain_timestamp ); Py_INCREF( const_str_plain_timestamp );
    PyTuple_SET_ITEM( const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 1, const_str_plain_generalized_timestamp ); Py_INCREF( const_str_plain_generalized_timestamp );
    PyTuple_SET_ITEM( const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 2, const_str_plain_string_result ); Py_INCREF( const_str_plain_string_result );
    PyTuple_SET_ITEM( const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 3, const_str_plain_string_data ); Py_INCREF( const_str_plain_string_data );
    PyTuple_SET_ITEM( const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 4, const_str_plain_string_timestamp ); Py_INCREF( const_str_plain_string_timestamp );
    const_str_plain__byte_string = UNSTREAM_STRING( &constant_bin[ 84456 ], 12, 1 );
    const_str_plain_X509_alias_get0 = UNSTREAM_STRING( &constant_bin[ 84468 ], 15, 1 );
    const_str_digest_517da8fff62752bad266dd317b6fd3d1 = UNSTREAM_STRING( &constant_bin[ 84483 ], 14, 0 );
    const_str_plain_X509_NAME_cmp = UNSTREAM_STRING( &constant_bin[ 84497 ], 13, 1 );
    const_str_plain__integer_types = UNSTREAM_STRING( &constant_bin[ 84510 ], 14, 1 );
    const_str_plain_EXPLICIT_POLICY = UNSTREAM_STRING( &constant_bin[ 60358 ], 15, 1 );
    const_str_plain_set_issuer = UNSTREAM_STRING( &constant_bin[ 84524 ], 10, 1 );
    const_str_plain_ASN1_INTEGER_set = UNSTREAM_STRING( &constant_bin[ 84534 ], 16, 1 );
    const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple, 1, const_str_plain_result_buffer ); Py_INCREF( const_str_plain_result_buffer );
    PyTuple_SET_ITEM( const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple, 2, const_str_plain_format_result ); Py_INCREF( const_str_plain_format_result );
    const_str_digest_2dbcbe3e7da77178b4a9da40244d072a = UNSTREAM_STRING( &constant_bin[ 84550 ], 26, 0 );
    const_list_298f4a46a008df82aecc87d37443e76b_list = PyList_New( 7 );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 0, const_str_plain_unspecified ); Py_INCREF( const_str_plain_unspecified );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 1, const_str_plain_keyCompromise ); Py_INCREF( const_str_plain_keyCompromise );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 2, const_str_plain_CACompromise ); Py_INCREF( const_str_plain_CACompromise );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 3, const_str_plain_affiliationChanged ); Py_INCREF( const_str_plain_affiliationChanged );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 4, const_str_plain_superseded ); Py_INCREF( const_str_plain_superseded );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 5, const_str_plain_cessationOfOperation ); Py_INCREF( const_str_plain_cessationOfOperation );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 6, const_str_plain_certificateHold ); Py_INCREF( const_str_plain_certificateHold );
    const_str_digest_0d925750cb36e0c0e5f47f40c47790e6 = UNSTREAM_STRING( &constant_bin[ 84576 ], 22, 0 );
    const_str_plain_type_is_data = UNSTREAM_STRING( &constant_bin[ 46007 ], 12, 1 );
    const_str_digest_66b2a3b8e35254752e96fbbddc255dfd = UNSTREAM_STRING( &constant_bin[ 84598 ], 174, 0 );
    const_str_digest_998fe297d663eb0475d60a56d2b84182 = UNSTREAM_STRING( &constant_bin[ 84772 ], 447, 0 );
    const_str_digest_859c7c43c5cf3124cdd58374d6e7359e = UNSTREAM_STRING( &constant_bin[ 85219 ], 79, 0 );
    const_str_plain_BN_set_word = UNSTREAM_STRING( &constant_bin[ 85298 ], 11, 1 );
    const_str_digest_3c820c2fc1d76f73132dab0e4e8d3a14 = UNSTREAM_STRING( &constant_bin[ 85309 ], 32, 0 );
    const_str_digest_bb334a0dc943b8e820be149d2c515af0 = UNSTREAM_STRING( &constant_bin[ 85341 ], 19, 0 );
    const_tuple_57dca116533b0d6d636b268e7001e41b_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 1, const_str_plain_digest_name ); Py_INCREF( const_str_plain_digest_name );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 2, const_str_plain_digest_result ); Py_INCREF( const_str_plain_digest_result );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 3, const_str_plain_ch ); Py_INCREF( const_str_plain_ch );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 4, const_str_plain_result_length ); Py_INCREF( const_str_plain_result_length );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 5, const_str_plain_result_buffer ); Py_INCREF( const_str_plain_result_buffer );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 6, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    const_str_plain__get_backend = UNSTREAM_STRING( &constant_bin[ 59615 ], 12, 1 );
    const_str_plain_X509StoreFlags = UNSTREAM_STRING( &constant_bin[ 63876 ], 14, 1 );
    const_str_digest_6b664ec0d0974a050be8b09b84bd0a5d = UNSTREAM_STRING( &constant_bin[ 85360 ], 177, 0 );
    const_str_digest_4b3673d04a6e4a628e29457d54d43c0d = UNSTREAM_STRING( &constant_bin[ 85537 ], 29, 0 );
    const_str_plain__untested_error = UNSTREAM_STRING( &constant_bin[ 85566 ], 15, 1 );
    const_str_plain_V_ASN1_GENERALIZEDTIME = UNSTREAM_STRING( &constant_bin[ 85581 ], 22, 1 );
    const_str_plain_get_revoked = UNSTREAM_STRING( &constant_bin[ 85603 ], 11, 1 );
    const_str_plain_dump_certificate_request = UNSTREAM_STRING( &constant_bin[ 64134 ], 24, 1 );
    const_str_plain_X509_gmtime_adj = UNSTREAM_STRING( &constant_bin[ 85614 ], 15, 1 );
    const_str_plain_NETSCAPE_SPKI_set_pubkey = UNSTREAM_STRING( &constant_bin[ 85629 ], 24, 1 );
    const_str_digest_6b6b180b644052fa34c3e81151f6ea0a = UNSTREAM_STRING( &constant_bin[ 85653 ], 40, 0 );
    const_str_digest_b1f5a355e1403668d0044e1a65ec29ce = UNSTREAM_STRING( &constant_bin[ 85693 ], 25, 0 );
    const_str_plain_load_pkcs12 = UNSTREAM_STRING( &constant_bin[ 64258 ], 11, 1 );
    const_str_plain_X509_VERIFY_PARAM_set_time = UNSTREAM_STRING( &constant_bin[ 85718 ], 26, 1 );
    const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 1, const_str_plain_revoked ); Py_INCREF( const_str_plain_revoked );
    PyTuple_SET_ITEM( const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 2, const_str_plain_copy ); Py_INCREF( const_str_plain_copy );
    PyTuple_SET_ITEM( const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 3, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    const_str_plain_verify_certificate = UNSTREAM_STRING( &constant_bin[ 52560 ], 18, 1 );
    const_str_digest_8ad6e418a1b04e7939cf7e738b8257d2 = UNSTREAM_STRING( &constant_bin[ 85744 ], 161, 0 );
    const_str_digest_11c225ccbab9acffc38107dee9691702 = UNSTREAM_STRING( &constant_bin[ 85905 ], 67, 0 );
    const_tuple_13745beac221529fe5d89135e9b648d3_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 1, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 2, const_str_plain_key ); Py_INCREF( const_str_plain_key );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 3, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 4, const_str_plain_days ); Py_INCREF( const_str_plain_days );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 5, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 6, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 7, const_str_plain_sometime ); Py_INCREF( const_str_plain_sometime );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 8, const_str_plain_digest_obj ); Py_INCREF( const_str_plain_digest_obj );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 9, const_str_plain_sign_result ); Py_INCREF( const_str_plain_sign_result );
    const_str_plain_NETSCAPE_SPKI_b64_encode = UNSTREAM_STRING( &constant_bin[ 85972 ], 24, 1 );
    const_tuple_788a505d6e43a02df061e74659415d8f_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 2, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 3, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 4, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 5, const_str_plain_ent_obj ); Py_INCREF( const_str_plain_ent_obj );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 6, const_str_plain_ent ); Py_INCREF( const_str_plain_ent );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 7, const_str_plain_ent_nid ); Py_INCREF( const_str_plain_ent_nid );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 8, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple, 0, const_str_digest_5339fa8ff3df372e54ef7b09078767aa ); Py_INCREF( const_str_digest_5339fa8ff3df372e54ef7b09078767aa );
    const_str_digest_cd7d7b6c262cf257f5bafa26f39b567e = UNSTREAM_STRING( &constant_bin[ 85996 ], 356, 0 );
    const_str_plain_NETSCAPE_SPKI_new = UNSTREAM_STRING( &constant_bin[ 86352 ], 17, 1 );
    const_str_digest_1c1759444507dc6d4c0d7b4ce6b62611 = UNSTREAM_STRING( &constant_bin[ 86369 ], 273, 0 );
    const_str_digest_2cf9e4c7f607857df636a128997ff3fc = UNSTREAM_STRING( &constant_bin[ 86642 ], 31, 0 );
    const_str_plain__subjectAltNameString = UNSTREAM_STRING( &constant_bin[ 86673 ], 21, 1 );
    const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 1, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 2, const_str_plain_bits ); Py_INCREF( const_str_plain_bits );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 3, const_str_plain_exponent ); Py_INCREF( const_str_plain_exponent );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 4, const_str_plain_rsa ); Py_INCREF( const_str_plain_rsa );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 5, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 6, const_str_plain_res ); Py_INCREF( const_str_plain_res );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 7, const_str_plain_dsa ); Py_INCREF( const_str_plain_dsa );
    const_tuple_e0284b4dc341731363d45f065b316e64_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 1, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 2, const_str_plain_passphrase ); Py_INCREF( const_str_plain_passphrase );
    PyTuple_SET_ITEM( const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 3, const_str_plain_more_args ); Py_INCREF( const_str_plain_more_args );
    PyTuple_SET_ITEM( const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 4, const_str_plain_truncate ); Py_INCREF( const_str_plain_truncate );
    const_str_plain_get_data = UNSTREAM_STRING( &constant_bin[ 86694 ], 8, 1 );
    const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple, 0, const_str_plain_boundary ); Py_INCREF( const_str_plain_boundary );
    PyTuple_SET_ITEM( const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple, 1, const_str_plain_when ); Py_INCREF( const_str_plain_when );
    PyTuple_SET_ITEM( const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple, 2, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_str_digest_9226325aac109a91f8326c1a26ede065 = UNSTREAM_STRING( &constant_bin[ 86702 ], 48, 0 );
    const_tuple_str_digest_0d925750cb36e0c0e5f47f40c47790e6_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_0d925750cb36e0c0e5f47f40c47790e6_tuple, 0, const_str_digest_0d925750cb36e0c0e5f47f40c47790e6 ); Py_INCREF( const_str_digest_0d925750cb36e0c0e5f47f40c47790e6 );
    const_str_digest_4357c956c1f3628f437632877b5d8593 = UNSTREAM_STRING( &constant_bin[ 86750 ], 197, 0 );
    const_str_digest_b16563a844474e8eed4710209909ab32 = UNSTREAM_STRING( &constant_bin[ 86947 ], 283, 0 );
    const_str_digest_8bcf6e6fbaf96377cbe58ba9960c9d58 = UNSTREAM_STRING( &constant_bin[ 87230 ], 211, 0 );
    const_str_plain_X509_REQ_print_ex = UNSTREAM_STRING( &constant_bin[ 87441 ], 17, 1 );
    const_str_digest_e2d5c2f473553b6759cc455da987e04a = UNSTREAM_STRING( &constant_bin[ 87458 ], 163, 0 );
    const_str_plain_add_revoked = UNSTREAM_STRING( &constant_bin[ 87621 ], 11, 1 );
    const_str_digest_290681512f72ca11cbf3e4827987aabb = UNSTREAM_STRING( &constant_bin[ 87632 ], 20, 0 );

    constants_created = true;
}

#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_OpenSSL$crypto( void )
{
    // The module may not have been used at all.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_10320fceee2af85afeed8b3d012ca947;
static PyCodeObject *codeobj_40177b130baad3068ebe5a951155469e;
static PyCodeObject *codeobj_46b4308dcfe4b8f3851708d0fb7512b6;
static PyCodeObject *codeobj_e6218c4ff5c9cc85be7135f57a324c77;
static PyCodeObject *codeobj_49f77dedf80bc3efafd2f5a607bc3228;
static PyCodeObject *codeobj_ef4113a8028bdb676c80e7a90f63ad7d;
static PyCodeObject *codeobj_efbe69aec7044cb2a39b1ace99dec096;
static PyCodeObject *codeobj_bd5dfefd12bc6c3f36089482b1206592;
static PyCodeObject *codeobj_d6e3285b23310238237c90ac0797e840;
static PyCodeObject *codeobj_e7c675b53b12683555b138ae5949022f;
static PyCodeObject *codeobj_6193021140077dcce0ad2cf734bebd36;
static PyCodeObject *codeobj_d39cbe985793ae46e571988cae52c815;
static PyCodeObject *codeobj_129fe76254a1387737fbb2b415f27966;
static PyCodeObject *codeobj_a82ccd2c0741621ed27296148a68c29b;
static PyCodeObject *codeobj_3fbfe9df01a81af8e37bd5a7f5ae6696;
static PyCodeObject *codeobj_c420853ec5373143d72a06d844a52757;
static PyCodeObject *codeobj_063b1a0e18b7d09d3c7304577aae337e;
static PyCodeObject *codeobj_e74409a73207f7b2752994c2618d873f;
static PyCodeObject *codeobj_2dae63b82183f47dc1d1ccf37238a118;
static PyCodeObject *codeobj_35224eb056f22fe92af87e40d652fea6;
static PyCodeObject *codeobj_1c0cae65699467a80d94f781d6c3d9b1;
static PyCodeObject *codeobj_cf52b2979abc3841b63feac291ec11ae;
static PyCodeObject *codeobj_4e3b06b88584206930ad4ab3fea731d0;
static PyCodeObject *codeobj_cc4235dd9f43b9c9542b53c88b8e6a03;
static PyCodeObject *codeobj_781624e00a9735ef39d890417814f755;
static PyCodeObject *codeobj_2043efb2389ea54ec41185bb817d4d92;
static PyCodeObject *codeobj_d792dc0a2b4ceb48a62671146c8bf0d7;
static PyCodeObject *codeobj_459d1e2f5259dad1fd69735ed07121a4;
static PyCodeObject *codeobj_e284a8d70714fdb79809fb1913c8d00d;
static PyCodeObject *codeobj_3017da2311b90aa13ec5c98739847c3a;
static PyCodeObject *codeobj_f3e20dc9e619a5c7b71876ef8e4ffdf2;
static PyCodeObject *codeobj_2a7bb83e6e75a054f19a73ff4f483805;
static PyCodeObject *codeobj_5257480cf0e5c2a0e7b7480a7cb50162;
static PyCodeObject *codeobj_6fee1e02bfdf5171d161d782964ddf8a;
static PyCodeObject *codeobj_f3aabc03ee2f84380109aeb9f42fe98a;
static PyCodeObject *codeobj_83f6355a0f982176162b7419981e2765;
static PyCodeObject *codeobj_6a070d2cef92fc76d5061d3f76c44171;
static PyCodeObject *codeobj_d868387e609dfd72b81d3fa1fa8ab351;
static PyCodeObject *codeobj_3786f0d21253e58936f662cecbfc0803;
static PyCodeObject *codeobj_22507613a2c65d750fef04b0041d1bcf;
static PyCodeObject *codeobj_474b942d1079d7aa7b5b630fd0d8885f;
static PyCodeObject *codeobj_91f0594f09524e3872738633f4f7e4d8;
static PyCodeObject *codeobj_91827650124a919342a3904039e7cc23;
static PyCodeObject *codeobj_d2e6aa63601547b6b03bc44158eb1f5e;
static PyCodeObject *codeobj_7096b6ad0685416ea20fafee5d682357;
static PyCodeObject *codeobj_31cede2371f8cc0be31721e82cc1d349;
static PyCodeObject *codeobj_939508a1e0496c5c137cc6f48b750d12;
static PyCodeObject *codeobj_9da9fa45beb0c9f41a9608504e4060ef;
static PyCodeObject *codeobj_a5edad3959ffbe1dd9ddf61f4b759fb6;
static PyCodeObject *codeobj_be69f2a07a72c09df887316bd387c371;
static PyCodeObject *codeobj_aa80a5d36a11ceafba5ad49aa16e30e0;
static PyCodeObject *codeobj_c196634e750512d513f350e0875f8a1f;
static PyCodeObject *codeobj_a856bd49c4603c5e0e8b903888741c02;
static PyCodeObject *codeobj_06807d7bae8f316ff9a9e8ff657f7c28;
static PyCodeObject *codeobj_57a4f44f27b7dd0a656889214e64bb91;
static PyCodeObject *codeobj_b2eb147418d5fabeff8e35f9b5686e90;
static PyCodeObject *codeobj_9104ea89573b61be15ab468f377fb279;
static PyCodeObject *codeobj_a315eda621833a13d7eb0a139c70dafe;
static PyCodeObject *codeobj_d0b5dc3540b8ce76d706929407f28bf8;
static PyCodeObject *codeobj_fb7171180cafea0f8feff8daea432726;
static PyCodeObject *codeobj_7c89e32ae632b40579beca91c3fdd7c2;
static PyCodeObject *codeobj_5bfb296d5731d584cf8608b23453951b;
static PyCodeObject *codeobj_9f2b9ad144beb7aa9e8cd5e09d9fa943;
static PyCodeObject *codeobj_22c8795b049654d8bc8a72f08c1a0691;
static PyCodeObject *codeobj_d51c13718977056415bef87cf9ca74e3;
static PyCodeObject *codeobj_119480fb0feb54a4f011bffa2f21182e;
static PyCodeObject *codeobj_d646955fcdf80afde1b63bdd49140dae;
static PyCodeObject *codeobj_b937f289fb17e79995f422e1b9152e9d;
static PyCodeObject *codeobj_74cde753c21d561d79e5c3fb8ec14b96;
static PyCodeObject *codeobj_70275adf8e6632812c63bb55ba5541ea;
static PyCodeObject *codeobj_dbceb89b1b1d3b1149b72b5d9f552b47;
static PyCodeObject *codeobj_f3c023895e4501d84ce768a27bdd335b;
static PyCodeObject *codeobj_8074998756d76facb0acefe4e2bce233;
static PyCodeObject *codeobj_39cfa03514a1d73dd0565fdcb05e6808;
static PyCodeObject *codeobj_6a7a8eee239b6a4648d8651514b607eb;
static PyCodeObject *codeobj_0a9fc1297fc6ce588e759c7014f8b308;
static PyCodeObject *codeobj_7189c655d187dba7fe5d32c5a002d947;
static PyCodeObject *codeobj_2f75eb83f141c45e8429039b2cce5fd5;
static PyCodeObject *codeobj_96feb5417aba60c65386efdfa05ffda6;
static PyCodeObject *codeobj_e2d69c1085f8607b608690a912064382;
static PyCodeObject *codeobj_1a7304e9294486f283f111b9533e37ac;
static PyCodeObject *codeobj_ecc5f2c4e5dc86a32ed116e99c89a5d1;
static PyCodeObject *codeobj_aad48952174175fb990f54e79c3441f0;
static PyCodeObject *codeobj_0c7b9a5b3ed4ff89630439f7e0f3a7c3;
static PyCodeObject *codeobj_e1bd12349b684047b31907a697c36274;
static PyCodeObject *codeobj_89c93e5d81ce22610ffc5a6402eaa2b2;
static PyCodeObject *codeobj_3a363175d5408a6bc23af5d6f91497ed;
static PyCodeObject *codeobj_d9b4aca46fa45edc20186def74d2cc85;
static PyCodeObject *codeobj_319356766fa623fbb53f8001dc596471;
static PyCodeObject *codeobj_9b12eba053e44d5fd15b6e0ac3462f9f;
static PyCodeObject *codeobj_0c82a5452c5febb9099bd8db0c10394d;
static PyCodeObject *codeobj_ae02106742003eefd25af05a0213f462;
static PyCodeObject *codeobj_4c30ea601179f11262c4deefdcac8ea8;
static PyCodeObject *codeobj_58da277305ed77bd76ae182c07ff471f;
static PyCodeObject *codeobj_153767201ad1e1a2e0fa3001f507c4f6;
static PyCodeObject *codeobj_107afbc3261214969697ae7bd17eb403;
static PyCodeObject *codeobj_05bd525e51ba5f81f7baedbcb28010d8;
static PyCodeObject *codeobj_52692d97d9af6bf5d9cdd4e751d8736f;
static PyCodeObject *codeobj_fe1ab9327216940b89ff10309b7e559c;
static PyCodeObject *codeobj_b1486947c5a61e6df127599c97e465e7;
static PyCodeObject *codeobj_8ba34bf3bdf107b089c685c0ea45312d;
static PyCodeObject *codeobj_ebf7313f23a0eb07511542b17ec730a1;
static PyCodeObject *codeobj_1455e3e00773aae57fb3dc956853d9a5;
static PyCodeObject *codeobj_70910ab61c2a9a1468d98c3214045299;
static PyCodeObject *codeobj_297408a0aa65f790cf77d6f0ddab5fc4;
static PyCodeObject *codeobj_817e625125db0bed6c9af343a2fa01ac;
static PyCodeObject *codeobj_f442bcbb68e2ecc7a7ffb9f1ee7dc59b;
static PyCodeObject *codeobj_e7ae04d16d91e8d239c7d8ea0b0f0b05;
static PyCodeObject *codeobj_d092a227600410e01a6b811aac2b1868;
static PyCodeObject *codeobj_ed069d1a9991feb4397571ea46f32f1d;
static PyCodeObject *codeobj_7abef46ac5fd5222e8eee23d9d0de8fa;
static PyCodeObject *codeobj_0612b9518d882fcbc0d3f58a38c9a868;
static PyCodeObject *codeobj_cd8026d8c03981ef7b359feb3aa91a02;
static PyCodeObject *codeobj_cfbf41ceb63c16d529c709e5c8297fb7;
static PyCodeObject *codeobj_80b295e7b075bea47091b563200e78b8;
static PyCodeObject *codeobj_00cd31b4c5e27fc1a7515a659d7cbc7a;
static PyCodeObject *codeobj_4f8ed7f420c0ac066c4fb9a1c956cabc;
static PyCodeObject *codeobj_17894a2bd573cf70312dff7783ba8c00;
static PyCodeObject *codeobj_b7cc71e6ff631f267fd48a1034a4d982;
static PyCodeObject *codeobj_84f20b87ad7f63be7d712f315dc27fea;
static PyCodeObject *codeobj_21af353ae645ab8ee28b6adbc1ad3978;
static PyCodeObject *codeobj_b6e7e7435391bc9113c1cc9764c3e6e3;
static PyCodeObject *codeobj_a797f2541923bcc6c680cbf8841d85e0;
static PyCodeObject *codeobj_4dcbd11112592d2548a66b42db5772e6;
static PyCodeObject *codeobj_cde66f85dffd5588bcc9694a7fafb9fc;
static PyCodeObject *codeobj_49f65499044958fd105e8a41711525ee;
static PyCodeObject *codeobj_14c48645ee3ca3c857b7652479da20fc;
static PyCodeObject *codeobj_2f3ff2ef3c95694bc7821e44dd686feb;
static PyCodeObject *codeobj_2709b5b328fe0d9822af3023feb7896a;
static PyCodeObject *codeobj_6817feb5181abfef1d37cfd39fe30cb8;
static PyCodeObject *codeobj_a88924701bcd8a1d6541ab7a94a691c9;
static PyCodeObject *codeobj_ee8c5e94f6b2bf50cc0c751599edbbf4;
static PyCodeObject *codeobj_95e8045ab91a3cf5ec43d09da1cff4dc;
static PyCodeObject *codeobj_81d019b3ef51f73c296d9bd966429c42;
static PyCodeObject *codeobj_ff2082c1effa87cca79f7de3b6f33a05;
static PyCodeObject *codeobj_aa37b9cbdf49270d594d1c8bbf09fed2;
static PyCodeObject *codeobj_e56da31fff9a5ba5ac59532a15df82d5;
static PyCodeObject *codeobj_fba8564faf4c03ce4d5b0d189ce6194b;
static PyCodeObject *codeobj_d0171732bc26f9a167787680f68c98bf;
static PyCodeObject *codeobj_b39bc7f4b92f008bf056168e2d35a0b3;
static PyCodeObject *codeobj_83c24878a9b5a5e8cf8af59795ee05c6;
static PyCodeObject *codeobj_7616cad37f05a65bcb8c1a4729346ad9;
static PyCodeObject *codeobj_60d95cc23d60386c3b98865d2e08e264;
static PyCodeObject *codeobj_27ff3ab34ec54fd0321637ec5b9468ab;
static PyCodeObject *codeobj_e3fe386d49259b679544c27db4211b3f;
static PyCodeObject *codeobj_335819dcf5f2ff177db72f200198965d;
static PyCodeObject *codeobj_8288a95eb966387b5a4b6507bc1f1a0b;
static PyCodeObject *codeobj_b3244c50c8c54c5da547fc5b29816352;
static PyCodeObject *codeobj_9bb39077dd2210e297f9b293e3ba3d43;
static PyCodeObject *codeobj_eaa8abaf1b913554e0e3552e860e2ed1;
static PyCodeObject *codeobj_ece9e443ce0480c90f4788350c457a64;
static PyCodeObject *codeobj_deef68f99d6ac4c33ddafe5e7f7cd886;
static PyCodeObject *codeobj_be33a06b1200d059a460c969c87bf108;
static PyCodeObject *codeobj_b357cc9e906b9722fc07e8962b40d11d;
static PyCodeObject *codeobj_9f23f9ebe329837518bdc3f7e1a6e88c;
static PyCodeObject *codeobj_d41d40838f88795a151b0b852e40ee1b;
static PyCodeObject *codeobj_1611b903c9b5e6e33168f01f5ca2e18f;
static PyCodeObject *codeobj_a3b1f8e833aa031bd6d706c06d21fefb;
static PyCodeObject *codeobj_62b37b398cca624e1da0cba42e8c2fbe;
static PyCodeObject *codeobj_99e4ea9ef8921a672a5c09e7667ef6af;
static PyCodeObject *codeobj_8eb0152ada49813b33550455d2f476e6;
static PyCodeObject *codeobj_ea1b89400f70df5f265adb95fc821fef;
static PyCodeObject *codeobj_8a05448908bde9009224b5554b838346;
static PyCodeObject *codeobj_634dd2520f2d2675325c340573d2f303;
static PyCodeObject *codeobj_6f232e0892e44270bff4d47905df44dc;
static PyCodeObject *codeobj_753e3dd3d02b58575f16808234de0cc5;
static PyCodeObject *codeobj_0b51c794f2deb346eb163bcfa124fc96;
static PyCodeObject *codeobj_581db0cca4d33e8ad35e2569a0dead0b;
static PyCodeObject *codeobj_7349adb7b143cb067732bf2b6a832926;
static PyCodeObject *codeobj_827362a983b7474d6f375edfc3634b35;
static PyCodeObject *codeobj_28c84ee70c601df7b191b6f7900ba260;
static PyCodeObject *codeobj_d5256ae10053b2c8525f915629371344;
static PyCodeObject *codeobj_84aebb049548e459b85da103bbfd2471;
static PyCodeObject *codeobj_33a88964d744834d19cbcd47d9aefd1b;
static PyCodeObject *codeobj_16d689f7baaa9ade885f0b9a9d240d0e;
static PyCodeObject *codeobj_6093350e55e88ba43a75d89738bbea61;

static void createModuleCodeObjects(void)
{
    module_filename_obj = MAKE_RELATIVE_PATH( const_str_digest_1a3a564060f5ebd53d44f6035495ba48 );
    codeobj_10320fceee2af85afeed8b3d012ca947 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 423, const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_40177b130baad3068ebe5a951155469e = MAKE_CODEOBJ( module_filename_obj, const_str_angle_lambda, 1022, const_tuple_str_plain_x_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_46b4308dcfe4b8f3851708d0fb7512b6 = MAKE_CODEOBJ( module_filename_obj, const_str_digest_1f7559cec53c5da336c35128000e1652, 1, const_tuple_empty, 0, CO_NOFREE );
    codeobj_e6218c4ff5c9cc85be7135f57a324c77 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_CRL, 2246, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_49f77dedf80bc3efafd2f5a607bc3228 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PKey, 223, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_ef4113a8028bdb676c80e7a90f63ad7d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_X509, 1083, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_efbe69aec7044cb2a39b1ace99dec096 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_X509Extension, 720, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_bd5dfefd12bc6c3f36089482b1206592 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_X509Name, 520, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_d6e3285b23310238237c90ac0797e840 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_X509Req, 872, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_e7c675b53b12683555b138ae5949022f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_X509StoreContext, 1746, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_6193021140077dcce0ad2cf734bebd36 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_X509StoreFlags, 1556, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_d39cbe985793ae46e571988cae52c815 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__EllipticCurve, 382, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_129fe76254a1387737fbb2b415f27966 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__PassphraseHelper, 2782, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_a82ccd2c0741621ed27296148a68c29b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___getattr__, 594, const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3fbfe9df01a81af8e37bd5a7f5ae6696 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 211, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c420853ec5373143d72a06d844a52757 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 231, const_tuple_str_plain_self_str_plain_pkey_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_063b1a0e18b7d09d3c7304577aae337e = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 456, const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e74409a73207f7b2752994c2618d873f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 545, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2dae63b82183f47dc1d1ccf37238a118 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 725, const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 6, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_35224eb056f22fe92af87e40d652fea6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 877, const_tuple_str_plain_self_str_plain_req_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1c0cae65699467a80d94f781d6c3d9b1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1088, const_tuple_str_plain_self_str_plain_x509_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cf52b2979abc3841b63feac291ec11ae = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1594, const_tuple_str_plain_self_str_plain_store_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4e3b06b88584206930ad4ab3fea731d0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1741, const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cc4235dd9f43b9c9542b53c88b8e6a03 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1768, const_tuple_2a726d59ade46c77b6bfd95ed66c5a12_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_781624e00a9735ef39d890417814f755 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 2093, const_tuple_str_plain_self_str_plain_revoked_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2043efb2389ea54ec41185bb817d4d92 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 2251, const_tuple_str_plain_self_str_plain_crl_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d792dc0a2b4ceb48a62671146c8bf0d7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 2516, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_459d1e2f5259dad1fd69735ed07121a4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 2697, const_tuple_str_plain_self_str_plain_spki_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e284a8d70714fdb79809fb1913c8d00d = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 2783, const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3017da2311b90aa13ec5c98739847c3a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 396, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f3e20dc9e619a5c7b71876ef8e4ffdf2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 473, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2a7bb83e6e75a054f19a73ff4f483805 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 652, const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5257480cf0e5c2a0e7b7480a7cb50162 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___setattr__, 555, const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6fee1e02bfdf5171d161d782964ddf8a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___str__, 820, const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f3aabc03ee2f84380109aeb9f42fe98a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__bio_to_string, 138, const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_83f6355a0f982176162b7419981e2765 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__build_certificate_stack, 1779, const_tuple_48ab3cdc7d6d88da8bc682675f6a64b7_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6a070d2cef92fc76d5061d3f76c44171 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__cleanup, 1820, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d868387e609dfd72b81d3fa1fa8ab351 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__cmp, 634, const_tuple_str_plain_op_str_plain_f_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3786f0d21253e58936f662cecbfc0803 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__delete_reason, 2139, const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_22507613a2c65d750fef04b0041d1bcf = MAKE_CODEOBJ( module_filename_obj, const_str_plain__exception_from_context, 1828, const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_474b942d1079d7aa7b5b630fd0d8885f = MAKE_CODEOBJ( module_filename_obj, const_str_plain__from_raw_x509_ptr, 1096, const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_91f0594f09524e3872738633f4f7e4d8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_asn1_time, 169, const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_91827650124a919342a3904039e7cc23 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_backend, 90, const_tuple_str_plain_backend_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d2e6aa63601547b6b03bc44158eb1f5e = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_boundary_time, 1374, const_tuple_str_plain_self_str_plain_which_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7096b6ad0685416ea20fafee5d682357 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_elliptic_curves, 425, const_tuple_str_plain_cls_str_plain_lib_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_31cede2371f8cc0be31721e82cc1d349 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_name, 1432, const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_939508a1e0496c5c137cc6f48b750d12 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__init, 1807, const_tuple_str_plain_self_str_plain_ret_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9da9fa45beb0c9f41a9608504e4060ef = MAKE_CODEOBJ( module_filename_obj, const_str_plain__load_elliptic_curves, 407, const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a5edad3959ffbe1dd9ddf61f4b759fb6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__new_mem_buf, 112, const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_be69f2a07a72c09df887316bd387c371 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__nid, 786, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_aa80a5d36a11ceafba5ad49aa16e30e0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__read_passphrase, 2826, const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c196634e750512d513f350e0875f8a1f = MAKE_CODEOBJ( module_filename_obj, const_str_plain__set_asn1_time, 147, const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a856bd49c4603c5e0e8b903888741c02 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__set_boundary_time, 1390, const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_06807d7bae8f316ff9a9e8ff657f7c28 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__set_boundary_time, 2353, const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_57a4f44f27b7dd0a656889214e64bb91 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__set_name, 1443, const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b2eb147418d5fabeff8e35f9b5686e90 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__subjectAltNameString, 798, const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9104ea89573b61be15ab468f377fb279 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__to_EC_KEY, 476, const_tuple_str_plain_self_str_plain_key_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a315eda621833a13d7eb0a139c70dafe = MAKE_CODEOBJ( module_filename_obj, const_str_plain__untested_error, 103, const_tuple_str_plain_where_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d0b5dc3540b8ce76d706929407f28bf8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add, 214, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fb7171180cafea0f8feff8daea432726 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_cert, 1598, const_tuple_str_plain_self_str_plain_cert_str_plain_res_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7c89e32ae632b40579beca91c3fdd7c2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_crl, 1620, const_tuple_str_plain_self_str_plain_crl_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5bfb296d5731d584cf8608b23453951b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_extensions, 986, const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9f2b9ad144beb7aa9e8cd5e09d9fa943 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_extensions, 1516, const_tuple_80a9571108770bd34772239ad97225a5_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_22c8795b049654d8bc8a72f08c1a0691 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_revoked, 2310, const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d51c13718977056415bef87cf9ca74e3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_all_reasons, 2212, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_119480fb0feb54a4f011bffa2f21182e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_b64_encode, 2745, const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d646955fcdf80afde1b63bdd49140dae = MAKE_CODEOBJ( module_filename_obj, const_str_plain_bits, 373, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b937f289fb17e79995f422e1b9152e9d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_callback, 2793, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_74cde753c21d561d79e5c3fb8ec14b96 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_callback_args, 2804, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_70275adf8e6632812c63bb55ba5541ea = MAKE_CODEOBJ( module_filename_obj, const_str_plain_check, 339, const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dbceb89b1b1d3b1149b72b5d9f552b47 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_cleanup, 1781, const_tuple_str_plain_s_str_plain_i_str_plain_x_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f3c023895e4501d84ce768a27bdd335b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_clear, 217, const_tuple_str_plain_self_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8074998756d76facb0acefe4e2bce233 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_der, 678, const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_39cfa03514a1d73dd0565fdcb05e6808 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_digest, 1235, const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6a7a8eee239b6a4648d8651514b607eb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_dump_certificate, 1956, const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0a9fc1297fc6ce588e759c7014f8b308 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_dump_certificate_request, 2923, const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7189c655d187dba7fe5d32c5a002d947 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_dump_crl, 3050, const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2f75eb83f141c45e8429039b2cce5fd5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_dump_privatekey, 2009, const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_96feb5417aba60c65386efdfa05ffda6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_dump_publickey, 1984, const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e2d69c1085f8607b608690a912064382 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_export, 2412, const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 6, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1a7304e9294486f283f111b9533e37ac = MAKE_CODEOBJ( module_filename_obj, const_str_plain_export, 2624, const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ecc5f2c4e5dc86a32ed116e99c89a5d1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_f, 635, const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_aad48952174175fb990f54e79c3441f0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_free, 129, const_tuple_str_plain_bio_str_plain_ref_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0c7b9a5b3ed4ff89630439f7e0f3a7c3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_from_cryptography, 898, const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e1bd12349b684047b31907a697c36274 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_from_cryptography, 1117, const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_89c93e5d81ce22610ffc5a6402eaa2b2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_from_cryptography, 2270, const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3a363175d5408a6bc23af5d6f91497ed = MAKE_CODEOBJ( module_filename_obj, const_str_plain_from_cryptography_key, 253, const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d9b4aca46fa45edc20186def74d2cc85 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_from_nid, 439, const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_319356766fa623fbb53f8001dc596471 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_generate_key, 283, const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9b12eba053e44d5fd15b6e0ac3462f9f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_ca_certificates, 2566, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0c82a5452c5febb9099bd8db0c10394d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_certificate, 2522, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ae02106742003eefd25af05a0213f462 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_components, 693, const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4c30ea601179f11262c4deefdcac8ea8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_critical, 833, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_58da277305ed77bd76ae182c07ff471f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_data, 856, const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_153767201ad1e1a2e0fa3001f507c4f6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_elliptic_curve, 502, const_tuple_str_plain_name_str_plain_curve_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_107afbc3261214969697ae7bd17eb403 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_elliptic_curves, 487, const_tuple_empty, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_05bd525e51ba5f81f7baedbcb28010d8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_extension, 1532, const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_52692d97d9af6bf5d9cdd4e751d8736f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_extension_count, 1505, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fe1ab9327216940b89ff10309b7e559c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_extensions, 1009, const_tuple_85794016896eca55eb5b3d7e4628b724_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b1486947c5a61e6df127599c97e465e7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_friendlyname, 2615, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8ba34bf3bdf107b089c685c0ea45312d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_issuer, 1449, const_tuple_str_plain_self_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ebf7313f23a0eb07511542b17ec730a1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_issuer, 2327, const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1455e3e00773aae57fb3dc956853d9a5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_notAfter, 1406, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_70910ab61c2a9a1468d98c3214045299 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_notBefore, 1377, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_297408a0aa65f790cf77d6f0ddab5fc4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_privatekey, 2544, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_817e625125db0bed6c9af343a2fa01ac = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_pubkey, 929, const_tuple_str_plain_self_str_plain_pkey_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f442bcbb68e2ecc7a7ffb9f1ee7dc59b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_pubkey, 1160, const_tuple_str_plain_self_str_plain_pkey_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e7ae04d16d91e8d239c7d8ea0b0f0b05 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_pubkey, 2757, const_tuple_str_plain_self_str_plain_pkey_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d092a227600410e01a6b811aac2b1868 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_reason, 2185, const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ed069d1a9991feb4397571ea46f32f1d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_rev_date, 2235, const_tuple_str_plain_self_str_plain_dt_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7abef46ac5fd5222e8eee23d9d0de8fa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_revoked, 2289, const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0612b9518d882fcbc0d3f58a38c9a868 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_serial, 2121, const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cd8026d8c03981ef7b359feb3aa91a02 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_serial_number, 1315, const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cfbf41ceb63c16d529c709e5c8297fb7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_short_name, 841, const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_80b295e7b075bea47091b563200e78b8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_signature_algorithm, 1218, const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_00cd31b4c5e27fc1a7515a659d7cbc7a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_subject, 964, const_tuple_str_plain_self_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4f8ed7f420c0ac066c4fb9a1c956cabc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_subject, 1477, const_tuple_str_plain_self_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_17894a2bd573cf70312dff7783ba8c00 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_type_name, 2500, const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b7cc71e6ff631f267fd48a1034a4d982 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_verified_chain, 1887, const_tuple_da33f491cad89fe7f4a10b4791a01172_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_84f20b87ad7f63be7d712f315dc27fea = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_version, 954, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_21af353ae645ab8ee28b6adbc1ad3978 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_version, 1151, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b6e7e7435391bc9113c1cc9764c3e6e3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_gmtime_adj_notAfter, 1335, const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a797f2541923bcc6c680cbf8841d85e0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_gmtime_adj_notBefore, 1349, const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4dcbd11112592d2548a66b42db5772e6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_has_expired, 1362, const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cde66f85dffd5588bcc9694a7fafb9fc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hash, 666, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_49f65499044958fd105e8a41711525ee = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_certificate, 1927, const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_14c48645ee3ca3c857b7652479da20fc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_certificate_request, 2951, const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2f3ff2ef3c95694bc7821e44dd686feb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_crl, 3079, const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2709b5b328fe0d9822af3023feb7896a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_locations, 1684, const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6817feb5181abfef1d37cfd39fe30cb8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_pkcs12, 3149, const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a88924701bcd8a1d6541ab7a94a691c9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_pkcs7_data, 3109, const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ee8c5e94f6b2bf50cc0c751599edbbf4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_privatekey, 2886, const_tuple_76984bb103279dcce095840ed073cae5_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_95e8045ab91a3cf5ec43d09da1cff4dc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_publickey, 2852, const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_81d019b3ef51f73c296d9bd966429c42 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_raise_if_problem, 2815, const_tuple_str_plain_self_str_plain_exceptionType_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ff2082c1effa87cca79f7de3b6f33a05 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_ca_certificates, 2577, const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_aa37b9cbdf49270d594d1c8bbf09fed2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_certificate, 2531, const_tuple_str_plain_self_str_plain_cert_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e56da31fff9a5ba5ac59532a15df82d5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_flags, 1636, const_tuple_str_plain_self_str_plain_flags_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fba8564faf4c03ce4d5b0d189ce6194b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_friendlyname, 2598, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d0171732bc26f9a167787680f68c98bf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_issuer, 1465, const_tuple_str_plain_self_str_plain_issuer_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b39bc7f4b92f008bf056168e2d35a0b3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_lastUpdate, 2356, const_tuple_str_plain_self_str_plain_when_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_83c24878a9b5a5e8cf8af59795ee05c6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_nextUpdate, 2371, const_tuple_str_plain_self_str_plain_when_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7616cad37f05a65bcb8c1a4729346ad9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_notAfter, 1419, const_tuple_str_plain_self_str_plain_when_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_60d95cc23d60386c3b98865d2e08e264 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_notBefore, 1393, const_tuple_str_plain_self_str_plain_when_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_27ff3ab34ec54fd0321637ec5b9468ab = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_privatekey, 2553, const_tuple_str_plain_self_str_plain_pkey_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e3fe386d49259b679544c27db4211b3f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_pubkey, 917, const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_335819dcf5f2ff177db72f200198965d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_pubkey, 1175, const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8288a95eb966387b5a4b6507bc1f1a0b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_pubkey, 2771, const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b3244c50c8c54c5da547fc5b29816352 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_reason, 2148, const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9bb39077dd2210e297f9b293e3ba3d43 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_rev_date, 2224, const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_eaa8abaf1b913554e0e3552e860e2ed1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_serial, 2097, const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ece9e443ce0480c90f4788350c457a64 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_serial_number, 1275, const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_deef68f99d6ac4c33ddafe5e7f7cd886 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_store, 1854, const_tuple_str_plain_self_str_plain_store_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_be33a06b1200d059a460c969c87bf108 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_subject, 1493, const_tuple_str_plain_self_str_plain_subject_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b357cc9e906b9722fc07e8962b40d11d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_time, 1660, const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9f23f9ebe329837518bdc3f7e1a6e88c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_version, 943, const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d41d40838f88795a151b0b852e40ee1b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_version, 1136, const_tuple_str_plain_self_str_plain_version_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1611b903c9b5e6e33168f01f5ca2e18f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_version, 2342, const_tuple_str_plain_self_str_plain_version_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a3b1f8e833aa031bd6d706c06d21fefb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sign, 1037, const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_62b37b398cca624e1da0cba42e8c2fbe = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sign, 1190, const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_99e4ea9ef8921a672a5c09e7667ef6af = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sign, 2386, const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8eb0152ada49813b33550455d2f476e6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sign, 2701, const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ea1b89400f70df5f265adb95fc821fef = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sign, 2979, const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8a05448908bde9009224b5554b838346 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_subject_name_hash, 1266, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_634dd2520f2d2675325c340573d2f303 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_to_cryptography, 883, const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6f232e0892e44270bff4d47905df44dc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_to_cryptography, 1104, const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_753e3dd3d02b58575f16808234de0cc5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_to_cryptography, 2255, const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0b51c794f2deb346eb163bcfa124fc96 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_to_cryptography_key, 236, const_tuple_str_plain_self_str_plain_backend_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_581db0cca4d33e8ad35e2569a0dead0b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_type, 365, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7349adb7b143cb067732bf2b6a832926 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_type_is_data, 2492, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_827362a983b7474d6f375edfc3634b35 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_type_is_enveloped, 2476, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_28c84ee70c601df7b191b6f7900ba260 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_type_is_signed, 2468, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d5256ae10053b2c8525f915629371344 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_type_is_signedAndEnveloped, 2484, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_84aebb049548e459b85da103bbfd2471 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify, 1061, const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_33a88964d744834d19cbcd47d9aefd1b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify, 2728, const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_16d689f7baaa9ade885f0b9a9d240d0e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify, 3014, const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6093350e55e88ba43a75d89738bbea61 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify_certificate, 1865, const_tuple_str_plain_self_str_plain_ret_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
}

// The module function declarations.
#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_100_load_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_101_dump_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_102_dump_publickey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_103_dump_privatekey( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_104___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_105_set_serial(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_106_get_serial(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_107__delete_reason(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_108_set_reason(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_109_get_reason(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_10___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_110_all_reasons(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_111_set_rev_date(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_112_get_rev_date(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_113___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_114_to_cryptography(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_115_from_cryptography(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_116_get_revoked(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_117_add_revoked(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_118_get_issuer(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_119_set_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_11_to_cryptography_key(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_120__set_boundary_time(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_121_set_lastUpdate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_122_set_nextUpdate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_123_sign(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_124_export( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_125_type_is_signed(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_126_type_is_enveloped(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_127_type_is_signedAndEnveloped(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_128_type_is_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_129_get_type_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_12_from_cryptography_key(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_130___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_131_get_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_132_set_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_133_get_privatekey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_134_set_privatekey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_135_get_ca_certificates(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_136_set_ca_certificates(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_137_set_friendlyname(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_138_get_friendlyname(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_139_export( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_13_generate_key(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_140___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_141_sign(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_142_verify(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_143_b64_encode(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_144_get_pubkey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_145_set_pubkey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_146___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_147_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_148_callback_args(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_149_raise_if_problem( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_14_check(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_150__read_passphrase(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_151_load_publickey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_152_load_privatekey( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_153_dump_certificate_request(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_154_load_certificate_request(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_155_sign(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_156_verify(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_157_dump_crl(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_158_load_crl(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_159_load_pkcs7_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_15_type(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_160_load_pkcs12( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_16_bits(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_17___ne__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_18__load_elliptic_curves(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_19__get_elliptic_curves(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_1__get_backend(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_20_from_nid(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_21___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_22___repr__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_23__to_EC_KEY(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_24_get_elliptic_curves(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_25_get_elliptic_curve(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_26___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_27___setattr__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_28___getattr__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp$$$function_1_f( struct Nuitka_CellObject *closure_op );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_2__untested_error(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_30___repr__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_31_hash(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_32_der(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_33_get_components(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_34___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_35__nid(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_36__subjectAltNameString(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_37___str__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_38_get_critical(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_39_get_short_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_40_get_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_41___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_42_to_cryptography(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_43_from_cryptography(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_44_set_pubkey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_45_get_pubkey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_46_set_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_47_get_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_48_get_subject(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_49_add_extensions(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_4__bio_to_string(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_50_get_extensions(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_50_get_extensions$$$function_1_lambda(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_51_sign(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_52_verify(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_53___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_54__from_raw_x509_ptr(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_55_to_cryptography(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_56_from_cryptography(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_57_set_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_58_get_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_59_get_pubkey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_5__set_asn1_time(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_60_set_pubkey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_61_sign(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_62_get_signature_algorithm(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_63_digest(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_64_subject_name_hash(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_65_set_serial_number(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_66_get_serial_number(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_69_has_expired(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_6__get_asn1_time(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_70__get_boundary_time(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_71_get_notBefore(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_72__set_boundary_time(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_73_set_notBefore(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_74_get_notAfter(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_75_set_notAfter(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_76__get_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_77__set_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_78_get_issuer(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_79_set_issuer(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_7___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_80_get_subject(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_81_set_subject(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_82_get_extension_count(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_83_add_extensions(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_84_get_extension(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_85___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_86_add_cert(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_87_add_crl(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_88_set_flags(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_89_set_time(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_8_add(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_90_load_locations( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_91___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_92___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_93__build_certificate_stack(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_93__build_certificate_stack$$$function_1_cleanup(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_94__init(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_95__cleanup(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_96__exception_from_context(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_97_set_store(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_98_verify_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_99_get_verified_chain(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_9_clear(  );


// The module function definitions.
static PyObject *impl_OpenSSL$crypto$$$function_1__get_backend( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_backend = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_91827650124a919342a3904039e7cc23 = NULL;

    struct Nuitka_FrameObject *frame_91827650124a919342a3904039e7cc23;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_91827650124a919342a3904039e7cc23, codeobj_91827650124a919342a3904039e7cc23, module_OpenSSL$crypto, sizeof(void *) );
    frame_91827650124a919342a3904039e7cc23 = cache_frame_91827650124a919342a3904039e7cc23;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_91827650124a919342a3904039e7cc23 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_91827650124a919342a3904039e7cc23 ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_9abb9f40508debfa3aae6d9135753f7e;
    tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_backend_tuple;
    frame_91827650124a919342a3904039e7cc23->m_frame.f_lineno = 98;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 98;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_backend );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 98;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    assert( var_backend == NULL );
    var_backend = tmp_assign_source_1;


#if 0
    RESTORE_FRAME_EXCEPTION( frame_91827650124a919342a3904039e7cc23 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_91827650124a919342a3904039e7cc23 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_91827650124a919342a3904039e7cc23, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_91827650124a919342a3904039e7cc23->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_91827650124a919342a3904039e7cc23, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_91827650124a919342a3904039e7cc23,
        type_description_1,
        var_backend
    );


    // Release cached frame.
    if ( frame_91827650124a919342a3904039e7cc23 == cache_frame_91827650124a919342a3904039e7cc23 )
    {
        Py_DECREF( frame_91827650124a919342a3904039e7cc23 );
    }
    cache_frame_91827650124a919342a3904039e7cc23 = NULL;

    assertFrameObject( frame_91827650124a919342a3904039e7cc23 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_backend;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_1__get_backend );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_backend );
    Py_DECREF( var_backend );
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_1__get_backend );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_2__untested_error( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_where = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_right_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_a315eda621833a13d7eb0a139c70dafe = NULL;

    struct Nuitka_FrameObject *frame_a315eda621833a13d7eb0a139c70dafe;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a315eda621833a13d7eb0a139c70dafe, codeobj_a315eda621833a13d7eb0a139c70dafe, module_OpenSSL$crypto, sizeof(void *) );
    frame_a315eda621833a13d7eb0a139c70dafe = cache_frame_a315eda621833a13d7eb0a139c70dafe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a315eda621833a13d7eb0a139c70dafe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a315eda621833a13d7eb0a139c70dafe ) == 2 ); // Frame stack

    // Framed code:
    tmp_left_name_1 = const_str_digest_819566a56c114d5ab553db6b3a965184;
    tmp_right_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_where;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 109;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_a315eda621833a13d7eb0a139c70dafe->m_frame.f_lineno = 109;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_RuntimeError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 109;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "o";
    goto frame_exception_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a315eda621833a13d7eb0a139c70dafe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a315eda621833a13d7eb0a139c70dafe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a315eda621833a13d7eb0a139c70dafe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a315eda621833a13d7eb0a139c70dafe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a315eda621833a13d7eb0a139c70dafe, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a315eda621833a13d7eb0a139c70dafe,
        type_description_1,
        par_where
    );


    // Release cached frame.
    if ( frame_a315eda621833a13d7eb0a139c70dafe == cache_frame_a315eda621833a13d7eb0a139c70dafe )
    {
        Py_DECREF( frame_a315eda621833a13d7eb0a139c70dafe );
    }
    cache_frame_a315eda621833a13d7eb0a139c70dafe = NULL;

    assertFrameObject( frame_a315eda621833a13d7eb0a139c70dafe );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_2__untested_error );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_where );
    Py_DECREF( par_where );
    par_where = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_2__untested_error );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_OpenSSL$crypto$$$function_3__new_mem_buf( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_buffer = python_pars[ 0 ];
    PyObject *var_bio = NULL;
    PyObject *var_data = NULL;
    PyObject *var_free = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_defaults_1;
    bool tmp_is_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_a5edad3959ffbe1dd9ddf61f4b759fb6 = NULL;

    struct Nuitka_FrameObject *frame_a5edad3959ffbe1dd9ddf61f4b759fb6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a5edad3959ffbe1dd9ddf61f4b759fb6, codeobj_a5edad3959ffbe1dd9ddf61f4b759fb6, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a5edad3959ffbe1dd9ddf61f4b759fb6 = cache_frame_a5edad3959ffbe1dd9ddf61f4b759fb6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a5edad3959ffbe1dd9ddf61f4b759fb6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a5edad3959ffbe1dd9ddf61f4b759fb6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_buffer;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 122;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_BIO_new );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 122;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 122;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_a5edad3959ffbe1dd9ddf61f4b759fb6->m_frame.f_lineno = 122;
    tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_BIO_s_mem );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 122;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_a5edad3959ffbe1dd9ddf61f4b759fb6->m_frame.f_lineno = 122;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 122;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_1;

    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 123;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_BIO_free );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 123;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_free == NULL );
    var_free = tmp_assign_source_2;

    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 125;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_str_digest_c561652c58984ec0e9541542aa405594;
    tmp_args_element_name_3 = par_buffer;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_a5edad3959ffbe1dd9ddf61f4b759fb6->m_frame.f_lineno = 125;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_new, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 125;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_data == NULL );
    var_data = tmp_assign_source_3;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 126;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_BIO_new_mem_buf );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 126;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = var_data;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_len_arg_1 = par_buffer;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_args_element_name_5 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 126;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_a5edad3959ffbe1dd9ddf61f4b759fb6->m_frame.f_lineno = 126;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 126;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_4;

    tmp_defaults_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = var_data;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_defaults_1, 0, tmp_tuple_element_1 );
    tmp_assign_source_5 = MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free( tmp_defaults_1 );
    assert( var_free == NULL );
    var_free = tmp_assign_source_5;

    branch_end_1:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 132;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_bio;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 132;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 132;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 132;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_a5edad3959ffbe1dd9ddf61f4b759fb6->m_frame.f_lineno = 132;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 132;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 134;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = var_free;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_a5edad3959ffbe1dd9ddf61f4b759fb6->m_frame.f_lineno = 134;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_gc, call_args );
    }

    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 134;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_bio;
        assert( old != NULL );
        var_bio = tmp_assign_source_6;
        Py_DECREF( old );
    }


#if 0
    RESTORE_FRAME_EXCEPTION( frame_a5edad3959ffbe1dd9ddf61f4b759fb6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a5edad3959ffbe1dd9ddf61f4b759fb6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a5edad3959ffbe1dd9ddf61f4b759fb6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a5edad3959ffbe1dd9ddf61f4b759fb6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a5edad3959ffbe1dd9ddf61f4b759fb6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a5edad3959ffbe1dd9ddf61f4b759fb6,
        type_description_1,
        par_buffer,
        var_bio,
        var_data,
        var_free
    );


    // Release cached frame.
    if ( frame_a5edad3959ffbe1dd9ddf61f4b759fb6 == cache_frame_a5edad3959ffbe1dd9ddf61f4b759fb6 )
    {
        Py_DECREF( frame_a5edad3959ffbe1dd9ddf61f4b759fb6 );
    }
    cache_frame_a5edad3959ffbe1dd9ddf61f4b759fb6 = NULL;

    assertFrameObject( frame_a5edad3959ffbe1dd9ddf61f4b759fb6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_bio;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_3__new_mem_buf );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    CHECK_OBJECT( (PyObject *)var_free );
    Py_DECREF( var_free );
    var_free = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    Py_XDECREF( var_free );
    var_free = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_3__new_mem_buf );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_bio = python_pars[ 0 ];
    PyObject *par_ref = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_aad48952174175fb990f54e79c3441f0 = NULL;

    struct Nuitka_FrameObject *frame_aad48952174175fb990f54e79c3441f0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_aad48952174175fb990f54e79c3441f0, codeobj_aad48952174175fb990f54e79c3441f0, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_aad48952174175fb990f54e79c3441f0 = cache_frame_aad48952174175fb990f54e79c3441f0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_aad48952174175fb990f54e79c3441f0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_aad48952174175fb990f54e79c3441f0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 130;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_bio;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_aad48952174175fb990f54e79c3441f0->m_frame.f_lineno = 130;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_BIO_free, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 130;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aad48952174175fb990f54e79c3441f0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_aad48952174175fb990f54e79c3441f0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aad48952174175fb990f54e79c3441f0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_aad48952174175fb990f54e79c3441f0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_aad48952174175fb990f54e79c3441f0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_aad48952174175fb990f54e79c3441f0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_aad48952174175fb990f54e79c3441f0,
        type_description_1,
        par_bio,
        par_ref
    );


    // Release cached frame.
    if ( frame_aad48952174175fb990f54e79c3441f0 == cache_frame_aad48952174175fb990f54e79c3441f0 )
    {
        Py_DECREF( frame_aad48952174175fb990f54e79c3441f0 );
    }
    cache_frame_aad48952174175fb990f54e79c3441f0 = NULL;

    assertFrameObject( frame_aad48952174175fb990f54e79c3441f0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_bio );
    Py_DECREF( par_bio );
    par_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_ref );
    Py_DECREF( par_ref );
    par_ref = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_bio );
    Py_DECREF( par_bio );
    par_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_ref );
    Py_DECREF( par_ref );
    par_ref = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_4__bio_to_string( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_bio = python_pars[ 0 ];
    PyObject *var_buffer_length = NULL;
    PyObject *var_result_buffer = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_f3aabc03ee2f84380109aeb9f42fe98a = NULL;

    struct Nuitka_FrameObject *frame_f3aabc03ee2f84380109aeb9f42fe98a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f3aabc03ee2f84380109aeb9f42fe98a, codeobj_f3aabc03ee2f84380109aeb9f42fe98a, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f3aabc03ee2f84380109aeb9f42fe98a = cache_frame_f3aabc03ee2f84380109aeb9f42fe98a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f3aabc03ee2f84380109aeb9f42fe98a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f3aabc03ee2f84380109aeb9f42fe98a ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 142;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_f3aabc03ee2f84380109aeb9f42fe98a->m_frame.f_lineno = 142;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_70b987f75825a6c2ffe2c8fe53d85a21_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 142;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_buffer == NULL );
    var_result_buffer = tmp_assign_source_1;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 143;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_bio;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = var_result_buffer;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_f3aabc03ee2f84380109aeb9f42fe98a->m_frame.f_lineno = 143;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_BIO_get_mem_data, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 143;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_buffer_length == NULL );
    var_buffer_length = tmp_assign_source_2;

    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 144;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_buffer );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 144;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = var_result_buffer;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_args_element_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 144;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = var_buffer_length;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_f3aabc03ee2f84380109aeb9f42fe98a->m_frame.f_lineno = 144;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 144;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 144;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3aabc03ee2f84380109aeb9f42fe98a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3aabc03ee2f84380109aeb9f42fe98a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3aabc03ee2f84380109aeb9f42fe98a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f3aabc03ee2f84380109aeb9f42fe98a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f3aabc03ee2f84380109aeb9f42fe98a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f3aabc03ee2f84380109aeb9f42fe98a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f3aabc03ee2f84380109aeb9f42fe98a,
        type_description_1,
        par_bio,
        var_buffer_length,
        var_result_buffer
    );


    // Release cached frame.
    if ( frame_f3aabc03ee2f84380109aeb9f42fe98a == cache_frame_f3aabc03ee2f84380109aeb9f42fe98a )
    {
        Py_DECREF( frame_f3aabc03ee2f84380109aeb9f42fe98a );
    }
    cache_frame_f3aabc03ee2f84380109aeb9f42fe98a = NULL;

    assertFrameObject( frame_f3aabc03ee2f84380109aeb9f42fe98a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_4__bio_to_string );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_buffer_length );
    Py_DECREF( var_buffer_length );
    var_buffer_length = NULL;

    CHECK_OBJECT( (PyObject *)par_bio );
    Py_DECREF( par_bio );
    par_bio = NULL;

    CHECK_OBJECT( (PyObject *)var_result_buffer );
    Py_DECREF( var_result_buffer );
    var_result_buffer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_buffer_length );
    var_buffer_length = NULL;

    CHECK_OBJECT( (PyObject *)par_bio );
    Py_DECREF( par_bio );
    par_bio = NULL;

    Py_XDECREF( var_result_buffer );
    var_result_buffer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_4__bio_to_string );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_5__set_asn1_time( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_boundary = python_pars[ 0 ];
    PyObject *par_when = python_pars[ 1 ];
    PyObject *var_set_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_c196634e750512d513f350e0875f8a1f = NULL;

    struct Nuitka_FrameObject *frame_c196634e750512d513f350e0875f8a1f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c196634e750512d513f350e0875f8a1f, codeobj_c196634e750512d513f350e0875f8a1f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c196634e750512d513f350e0875f8a1f = cache_frame_c196634e750512d513f350e0875f8a1f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c196634e750512d513f350e0875f8a1f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c196634e750512d513f350e0875f8a1f ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_when;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 161;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_0632ce6142bf9815370c626f0fb1235a;
    frame_c196634e750512d513f350e0875f8a1f->m_frame.f_lineno = 162;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 162;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 164;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_boundary;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = par_when;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_c196634e750512d513f350e0875f8a1f->m_frame.f_lineno = 164;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_ASN1_TIME_set_string, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 164;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_set_result == NULL );
    var_set_result = tmp_assign_source_1;

    tmp_compare_left_1 = var_set_result;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 165;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_c623dd0c947983ab2cfcbe4c53400720;
    frame_c196634e750512d513f350e0875f8a1f->m_frame.f_lineno = 166;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 166;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c196634e750512d513f350e0875f8a1f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c196634e750512d513f350e0875f8a1f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c196634e750512d513f350e0875f8a1f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c196634e750512d513f350e0875f8a1f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c196634e750512d513f350e0875f8a1f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c196634e750512d513f350e0875f8a1f,
        type_description_1,
        par_boundary,
        par_when,
        var_set_result
    );


    // Release cached frame.
    if ( frame_c196634e750512d513f350e0875f8a1f == cache_frame_c196634e750512d513f350e0875f8a1f )
    {
        Py_DECREF( frame_c196634e750512d513f350e0875f8a1f );
    }
    cache_frame_c196634e750512d513f350e0875f8a1f = NULL;

    assertFrameObject( frame_c196634e750512d513f350e0875f8a1f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_5__set_asn1_time );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_boundary );
    Py_DECREF( par_boundary );
    par_boundary = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_boundary );
    Py_DECREF( par_boundary );
    par_boundary = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_5__set_asn1_time );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_6__get_asn1_time( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_timestamp = python_pars[ 0 ];
    PyObject *var_generalized_timestamp = NULL;
    PyObject *var_string_result = NULL;
    PyObject *var_string_data = NULL;
    PyObject *var_string_timestamp = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_91f0594f09524e3872738633f4f7e4d8 = NULL;

    struct Nuitka_FrameObject *frame_91f0594f09524e3872738633f4f7e4d8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_91f0594f09524e3872738633f4f7e4d8, codeobj_91f0594f09524e3872738633f4f7e4d8, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_91f0594f09524e3872738633f4f7e4d8 = cache_frame_91f0594f09524e3872738633f4f7e4d8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_91f0594f09524e3872738633f4f7e4d8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_91f0594f09524e3872738633f4f7e4d8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 179;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9;
    tmp_args_element_name_2 = par_timestamp;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_91f0594f09524e3872738633f4f7e4d8->m_frame.f_lineno = 179;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_cast, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 179;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_string_timestamp == NULL );
    var_string_timestamp = tmp_assign_source_1;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 180;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_string_timestamp;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_91f0594f09524e3872738633f4f7e4d8->m_frame.f_lineno = 180;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_compare_left_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_ASN1_STRING_length, call_args );
    }

    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 180;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 180;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 183;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = var_string_timestamp;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_91f0594f09524e3872738633f4f7e4d8->m_frame.f_lineno = 183;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_compare_left_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_ASN1_STRING_type, call_args );
    }

    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 183;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_compare_left_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 183;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_V_ASN1_GENERALIZEDTIME );
    if ( tmp_compare_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 183;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 183;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_2 );
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 185;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_string );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 185;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 185;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = var_string_timestamp;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_91f0594f09524e3872738633f4f7e4d8->m_frame.f_lineno = 185;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_args_element_name_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_ASN1_STRING_data, call_args );
    }

    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 185;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_91f0594f09524e3872738633f4f7e4d8->m_frame.f_lineno = 185;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 185;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_2;
    branch_no_2:;
    tmp_called_instance_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_5 == NULL ))
    {
        tmp_called_instance_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 187;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_91f0594f09524e3872738633f4f7e4d8->m_frame.f_lineno = 187;
    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_0d925750cb36e0c0e5f47f40c47790e6_tuple, 0 ) );

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 187;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_generalized_timestamp == NULL );
    var_generalized_timestamp = tmp_assign_source_2;

    tmp_called_instance_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_6 == NULL ))
    {
        tmp_called_instance_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 188;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = par_timestamp;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = var_generalized_timestamp;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_91f0594f09524e3872738633f4f7e4d8->m_frame.f_lineno = 188;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_6, const_str_plain_ASN1_TIME_to_generalizedtime, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 188;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_subscribed_name_1 = var_generalized_timestamp;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_compare_left_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_compare_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 189;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_compare_left_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 189;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_3 );

        exception_lineno = 189;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_3 );
        Py_DECREF( tmp_compare_right_3 );

        exception_lineno = 189;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_3 );
    Py_DECREF( tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__untested_error );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__untested_error );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_untested_error" );
        exception_tb = NULL;

        exception_lineno = 199;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_91f0594f09524e3872738633f4f7e4d8->m_frame.f_lineno = 199;
    tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, &PyTuple_GET_ITEM( const_tuple_str_plain_ASN1_TIME_to_generalizedtime_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 199;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_3;
    branch_no_3:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 201;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_cast );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 201;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9;
    tmp_subscribed_name_2 = var_generalized_timestamp;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_0;
    tmp_args_element_name_10 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 202;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_91f0594f09524e3872738633f4f7e4d8->m_frame.f_lineno = 201;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 201;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_string_timestamp;
        assert( old != NULL );
        var_string_timestamp = tmp_assign_source_3;
        Py_DECREF( old );
    }

    tmp_called_instance_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_7 == NULL ))
    {
        tmp_called_instance_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 204;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = var_string_timestamp;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_91f0594f09524e3872738633f4f7e4d8->m_frame.f_lineno = 204;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_ASN1_STRING_data, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 204;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_string_data == NULL );
    var_string_data = tmp_assign_source_4;

    tmp_called_instance_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_8 == NULL ))
    {
        tmp_called_instance_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 205;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_12 = var_string_data;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_91f0594f09524e3872738633f4f7e4d8->m_frame.f_lineno = 205;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_8, const_str_plain_string, call_args );
    }

    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 205;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_string_result == NULL );
    var_string_result = tmp_assign_source_5;

    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 206;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_ASN1_GENERALIZEDTIME_free );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 206;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = var_generalized_timestamp;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_0;
    tmp_args_element_name_13 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 206;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_91f0594f09524e3872738633f4f7e4d8->m_frame.f_lineno = 206;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_13 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 206;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_return_value = var_string_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_end_3:;
    branch_end_2:;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_91f0594f09524e3872738633f4f7e4d8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_91f0594f09524e3872738633f4f7e4d8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_91f0594f09524e3872738633f4f7e4d8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_91f0594f09524e3872738633f4f7e4d8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_91f0594f09524e3872738633f4f7e4d8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_91f0594f09524e3872738633f4f7e4d8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_91f0594f09524e3872738633f4f7e4d8,
        type_description_1,
        par_timestamp,
        var_generalized_timestamp,
        var_string_result,
        var_string_data,
        var_string_timestamp
    );


    // Release cached frame.
    if ( frame_91f0594f09524e3872738633f4f7e4d8 == cache_frame_91f0594f09524e3872738633f4f7e4d8 )
    {
        Py_DECREF( frame_91f0594f09524e3872738633f4f7e4d8 );
    }
    cache_frame_91f0594f09524e3872738633f4f7e4d8 = NULL;

    assertFrameObject( frame_91f0594f09524e3872738633f4f7e4d8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_6__get_asn1_time );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_timestamp );
    Py_DECREF( par_timestamp );
    par_timestamp = NULL;

    Py_XDECREF( var_generalized_timestamp );
    var_generalized_timestamp = NULL;

    Py_XDECREF( var_string_result );
    var_string_result = NULL;

    Py_XDECREF( var_string_data );
    var_string_data = NULL;

    CHECK_OBJECT( (PyObject *)var_string_timestamp );
    Py_DECREF( var_string_timestamp );
    var_string_timestamp = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_timestamp );
    Py_DECREF( par_timestamp );
    par_timestamp = NULL;

    Py_XDECREF( var_generalized_timestamp );
    var_generalized_timestamp = NULL;

    Py_XDECREF( var_string_result );
    var_string_result = NULL;

    Py_XDECREF( var_string_data );
    var_string_data = NULL;

    Py_XDECREF( var_string_timestamp );
    var_string_timestamp = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_6__get_asn1_time );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_7___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_3fbfe9df01a81af8e37bd5a7f5ae6696 = NULL;

    struct Nuitka_FrameObject *frame_3fbfe9df01a81af8e37bd5a7f5ae6696;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3fbfe9df01a81af8e37bd5a7f5ae6696, codeobj_3fbfe9df01a81af8e37bd5a7f5ae6696, module_OpenSSL$crypto, sizeof(void *) );
    frame_3fbfe9df01a81af8e37bd5a7f5ae6696 = cache_frame_3fbfe9df01a81af8e37bd5a7f5ae6696;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3fbfe9df01a81af8e37bd5a7f5ae6696 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3fbfe9df01a81af8e37bd5a7f5ae6696 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = PyList_New( 0 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__names, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 212;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3fbfe9df01a81af8e37bd5a7f5ae6696 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3fbfe9df01a81af8e37bd5a7f5ae6696 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3fbfe9df01a81af8e37bd5a7f5ae6696, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3fbfe9df01a81af8e37bd5a7f5ae6696->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3fbfe9df01a81af8e37bd5a7f5ae6696, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3fbfe9df01a81af8e37bd5a7f5ae6696,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_3fbfe9df01a81af8e37bd5a7f5ae6696 == cache_frame_3fbfe9df01a81af8e37bd5a7f5ae6696 )
    {
        Py_DECREF( frame_3fbfe9df01a81af8e37bd5a7f5ae6696 );
    }
    cache_frame_3fbfe9df01a81af8e37bd5a7f5ae6696 = NULL;

    assertFrameObject( frame_3fbfe9df01a81af8e37bd5a7f5ae6696 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_7___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_7___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_8_add( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_d0b5dc3540b8ce76d706929407f28bf8 = NULL;

    struct Nuitka_FrameObject *frame_d0b5dc3540b8ce76d706929407f28bf8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d0b5dc3540b8ce76d706929407f28bf8, codeobj_d0b5dc3540b8ce76d706929407f28bf8, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_d0b5dc3540b8ce76d706929407f28bf8 = cache_frame_d0b5dc3540b8ce76d706929407f28bf8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d0b5dc3540b8ce76d706929407f28bf8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d0b5dc3540b8ce76d706929407f28bf8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__names );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 215;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_name;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_d0b5dc3540b8ce76d706929407f28bf8->m_frame.f_lineno = 215;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 215;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0b5dc3540b8ce76d706929407f28bf8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0b5dc3540b8ce76d706929407f28bf8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d0b5dc3540b8ce76d706929407f28bf8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d0b5dc3540b8ce76d706929407f28bf8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d0b5dc3540b8ce76d706929407f28bf8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d0b5dc3540b8ce76d706929407f28bf8,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if ( frame_d0b5dc3540b8ce76d706929407f28bf8 == cache_frame_d0b5dc3540b8ce76d706929407f28bf8 )
    {
        Py_DECREF( frame_d0b5dc3540b8ce76d706929407f28bf8 );
    }
    cache_frame_d0b5dc3540b8ce76d706929407f28bf8 = NULL;

    assertFrameObject( frame_d0b5dc3540b8ce76d706929407f28bf8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_8_add );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_8_add );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_9_clear( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_name = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_attrdel_target_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_f3c023895e4501d84ce768a27bdd335b = NULL;

    struct Nuitka_FrameObject *frame_f3c023895e4501d84ce768a27bdd335b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f3c023895e4501d84ce768a27bdd335b, codeobj_f3c023895e4501d84ce768a27bdd335b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_f3c023895e4501d84ce768a27bdd335b = cache_frame_f3c023895e4501d84ce768a27bdd335b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f3c023895e4501d84ce768a27bdd335b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f3c023895e4501d84ce768a27bdd335b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__names );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 218;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 218;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oo";
        exception_lineno = 218;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 218;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_name;
        var_name = tmp_assign_source_3;
        Py_INCREF( var_name );
        Py_XDECREF( old );
    }

    tmp_attrdel_target_1 = var_name;

    CHECK_OBJECT( tmp_attrdel_target_1 );
    tmp_res = PyObject_DelAttr( tmp_attrdel_target_1, const_str_plain__name );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 220;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 218;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3c023895e4501d84ce768a27bdd335b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3c023895e4501d84ce768a27bdd335b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f3c023895e4501d84ce768a27bdd335b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f3c023895e4501d84ce768a27bdd335b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f3c023895e4501d84ce768a27bdd335b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f3c023895e4501d84ce768a27bdd335b,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if ( frame_f3c023895e4501d84ce768a27bdd335b == cache_frame_f3c023895e4501d84ce768a27bdd335b )
    {
        Py_DECREF( frame_f3c023895e4501d84ce768a27bdd335b );
    }
    cache_frame_f3c023895e4501d84ce768a27bdd335b = NULL;

    assertFrameObject( frame_f3c023895e4501d84ce768a27bdd335b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_9_clear );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_9_clear );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_10___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_pkey = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_c420853ec5373143d72a06d844a52757 = NULL;

    struct Nuitka_FrameObject *frame_c420853ec5373143d72a06d844a52757;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c420853ec5373143d72a06d844a52757, codeobj_c420853ec5373143d72a06d844a52757, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_c420853ec5373143d72a06d844a52757 = cache_frame_c420853ec5373143d72a06d844a52757;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c420853ec5373143d72a06d844a52757 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c420853ec5373143d72a06d844a52757 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 232;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_c420853ec5373143d72a06d844a52757->m_frame.f_lineno = 232;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_EVP_PKEY_new );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 232;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_pkey == NULL );
    var_pkey = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 233;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 233;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_pkey;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 233;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_EVP_PKEY_free );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 233;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_c420853ec5373143d72a06d844a52757->m_frame.f_lineno = 233;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 233;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 233;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_assattr_name_2 = Py_False;
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__initialized, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 234;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c420853ec5373143d72a06d844a52757 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c420853ec5373143d72a06d844a52757 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c420853ec5373143d72a06d844a52757, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c420853ec5373143d72a06d844a52757->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c420853ec5373143d72a06d844a52757, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c420853ec5373143d72a06d844a52757,
        type_description_1,
        par_self,
        var_pkey
    );


    // Release cached frame.
    if ( frame_c420853ec5373143d72a06d844a52757 == cache_frame_c420853ec5373143d72a06d844a52757 )
    {
        Py_DECREF( frame_c420853ec5373143d72a06d844a52757 );
    }
    cache_frame_c420853ec5373143d72a06d844a52757 = NULL;

    assertFrameObject( frame_c420853ec5373143d72a06d844a52757 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_10___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_10___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_11_to_cryptography_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_backend = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    static struct Nuitka_FrameObject *cache_frame_0b51c794f2deb346eb163bcfa124fc96 = NULL;

    struct Nuitka_FrameObject *frame_0b51c794f2deb346eb163bcfa124fc96;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0b51c794f2deb346eb163bcfa124fc96, codeobj_0b51c794f2deb346eb163bcfa124fc96, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_0b51c794f2deb346eb163bcfa124fc96 = cache_frame_0b51c794f2deb346eb163bcfa124fc96;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0b51c794f2deb346eb163bcfa124fc96 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0b51c794f2deb346eb163bcfa124fc96 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__get_backend );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_get_backend" );
        exception_tb = NULL;

        exception_lineno = 247;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_0b51c794f2deb346eb163bcfa124fc96->m_frame.f_lineno = 247;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 247;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_backend == NULL );
    var_backend = tmp_assign_source_1;

    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__only_public );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 248;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 248;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = var_backend;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__evp_pkey_to_public_key );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 249;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_0b51c794f2deb346eb163bcfa124fc96->m_frame.f_lineno = 249;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_4 = var_backend;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__evp_pkey_to_private_key );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 251;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__pkey );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 251;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_0b51c794f2deb346eb163bcfa124fc96->m_frame.f_lineno = 251;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 251;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b51c794f2deb346eb163bcfa124fc96 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b51c794f2deb346eb163bcfa124fc96 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b51c794f2deb346eb163bcfa124fc96 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0b51c794f2deb346eb163bcfa124fc96, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0b51c794f2deb346eb163bcfa124fc96->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0b51c794f2deb346eb163bcfa124fc96, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0b51c794f2deb346eb163bcfa124fc96,
        type_description_1,
        par_self,
        var_backend
    );


    // Release cached frame.
    if ( frame_0b51c794f2deb346eb163bcfa124fc96 == cache_frame_0b51c794f2deb346eb163bcfa124fc96 )
    {
        Py_DECREF( frame_0b51c794f2deb346eb163bcfa124fc96 );
    }
    cache_frame_0b51c794f2deb346eb163bcfa124fc96 = NULL;

    assertFrameObject( frame_0b51c794f2deb346eb163bcfa124fc96 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_11_to_cryptography_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_backend );
    Py_DECREF( var_backend );
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_backend );
    var_backend = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_11_to_cryptography_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_12_from_cryptography_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_crypto_key = python_pars[ 1 ];
    PyObject *var_pkey = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    static struct Nuitka_FrameObject *cache_frame_3a363175d5408a6bc23af5d6f91497ed = NULL;

    struct Nuitka_FrameObject *frame_3a363175d5408a6bc23af5d6f91497ed;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3a363175d5408a6bc23af5d6f91497ed, codeobj_3a363175d5408a6bc23af5d6f91497ed, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3a363175d5408a6bc23af5d6f91497ed = cache_frame_3a363175d5408a6bc23af5d6f91497ed;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3a363175d5408a6bc23af5d6f91497ed );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3a363175d5408a6bc23af5d6f91497ed ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = par_cls;

    CHECK_OBJECT( tmp_called_name_1 );
    frame_3a363175d5408a6bc23af5d6f91497ed->m_frame.f_lineno = 265;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 265;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_pkey == NULL );
    var_pkey = tmp_assign_source_1;

    tmp_isinstance_inst_1 = par_crypto_key;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = PyTuple_New( 4 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_rsa );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_rsa );
    }

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_isinstance_cls_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "rsa" );
        exception_tb = NULL;

        exception_lineno = 269;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_RSAPublicKey );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_cls_1 );

        exception_lineno = 269;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_1, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_rsa );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_rsa );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_isinstance_cls_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "rsa" );
        exception_tb = NULL;

        exception_lineno = 270;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_RSAPrivateKey );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_cls_1 );

        exception_lineno = 270;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_1, 1, tmp_tuple_element_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dsa );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_dsa );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_isinstance_cls_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "dsa" );
        exception_tb = NULL;

        exception_lineno = 271;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_DSAPublicKey );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_cls_1 );

        exception_lineno = 271;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_1, 2, tmp_tuple_element_1 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dsa );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_dsa );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_isinstance_cls_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "dsa" );
        exception_tb = NULL;

        exception_lineno = 272;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_DSAPrivateKey );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_cls_1 );

        exception_lineno = 272;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_1, 3, tmp_tuple_element_1 );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_290681512f72ca11cbf3e4827987aabb;
    frame_3a363175d5408a6bc23af5d6f91497ed->m_frame.f_lineno = 275;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 275;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_5 = par_crypto_key;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__evp_pkey );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 277;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 277;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_isinstance_inst_2 = par_crypto_key;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_isinstance_cls_2 = PyTuple_New( 2 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_rsa );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_rsa );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_isinstance_cls_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "rsa" );
        exception_tb = NULL;

        exception_lineno = 278;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_RSAPublicKey );
    if ( tmp_tuple_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_cls_2 );

        exception_lineno = 278;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_2, 0, tmp_tuple_element_2 );
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dsa );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_dsa );
    }

    if ( tmp_source_name_7 == NULL )
    {
        Py_DECREF( tmp_isinstance_cls_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "dsa" );
        exception_tb = NULL;

        exception_lineno = 278;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_DSAPublicKey );
    if ( tmp_tuple_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_cls_2 );

        exception_lineno = 278;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_2, 1, tmp_tuple_element_2 );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    Py_DECREF( tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 278;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assattr_name_2 = Py_True;
    tmp_assattr_target_2 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__only_public, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 279;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    branch_no_2:;
    tmp_assattr_name_3 = Py_True;
    tmp_assattr_target_3 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__initialized, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 280;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3a363175d5408a6bc23af5d6f91497ed );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3a363175d5408a6bc23af5d6f91497ed );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3a363175d5408a6bc23af5d6f91497ed, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3a363175d5408a6bc23af5d6f91497ed->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3a363175d5408a6bc23af5d6f91497ed, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3a363175d5408a6bc23af5d6f91497ed,
        type_description_1,
        par_cls,
        par_crypto_key,
        var_pkey
    );


    // Release cached frame.
    if ( frame_3a363175d5408a6bc23af5d6f91497ed == cache_frame_3a363175d5408a6bc23af5d6f91497ed )
    {
        Py_DECREF( frame_3a363175d5408a6bc23af5d6f91497ed );
    }
    cache_frame_3a363175d5408a6bc23af5d6f91497ed = NULL;

    assertFrameObject( frame_3a363175d5408a6bc23af5d6f91497ed );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_pkey;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_12_from_cryptography_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_crypto_key );
    Py_DECREF( par_crypto_key );
    par_crypto_key = NULL;

    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_crypto_key );
    Py_DECREF( par_crypto_key );
    par_crypto_key = NULL;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_12_from_cryptography_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_13_generate_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_type = python_pars[ 1 ];
    PyObject *par_bits = python_pars[ 2 ];
    PyObject *var_exponent = NULL;
    PyObject *var_rsa = NULL;
    PyObject *var_result = NULL;
    PyObject *var_res = NULL;
    PyObject *var_dsa = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_element_name_22;
    PyObject *tmp_args_element_name_23;
    PyObject *tmp_args_element_name_24;
    PyObject *tmp_args_element_name_25;
    PyObject *tmp_args_element_name_26;
    PyObject *tmp_args_element_name_27;
    PyObject *tmp_args_element_name_28;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_LtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_left_4;
    PyObject *tmp_compexpr_left_5;
    PyObject *tmp_compexpr_left_6;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    PyObject *tmp_compexpr_right_4;
    PyObject *tmp_compexpr_right_5;
    PyObject *tmp_compexpr_right_6;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_raise_type_4;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_319356766fa623fbb53f8001dc596471 = NULL;

    struct Nuitka_FrameObject *frame_319356766fa623fbb53f8001dc596471;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_319356766fa623fbb53f8001dc596471, codeobj_319356766fa623fbb53f8001dc596471, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_319356766fa623fbb53f8001dc596471 = cache_frame_319356766fa623fbb53f8001dc596471;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_319356766fa623fbb53f8001dc596471 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_319356766fa623fbb53f8001dc596471 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_type;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 299;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_50f07d7dbc7dc060eb5685744b92c007;
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 300;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 300;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_isinstance_inst_2 = par_bits;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_isinstance_cls_2 = (PyObject *)&PyInt_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 302;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_3910fdd1c3b683a0988d08f77454ce47;
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 303;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 303;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_compare_left_1 = par_type;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_RSA );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TYPE_RSA );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "TYPE_RSA" );
        exception_tb = NULL;

        exception_lineno = 305;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 305;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_compare_left_2 = par_bits;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = const_int_0;
    tmp_cmp_LtE_1 = RICH_COMPARE_BOOL_LE( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_LtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 306;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_LtE_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_make_exception_arg_3 = const_str_digest_4fd5a0c1d1fb7366c52acc7b3ac0b5b1;
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 307;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 307;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooo";
    goto frame_exception_exit_1;
    branch_no_4:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 310;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 310;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_BN_new );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 310;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_exponent == NULL );
    var_exponent = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 311;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 311;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_exponent;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 311;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_BN_free );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 311;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 311;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 311;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_exponent;
        assert( old != NULL );
        var_exponent = tmp_assign_source_2;
        Py_DECREF( old );
    }

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 312;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_BN_set_word );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_exponent;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 312;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_RSA_F4 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 312;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 312;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 314;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 314;
    tmp_assign_source_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_RSA_new );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 314;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_rsa == NULL );
    var_rsa = tmp_assign_source_3;

    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 316;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_RSA_generate_key_ex );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 316;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_rsa;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = par_bits;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = var_exponent;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 316;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 316;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 316;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 316;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_4;

    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 317;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_9 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 317;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 317;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 317;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 319;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_EVP_PKEY_assign_RSA );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 319;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = par_self;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__pkey );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 319;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_11 = var_rsa;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 319;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 319;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_result;
        assert( old != NULL );
        var_result = tmp_assign_source_5;
        Py_DECREF( old );
    }

    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 320;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_2 = var_result;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = const_int_pos_1;
    tmp_args_element_name_12 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    if ( tmp_args_element_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 320;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 320;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_args_element_name_12 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 320;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_3;
    branch_no_3:;
    tmp_compare_left_3 = par_type;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_DSA );

    if (unlikely( tmp_compare_right_3 == NULL ))
    {
        tmp_compare_right_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TYPE_DSA );
    }

    if ( tmp_compare_right_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "TYPE_DSA" );
        exception_tb = NULL;

        exception_lineno = 322;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 322;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 323;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 323;
    tmp_assign_source_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_DSA_new );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 323;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_dsa == NULL );
    var_dsa = tmp_assign_source_6;

    tmp_called_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_7 == NULL ))
    {
        tmp_called_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 324;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_3 = var_dsa;

    CHECK_OBJECT( tmp_compexpr_left_3 );
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 324;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_NULL );
    if ( tmp_compexpr_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 324;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_13 = RICH_COMPARE_NE( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    Py_DECREF( tmp_compexpr_right_3 );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 324;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 324;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_args_element_name_13 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 324;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 326;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_gc );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 326;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_14 = var_dsa;

    CHECK_OBJECT( tmp_args_element_name_14 );
    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_11 == NULL )
    {
        Py_DECREF( tmp_called_name_8 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 326;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_DSA_free );
    if ( tmp_args_element_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );

        exception_lineno = 326;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 326;
    {
        PyObject *call_args[] = { tmp_args_element_name_14, tmp_args_element_name_15 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_called_name_8 );
    Py_DECREF( tmp_args_element_name_15 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 326;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_dsa;
        assert( old != NULL );
        var_dsa = tmp_assign_source_7;
        Py_DECREF( old );
    }

    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 327;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_DSA_generate_parameters_ex );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 327;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_16 = var_dsa;

    CHECK_OBJECT( tmp_args_element_name_16 );
    tmp_args_element_name_17 = par_bits;

    CHECK_OBJECT( tmp_args_element_name_17 );
    tmp_source_name_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_13 == NULL ))
    {
        tmp_source_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_13 == NULL )
    {
        Py_DECREF( tmp_called_name_9 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 328;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_18 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_NULL );
    if ( tmp_args_element_name_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );

        exception_lineno = 328;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_19 = const_int_0;
    tmp_source_name_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_14 == NULL ))
    {
        tmp_source_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_14 == NULL )
    {
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_18 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 328;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_20 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_NULL );
    if ( tmp_args_element_name_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_18 );

        exception_lineno = 328;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_15 == NULL ))
    {
        tmp_source_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_15 == NULL )
    {
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_18 );
        Py_DECREF( tmp_args_element_name_20 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 328;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_21 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_NULL );
    if ( tmp_args_element_name_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_18 );
        Py_DECREF( tmp_args_element_name_20 );

        exception_lineno = 328;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_16 == NULL ))
    {
        tmp_source_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_16 == NULL )
    {
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_18 );
        Py_DECREF( tmp_args_element_name_20 );
        Py_DECREF( tmp_args_element_name_21 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 328;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_22 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_NULL );
    if ( tmp_args_element_name_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_18 );
        Py_DECREF( tmp_args_element_name_20 );
        Py_DECREF( tmp_args_element_name_21 );

        exception_lineno = 328;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 327;
    {
        PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19, tmp_args_element_name_20, tmp_args_element_name_21, tmp_args_element_name_22 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS7( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_element_name_18 );
    Py_DECREF( tmp_args_element_name_20 );
    Py_DECREF( tmp_args_element_name_21 );
    Py_DECREF( tmp_args_element_name_22 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 327;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_res == NULL );
    var_res = tmp_assign_source_8;

    tmp_called_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_10 == NULL ))
    {
        tmp_called_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 330;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_4 = var_res;

    CHECK_OBJECT( tmp_compexpr_left_4 );
    tmp_compexpr_right_4 = const_int_pos_1;
    tmp_args_element_name_23 = RICH_COMPARE_EQ( tmp_compexpr_left_4, tmp_compexpr_right_4 );
    if ( tmp_args_element_name_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 330;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 330;
    {
        PyObject *call_args[] = { tmp_args_element_name_23 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
    }

    Py_DECREF( tmp_args_element_name_23 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 330;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_11 == NULL ))
    {
        tmp_called_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 332;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 332;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_25 = var_dsa;

    CHECK_OBJECT( tmp_args_element_name_25 );
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 332;
    {
        PyObject *call_args[] = { tmp_args_element_name_25 };
        tmp_compexpr_left_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_DSA_generate_key, call_args );
    }

    if ( tmp_compexpr_left_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 332;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_5 = const_int_pos_1;
    tmp_args_element_name_24 = RICH_COMPARE_EQ( tmp_compexpr_left_5, tmp_compexpr_right_5 );
    Py_DECREF( tmp_compexpr_left_5 );
    if ( tmp_args_element_name_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 332;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 332;
    {
        PyObject *call_args[] = { tmp_args_element_name_24 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    Py_DECREF( tmp_args_element_name_24 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 332;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_12 == NULL ))
    {
        tmp_called_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 333;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_17 == NULL ))
    {
        tmp_source_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 333;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_EVP_PKEY_set1_DSA );
    if ( tmp_called_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 333;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_18 = par_self;

    CHECK_OBJECT( tmp_source_name_18 );
    tmp_args_element_name_27 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain__pkey );
    if ( tmp_args_element_name_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_13 );

        exception_lineno = 333;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_28 = var_dsa;

    CHECK_OBJECT( tmp_args_element_name_28 );
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 333;
    {
        PyObject *call_args[] = { tmp_args_element_name_27, tmp_args_element_name_28 };
        tmp_compexpr_left_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_13, call_args );
    }

    Py_DECREF( tmp_called_name_13 );
    Py_DECREF( tmp_args_element_name_27 );
    if ( tmp_compexpr_left_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 333;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_6 = const_int_pos_1;
    tmp_args_element_name_26 = RICH_COMPARE_EQ( tmp_compexpr_left_6, tmp_compexpr_right_6 );
    Py_DECREF( tmp_compexpr_left_6 );
    if ( tmp_args_element_name_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 333;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 333;
    {
        PyObject *call_args[] = { tmp_args_element_name_26 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_12, call_args );
    }

    Py_DECREF( tmp_args_element_name_26 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 333;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_5;
    branch_no_5:;
    tmp_called_name_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_called_name_14 == NULL ))
    {
        tmp_called_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_called_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 335;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_319356766fa623fbb53f8001dc596471->m_frame.f_lineno = 335;
    tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, &PyTuple_GET_ITEM( const_tuple_str_digest_e2d15f7f418fdd55a54be9ea476feee3_tuple, 0 ) );

    if ( tmp_raise_type_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 335;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_4;
    exception_lineno = 335;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooo";
    goto frame_exception_exit_1;
    branch_end_5:;
    branch_end_3:;
    tmp_assattr_name_1 = Py_True;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__initialized, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 337;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_319356766fa623fbb53f8001dc596471 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_319356766fa623fbb53f8001dc596471 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_319356766fa623fbb53f8001dc596471, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_319356766fa623fbb53f8001dc596471->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_319356766fa623fbb53f8001dc596471, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_319356766fa623fbb53f8001dc596471,
        type_description_1,
        par_self,
        par_type,
        par_bits,
        var_exponent,
        var_rsa,
        var_result,
        var_res,
        var_dsa
    );


    // Release cached frame.
    if ( frame_319356766fa623fbb53f8001dc596471 == cache_frame_319356766fa623fbb53f8001dc596471 )
    {
        Py_DECREF( frame_319356766fa623fbb53f8001dc596471 );
    }
    cache_frame_319356766fa623fbb53f8001dc596471 = NULL;

    assertFrameObject( frame_319356766fa623fbb53f8001dc596471 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_13_generate_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_exponent );
    var_exponent = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_rsa );
    var_rsa = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_res );
    var_res = NULL;

    CHECK_OBJECT( (PyObject *)par_bits );
    Py_DECREF( par_bits );
    par_bits = NULL;

    Py_XDECREF( var_dsa );
    var_dsa = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_exponent );
    var_exponent = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_rsa );
    var_rsa = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_res );
    var_res = NULL;

    CHECK_OBJECT( (PyObject *)par_bits );
    Py_DECREF( par_bits );
    par_bits = NULL;

    Py_XDECREF( var_dsa );
    var_dsa = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_13_generate_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_14_check( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_rsa = NULL;
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_70275adf8e6632812c63bb55ba5541ea = NULL;

    struct Nuitka_FrameObject *frame_70275adf8e6632812c63bb55ba5541ea;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_70275adf8e6632812c63bb55ba5541ea, codeobj_70275adf8e6632812c63bb55ba5541ea, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_70275adf8e6632812c63bb55ba5541ea = cache_frame_70275adf8e6632812c63bb55ba5541ea;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_70275adf8e6632812c63bb55ba5541ea );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_70275adf8e6632812c63bb55ba5541ea ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__only_public );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 352;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 352;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_3d684470d9353bc1a1e8d63a3aab4679;
    frame_70275adf8e6632812c63bb55ba5541ea->m_frame.f_lineno = 353;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 353;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 355;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_EVP_PKEY_type );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 355;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_70275adf8e6632812c63bb55ba5541ea->m_frame.f_lineno = 355;
    tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_type );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 355;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_70275adf8e6632812c63bb55ba5541ea->m_frame.f_lineno = 355;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_compare_left_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 355;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_compare_left_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 355;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_EVP_PKEY_RSA );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 355;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 355;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_c85d62bfc2af2f3c2202464fd6374ea7;
    frame_70275adf8e6632812c63bb55ba5541ea->m_frame.f_lineno = 356;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 356;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 358;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_EVP_PKEY_get1_RSA );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 358;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__pkey );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 358;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_70275adf8e6632812c63bb55ba5541ea->m_frame.f_lineno = 358;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 358;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_rsa == NULL );
    var_rsa = tmp_assign_source_1;

    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 359;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_gc );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 359;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_rsa;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 359;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_RSA_free );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 359;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_70275adf8e6632812c63bb55ba5541ea->m_frame.f_lineno = 359;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 359;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_rsa;
        assert( old != NULL );
        var_rsa = tmp_assign_source_2;
        Py_DECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 360;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = var_rsa;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_70275adf8e6632812c63bb55ba5541ea->m_frame.f_lineno = 360;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_RSA_check_key, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 360;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_3;

    tmp_compare_left_2 = var_result;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = const_int_pos_1;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 361;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_3:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 363;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_70275adf8e6632812c63bb55ba5541ea->m_frame.f_lineno = 363;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 363;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_70275adf8e6632812c63bb55ba5541ea );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_70275adf8e6632812c63bb55ba5541ea );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_70275adf8e6632812c63bb55ba5541ea );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_70275adf8e6632812c63bb55ba5541ea, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_70275adf8e6632812c63bb55ba5541ea->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_70275adf8e6632812c63bb55ba5541ea, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_70275adf8e6632812c63bb55ba5541ea,
        type_description_1,
        par_self,
        var_rsa,
        var_result
    );


    // Release cached frame.
    if ( frame_70275adf8e6632812c63bb55ba5541ea == cache_frame_70275adf8e6632812c63bb55ba5541ea )
    {
        Py_DECREF( frame_70275adf8e6632812c63bb55ba5541ea );
    }
    cache_frame_70275adf8e6632812c63bb55ba5541ea = NULL;

    assertFrameObject( frame_70275adf8e6632812c63bb55ba5541ea );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_14_check );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_rsa );
    Py_DECREF( var_rsa );
    var_rsa = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_rsa );
    var_rsa = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_14_check );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_15_type( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_581db0cca4d33e8ad35e2569a0dead0b = NULL;

    struct Nuitka_FrameObject *frame_581db0cca4d33e8ad35e2569a0dead0b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_581db0cca4d33e8ad35e2569a0dead0b, codeobj_581db0cca4d33e8ad35e2569a0dead0b, module_OpenSSL$crypto, sizeof(void *) );
    frame_581db0cca4d33e8ad35e2569a0dead0b = cache_frame_581db0cca4d33e8ad35e2569a0dead0b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_581db0cca4d33e8ad35e2569a0dead0b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_581db0cca4d33e8ad35e2569a0dead0b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 371;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EVP_PKEY_id );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 371;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__pkey );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 371;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_581db0cca4d33e8ad35e2569a0dead0b->m_frame.f_lineno = 371;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 371;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_581db0cca4d33e8ad35e2569a0dead0b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_581db0cca4d33e8ad35e2569a0dead0b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_581db0cca4d33e8ad35e2569a0dead0b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_581db0cca4d33e8ad35e2569a0dead0b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_581db0cca4d33e8ad35e2569a0dead0b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_581db0cca4d33e8ad35e2569a0dead0b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_581db0cca4d33e8ad35e2569a0dead0b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_581db0cca4d33e8ad35e2569a0dead0b == cache_frame_581db0cca4d33e8ad35e2569a0dead0b )
    {
        Py_DECREF( frame_581db0cca4d33e8ad35e2569a0dead0b );
    }
    cache_frame_581db0cca4d33e8ad35e2569a0dead0b = NULL;

    assertFrameObject( frame_581db0cca4d33e8ad35e2569a0dead0b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_15_type );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_15_type );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_16_bits( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_d646955fcdf80afde1b63bdd49140dae = NULL;

    struct Nuitka_FrameObject *frame_d646955fcdf80afde1b63bdd49140dae;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d646955fcdf80afde1b63bdd49140dae, codeobj_d646955fcdf80afde1b63bdd49140dae, module_OpenSSL$crypto, sizeof(void *) );
    frame_d646955fcdf80afde1b63bdd49140dae = cache_frame_d646955fcdf80afde1b63bdd49140dae;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d646955fcdf80afde1b63bdd49140dae );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d646955fcdf80afde1b63bdd49140dae ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 379;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EVP_PKEY_bits );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 379;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__pkey );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 379;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_d646955fcdf80afde1b63bdd49140dae->m_frame.f_lineno = 379;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 379;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d646955fcdf80afde1b63bdd49140dae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d646955fcdf80afde1b63bdd49140dae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d646955fcdf80afde1b63bdd49140dae );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d646955fcdf80afde1b63bdd49140dae, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d646955fcdf80afde1b63bdd49140dae->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d646955fcdf80afde1b63bdd49140dae, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d646955fcdf80afde1b63bdd49140dae,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d646955fcdf80afde1b63bdd49140dae == cache_frame_d646955fcdf80afde1b63bdd49140dae )
    {
        Py_DECREF( frame_d646955fcdf80afde1b63bdd49140dae );
    }
    cache_frame_d646955fcdf80afde1b63bdd49140dae = NULL;

    assertFrameObject( frame_d646955fcdf80afde1b63bdd49140dae );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_16_bits );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_16_bits );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_17___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_object_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_type_name_1;
    static struct Nuitka_FrameObject *cache_frame_3017da2311b90aa13ec5c98739847c3a = NULL;

    struct Nuitka_FrameObject *frame_3017da2311b90aa13ec5c98739847c3a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3017da2311b90aa13ec5c98739847c3a, codeobj_3017da2311b90aa13ec5c98739847c3a, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_3017da2311b90aa13ec5c98739847c3a = cache_frame_3017da2311b90aa13ec5c98739847c3a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3017da2311b90aa13ec5c98739847c3a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3017da2311b90aa13ec5c98739847c3a ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__EllipticCurve );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__EllipticCurve );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_EllipticCurve" );
        exception_tb = NULL;

        exception_lineno = 403;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 403;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_type_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__EllipticCurve );

    if (unlikely( tmp_type_name_1 == NULL ))
    {
        tmp_type_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__EllipticCurve );
    }

    if ( tmp_type_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_EllipticCurve" );
        exception_tb = NULL;

        exception_lineno = 404;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_object_name_1 = par_self;

    CHECK_OBJECT( tmp_object_name_1 );
    tmp_called_instance_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 404;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_other;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_3017da2311b90aa13ec5c98739847c3a->m_frame.f_lineno = 404;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___ne__, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 404;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3017da2311b90aa13ec5c98739847c3a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3017da2311b90aa13ec5c98739847c3a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3017da2311b90aa13ec5c98739847c3a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3017da2311b90aa13ec5c98739847c3a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3017da2311b90aa13ec5c98739847c3a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3017da2311b90aa13ec5c98739847c3a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3017da2311b90aa13ec5c98739847c3a,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_3017da2311b90aa13ec5c98739847c3a == cache_frame_3017da2311b90aa13ec5c98739847c3a )
    {
        Py_DECREF( frame_3017da2311b90aa13ec5c98739847c3a );
    }
    cache_frame_3017da2311b90aa13ec5c98739847c3a = NULL;

    assertFrameObject( frame_3017da2311b90aa13ec5c98739847c3a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_17___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_17___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_18__load_elliptic_curves( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_cls = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_lib = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_builtin_curves = NULL;
    PyObject *var_num_curves = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_set_arg_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_9da9fa45beb0c9f41a9608504e4060ef = NULL;

    struct Nuitka_FrameObject *frame_9da9fa45beb0c9f41a9608504e4060ef;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9da9fa45beb0c9f41a9608504e4060ef, codeobj_9da9fa45beb0c9f41a9608504e4060ef, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9da9fa45beb0c9f41a9608504e4060ef = cache_frame_9da9fa45beb0c9f41a9608504e4060ef;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9da9fa45beb0c9f41a9608504e4060ef );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9da9fa45beb0c9f41a9608504e4060ef ) == 2 ); // Frame stack

    // Framed code:
    if ( par_lib == NULL )
    {
        tmp_source_name_1 = NULL;
    }
    else
    {
        tmp_source_name_1 = PyCell_GET( par_lib );
    }

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EC_get_builtin_curves );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 417;
        type_description_1 = "ccoo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 417;
        type_description_1 = "ccoo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 417;
        type_description_1 = "ccoo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = const_int_0;
    frame_9da9fa45beb0c9f41a9608504e4060ef->m_frame.f_lineno = 417;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 417;
        type_description_1 = "ccoo";
        goto frame_exception_exit_1;
    }
    assert( var_num_curves == NULL );
    var_num_curves = tmp_assign_source_1;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 418;
        type_description_1 = "ccoo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = const_str_digest_73f7a7ef7b02ca8c5d7fdfe1049be561;
    tmp_args_element_name_4 = var_num_curves;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_9da9fa45beb0c9f41a9608504e4060ef->m_frame.f_lineno = 418;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_new, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 418;
        type_description_1 = "ccoo";
        goto frame_exception_exit_1;
    }
    assert( var_builtin_curves == NULL );
    var_builtin_curves = tmp_assign_source_2;

    if ( par_lib == NULL )
    {
        tmp_called_instance_2 = NULL;
    }
    else
    {
        tmp_called_instance_2 = PyCell_GET( par_lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "lib" );
        exception_tb = NULL;

        exception_lineno = 422;
        type_description_1 = "ccoo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = var_builtin_curves;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = var_num_curves;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_9da9fa45beb0c9f41a9608504e4060ef->m_frame.f_lineno = 422;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_EC_get_builtin_curves, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 422;
        type_description_1 = "ccoo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_iter_arg_1 = var_builtin_curves;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 423;
        type_description_1 = "ccoo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_3;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_context,
        module_OpenSSL$crypto,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_10320fceee2af85afeed8b3d012ca947,
        3
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = par_cls;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] );
    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[1] = PyCell_NEW0( tmp_genexpr_1__$0 );
    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[2] = par_lib;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[2] );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 3 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_18__load_elliptic_curves );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_18__load_elliptic_curves );
    return NULL;
    outline_result_1:;
    tmp_set_arg_1 = tmp_outline_return_value_1;
    tmp_return_value = PySet_New( tmp_set_arg_1 );
    Py_DECREF( tmp_set_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 423;
        type_description_1 = "ccoo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9da9fa45beb0c9f41a9608504e4060ef );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9da9fa45beb0c9f41a9608504e4060ef );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9da9fa45beb0c9f41a9608504e4060ef );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9da9fa45beb0c9f41a9608504e4060ef, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9da9fa45beb0c9f41a9608504e4060ef->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9da9fa45beb0c9f41a9608504e4060ef, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9da9fa45beb0c9f41a9608504e4060ef,
        type_description_1,
        par_cls,
        par_lib,
        var_builtin_curves,
        var_num_curves
    );


    // Release cached frame.
    if ( frame_9da9fa45beb0c9f41a9608504e4060ef == cache_frame_9da9fa45beb0c9f41a9608504e4060ef )
    {
        Py_DECREF( frame_9da9fa45beb0c9f41a9608504e4060ef );
    }
    cache_frame_9da9fa45beb0c9f41a9608504e4060ef = NULL;

    assertFrameObject( frame_9da9fa45beb0c9f41a9608504e4060ef );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_18__load_elliptic_curves );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_builtin_curves );
    Py_DECREF( var_builtin_curves );
    var_builtin_curves = NULL;

    CHECK_OBJECT( (PyObject *)var_num_curves );
    Py_DECREF( var_num_curves );
    var_num_curves = NULL;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_builtin_curves );
    var_builtin_curves = NULL;

    Py_XDECREF( var_num_curves );
    var_num_curves = NULL;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_18__load_elliptic_curves );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_locals {
    PyObject *var_c
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_c = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_10320fceee2af85afeed8b3d012ca947, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[1] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[1] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "Nocc";
        exception_lineno = 423;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 423;
        type_description_1 = "Nocc";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_c;
        var_c = tmp_assign_source_2;
        Py_INCREF( var_c );
        Py_XDECREF( old );
    }

    if ( generator->m_closure[0] == NULL )
    {
        tmp_source_name_1 = NULL;
    }
    else
    {
        tmp_source_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "cls" );
        exception_tb = NULL;

        exception_lineno = 423;
        type_description_1 = "Nocc";
        goto try_except_handler_2;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_from_nid );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 423;
        type_description_1 = "Nocc";
        goto try_except_handler_2;
    }
    if ( generator->m_closure[2] == NULL )
    {
        tmp_args_element_name_1 = NULL;
    }
    else
    {
        tmp_args_element_name_1 = PyCell_GET( generator->m_closure[2] );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "lib" );
        exception_tb = NULL;

        exception_lineno = 423;
        type_description_1 = "Nocc";
        goto try_except_handler_2;
    }

    tmp_source_name_2 = var_c;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_nid );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 423;
        type_description_1 = "Nocc";
        goto try_except_handler_2;
    }
    generator->m_frame->m_frame.f_lineno = 423;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_expression_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 423;
        type_description_1 = "Nocc";
        goto try_except_handler_2;
    }
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 423;
        type_description_1 = "Nocc";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 423;
        type_description_1 = "Nocc";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_c,
            generator->m_closure[2],
            generator->m_closure[0]
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_c );
    var_c = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_c );
    var_c = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_OpenSSL$crypto$$$function_19__get_elliptic_curves( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_lib = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_is_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_7096b6ad0685416ea20fafee5d682357 = NULL;

    struct Nuitka_FrameObject *frame_7096b6ad0685416ea20fafee5d682357;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7096b6ad0685416ea20fafee5d682357, codeobj_7096b6ad0685416ea20fafee5d682357, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_7096b6ad0685416ea20fafee5d682357 = cache_frame_7096b6ad0685416ea20fafee5d682357;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7096b6ad0685416ea20fafee5d682357 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7096b6ad0685416ea20fafee5d682357 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_cls;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__curves );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 435;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_cls;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_lib;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_7096b6ad0685416ea20fafee5d682357->m_frame.f_lineno = 436;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__load_elliptic_curves, call_args );
    }

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 436;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_cls;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__curves, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 436;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    branch_no_1:;
    tmp_source_name_2 = par_cls;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__curves );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 437;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7096b6ad0685416ea20fafee5d682357 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7096b6ad0685416ea20fafee5d682357 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7096b6ad0685416ea20fafee5d682357 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7096b6ad0685416ea20fafee5d682357, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7096b6ad0685416ea20fafee5d682357->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7096b6ad0685416ea20fafee5d682357, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7096b6ad0685416ea20fafee5d682357,
        type_description_1,
        par_cls,
        par_lib
    );


    // Release cached frame.
    if ( frame_7096b6ad0685416ea20fafee5d682357 == cache_frame_7096b6ad0685416ea20fafee5d682357 )
    {
        Py_DECREF( frame_7096b6ad0685416ea20fafee5d682357 );
    }
    cache_frame_7096b6ad0685416ea20fafee5d682357 = NULL;

    assertFrameObject( frame_7096b6ad0685416ea20fafee5d682357 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_19__get_elliptic_curves );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_19__get_elliptic_curves );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_20_from_nid( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_lib = python_pars[ 1 ];
    PyObject *par_nid = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_d9b4aca46fa45edc20186def74d2cc85 = NULL;

    struct Nuitka_FrameObject *frame_d9b4aca46fa45edc20186def74d2cc85;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d9b4aca46fa45edc20186def74d2cc85, codeobj_d9b4aca46fa45edc20186def74d2cc85, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d9b4aca46fa45edc20186def74d2cc85 = cache_frame_d9b4aca46fa45edc20186def74d2cc85;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d9b4aca46fa45edc20186def74d2cc85 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d9b4aca46fa45edc20186def74d2cc85 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = par_cls;

    CHECK_OBJECT( tmp_called_name_1 );
    tmp_args_element_name_1 = par_lib;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = par_nid;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 454;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_string );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 454;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_2 = par_lib;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_5 = par_nid;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_d9b4aca46fa45edc20186def74d2cc85->m_frame.f_lineno = 454;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_args_element_name_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_OBJ_nid2sn, call_args );
    }

    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 454;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_d9b4aca46fa45edc20186def74d2cc85->m_frame.f_lineno = 454;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_called_instance_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 454;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_d9b4aca46fa45edc20186def74d2cc85->m_frame.f_lineno = 454;
    tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 454;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_d9b4aca46fa45edc20186def74d2cc85->m_frame.f_lineno = 454;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 454;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9b4aca46fa45edc20186def74d2cc85 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9b4aca46fa45edc20186def74d2cc85 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9b4aca46fa45edc20186def74d2cc85 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d9b4aca46fa45edc20186def74d2cc85, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d9b4aca46fa45edc20186def74d2cc85->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d9b4aca46fa45edc20186def74d2cc85, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d9b4aca46fa45edc20186def74d2cc85,
        type_description_1,
        par_cls,
        par_lib,
        par_nid
    );


    // Release cached frame.
    if ( frame_d9b4aca46fa45edc20186def74d2cc85 == cache_frame_d9b4aca46fa45edc20186def74d2cc85 )
    {
        Py_DECREF( frame_d9b4aca46fa45edc20186def74d2cc85 );
    }
    cache_frame_d9b4aca46fa45edc20186def74d2cc85 = NULL;

    assertFrameObject( frame_d9b4aca46fa45edc20186def74d2cc85 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_20_from_nid );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_nid );
    Py_DECREF( par_nid );
    par_nid = NULL;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_nid );
    Py_DECREF( par_nid );
    par_nid = NULL;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_20_from_nid );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_21___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_lib = python_pars[ 1 ];
    PyObject *par_nid = python_pars[ 2 ];
    PyObject *par_name = python_pars[ 3 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_063b1a0e18b7d09d3c7304577aae337e = NULL;

    struct Nuitka_FrameObject *frame_063b1a0e18b7d09d3c7304577aae337e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_063b1a0e18b7d09d3c7304577aae337e, codeobj_063b1a0e18b7d09d3c7304577aae337e, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_063b1a0e18b7d09d3c7304577aae337e = cache_frame_063b1a0e18b7d09d3c7304577aae337e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_063b1a0e18b7d09d3c7304577aae337e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_063b1a0e18b7d09d3c7304577aae337e ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = par_lib;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__lib, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 469;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_nid;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__nid, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 470;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = par_name;

    CHECK_OBJECT( tmp_assattr_name_3 );
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_name, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 471;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_063b1a0e18b7d09d3c7304577aae337e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_063b1a0e18b7d09d3c7304577aae337e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_063b1a0e18b7d09d3c7304577aae337e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_063b1a0e18b7d09d3c7304577aae337e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_063b1a0e18b7d09d3c7304577aae337e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_063b1a0e18b7d09d3c7304577aae337e,
        type_description_1,
        par_self,
        par_lib,
        par_nid,
        par_name
    );


    // Release cached frame.
    if ( frame_063b1a0e18b7d09d3c7304577aae337e == cache_frame_063b1a0e18b7d09d3c7304577aae337e )
    {
        Py_DECREF( frame_063b1a0e18b7d09d3c7304577aae337e );
    }
    cache_frame_063b1a0e18b7d09d3c7304577aae337e = NULL;

    assertFrameObject( frame_063b1a0e18b7d09d3c7304577aae337e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_21___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_nid );
    Py_DECREF( par_nid );
    par_nid = NULL;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_nid );
    Py_DECREF( par_nid );
    par_nid = NULL;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_21___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_22___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_f3e20dc9e619a5c7b71876ef8e4ffdf2 = NULL;

    struct Nuitka_FrameObject *frame_f3e20dc9e619a5c7b71876ef8e4ffdf2;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f3e20dc9e619a5c7b71876ef8e4ffdf2, codeobj_f3e20dc9e619a5c7b71876ef8e4ffdf2, module_OpenSSL$crypto, sizeof(void *) );
    frame_f3e20dc9e619a5c7b71876ef8e4ffdf2 = cache_frame_f3e20dc9e619a5c7b71876ef8e4ffdf2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f3e20dc9e619a5c7b71876ef8e4ffdf2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f3e20dc9e619a5c7b71876ef8e4ffdf2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_left_name_1 = const_str_digest_221848055f0a545c7ef1969a37bb78a5;
    tmp_right_name_1 = PyTuple_New( 1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 474;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 474;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3e20dc9e619a5c7b71876ef8e4ffdf2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3e20dc9e619a5c7b71876ef8e4ffdf2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3e20dc9e619a5c7b71876ef8e4ffdf2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f3e20dc9e619a5c7b71876ef8e4ffdf2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f3e20dc9e619a5c7b71876ef8e4ffdf2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f3e20dc9e619a5c7b71876ef8e4ffdf2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f3e20dc9e619a5c7b71876ef8e4ffdf2,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f3e20dc9e619a5c7b71876ef8e4ffdf2 == cache_frame_f3e20dc9e619a5c7b71876ef8e4ffdf2 )
    {
        Py_DECREF( frame_f3e20dc9e619a5c7b71876ef8e4ffdf2 );
    }
    cache_frame_f3e20dc9e619a5c7b71876ef8e4ffdf2 = NULL;

    assertFrameObject( frame_f3e20dc9e619a5c7b71876ef8e4ffdf2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_22___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_22___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_23__to_EC_KEY( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_key = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    static struct Nuitka_FrameObject *cache_frame_9104ea89573b61be15ab468f377fb279 = NULL;

    struct Nuitka_FrameObject *frame_9104ea89573b61be15ab468f377fb279;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9104ea89573b61be15ab468f377fb279, codeobj_9104ea89573b61be15ab468f377fb279, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_9104ea89573b61be15ab468f377fb279 = cache_frame_9104ea89573b61be15ab468f377fb279;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9104ea89573b61be15ab468f377fb279 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9104ea89573b61be15ab468f377fb279 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__lib );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 483;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EC_KEY_new_by_curve_name );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 483;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__nid );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 483;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_9104ea89573b61be15ab468f377fb279->m_frame.f_lineno = 483;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 483;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_key == NULL );
    var_key = tmp_assign_source_1;

    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 484;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_gc );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 484;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_key;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 484;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_EC_KEY_free );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 484;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_9104ea89573b61be15ab468f377fb279->m_frame.f_lineno = 484;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 484;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9104ea89573b61be15ab468f377fb279 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9104ea89573b61be15ab468f377fb279 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9104ea89573b61be15ab468f377fb279 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9104ea89573b61be15ab468f377fb279, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9104ea89573b61be15ab468f377fb279->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9104ea89573b61be15ab468f377fb279, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9104ea89573b61be15ab468f377fb279,
        type_description_1,
        par_self,
        var_key
    );


    // Release cached frame.
    if ( frame_9104ea89573b61be15ab468f377fb279 == cache_frame_9104ea89573b61be15ab468f377fb279 )
    {
        Py_DECREF( frame_9104ea89573b61be15ab468f377fb279 );
    }
    cache_frame_9104ea89573b61be15ab468f377fb279 = NULL;

    assertFrameObject( frame_9104ea89573b61be15ab468f377fb279 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_23__to_EC_KEY );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_key );
    Py_DECREF( var_key );
    var_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_23__to_EC_KEY );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_24_get_elliptic_curves( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_107afbc3261214969697ae7bd17eb403 = NULL;

    struct Nuitka_FrameObject *frame_107afbc3261214969697ae7bd17eb403;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_107afbc3261214969697ae7bd17eb403, codeobj_107afbc3261214969697ae7bd17eb403, module_OpenSSL$crypto, 0 );
    frame_107afbc3261214969697ae7bd17eb403 = cache_frame_107afbc3261214969697ae7bd17eb403;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_107afbc3261214969697ae7bd17eb403 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_107afbc3261214969697ae7bd17eb403 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__EllipticCurve );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__EllipticCurve );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_EllipticCurve" );
        exception_tb = NULL;

        exception_lineno = 499;

        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_elliptic_curves );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 499;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_args_element_name_1 == NULL ))
    {
        tmp_args_element_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 499;

        goto frame_exception_exit_1;
    }

    frame_107afbc3261214969697ae7bd17eb403->m_frame.f_lineno = 499;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 499;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_107afbc3261214969697ae7bd17eb403 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_107afbc3261214969697ae7bd17eb403 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_107afbc3261214969697ae7bd17eb403 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_107afbc3261214969697ae7bd17eb403, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_107afbc3261214969697ae7bd17eb403->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_107afbc3261214969697ae7bd17eb403, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_107afbc3261214969697ae7bd17eb403,
        type_description_1
    );


    // Release cached frame.
    if ( frame_107afbc3261214969697ae7bd17eb403 == cache_frame_107afbc3261214969697ae7bd17eb403 )
    {
        Py_DECREF( frame_107afbc3261214969697ae7bd17eb403 );
    }
    cache_frame_107afbc3261214969697ae7bd17eb403 = NULL;

    assertFrameObject( frame_107afbc3261214969697ae7bd17eb403 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_24_get_elliptic_curves );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_25_get_elliptic_curve( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_name = python_pars[ 0 ];
    PyObject *var_curve = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_153767201ad1e1a2e0fa3001f507c4f6 = NULL;

    struct Nuitka_FrameObject *frame_153767201ad1e1a2e0fa3001f507c4f6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_153767201ad1e1a2e0fa3001f507c4f6, codeobj_153767201ad1e1a2e0fa3001f507c4f6, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_153767201ad1e1a2e0fa3001f507c4f6 = cache_frame_153767201ad1e1a2e0fa3001f507c4f6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_153767201ad1e1a2e0fa3001f507c4f6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_153767201ad1e1a2e0fa3001f507c4f6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_get_elliptic_curves );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_get_elliptic_curves );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "get_elliptic_curves" );
        exception_tb = NULL;

        exception_lineno = 514;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_153767201ad1e1a2e0fa3001f507c4f6->m_frame.f_lineno = 514;
    tmp_iter_arg_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 514;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 514;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oo";
        exception_lineno = 514;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 514;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_curve;
        var_curve = tmp_assign_source_3;
        Py_INCREF( var_curve );
        Py_XDECREF( old );
    }

    tmp_source_name_1 = var_curve;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 515;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    tmp_compare_right_2 = par_name;

    CHECK_OBJECT( tmp_compare_right_2 );
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 515;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_return_value = var_curve;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_2;
    branch_no_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 514;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__iter_value );
    Py_DECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_make_exception_arg_1 = const_str_digest_95aba6f0be0722dff4a715f251a45159;
    tmp_make_exception_arg_2 = par_name;

    CHECK_OBJECT( tmp_make_exception_arg_2 );
    frame_153767201ad1e1a2e0fa3001f507c4f6->m_frame.f_lineno = 517;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1, tmp_make_exception_arg_2 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS2( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 517;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_153767201ad1e1a2e0fa3001f507c4f6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_153767201ad1e1a2e0fa3001f507c4f6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_153767201ad1e1a2e0fa3001f507c4f6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_153767201ad1e1a2e0fa3001f507c4f6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_153767201ad1e1a2e0fa3001f507c4f6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_153767201ad1e1a2e0fa3001f507c4f6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_153767201ad1e1a2e0fa3001f507c4f6,
        type_description_1,
        par_name,
        var_curve
    );


    // Release cached frame.
    if ( frame_153767201ad1e1a2e0fa3001f507c4f6 == cache_frame_153767201ad1e1a2e0fa3001f507c4f6 )
    {
        Py_DECREF( frame_153767201ad1e1a2e0fa3001f507c4f6 );
    }
    cache_frame_153767201ad1e1a2e0fa3001f507c4f6 = NULL;

    assertFrameObject( frame_153767201ad1e1a2e0fa3001f507c4f6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_25_get_elliptic_curve );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_curve );
    Py_DECREF( var_curve );
    var_curve = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_curve );
    var_curve = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_25_get_elliptic_curve );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_26___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_e74409a73207f7b2752994c2618d873f = NULL;

    struct Nuitka_FrameObject *frame_e74409a73207f7b2752994c2618d873f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e74409a73207f7b2752994c2618d873f, codeobj_e74409a73207f7b2752994c2618d873f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_e74409a73207f7b2752994c2618d873f = cache_frame_e74409a73207f7b2752994c2618d873f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e74409a73207f7b2752994c2618d873f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e74409a73207f7b2752994c2618d873f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 552;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_NAME_dup );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 552;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_name;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 552;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_e74409a73207f7b2752994c2618d873f->m_frame.f_lineno = 552;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 552;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_name;
        assert( old != NULL );
        par_name = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 553;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_gc );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 553;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_name;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 553;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_NAME_free );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 553;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_e74409a73207f7b2752994c2618d873f->m_frame.f_lineno = 553;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 553;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 553;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e74409a73207f7b2752994c2618d873f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e74409a73207f7b2752994c2618d873f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e74409a73207f7b2752994c2618d873f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e74409a73207f7b2752994c2618d873f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e74409a73207f7b2752994c2618d873f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e74409a73207f7b2752994c2618d873f,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if ( frame_e74409a73207f7b2752994c2618d873f == cache_frame_e74409a73207f7b2752994c2618d873f )
    {
        Py_DECREF( frame_e74409a73207f7b2752994c2618d873f );
    }
    cache_frame_e74409a73207f7b2752994c2618d873f = NULL;

    assertFrameObject( frame_e74409a73207f7b2752994c2618d873f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_26___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_26___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_27___setattr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_value = python_pars[ 2 ];
    PyObject *var_i = NULL;
    PyObject *var_nid = NULL;
    PyObject *var_ent_obj = NULL;
    PyObject *var_ent = NULL;
    PyObject *var_ent_nid = NULL;
    PyObject *var_add_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    bool tmp_isnot_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_object_name_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_range_arg_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_type_arg_1;
    PyObject *tmp_type_arg_2;
    PyObject *tmp_type_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_5257480cf0e5c2a0e7b7480a7cb50162 = NULL;

    struct Nuitka_FrameObject *frame_5257480cf0e5c2a0e7b7480a7cb50162;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5257480cf0e5c2a0e7b7480a7cb50162, codeobj_5257480cf0e5c2a0e7b7480a7cb50162, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5257480cf0e5c2a0e7b7480a7cb50162 = cache_frame_5257480cf0e5c2a0e7b7480a7cb50162;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5257480cf0e5c2a0e7b7480a7cb50162 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5257480cf0e5c2a0e7b7480a7cb50162 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_name;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 556;
    tmp_cond_value_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_startswith, &PyTuple_GET_ITEM( const_tuple_str_plain___tuple, 0 ) );

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 556;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 556;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_type_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

    if (unlikely( tmp_type_name_1 == NULL ))
    {
        tmp_type_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
    }

    if ( tmp_type_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
        exception_tb = NULL;

        exception_lineno = 557;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_object_name_1 = par_self;

    CHECK_OBJECT( tmp_object_name_1 );
    tmp_called_instance_2 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 557;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_name;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = par_value;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 557;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain___setattr__, call_args );
    }

    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 557;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_type_arg_1 = par_name;

    CHECK_OBJECT( tmp_type_arg_1 );
    tmp_compare_left_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
    assert( tmp_compare_left_1 != NULL );
    tmp_compare_right_1 = (PyObject *)&PyString_Type;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_left_name_1 = const_str_digest_bbde1e297eda38e770b8fce1d06c225b;
    tmp_right_name_1 = PyTuple_New( 1 );
    tmp_type_arg_2 = par_value;

    CHECK_OBJECT( tmp_type_arg_2 );
    tmp_source_name_1 = BUILTIN_TYPE1( tmp_type_arg_2 );
    assert( tmp_source_name_1 != NULL );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___name__ );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 564;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 563;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 562;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 562;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 567;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_OBJ_txt2nid );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 567;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
    }

    if ( tmp_called_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
        exception_tb = NULL;

        exception_lineno = 567;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = par_name;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 567;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 567;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 567;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 567;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_nid == NULL );
    var_nid = tmp_assign_source_1;

    tmp_compare_left_2 = var_nid;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 568;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NID_undef );
    if ( tmp_compare_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 568;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 568;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    // Tried code:
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 570;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }

    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 570;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 570;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_5257480cf0e5c2a0e7b7480a7cb50162 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_5257480cf0e5c2a0e7b7480a7cb50162, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_5257480cf0e5c2a0e7b7480a7cb50162, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_3 = PyThreadState_GET()->exc_type;
    tmp_compare_right_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_compare_right_3 == NULL ))
    {
        tmp_compare_right_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_compare_right_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 571;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 571;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 569;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame) frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "ooooooooo";
    goto frame_exception_exit_1;
    branch_no_4:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_27___setattr__ );
    return NULL;
    // End of try:
    try_end_1:;
    tmp_make_exception_arg_2 = const_str_digest_7b5d428ebb9708d902c18ce8ddfb3cbc;
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 573;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_AttributeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 573;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 576;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_NAME_entry_count );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 576;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__name );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 576;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 576;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_range_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 576;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 576;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 576;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooooooo";
        exception_lineno = 576;
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_2;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_4 = exception_keeper_type_2;
    tmp_compare_right_4 = PyExc_StopIteration;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_4, tmp_compare_right_4 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 576;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    Py_DECREF( exception_keeper_type_2 );
    Py_XDECREF( exception_keeper_value_2 );
    Py_XDECREF( exception_keeper_tb_2 );
    goto loop_end_1;
    goto branch_end_5;
    branch_no_5:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_3;
    branch_end_5:;
    // End of try:
    try_end_2:;
    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_4;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 577;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_NAME_get_entry );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 577;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__name );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 577;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    tmp_args_element_name_7 = var_i;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 577;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 577;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_ent;
        var_ent = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 578;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }

    tmp_args_element_name_8 = var_ent;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 578;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_assign_source_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_X509_NAME_ENTRY_get_object, call_args );
    }

    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 578;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_ent_obj;
        var_ent_obj = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 579;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }

    tmp_args_element_name_9 = var_ent_obj;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 579;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_OBJ_obj2nid, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 579;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_ent_nid;
        var_ent_nid = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_compare_left_5 = var_nid;

    CHECK_OBJECT( tmp_compare_left_5 );
    tmp_compare_right_5 = var_ent_nid;

    CHECK_OBJECT( tmp_compare_right_5 );
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_5, tmp_compare_right_5 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 580;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 581;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_X509_NAME_delete_entry );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 581;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    tmp_source_name_9 = par_self;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__name );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 581;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    tmp_args_element_name_11 = var_i;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 581;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 581;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_ent;
        assert( old != NULL );
        var_ent = tmp_assign_source_8;
        Py_DECREF( old );
    }

    tmp_called_instance_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_5 == NULL ))
    {
        tmp_called_instance_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 582;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }

    tmp_args_element_name_12 = var_ent;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 582;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_X509_NAME_ENTRY_free, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 582;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    goto loop_end_1;
    branch_no_6:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 576;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_isinstance_inst_1 = par_value;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
        exception_tb = NULL;

        exception_lineno = 585;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 585;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_called_instance_6 = par_value;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 586;
    tmp_assign_source_9 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0 ) );

    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 586;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_value;
        assert( old != NULL );
        par_value = tmp_assign_source_9;
        Py_DECREF( old );
    }

    branch_no_7:;
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 588;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_X509_NAME_add_entry_by_NID );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 588;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_11 = par_self;

    CHECK_OBJECT( tmp_source_name_11 );
    tmp_args_element_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__name );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 589;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_14 = var_nid;

    CHECK_OBJECT( tmp_args_element_name_14 );
    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_12 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_13 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 589;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_MBSTRING_UTF8 );
    if ( tmp_args_element_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_13 );

        exception_lineno = 589;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_16 = par_value;

    CHECK_OBJECT( tmp_args_element_name_16 );
    tmp_args_element_name_17 = const_int_neg_1;
    tmp_args_element_name_18 = const_int_neg_1;
    tmp_args_element_name_19 = const_int_0;
    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 588;
    {
        PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15, tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19 };
        tmp_assign_source_10 = CALL_FUNCTION_WITH_ARGS7( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_13 );
    Py_DECREF( tmp_args_element_name_15 );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 588;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_add_result == NULL );
    var_add_result = tmp_assign_source_10;

    tmp_cond_value_2 = var_add_result;

    CHECK_OBJECT( tmp_cond_value_2 );
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 591;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_8;
    }
    else
    {
        goto branch_yes_8;
    }
    branch_yes_8:;
    tmp_called_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_8 == NULL ))
    {
        tmp_called_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 592;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame.f_lineno = 592;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 592;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_8:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_5257480cf0e5c2a0e7b7480a7cb50162 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_5257480cf0e5c2a0e7b7480a7cb50162 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_5257480cf0e5c2a0e7b7480a7cb50162 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5257480cf0e5c2a0e7b7480a7cb50162, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5257480cf0e5c2a0e7b7480a7cb50162->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5257480cf0e5c2a0e7b7480a7cb50162, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5257480cf0e5c2a0e7b7480a7cb50162,
        type_description_1,
        par_self,
        par_name,
        par_value,
        var_i,
        var_nid,
        var_ent_obj,
        var_ent,
        var_ent_nid,
        var_add_result
    );


    // Release cached frame.
    if ( frame_5257480cf0e5c2a0e7b7480a7cb50162 == cache_frame_5257480cf0e5c2a0e7b7480a7cb50162 )
    {
        Py_DECREF( frame_5257480cf0e5c2a0e7b7480a7cb50162 );
    }
    cache_frame_5257480cf0e5c2a0e7b7480a7cb50162 = NULL;

    assertFrameObject( frame_5257480cf0e5c2a0e7b7480a7cb50162 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_27___setattr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    Py_XDECREF( var_ent_obj );
    var_ent_obj = NULL;

    Py_XDECREF( var_ent );
    var_ent = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    Py_XDECREF( var_ent_nid );
    var_ent_nid = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    Py_XDECREF( var_ent_obj );
    var_ent_obj = NULL;

    Py_XDECREF( var_ent );
    var_ent = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    Py_XDECREF( var_ent_nid );
    var_ent_nid = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_27___setattr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_28___getattr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *var_result_buffer = NULL;
    PyObject *var_data_length = NULL;
    PyObject *var_nid = NULL;
    PyObject *var_result = NULL;
    PyObject *var_entry_index = NULL;
    PyObject *var_entry = NULL;
    PyObject *var_data = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_object_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_type_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_a82ccd2c0741621ed27296148a68c29b = NULL;

    struct Nuitka_FrameObject *frame_a82ccd2c0741621ed27296148a68c29b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a82ccd2c0741621ed27296148a68c29b, codeobj_a82ccd2c0741621ed27296148a68c29b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a82ccd2c0741621ed27296148a68c29b = cache_frame_a82ccd2c0741621ed27296148a68c29b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a82ccd2c0741621ed27296148a68c29b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a82ccd2c0741621ed27296148a68c29b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 601;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_OBJ_txt2nid );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 601;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
    }

    if ( tmp_called_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
        exception_tb = NULL;

        exception_lineno = 601;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_name;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 601;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 601;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 601;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 601;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_nid == NULL );
    var_nid = tmp_assign_source_1;

    tmp_compare_left_1 = var_nid;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 602;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NID_undef );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 602;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 602;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    // Tried code:
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 609;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }

    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 609;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 609;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_a82ccd2c0741621ed27296148a68c29b );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_a82ccd2c0741621ed27296148a68c29b, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_a82ccd2c0741621ed27296148a68c29b, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_compare_right_2 == NULL ))
    {
        tmp_compare_right_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_compare_right_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 610;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 610;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 608;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_a82ccd2c0741621ed27296148a68c29b->m_frame) frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "ooooooooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_28___getattr__ );
    return NULL;
    // End of try:
    try_end_1:;
    tmp_type_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

    if (unlikely( tmp_type_name_1 == NULL ))
    {
        tmp_type_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
    }

    if ( tmp_type_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
        exception_tb = NULL;

        exception_lineno = 612;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_object_name_1 = par_self;

    CHECK_OBJECT( tmp_object_name_1 );
    tmp_called_instance_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 612;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_name;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 612;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___getattr__, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 612;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 614;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_NAME_get_index_by_NID );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 614;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__name );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 614;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_nid;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = const_int_neg_1;
    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 614;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 614;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_entry_index == NULL );
    var_entry_index = tmp_assign_source_2;

    tmp_compare_left_3 = var_entry_index;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = const_int_neg_1;
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 615;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 618;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_NAME_get_entry );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 618;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__name );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 618;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = var_entry_index;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 618;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 618;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_entry == NULL );
    var_entry = tmp_assign_source_3;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 619;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_9 = var_entry;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 619;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_X509_NAME_ENTRY_get_data, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 619;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_data == NULL );
    var_data = tmp_assign_source_4;

    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 621;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 621;
    tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple, 0 ) );

    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 621;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_buffer == NULL );
    var_result_buffer = tmp_assign_source_5;

    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 622;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = var_result_buffer;

    CHECK_OBJECT( tmp_args_element_name_10 );
    tmp_args_element_name_11 = var_data;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 622;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_4, const_str_plain_ASN1_STRING_to_UTF8, call_args );
    }

    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 622;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_data_length == NULL );
    var_data_length = tmp_assign_source_6;

    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 623;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_data_length;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_12 = RICH_COMPARE_GE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 623;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 623;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_args_element_name_12 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 623;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    // Tried code:
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 626;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_buffer );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 626;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    tmp_subscribed_name_1 = var_result_buffer;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_args_element_name_13 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 626;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    tmp_args_element_name_14 = var_data_length;

    CHECK_OBJECT( tmp_args_element_name_14 );
    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 626;
    {
        PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14 };
        tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_13 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 626;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    tmp_called_instance_5 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_called_instance_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 626;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 626;
    tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0 ) );

    Py_DECREF( tmp_called_instance_5 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 626;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_7;

    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 631;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_OPENSSL_free );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 631;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = var_result_buffer;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_0;
    tmp_args_element_name_15 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 631;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 631;
    {
        PyObject *call_args[] = { tmp_args_element_name_15 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_called_name_8 );
    Py_DECREF( tmp_args_element_name_15 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 631;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 631;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_OPENSSL_free );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 631;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = var_result_buffer;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_0;
    tmp_args_element_name_16 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );

        exception_lineno = 631;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_a82ccd2c0741621ed27296148a68c29b->m_frame.f_lineno = 631;
    {
        PyObject *call_args[] = { tmp_args_element_name_16 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_element_name_16 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 631;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 1
    RESTORE_FRAME_EXCEPTION( frame_a82ccd2c0741621ed27296148a68c29b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_a82ccd2c0741621ed27296148a68c29b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_a82ccd2c0741621ed27296148a68c29b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a82ccd2c0741621ed27296148a68c29b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a82ccd2c0741621ed27296148a68c29b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a82ccd2c0741621ed27296148a68c29b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a82ccd2c0741621ed27296148a68c29b,
        type_description_1,
        par_self,
        par_name,
        var_result_buffer,
        var_data_length,
        var_nid,
        var_result,
        var_entry_index,
        var_entry,
        var_data
    );


    // Release cached frame.
    if ( frame_a82ccd2c0741621ed27296148a68c29b == cache_frame_a82ccd2c0741621ed27296148a68c29b )
    {
        Py_DECREF( frame_a82ccd2c0741621ed27296148a68c29b );
    }
    cache_frame_a82ccd2c0741621ed27296148a68c29b = NULL;

    assertFrameObject( frame_a82ccd2c0741621ed27296148a68c29b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_28___getattr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_data_length );
    var_data_length = NULL;

    CHECK_OBJECT( (PyObject *)var_nid );
    Py_DECREF( var_nid );
    var_nid = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_entry_index );
    var_entry_index = NULL;

    Py_XDECREF( var_entry );
    var_entry = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_data_length );
    var_data_length = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_entry_index );
    var_entry_index = NULL;

    Py_XDECREF( var_entry );
    var_entry = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_28___getattr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_29__cmp( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_op = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *var_f = NULL;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp$$$function_1_f( par_op );
    assert( var_f == NULL );
    var_f = tmp_assign_source_1;

    // Tried code:
    tmp_return_value = var_f;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_29__cmp );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_f );
    Py_DECREF( var_f );
    var_f = NULL;

    CHECK_OBJECT( (PyObject *)par_op );
    Py_DECREF( par_op );
    par_op = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_29__cmp );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_29__cmp$$$function_1_f( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_ecc5f2c4e5dc86a32ed116e99c89a5d1 = NULL;

    struct Nuitka_FrameObject *frame_ecc5f2c4e5dc86a32ed116e99c89a5d1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ecc5f2c4e5dc86a32ed116e99c89a5d1, codeobj_ecc5f2c4e5dc86a32ed116e99c89a5d1, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ecc5f2c4e5dc86a32ed116e99c89a5d1 = cache_frame_ecc5f2c4e5dc86a32ed116e99c89a5d1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ecc5f2c4e5dc86a32ed116e99c89a5d1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ecc5f2c4e5dc86a32ed116e99c89a5d1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_other;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
        exception_tb = NULL;

        exception_lineno = 636;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 636;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 638;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_NAME_cmp );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 638;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 638;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_other;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__name );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 638;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    frame_ecc5f2c4e5dc86a32ed116e99c89a5d1->m_frame.f_lineno = 638;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 638;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    if ( self->m_closure[0] == NULL )
    {
        tmp_called_name_2 = NULL;
    }
    else
    {
        tmp_called_name_2 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "op" );
        exception_tb = NULL;

        exception_lineno = 639;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_result;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = const_int_0;
    frame_ecc5f2c4e5dc86a32ed116e99c89a5d1->m_frame.f_lineno = 639;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 639;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ecc5f2c4e5dc86a32ed116e99c89a5d1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ecc5f2c4e5dc86a32ed116e99c89a5d1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ecc5f2c4e5dc86a32ed116e99c89a5d1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ecc5f2c4e5dc86a32ed116e99c89a5d1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ecc5f2c4e5dc86a32ed116e99c89a5d1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ecc5f2c4e5dc86a32ed116e99c89a5d1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ecc5f2c4e5dc86a32ed116e99c89a5d1,
        type_description_1,
        par_self,
        par_other,
        var_result,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_ecc5f2c4e5dc86a32ed116e99c89a5d1 == cache_frame_ecc5f2c4e5dc86a32ed116e99c89a5d1 )
    {
        Py_DECREF( frame_ecc5f2c4e5dc86a32ed116e99c89a5d1 );
    }
    cache_frame_ecc5f2c4e5dc86a32ed116e99c89a5d1 = NULL;

    assertFrameObject( frame_ecc5f2c4e5dc86a32ed116e99c89a5d1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_29__cmp$$$function_1_f );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_29__cmp$$$function_1_f );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_30___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_result_buffer = NULL;
    PyObject *var_format_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_2a7bb83e6e75a054f19a73ff4f483805 = NULL;

    struct Nuitka_FrameObject *frame_2a7bb83e6e75a054f19a73ff4f483805;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2a7bb83e6e75a054f19a73ff4f483805, codeobj_2a7bb83e6e75a054f19a73ff4f483805, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_2a7bb83e6e75a054f19a73ff4f483805 = cache_frame_2a7bb83e6e75a054f19a73ff4f483805;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2a7bb83e6e75a054f19a73ff4f483805 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2a7bb83e6e75a054f19a73ff4f483805 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 656;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_2a7bb83e6e75a054f19a73ff4f483805->m_frame.f_lineno = 656;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 656;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_buffer == NULL );
    var_result_buffer = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 657;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_NAME_oneline );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 657;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 658;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_result_buffer;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_len_arg_1 = var_result_buffer;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_args_element_name_3 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 658;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_2a7bb83e6e75a054f19a73ff4f483805->m_frame.f_lineno = 657;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 657;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_format_result == NULL );
    var_format_result = tmp_assign_source_2;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 660;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_format_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 660;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 660;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 660;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_2a7bb83e6e75a054f19a73ff4f483805->m_frame.f_lineno = 660;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 660;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_left_name_1 = const_str_digest_169aa7f0589e4a3c83203d48f57770af;
    tmp_right_name_1 = PyTuple_New( 1 );
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
    }

    if ( tmp_called_name_3 == NULL )
    {
        Py_DECREF( tmp_right_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
        exception_tb = NULL;

        exception_lineno = 663;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {
        Py_DECREF( tmp_right_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 663;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = var_result_buffer;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_2a7bb83e6e75a054f19a73ff4f483805->m_frame.f_lineno = 663;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_args_element_name_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_string, call_args );
    }

    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 663;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_2a7bb83e6e75a054f19a73ff4f483805->m_frame.f_lineno = 663;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 663;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 662;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2a7bb83e6e75a054f19a73ff4f483805 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2a7bb83e6e75a054f19a73ff4f483805 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2a7bb83e6e75a054f19a73ff4f483805 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2a7bb83e6e75a054f19a73ff4f483805, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2a7bb83e6e75a054f19a73ff4f483805->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2a7bb83e6e75a054f19a73ff4f483805, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2a7bb83e6e75a054f19a73ff4f483805,
        type_description_1,
        par_self,
        var_result_buffer,
        var_format_result
    );


    // Release cached frame.
    if ( frame_2a7bb83e6e75a054f19a73ff4f483805 == cache_frame_2a7bb83e6e75a054f19a73ff4f483805 )
    {
        Py_DECREF( frame_2a7bb83e6e75a054f19a73ff4f483805 );
    }
    cache_frame_2a7bb83e6e75a054f19a73ff4f483805 = NULL;

    assertFrameObject( frame_2a7bb83e6e75a054f19a73ff4f483805 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_30___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_result_buffer );
    Py_DECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_format_result );
    Py_DECREF( var_format_result );
    var_format_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_format_result );
    var_format_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_30___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_31_hash( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_cde66f85dffd5588bcc9694a7fafb9fc = NULL;

    struct Nuitka_FrameObject *frame_cde66f85dffd5588bcc9694a7fafb9fc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cde66f85dffd5588bcc9694a7fafb9fc, codeobj_cde66f85dffd5588bcc9694a7fafb9fc, module_OpenSSL$crypto, sizeof(void *) );
    frame_cde66f85dffd5588bcc9694a7fafb9fc = cache_frame_cde66f85dffd5588bcc9694a7fafb9fc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cde66f85dffd5588bcc9694a7fafb9fc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cde66f85dffd5588bcc9694a7fafb9fc ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 676;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_NAME_hash );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 676;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 676;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_cde66f85dffd5588bcc9694a7fafb9fc->m_frame.f_lineno = 676;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 676;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cde66f85dffd5588bcc9694a7fafb9fc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cde66f85dffd5588bcc9694a7fafb9fc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cde66f85dffd5588bcc9694a7fafb9fc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cde66f85dffd5588bcc9694a7fafb9fc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cde66f85dffd5588bcc9694a7fafb9fc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cde66f85dffd5588bcc9694a7fafb9fc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cde66f85dffd5588bcc9694a7fafb9fc,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_cde66f85dffd5588bcc9694a7fafb9fc == cache_frame_cde66f85dffd5588bcc9694a7fafb9fc )
    {
        Py_DECREF( frame_cde66f85dffd5588bcc9694a7fafb9fc );
    }
    cache_frame_cde66f85dffd5588bcc9694a7fafb9fc = NULL;

    assertFrameObject( frame_cde66f85dffd5588bcc9694a7fafb9fc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_31_hash );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_31_hash );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_32_der( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_result_buffer = NULL;
    PyObject *var_string_result = NULL;
    PyObject *var_encode_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_8074998756d76facb0acefe4e2bce233 = NULL;

    struct Nuitka_FrameObject *frame_8074998756d76facb0acefe4e2bce233;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8074998756d76facb0acefe4e2bce233, codeobj_8074998756d76facb0acefe4e2bce233, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8074998756d76facb0acefe4e2bce233 = cache_frame_8074998756d76facb0acefe4e2bce233;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8074998756d76facb0acefe4e2bce233 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8074998756d76facb0acefe4e2bce233 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 685;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_8074998756d76facb0acefe4e2bce233->m_frame.f_lineno = 685;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 685;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_buffer == NULL );
    var_result_buffer = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 686;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_i2d_X509_NAME );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 686;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 686;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_result_buffer;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_8074998756d76facb0acefe4e2bce233->m_frame.f_lineno = 686;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 686;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_encode_result == NULL );
    var_encode_result = tmp_assign_source_2;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 687;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_encode_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_3 = RICH_COMPARE_GE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 687;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_8074998756d76facb0acefe4e2bce233->m_frame.f_lineno = 687;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 687;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 689;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_buffer );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 689;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = var_result_buffer;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_args_element_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 689;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_encode_result;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_8074998756d76facb0acefe4e2bce233->m_frame.f_lineno = 689;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 689;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_3 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 689;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_string_result == NULL );
    var_string_result = tmp_assign_source_3;

    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 690;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_OPENSSL_free );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 690;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = var_result_buffer;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_0;
    tmp_args_element_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 690;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_8074998756d76facb0acefe4e2bce233->m_frame.f_lineno = 690;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 690;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8074998756d76facb0acefe4e2bce233 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8074998756d76facb0acefe4e2bce233 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8074998756d76facb0acefe4e2bce233, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8074998756d76facb0acefe4e2bce233->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8074998756d76facb0acefe4e2bce233, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8074998756d76facb0acefe4e2bce233,
        type_description_1,
        par_self,
        var_result_buffer,
        var_string_result,
        var_encode_result
    );


    // Release cached frame.
    if ( frame_8074998756d76facb0acefe4e2bce233 == cache_frame_8074998756d76facb0acefe4e2bce233 )
    {
        Py_DECREF( frame_8074998756d76facb0acefe4e2bce233 );
    }
    cache_frame_8074998756d76facb0acefe4e2bce233 = NULL;

    assertFrameObject( frame_8074998756d76facb0acefe4e2bce233 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_string_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_32_der );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_result_buffer );
    Py_DECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_string_result );
    Py_DECREF( var_string_result );
    var_string_result = NULL;

    CHECK_OBJECT( (PyObject *)var_encode_result );
    Py_DECREF( var_encode_result );
    var_encode_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_string_result );
    var_string_result = NULL;

    Py_XDECREF( var_encode_result );
    var_encode_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_32_der );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_33_get_components( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_value = NULL;
    PyObject *var_name = NULL;
    PyObject *var_i = NULL;
    PyObject *var_nid = NULL;
    PyObject *var_fval = NULL;
    PyObject *var_ent = NULL;
    PyObject *var_result = NULL;
    PyObject *var_fname = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_range_arg_1;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_ae02106742003eefd25af05a0213f462 = NULL;

    struct Nuitka_FrameObject *frame_ae02106742003eefd25af05a0213f462;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PyList_New( 0 );
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ae02106742003eefd25af05a0213f462, codeobj_ae02106742003eefd25af05a0213f462, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ae02106742003eefd25af05a0213f462 = cache_frame_ae02106742003eefd25af05a0213f462;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ae02106742003eefd25af05a0213f462 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ae02106742003eefd25af05a0213f462 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 701;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_NAME_entry_count );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 701;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_ae02106742003eefd25af05a0213f462->m_frame.f_lineno = 701;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_range_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooooooo";
        exception_lineno = 701;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 701;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_4;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 702;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_NAME_get_entry );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 702;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__name );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 702;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_3 = var_i;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_ae02106742003eefd25af05a0213f462->m_frame.f_lineno = 702;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 702;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_ent;
        var_ent = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 704;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_4 = var_ent;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_ae02106742003eefd25af05a0213f462->m_frame.f_lineno = 704;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_NAME_ENTRY_get_object, call_args );
    }

    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 704;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_fname;
        var_fname = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 705;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_5 = var_ent;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_ae02106742003eefd25af05a0213f462->m_frame.f_lineno = 705;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_X509_NAME_ENTRY_get_data, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 705;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_fval;
        var_fval = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 707;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_6 = var_fname;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_ae02106742003eefd25af05a0213f462->m_frame.f_lineno = 707;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_assign_source_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_OBJ_obj2nid, call_args );
    }

    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 707;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_nid;
        var_nid = tmp_assign_source_8;
        Py_XDECREF( old );
    }

    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 708;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_7 = var_nid;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_ae02106742003eefd25af05a0213f462->m_frame.f_lineno = 708;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_assign_source_9 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_OBJ_nid2sn, call_args );
    }

    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 708;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_name;
        var_name = tmp_assign_source_9;
        Py_XDECREF( old );
    }

    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 712;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_buffer );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 712;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    tmp_called_instance_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_5 == NULL ))
    {
        tmp_called_instance_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_5 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 713;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_9 = var_fval;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_ae02106742003eefd25af05a0213f462->m_frame.f_lineno = 713;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_args_element_name_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_ASN1_STRING_data, call_args );
    }

    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 713;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    tmp_called_instance_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_6 == NULL ))
    {
        tmp_called_instance_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_6 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_8 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 713;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_11 = var_fval;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_ae02106742003eefd25af05a0213f462->m_frame.f_lineno = 713;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_args_element_name_10 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_ASN1_STRING_length, call_args );
    }

    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_8 );

        exception_lineno = 713;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    frame_ae02106742003eefd25af05a0213f462->m_frame.f_lineno = 712;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_10 };
        tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_8 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 712;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    tmp_assign_source_10 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 712;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_value;
        var_value = tmp_assign_source_10;
        Py_XDECREF( old );
    }

    tmp_source_name_6 = var_result;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_append );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 715;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_12 = PyTuple_New( 2 );
    tmp_called_instance_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_7 == NULL ))
    {
        tmp_called_instance_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_7 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_12 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 715;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_13 = var_name;

    CHECK_OBJECT( tmp_args_element_name_13 );
    frame_ae02106742003eefd25af05a0213f462->m_frame.f_lineno = 715;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_tuple_element_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_string, call_args );
    }

    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_12 );

        exception_lineno = 715;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_args_element_name_12, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_value;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_element_name_12, 1, tmp_tuple_element_1 );
    frame_ae02106742003eefd25af05a0213f462->m_frame.f_lineno = 715;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_12 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 715;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ae02106742003eefd25af05a0213f462 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ae02106742003eefd25af05a0213f462 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ae02106742003eefd25af05a0213f462, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ae02106742003eefd25af05a0213f462->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ae02106742003eefd25af05a0213f462, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ae02106742003eefd25af05a0213f462,
        type_description_1,
        par_self,
        var_value,
        var_name,
        var_i,
        var_nid,
        var_fval,
        var_ent,
        var_result,
        var_fname
    );


    // Release cached frame.
    if ( frame_ae02106742003eefd25af05a0213f462 == cache_frame_ae02106742003eefd25af05a0213f462 )
    {
        Py_DECREF( frame_ae02106742003eefd25af05a0213f462 );
    }
    cache_frame_ae02106742003eefd25af05a0213f462 = NULL;

    assertFrameObject( frame_ae02106742003eefd25af05a0213f462 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = var_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_33_get_components );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_value );
    var_value = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    Py_XDECREF( var_fval );
    var_fval = NULL;

    Py_XDECREF( var_ent );
    var_ent = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_fname );
    var_fname = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_value );
    var_value = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    Py_XDECREF( var_fval );
    var_fval = NULL;

    Py_XDECREF( var_ent );
    var_ent = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_fname );
    var_fname = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_33_get_components );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_34___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_type_name = python_pars[ 1 ];
    PyObject *par_critical = python_pars[ 2 ];
    PyObject *par_value = python_pars[ 3 ];
    PyObject *par_subject = python_pars[ 4 ];
    PyObject *par_issuer = python_pars[ 5 ];
    PyObject *var_extension = NULL;
    PyObject *var_ctx = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    bool tmp_isnot_1;
    bool tmp_isnot_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_2dae63b82183f47dc1d1ccf37238a118 = NULL;

    struct Nuitka_FrameObject *frame_2dae63b82183f47dc1d1ccf37238a118;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2dae63b82183f47dc1d1ccf37238a118, codeobj_2dae63b82183f47dc1d1ccf37238a118, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_2dae63b82183f47dc1d1ccf37238a118 = cache_frame_2dae63b82183f47dc1d1ccf37238a118;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2dae63b82183f47dc1d1ccf37238a118 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2dae63b82183f47dc1d1ccf37238a118 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 747;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_2dae63b82183f47dc1d1ccf37238a118->m_frame.f_lineno = 747;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_f3b04f8993b30e664e4afacb3d64cdc4_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 747;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_ctx == NULL );
    var_ctx = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 752;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509V3_set_ctx );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 752;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_ctx;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 752;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 752;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 752;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 752;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 752;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 752;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 752;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 752;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = const_int_0;
    frame_2dae63b82183f47dc1d1ccf37238a118->m_frame.f_lineno = 752;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS6( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 752;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 756;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = var_ctx;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_2dae63b82183f47dc1d1ccf37238a118->m_frame.f_lineno = 756;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_X509V3_set_ctx_nodb, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 756;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_compare_left_1 = par_issuer;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_isinstance_inst_1 = par_issuer;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 763;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 763;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_1 = const_str_digest_7163953ad9ff69e46167d396f5625cf7;
    frame_2dae63b82183f47dc1d1ccf37238a118->m_frame.f_lineno = 764;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 764;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_source_name_6 = par_issuer;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__x509 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 765;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_ctx;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_issuer_cert, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 765;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    branch_no_1:;
    tmp_compare_left_2 = par_subject;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = Py_None;
    tmp_isnot_2 = ( tmp_compare_left_2 != tmp_compare_right_2 );
    if ( tmp_isnot_2 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_isinstance_inst_2 = par_subject;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_isinstance_cls_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_isinstance_cls_2 == NULL ))
    {
        tmp_isinstance_cls_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_isinstance_cls_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 767;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 767;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    tmp_make_exception_arg_2 = const_str_digest_3c820c2fc1d76f73132dab0e4e8d3a14;
    frame_2dae63b82183f47dc1d1ccf37238a118->m_frame.f_lineno = 768;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 768;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooo";
    goto frame_exception_exit_1;
    branch_no_4:;
    tmp_source_name_7 = par_subject;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__x509 );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 769;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = var_ctx;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_subject_cert, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 769;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    branch_no_3:;
    tmp_cond_value_1 = par_critical;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 771;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_left_name_1 = const_str_digest_3c5d018dd809b9a6147c1b47d39e8d31;
    tmp_right_name_1 = par_value;

    CHECK_OBJECT( tmp_right_name_1 );
    tmp_assign_source_2 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 779;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_value;
        assert( old != NULL );
        par_value = tmp_assign_source_2;
        Py_DECREF( old );
    }

    branch_no_5:;
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 781;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_X509V3_EXT_nconf );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 781;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 781;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_NULL );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 781;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_ctx;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_args_element_name_10 = par_type_name;

    CHECK_OBJECT( tmp_args_element_name_10 );
    tmp_args_element_name_11 = par_value;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_2dae63b82183f47dc1d1ccf37238a118->m_frame.f_lineno = 781;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 781;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_extension == NULL );
    var_extension = tmp_assign_source_3;

    tmp_compare_left_3 = var_extension;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 782;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_NULL );
    if ( tmp_compare_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 782;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_3 );

        exception_lineno = 782;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_3 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 783;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_2dae63b82183f47dc1d1ccf37238a118->m_frame.f_lineno = 783;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 783;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_6:;
    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 784;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_gc );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 784;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_12 = var_extension;

    CHECK_OBJECT( tmp_args_element_name_12 );
    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_12 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 784;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_X509_EXTENSION_free );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 784;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_2dae63b82183f47dc1d1ccf37238a118->m_frame.f_lineno = 784;
    {
        PyObject *call_args[] = { tmp_args_element_name_12, tmp_args_element_name_13 };
        tmp_assattr_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_13 );
    if ( tmp_assattr_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 784;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__extension, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_3 );

        exception_lineno = 784;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_3 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2dae63b82183f47dc1d1ccf37238a118 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2dae63b82183f47dc1d1ccf37238a118 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2dae63b82183f47dc1d1ccf37238a118, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2dae63b82183f47dc1d1ccf37238a118->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2dae63b82183f47dc1d1ccf37238a118, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2dae63b82183f47dc1d1ccf37238a118,
        type_description_1,
        par_self,
        par_type_name,
        par_critical,
        par_value,
        par_subject,
        par_issuer,
        var_extension,
        var_ctx
    );


    // Release cached frame.
    if ( frame_2dae63b82183f47dc1d1ccf37238a118 == cache_frame_2dae63b82183f47dc1d1ccf37238a118 )
    {
        Py_DECREF( frame_2dae63b82183f47dc1d1ccf37238a118 );
    }
    cache_frame_2dae63b82183f47dc1d1ccf37238a118 = NULL;

    assertFrameObject( frame_2dae63b82183f47dc1d1ccf37238a118 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_34___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_extension );
    Py_DECREF( var_extension );
    var_extension = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type_name );
    Py_DECREF( par_type_name );
    par_type_name = NULL;

    CHECK_OBJECT( (PyObject *)var_ctx );
    Py_DECREF( var_ctx );
    var_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_critical );
    Py_DECREF( par_critical );
    par_critical = NULL;

    CHECK_OBJECT( (PyObject *)par_subject );
    Py_DECREF( par_subject );
    par_subject = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer );
    Py_DECREF( par_issuer );
    par_issuer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_extension );
    var_extension = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type_name );
    Py_DECREF( par_type_name );
    par_type_name = NULL;

    Py_XDECREF( var_ctx );
    var_ctx = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_critical );
    Py_DECREF( par_critical );
    par_critical = NULL;

    CHECK_OBJECT( (PyObject *)par_subject );
    Py_DECREF( par_subject );
    par_subject = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer );
    Py_DECREF( par_issuer );
    par_issuer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_34___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_35__nid( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_be69f2a07a72c09df887316bd387c371 = NULL;

    struct Nuitka_FrameObject *frame_be69f2a07a72c09df887316bd387c371;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_be69f2a07a72c09df887316bd387c371, codeobj_be69f2a07a72c09df887316bd387c371, module_OpenSSL$crypto, sizeof(void *) );
    frame_be69f2a07a72c09df887316bd387c371 = cache_frame_be69f2a07a72c09df887316bd387c371;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_be69f2a07a72c09df887316bd387c371 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_be69f2a07a72c09df887316bd387c371 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 788;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_OBJ_obj2nid );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 788;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 789;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_EXTENSION_get_object );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 789;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__extension );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 789;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_be69f2a07a72c09df887316bd387c371->m_frame.f_lineno = 789;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 789;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_be69f2a07a72c09df887316bd387c371->m_frame.f_lineno = 788;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 788;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_be69f2a07a72c09df887316bd387c371 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_be69f2a07a72c09df887316bd387c371 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_be69f2a07a72c09df887316bd387c371 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_be69f2a07a72c09df887316bd387c371, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_be69f2a07a72c09df887316bd387c371->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_be69f2a07a72c09df887316bd387c371, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_be69f2a07a72c09df887316bd387c371,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_be69f2a07a72c09df887316bd387c371 == cache_frame_be69f2a07a72c09df887316bd387c371 )
    {
        Py_DECREF( frame_be69f2a07a72c09df887316bd387c371 );
    }
    cache_frame_be69f2a07a72c09df887316bd387c371 = NULL;

    assertFrameObject( frame_be69f2a07a72c09df887316bd387c371 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_35__nid );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_35__nid );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_36__subjectAltNameString( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_bio = NULL;
    PyObject *var_name = NULL;
    PyObject *var_i = NULL;
    PyObject *var_value = NULL;
    PyObject *var_label = NULL;
    PyObject *var_parts = NULL;
    PyObject *var_names = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_try_except_1__unhandled_indicator = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    bool tmp_is_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_range_arg_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_b2eb147418d5fabeff8e35f9b5686e90 = NULL;

    struct Nuitka_FrameObject *frame_b2eb147418d5fabeff8e35f9b5686e90;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b2eb147418d5fabeff8e35f9b5686e90, codeobj_b2eb147418d5fabeff8e35f9b5686e90, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b2eb147418d5fabeff8e35f9b5686e90 = cache_frame_b2eb147418d5fabeff8e35f9b5686e90;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b2eb147418d5fabeff8e35f9b5686e90 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b2eb147418d5fabeff8e35f9b5686e90 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 799;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cast );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 799;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = const_str_digest_1dbb147d3e039266688c4d87287eaaad;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 800;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509V3_EXT_d2i );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 800;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__extension );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 800;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 800;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 800;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 799;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 799;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_names == NULL );
    var_names = tmp_assign_source_1;

    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 803;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_gc );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 803;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = var_names;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 803;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_GENERAL_NAMES_free );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 803;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 803;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 803;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_names;
        assert( old != NULL );
        var_names = tmp_assign_source_2;
        Py_DECREF( old );
    }

    tmp_assign_source_3 = PyList_New( 0 );
    assert( var_parts == NULL );
    var_parts = tmp_assign_source_3;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 805;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = var_names;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 805;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_sk_GENERAL_NAME_num, call_args );
    }

    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 805;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 805;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 805;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_4;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_5 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooo";
        exception_lineno = 805;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 805;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_6 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_6 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_6;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 806;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_7 = var_names;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = var_i;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 806;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_sk_GENERAL_NAME_value, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 806;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_name;
        var_name = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_assign_source_8 = Py_True;
    {
        PyObject *old = tmp_try_except_1__unhandled_indicator;
        tmp_try_except_1__unhandled_indicator = tmp_assign_source_8;
        Py_INCREF( tmp_try_except_1__unhandled_indicator );
        Py_XDECREF( old );
    }

    // Tried code:
    // Tried code:
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__prefixes );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 808;
        type_description_1 = "oooooooo";
        goto try_except_handler_5;
    }
    tmp_source_name_7 = var_name;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_subscript_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_type );
    if ( tmp_subscript_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_subscribed_name_1 );

        exception_lineno = 808;
        type_description_1 = "oooooooo";
        goto try_except_handler_5;
    }
    tmp_assign_source_9 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    Py_DECREF( tmp_subscript_name_1 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 808;
        type_description_1 = "oooooooo";
        goto try_except_handler_5;
    }
    {
        PyObject *old = var_label;
        var_label = tmp_assign_source_9;
        Py_XDECREF( old );
    }

    goto try_end_2;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_assign_source_10 = Py_False;
    {
        PyObject *old = tmp_try_except_1__unhandled_indicator;
        assert( old != NULL );
        tmp_try_except_1__unhandled_indicator = tmp_assign_source_10;
        Py_INCREF( tmp_try_except_1__unhandled_indicator );
        Py_DECREF( old );
    }

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_b2eb147418d5fabeff8e35f9b5686e90 );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_b2eb147418d5fabeff8e35f9b5686e90, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != 0 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_b2eb147418d5fabeff8e35f9b5686e90, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyExc_KeyError;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 809;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 810;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }

    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 810;
    tmp_assign_source_11 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 810;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    {
        PyObject *old = var_bio;
        var_bio = tmp_assign_source_11;
        Py_XDECREF( old );
    }

    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 811;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }

    tmp_args_element_name_9 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_args_element_name_10 = var_name;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 811;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_GENERAL_NAME_print, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 811;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_8 = var_parts;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_append );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 812;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
    }

    if ( tmp_called_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
        exception_tb = NULL;

        exception_lineno = 812;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }

    tmp_called_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

    if (unlikely( tmp_called_name_7 == NULL ))
    {
        tmp_called_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
    }

    if ( tmp_called_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
        exception_tb = NULL;

        exception_lineno = 812;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }

    tmp_args_element_name_13 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_13 );
    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 812;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_args_element_name_12 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    if ( tmp_args_element_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 812;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 812;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_args_element_name_11 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_args_element_name_12 );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 812;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 812;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 812;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_2;
    branch_no_2:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 807;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame) frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooooooo";
    goto try_except_handler_4;
    branch_end_2:;
    goto try_end_2;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_36__subjectAltNameString );
    return NULL;
    // End of try:
    try_end_2:;
    tmp_compare_left_3 = tmp_try_except_1__unhandled_indicator;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = Py_True;
    tmp_is_1 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_called_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native );

    if (unlikely( tmp_called_name_8 == NULL ))
    {
        tmp_called_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
    }

    if ( tmp_called_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
        exception_tb = NULL;

        exception_lineno = 814;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }

    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 815;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_buffer );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 815;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    tmp_source_name_12 = var_name;

    CHECK_OBJECT( tmp_source_name_12 );
    tmp_source_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_d );
    if ( tmp_source_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );

        exception_lineno = 815;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    tmp_source_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_ia5 );
    Py_DECREF( tmp_source_name_11 );
    if ( tmp_source_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );

        exception_lineno = 815;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    tmp_args_element_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_data );
    Py_DECREF( tmp_source_name_10 );
    if ( tmp_args_element_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );

        exception_lineno = 815;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    tmp_source_name_15 = var_name;

    CHECK_OBJECT( tmp_source_name_15 );
    tmp_source_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_d );
    if ( tmp_source_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_15 );

        exception_lineno = 815;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    tmp_source_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_ia5 );
    Py_DECREF( tmp_source_name_14 );
    if ( tmp_source_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_15 );

        exception_lineno = 815;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    tmp_args_element_name_16 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_length );
    Py_DECREF( tmp_source_name_13 );
    if ( tmp_args_element_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_15 );

        exception_lineno = 815;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 815;
    {
        PyObject *call_args[] = { tmp_args_element_name_15, tmp_args_element_name_16 };
        tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_element_name_15 );
    Py_DECREF( tmp_args_element_name_16 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 815;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    tmp_args_element_name_14 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_args_element_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 815;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 814;
    {
        PyObject *call_args[] = { tmp_args_element_name_14 };
        tmp_assign_source_12 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_args_element_name_14 );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 814;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    {
        PyObject *old = var_value;
        var_value = tmp_assign_source_12;
        Py_XDECREF( old );
    }

    tmp_source_name_16 = var_parts;

    CHECK_OBJECT( tmp_source_name_16 );
    tmp_called_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_append );
    if ( tmp_called_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 817;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    tmp_left_name_2 = var_label;

    if ( tmp_left_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_10 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;

        exception_lineno = 817;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }

    tmp_right_name_1 = const_str_chr_58;
    tmp_left_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_10 );

        exception_lineno = 817;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    tmp_right_name_2 = var_value;

    CHECK_OBJECT( tmp_right_name_2 );
    tmp_args_element_name_17 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_2 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_args_element_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_10 );

        exception_lineno = 817;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 817;
    {
        PyObject *call_args[] = { tmp_args_element_name_17 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
    }

    Py_DECREF( tmp_called_name_10 );
    Py_DECREF( tmp_args_element_name_17 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 817;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_try_except_1__unhandled_indicator );
    tmp_try_except_1__unhandled_indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_2;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_try_except_1__unhandled_indicator );
    Py_DECREF( tmp_try_except_1__unhandled_indicator );
    tmp_try_except_1__unhandled_indicator = NULL;

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 805;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_called_instance_4 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_args_element_name_18 = var_parts;

    CHECK_OBJECT( tmp_args_element_name_18 );
    frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame.f_lineno = 818;
    {
        PyObject *call_args[] = { tmp_args_element_name_18 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_join, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 818;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_b2eb147418d5fabeff8e35f9b5686e90 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_b2eb147418d5fabeff8e35f9b5686e90 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_b2eb147418d5fabeff8e35f9b5686e90 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b2eb147418d5fabeff8e35f9b5686e90, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b2eb147418d5fabeff8e35f9b5686e90->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b2eb147418d5fabeff8e35f9b5686e90, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b2eb147418d5fabeff8e35f9b5686e90,
        type_description_1,
        par_self,
        var_bio,
        var_name,
        var_i,
        var_value,
        var_label,
        var_parts,
        var_names
    );


    // Release cached frame.
    if ( frame_b2eb147418d5fabeff8e35f9b5686e90 == cache_frame_b2eb147418d5fabeff8e35f9b5686e90 )
    {
        Py_DECREF( frame_b2eb147418d5fabeff8e35f9b5686e90 );
    }
    cache_frame_b2eb147418d5fabeff8e35f9b5686e90 = NULL;

    assertFrameObject( frame_b2eb147418d5fabeff8e35f9b5686e90 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_36__subjectAltNameString );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    Py_XDECREF( var_label );
    var_label = NULL;

    CHECK_OBJECT( (PyObject *)var_parts );
    Py_DECREF( var_parts );
    var_parts = NULL;

    CHECK_OBJECT( (PyObject *)var_names );
    Py_DECREF( var_names );
    var_names = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    Py_XDECREF( var_label );
    var_label = NULL;

    Py_XDECREF( var_parts );
    var_parts = NULL;

    Py_XDECREF( var_names );
    var_names = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_36__subjectAltNameString );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_37___str__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_bio = NULL;
    PyObject *var_print_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_6fee1e02bfdf5171d161d782964ddf8a = NULL;

    struct Nuitka_FrameObject *frame_6fee1e02bfdf5171d161d782964ddf8a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6fee1e02bfdf5171d161d782964ddf8a, codeobj_6fee1e02bfdf5171d161d782964ddf8a, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6fee1e02bfdf5171d161d782964ddf8a = cache_frame_6fee1e02bfdf5171d161d782964ddf8a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6fee1e02bfdf5171d161d782964ddf8a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6fee1e02bfdf5171d161d782964ddf8a ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 824;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NID_subject_alt_name );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 824;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__nid );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 824;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 824;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_6fee1e02bfdf5171d161d782964ddf8a->m_frame.f_lineno = 825;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__subjectAltNameString );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 825;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 827;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_6fee1e02bfdf5171d161d782964ddf8a->m_frame.f_lineno = 827;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 827;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_1;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 828;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509V3_EXT_print );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 828;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__extension );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 828;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = const_int_0;
    tmp_args_element_name_4 = const_int_0;
    frame_6fee1e02bfdf5171d161d782964ddf8a->m_frame.f_lineno = 828;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 828;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_print_result == NULL );
    var_print_result = tmp_assign_source_2;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 829;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_print_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_5 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 829;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_6fee1e02bfdf5171d161d782964ddf8a->m_frame.f_lineno = 829;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 829;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
        exception_tb = NULL;

        exception_lineno = 831;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
        exception_tb = NULL;

        exception_lineno = 831;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_6fee1e02bfdf5171d161d782964ddf8a->m_frame.f_lineno = 831;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_args_element_name_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 831;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_6fee1e02bfdf5171d161d782964ddf8a->m_frame.f_lineno = 831;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 831;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6fee1e02bfdf5171d161d782964ddf8a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6fee1e02bfdf5171d161d782964ddf8a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6fee1e02bfdf5171d161d782964ddf8a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6fee1e02bfdf5171d161d782964ddf8a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6fee1e02bfdf5171d161d782964ddf8a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6fee1e02bfdf5171d161d782964ddf8a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6fee1e02bfdf5171d161d782964ddf8a,
        type_description_1,
        par_self,
        var_bio,
        var_print_result
    );


    // Release cached frame.
    if ( frame_6fee1e02bfdf5171d161d782964ddf8a == cache_frame_6fee1e02bfdf5171d161d782964ddf8a )
    {
        Py_DECREF( frame_6fee1e02bfdf5171d161d782964ddf8a );
    }
    cache_frame_6fee1e02bfdf5171d161d782964ddf8a = NULL;

    assertFrameObject( frame_6fee1e02bfdf5171d161d782964ddf8a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_37___str__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_print_result );
    var_print_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_print_result );
    var_print_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_37___str__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_38_get_critical( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_4c30ea601179f11262c4deefdcac8ea8 = NULL;

    struct Nuitka_FrameObject *frame_4c30ea601179f11262c4deefdcac8ea8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4c30ea601179f11262c4deefdcac8ea8, codeobj_4c30ea601179f11262c4deefdcac8ea8, module_OpenSSL$crypto, sizeof(void *) );
    frame_4c30ea601179f11262c4deefdcac8ea8 = cache_frame_4c30ea601179f11262c4deefdcac8ea8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4c30ea601179f11262c4deefdcac8ea8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4c30ea601179f11262c4deefdcac8ea8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 839;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_EXTENSION_get_critical );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 839;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__extension );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 839;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_4c30ea601179f11262c4deefdcac8ea8->m_frame.f_lineno = 839;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 839;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4c30ea601179f11262c4deefdcac8ea8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4c30ea601179f11262c4deefdcac8ea8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4c30ea601179f11262c4deefdcac8ea8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4c30ea601179f11262c4deefdcac8ea8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4c30ea601179f11262c4deefdcac8ea8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4c30ea601179f11262c4deefdcac8ea8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4c30ea601179f11262c4deefdcac8ea8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_4c30ea601179f11262c4deefdcac8ea8 == cache_frame_4c30ea601179f11262c4deefdcac8ea8 )
    {
        Py_DECREF( frame_4c30ea601179f11262c4deefdcac8ea8 );
    }
    cache_frame_4c30ea601179f11262c4deefdcac8ea8 = NULL;

    assertFrameObject( frame_4c30ea601179f11262c4deefdcac8ea8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_38_get_critical );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_38_get_critical );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_39_get_short_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_obj = NULL;
    PyObject *var_nid = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_cfbf41ceb63c16d529c709e5c8297fb7 = NULL;

    struct Nuitka_FrameObject *frame_cfbf41ceb63c16d529c709e5c8297fb7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cfbf41ceb63c16d529c709e5c8297fb7, codeobj_cfbf41ceb63c16d529c709e5c8297fb7, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_cfbf41ceb63c16d529c709e5c8297fb7 = cache_frame_cfbf41ceb63c16d529c709e5c8297fb7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cfbf41ceb63c16d529c709e5c8297fb7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cfbf41ceb63c16d529c709e5c8297fb7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 852;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_EXTENSION_get_object );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 852;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__extension );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 852;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_cfbf41ceb63c16d529c709e5c8297fb7->m_frame.f_lineno = 852;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 852;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_obj == NULL );
    var_obj = tmp_assign_source_1;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 853;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_obj;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_cfbf41ceb63c16d529c709e5c8297fb7->m_frame.f_lineno = 853;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_OBJ_obj2nid, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 853;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_nid == NULL );
    var_nid = tmp_assign_source_2;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 854;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_string );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 854;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 854;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = var_nid;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_cfbf41ceb63c16d529c709e5c8297fb7->m_frame.f_lineno = 854;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_OBJ_nid2sn, call_args );
    }

    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 854;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_cfbf41ceb63c16d529c709e5c8297fb7->m_frame.f_lineno = 854;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 854;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cfbf41ceb63c16d529c709e5c8297fb7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cfbf41ceb63c16d529c709e5c8297fb7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cfbf41ceb63c16d529c709e5c8297fb7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cfbf41ceb63c16d529c709e5c8297fb7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cfbf41ceb63c16d529c709e5c8297fb7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cfbf41ceb63c16d529c709e5c8297fb7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cfbf41ceb63c16d529c709e5c8297fb7,
        type_description_1,
        par_self,
        var_obj,
        var_nid
    );


    // Release cached frame.
    if ( frame_cfbf41ceb63c16d529c709e5c8297fb7 == cache_frame_cfbf41ceb63c16d529c709e5c8297fb7 )
    {
        Py_DECREF( frame_cfbf41ceb63c16d529c709e5c8297fb7 );
    }
    cache_frame_cfbf41ceb63c16d529c709e5c8297fb7 = NULL;

    assertFrameObject( frame_cfbf41ceb63c16d529c709e5c8297fb7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_39_get_short_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_obj );
    Py_DECREF( var_obj );
    var_obj = NULL;

    CHECK_OBJECT( (PyObject *)var_nid );
    Py_DECREF( var_nid );
    var_nid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_39_get_short_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_40_get_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_char_result = NULL;
    PyObject *var_octet_result = NULL;
    PyObject *var_string_result = NULL;
    PyObject *var_result_length = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_58da277305ed77bd76ae182c07ff471f = NULL;

    struct Nuitka_FrameObject *frame_58da277305ed77bd76ae182c07ff471f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_58da277305ed77bd76ae182c07ff471f, codeobj_58da277305ed77bd76ae182c07ff471f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_58da277305ed77bd76ae182c07ff471f = cache_frame_58da277305ed77bd76ae182c07ff471f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_58da277305ed77bd76ae182c07ff471f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_58da277305ed77bd76ae182c07ff471f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 865;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_EXTENSION_get_data );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 865;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__extension );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 865;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_58da277305ed77bd76ae182c07ff471f->m_frame.f_lineno = 865;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 865;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_octet_result == NULL );
    var_octet_result = tmp_assign_source_1;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 866;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9;
    tmp_args_element_name_3 = var_octet_result;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_58da277305ed77bd76ae182c07ff471f->m_frame.f_lineno = 866;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_cast, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 866;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_string_result == NULL );
    var_string_result = tmp_assign_source_2;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 867;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = var_string_result;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_58da277305ed77bd76ae182c07ff471f->m_frame.f_lineno = 867;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_ASN1_STRING_data, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 867;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_char_result == NULL );
    var_char_result = tmp_assign_source_3;

    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 868;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = var_string_result;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_58da277305ed77bd76ae182c07ff471f->m_frame.f_lineno = 868;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_ASN1_STRING_length, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 868;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_length == NULL );
    var_result_length = tmp_assign_source_4;

    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 869;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = var_char_result;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = var_result_length;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_58da277305ed77bd76ae182c07ff471f->m_frame.f_lineno = 869;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_4, const_str_plain_buffer, call_args );
    }

    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 869;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 869;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_58da277305ed77bd76ae182c07ff471f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_58da277305ed77bd76ae182c07ff471f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_58da277305ed77bd76ae182c07ff471f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_58da277305ed77bd76ae182c07ff471f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_58da277305ed77bd76ae182c07ff471f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_58da277305ed77bd76ae182c07ff471f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_58da277305ed77bd76ae182c07ff471f,
        type_description_1,
        par_self,
        var_char_result,
        var_octet_result,
        var_string_result,
        var_result_length
    );


    // Release cached frame.
    if ( frame_58da277305ed77bd76ae182c07ff471f == cache_frame_58da277305ed77bd76ae182c07ff471f )
    {
        Py_DECREF( frame_58da277305ed77bd76ae182c07ff471f );
    }
    cache_frame_58da277305ed77bd76ae182c07ff471f = NULL;

    assertFrameObject( frame_58da277305ed77bd76ae182c07ff471f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_40_get_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_char_result );
    Py_DECREF( var_char_result );
    var_char_result = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_octet_result );
    Py_DECREF( var_octet_result );
    var_octet_result = NULL;

    CHECK_OBJECT( (PyObject *)var_string_result );
    Py_DECREF( var_string_result );
    var_string_result = NULL;

    CHECK_OBJECT( (PyObject *)var_result_length );
    Py_DECREF( var_result_length );
    var_result_length = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_char_result );
    var_char_result = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_octet_result );
    var_octet_result = NULL;

    Py_XDECREF( var_string_result );
    var_string_result = NULL;

    Py_XDECREF( var_result_length );
    var_result_length = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_40_get_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_41___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_req = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_35224eb056f22fe92af87e40d652fea6 = NULL;

    struct Nuitka_FrameObject *frame_35224eb056f22fe92af87e40d652fea6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_35224eb056f22fe92af87e40d652fea6, codeobj_35224eb056f22fe92af87e40d652fea6, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_35224eb056f22fe92af87e40d652fea6 = cache_frame_35224eb056f22fe92af87e40d652fea6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_35224eb056f22fe92af87e40d652fea6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_35224eb056f22fe92af87e40d652fea6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 878;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_35224eb056f22fe92af87e40d652fea6->m_frame.f_lineno = 878;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_REQ_new );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 878;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_req == NULL );
    var_req = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 879;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 879;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_req;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 879;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_REQ_free );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 879;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_35224eb056f22fe92af87e40d652fea6->m_frame.f_lineno = 879;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 879;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__req, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 879;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_35224eb056f22fe92af87e40d652fea6->m_frame.f_lineno = 881;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_set_version, &PyTuple_GET_ITEM( const_tuple_int_0_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 881;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_35224eb056f22fe92af87e40d652fea6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_35224eb056f22fe92af87e40d652fea6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_35224eb056f22fe92af87e40d652fea6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_35224eb056f22fe92af87e40d652fea6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_35224eb056f22fe92af87e40d652fea6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_35224eb056f22fe92af87e40d652fea6,
        type_description_1,
        par_self,
        var_req
    );


    // Release cached frame.
    if ( frame_35224eb056f22fe92af87e40d652fea6 == cache_frame_35224eb056f22fe92af87e40d652fea6 )
    {
        Py_DECREF( frame_35224eb056f22fe92af87e40d652fea6 );
    }
    cache_frame_35224eb056f22fe92af87e40d652fea6 = NULL;

    assertFrameObject( frame_35224eb056f22fe92af87e40d652fea6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_41___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_req );
    Py_DECREF( var_req );
    var_req = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_req );
    var_req = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_41___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_42_to_cryptography( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var__CertificateSigningRequest = NULL;
    PyObject *var_backend = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_634dd2520f2d2675325c340573d2f303 = NULL;

    struct Nuitka_FrameObject *frame_634dd2520f2d2675325c340573d2f303;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_634dd2520f2d2675325c340573d2f303, codeobj_634dd2520f2d2675325c340573d2f303, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_634dd2520f2d2675325c340573d2f303 = cache_frame_634dd2520f2d2675325c340573d2f303;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_634dd2520f2d2675325c340573d2f303 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_634dd2520f2d2675325c340573d2f303 ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_2b6a6c0099f1f1dd77d2725acd0722df;
    tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain__CertificateSigningRequest_tuple;
    frame_634dd2520f2d2675325c340573d2f303->m_frame.f_lineno = 891;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 891;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain__CertificateSigningRequest );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 891;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var__CertificateSigningRequest == NULL );
    var__CertificateSigningRequest = tmp_assign_source_1;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__get_backend );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_get_backend" );
        exception_tb = NULL;

        exception_lineno = 895;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_634dd2520f2d2675325c340573d2f303->m_frame.f_lineno = 895;
    tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 895;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_backend == NULL );
    var_backend = tmp_assign_source_2;

    tmp_called_name_2 = var__CertificateSigningRequest;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_args_element_name_1 = var_backend;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__req );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 896;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_634dd2520f2d2675325c340573d2f303->m_frame.f_lineno = 896;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 896;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_634dd2520f2d2675325c340573d2f303 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_634dd2520f2d2675325c340573d2f303 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_634dd2520f2d2675325c340573d2f303 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_634dd2520f2d2675325c340573d2f303, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_634dd2520f2d2675325c340573d2f303->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_634dd2520f2d2675325c340573d2f303, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_634dd2520f2d2675325c340573d2f303,
        type_description_1,
        par_self,
        var__CertificateSigningRequest,
        var_backend
    );


    // Release cached frame.
    if ( frame_634dd2520f2d2675325c340573d2f303 == cache_frame_634dd2520f2d2675325c340573d2f303 )
    {
        Py_DECREF( frame_634dd2520f2d2675325c340573d2f303 );
    }
    cache_frame_634dd2520f2d2675325c340573d2f303 = NULL;

    assertFrameObject( frame_634dd2520f2d2675325c340573d2f303 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_42_to_cryptography );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var__CertificateSigningRequest );
    Py_DECREF( var__CertificateSigningRequest );
    var__CertificateSigningRequest = NULL;

    CHECK_OBJECT( (PyObject *)var_backend );
    Py_DECREF( var_backend );
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var__CertificateSigningRequest );
    var__CertificateSigningRequest = NULL;

    Py_XDECREF( var_backend );
    var_backend = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_42_to_cryptography );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_43_from_cryptography( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_crypto_req = python_pars[ 1 ];
    PyObject *var_req = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3 = NULL;

    struct Nuitka_FrameObject *frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3, codeobj_0c7b9a5b3ed4ff89630439f7e0f3a7c3, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3 = cache_frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_crypto_req;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_x509 );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_x509 );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "x509" );
        exception_tb = NULL;

        exception_lineno = 910;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_CertificateSigningRequest );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 910;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 910;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_39641ea33feffed70915f1c391cc979e;
    frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3->m_frame.f_lineno = 911;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 911;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_called_name_1 = par_cls;

    CHECK_OBJECT( tmp_called_name_1 );
    frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3->m_frame.f_lineno = 913;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 913;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_req == NULL );
    var_req = tmp_assign_source_1;

    tmp_source_name_2 = par_crypto_req;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509_req );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 914;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_req;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__req, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 914;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3,
        type_description_1,
        par_cls,
        par_crypto_req,
        var_req
    );


    // Release cached frame.
    if ( frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3 == cache_frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3 )
    {
        Py_DECREF( frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3 );
    }
    cache_frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3 = NULL;

    assertFrameObject( frame_0c7b9a5b3ed4ff89630439f7e0f3a7c3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_req;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_43_from_cryptography );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_req );
    Py_DECREF( var_req );
    var_req = NULL;

    CHECK_OBJECT( (PyObject *)par_crypto_req );
    Py_DECREF( par_crypto_req );
    par_crypto_req = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_req );
    var_req = NULL;

    CHECK_OBJECT( (PyObject *)par_crypto_req );
    Py_DECREF( par_crypto_req );
    par_crypto_req = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_43_from_cryptography );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_44_set_pubkey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *var_set_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_e3fe386d49259b679544c27db4211b3f = NULL;

    struct Nuitka_FrameObject *frame_e3fe386d49259b679544c27db4211b3f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e3fe386d49259b679544c27db4211b3f, codeobj_e3fe386d49259b679544c27db4211b3f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e3fe386d49259b679544c27db4211b3f = cache_frame_e3fe386d49259b679544c27db4211b3f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e3fe386d49259b679544c27db4211b3f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e3fe386d49259b679544c27db4211b3f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 926;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REQ_set_pubkey );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 926;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__req );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 926;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_pkey;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 926;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_e3fe386d49259b679544c27db4211b3f->m_frame.f_lineno = 926;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 926;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_set_result == NULL );
    var_set_result = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 927;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_set_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_3 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_e3fe386d49259b679544c27db4211b3f->m_frame.f_lineno = 927;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e3fe386d49259b679544c27db4211b3f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e3fe386d49259b679544c27db4211b3f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e3fe386d49259b679544c27db4211b3f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e3fe386d49259b679544c27db4211b3f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e3fe386d49259b679544c27db4211b3f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e3fe386d49259b679544c27db4211b3f,
        type_description_1,
        par_self,
        par_pkey,
        var_set_result
    );


    // Release cached frame.
    if ( frame_e3fe386d49259b679544c27db4211b3f == cache_frame_e3fe386d49259b679544c27db4211b3f )
    {
        Py_DECREF( frame_e3fe386d49259b679544c27db4211b3f );
    }
    cache_frame_e3fe386d49259b679544c27db4211b3f = NULL;

    assertFrameObject( frame_e3fe386d49259b679544c27db4211b3f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_44_set_pubkey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_44_set_pubkey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_45_get_pubkey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_pkey = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_817e625125db0bed6c9af343a2fa01ac = NULL;

    struct Nuitka_FrameObject *frame_817e625125db0bed6c9af343a2fa01ac;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_817e625125db0bed6c9af343a2fa01ac, codeobj_817e625125db0bed6c9af343a2fa01ac, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_817e625125db0bed6c9af343a2fa01ac = cache_frame_817e625125db0bed6c9af343a2fa01ac;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_817e625125db0bed6c9af343a2fa01ac );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_817e625125db0bed6c9af343a2fa01ac ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 936;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 936;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_args_element_name_1 == NULL ))
    {
        tmp_args_element_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 936;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_817e625125db0bed6c9af343a2fa01ac->m_frame.f_lineno = 936;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 936;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_pkey == NULL );
    var_pkey = tmp_assign_source_1;

    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 937;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_REQ_get_pubkey );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 937;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__req );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 937;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_817e625125db0bed6c9af343a2fa01ac->m_frame.f_lineno = 937;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 937;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 937;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 938;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_4 = var_pkey;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__pkey );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 938;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_compexpr_left_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 938;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 938;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 938;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_817e625125db0bed6c9af343a2fa01ac->m_frame.f_lineno = 938;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 938;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 939;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_gc );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 939;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = var_pkey;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 939;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 939;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_EVP_PKEY_free );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 939;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_817e625125db0bed6c9af343a2fa01ac->m_frame.f_lineno = 939;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 939;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__pkey, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 939;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_assattr_name_3 = Py_True;
    tmp_assattr_target_3 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__only_public, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 940;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_817e625125db0bed6c9af343a2fa01ac );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_817e625125db0bed6c9af343a2fa01ac );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_817e625125db0bed6c9af343a2fa01ac, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_817e625125db0bed6c9af343a2fa01ac->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_817e625125db0bed6c9af343a2fa01ac, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_817e625125db0bed6c9af343a2fa01ac,
        type_description_1,
        par_self,
        var_pkey
    );


    // Release cached frame.
    if ( frame_817e625125db0bed6c9af343a2fa01ac == cache_frame_817e625125db0bed6c9af343a2fa01ac )
    {
        Py_DECREF( frame_817e625125db0bed6c9af343a2fa01ac );
    }
    cache_frame_817e625125db0bed6c9af343a2fa01ac = NULL;

    assertFrameObject( frame_817e625125db0bed6c9af343a2fa01ac );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_pkey;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_45_get_pubkey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_45_get_pubkey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_46_set_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_version = python_pars[ 1 ];
    PyObject *var_set_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_9f23f9ebe329837518bdc3f7e1a6e88c = NULL;

    struct Nuitka_FrameObject *frame_9f23f9ebe329837518bdc3f7e1a6e88c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9f23f9ebe329837518bdc3f7e1a6e88c, codeobj_9f23f9ebe329837518bdc3f7e1a6e88c, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9f23f9ebe329837518bdc3f7e1a6e88c = cache_frame_9f23f9ebe329837518bdc3f7e1a6e88c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9f23f9ebe329837518bdc3f7e1a6e88c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9f23f9ebe329837518bdc3f7e1a6e88c ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 951;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REQ_set_version );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 951;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__req );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 951;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_version;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_9f23f9ebe329837518bdc3f7e1a6e88c->m_frame.f_lineno = 951;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 951;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_set_result == NULL );
    var_set_result = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 952;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_set_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_3 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 952;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_9f23f9ebe329837518bdc3f7e1a6e88c->m_frame.f_lineno = 952;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 952;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9f23f9ebe329837518bdc3f7e1a6e88c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9f23f9ebe329837518bdc3f7e1a6e88c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9f23f9ebe329837518bdc3f7e1a6e88c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9f23f9ebe329837518bdc3f7e1a6e88c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9f23f9ebe329837518bdc3f7e1a6e88c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9f23f9ebe329837518bdc3f7e1a6e88c,
        type_description_1,
        par_self,
        par_version,
        var_set_result
    );


    // Release cached frame.
    if ( frame_9f23f9ebe329837518bdc3f7e1a6e88c == cache_frame_9f23f9ebe329837518bdc3f7e1a6e88c )
    {
        Py_DECREF( frame_9f23f9ebe329837518bdc3f7e1a6e88c );
    }
    cache_frame_9f23f9ebe329837518bdc3f7e1a6e88c = NULL;

    assertFrameObject( frame_9f23f9ebe329837518bdc3f7e1a6e88c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_46_set_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_version );
    Py_DECREF( par_version );
    par_version = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_version );
    Py_DECREF( par_version );
    par_version = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_46_set_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_47_get_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_84f20b87ad7f63be7d712f315dc27fea = NULL;

    struct Nuitka_FrameObject *frame_84f20b87ad7f63be7d712f315dc27fea;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_84f20b87ad7f63be7d712f315dc27fea, codeobj_84f20b87ad7f63be7d712f315dc27fea, module_OpenSSL$crypto, sizeof(void *) );
    frame_84f20b87ad7f63be7d712f315dc27fea = cache_frame_84f20b87ad7f63be7d712f315dc27fea;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_84f20b87ad7f63be7d712f315dc27fea );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_84f20b87ad7f63be7d712f315dc27fea ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 962;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REQ_get_version );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 962;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__req );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 962;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_84f20b87ad7f63be7d712f315dc27fea->m_frame.f_lineno = 962;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 962;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84f20b87ad7f63be7d712f315dc27fea );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_84f20b87ad7f63be7d712f315dc27fea );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84f20b87ad7f63be7d712f315dc27fea );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_84f20b87ad7f63be7d712f315dc27fea, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_84f20b87ad7f63be7d712f315dc27fea->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_84f20b87ad7f63be7d712f315dc27fea, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_84f20b87ad7f63be7d712f315dc27fea,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_84f20b87ad7f63be7d712f315dc27fea == cache_frame_84f20b87ad7f63be7d712f315dc27fea )
    {
        Py_DECREF( frame_84f20b87ad7f63be7d712f315dc27fea );
    }
    cache_frame_84f20b87ad7f63be7d712f315dc27fea = NULL;

    assertFrameObject( frame_84f20b87ad7f63be7d712f315dc27fea );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_47_get_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_47_get_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_48_get_subject( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_name = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_00cd31b4c5e27fc1a7515a659d7cbc7a = NULL;

    struct Nuitka_FrameObject *frame_00cd31b4c5e27fc1a7515a659d7cbc7a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_00cd31b4c5e27fc1a7515a659d7cbc7a, codeobj_00cd31b4c5e27fc1a7515a659d7cbc7a, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_00cd31b4c5e27fc1a7515a659d7cbc7a = cache_frame_00cd31b4c5e27fc1a7515a659d7cbc7a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_00cd31b4c5e27fc1a7515a659d7cbc7a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_00cd31b4c5e27fc1a7515a659d7cbc7a ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
        exception_tb = NULL;

        exception_lineno = 976;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 976;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

    if (unlikely( tmp_args_element_name_1 == NULL ))
    {
        tmp_args_element_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
        exception_tb = NULL;

        exception_lineno = 976;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_00cd31b4c5e27fc1a7515a659d7cbc7a->m_frame.f_lineno = 976;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 976;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_name == NULL );
    var_name = tmp_assign_source_1;

    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 977;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_REQ_get_subject_name );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 977;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__req );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 977;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_00cd31b4c5e27fc1a7515a659d7cbc7a->m_frame.f_lineno = 977;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 977;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_name;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 977;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 978;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_4 = var_name;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__name );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 978;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_compexpr_left_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 978;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 978;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 978;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_00cd31b4c5e27fc1a7515a659d7cbc7a->m_frame.f_lineno = 978;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 978;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_2 = par_self;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = var_name;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__owner, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 982;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_00cd31b4c5e27fc1a7515a659d7cbc7a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_00cd31b4c5e27fc1a7515a659d7cbc7a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_00cd31b4c5e27fc1a7515a659d7cbc7a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_00cd31b4c5e27fc1a7515a659d7cbc7a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_00cd31b4c5e27fc1a7515a659d7cbc7a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_00cd31b4c5e27fc1a7515a659d7cbc7a,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if ( frame_00cd31b4c5e27fc1a7515a659d7cbc7a == cache_frame_00cd31b4c5e27fc1a7515a659d7cbc7a )
    {
        Py_DECREF( frame_00cd31b4c5e27fc1a7515a659d7cbc7a );
    }
    cache_frame_00cd31b4c5e27fc1a7515a659d7cbc7a = NULL;

    assertFrameObject( frame_00cd31b4c5e27fc1a7515a659d7cbc7a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_name;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_48_get_subject );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_name );
    Py_DECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_48_get_subject );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_49_add_extensions( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_extensions = python_pars[ 1 ];
    PyObject *var_ext = NULL;
    PyObject *var_stack = NULL;
    PyObject *var_add_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_5bfb296d5731d584cf8608b23453951b = NULL;

    struct Nuitka_FrameObject *frame_5bfb296d5731d584cf8608b23453951b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5bfb296d5731d584cf8608b23453951b, codeobj_5bfb296d5731d584cf8608b23453951b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5bfb296d5731d584cf8608b23453951b = cache_frame_5bfb296d5731d584cf8608b23453951b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5bfb296d5731d584cf8608b23453951b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5bfb296d5731d584cf8608b23453951b ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 994;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_5bfb296d5731d584cf8608b23453951b->m_frame.f_lineno = 994;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_sk_X509_EXTENSION_new_null );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 994;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_stack == NULL );
    var_stack = tmp_assign_source_1;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 995;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_stack;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 995;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 995;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 995;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5bfb296d5731d584cf8608b23453951b->m_frame.f_lineno = 995;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 995;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 997;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_gc );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 997;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_stack;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 997;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_sk_X509_EXTENSION_free );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 997;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5bfb296d5731d584cf8608b23453951b->m_frame.f_lineno = 997;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 997;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_stack;
        assert( old != NULL );
        var_stack = tmp_assign_source_2;
        Py_DECREF( old );
    }

    tmp_iter_arg_1 = par_extensions;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 999;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_3;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_4 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooo";
        exception_lineno = 999;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 999;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_5 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_5 );
    {
        PyObject *old = var_ext;
        var_ext = tmp_assign_source_5;
        Py_INCREF( var_ext );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_ext;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Extension" );
        exception_tb = NULL;

        exception_lineno = 1000;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1000;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_1 = const_str_digest_c57795fb6a9ac3d47e928f9a8b608571;
    frame_5bfb296d5731d584cf8608b23453951b->m_frame.f_lineno = 1001;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1001;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto try_except_handler_2;
    branch_no_2:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1004;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_sk_X509_EXTENSION_push );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1004;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_4 = var_stack;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_source_name_5 = var_ext;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__extension );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1004;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    frame_5bfb296d5731d584cf8608b23453951b->m_frame.f_lineno = 1004;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1004;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 999;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1006;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_REQ_add_extensions );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1006;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__req );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1006;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = var_stack;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_5bfb296d5731d584cf8608b23453951b->m_frame.f_lineno = 1006;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1006;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_add_result == NULL );
    var_add_result = tmp_assign_source_6;

    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1007;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_2 = var_add_result;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = const_int_pos_1;
    tmp_args_element_name_8 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1007;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5bfb296d5731d584cf8608b23453951b->m_frame.f_lineno = 1007;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1007;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5bfb296d5731d584cf8608b23453951b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5bfb296d5731d584cf8608b23453951b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5bfb296d5731d584cf8608b23453951b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5bfb296d5731d584cf8608b23453951b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5bfb296d5731d584cf8608b23453951b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5bfb296d5731d584cf8608b23453951b,
        type_description_1,
        par_self,
        par_extensions,
        var_ext,
        var_stack,
        var_add_result
    );


    // Release cached frame.
    if ( frame_5bfb296d5731d584cf8608b23453951b == cache_frame_5bfb296d5731d584cf8608b23453951b )
    {
        Py_DECREF( frame_5bfb296d5731d584cf8608b23453951b );
    }
    cache_frame_5bfb296d5731d584cf8608b23453951b = NULL;

    assertFrameObject( frame_5bfb296d5731d584cf8608b23453951b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_49_add_extensions );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_ext );
    var_ext = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_extensions );
    Py_DECREF( par_extensions );
    par_extensions = NULL;

    CHECK_OBJECT( (PyObject *)var_stack );
    Py_DECREF( var_stack );
    var_stack = NULL;

    CHECK_OBJECT( (PyObject *)var_add_result );
    Py_DECREF( var_add_result );
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_extensions );
    Py_DECREF( par_extensions );
    par_extensions = NULL;

    Py_XDECREF( var_stack );
    var_stack = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_49_add_extensions );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_50_get_extensions( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_exts = NULL;
    PyObject *var_extension = NULL;
    PyObject *var_i = NULL;
    PyObject *var_ext = NULL;
    PyObject *var_native_exts_obj = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_range_arg_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_fe1ab9327216940b89ff10309b7e559c = NULL;

    struct Nuitka_FrameObject *frame_fe1ab9327216940b89ff10309b7e559c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PyList_New( 0 );
    assert( var_exts == NULL );
    var_exts = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fe1ab9327216940b89ff10309b7e559c, codeobj_fe1ab9327216940b89ff10309b7e559c, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_fe1ab9327216940b89ff10309b7e559c = cache_frame_fe1ab9327216940b89ff10309b7e559c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fe1ab9327216940b89ff10309b7e559c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fe1ab9327216940b89ff10309b7e559c ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1019;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REQ_get_extensions );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1019;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__req );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1019;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_fe1ab9327216940b89ff10309b7e559c->m_frame.f_lineno = 1019;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1019;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_native_exts_obj == NULL );
    var_native_exts_obj = tmp_assign_source_2;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1020;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_native_exts_obj;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$crypto$$$function_50_get_extensions$$$function_1_lambda(  );
    frame_fe1ab9327216940b89ff10309b7e559c->m_frame.f_lineno = 1020;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_gc, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1020;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_native_exts_obj;
        assert( old != NULL );
        var_native_exts_obj = tmp_assign_source_3;
        Py_DECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1028;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = var_native_exts_obj;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_fe1ab9327216940b89ff10309b7e559c->m_frame.f_lineno = 1028;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_sk_X509_EXTENSION_num, call_args );
    }

    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1028;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1028;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1028;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_4;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_5 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooo";
        exception_lineno = 1028;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1028;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_6 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_6 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_6;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Extension" );
        exception_tb = NULL;

        exception_lineno = 1029;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___new__ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1029;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension );

    if (unlikely( tmp_args_element_name_5 == NULL ))
    {
        tmp_args_element_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension );
    }

    if ( tmp_args_element_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Extension" );
        exception_tb = NULL;

        exception_lineno = 1029;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    frame_fe1ab9327216940b89ff10309b7e559c->m_frame.f_lineno = 1029;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1029;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_ext;
        var_ext = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1030;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_EXTENSION_dup );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1030;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1031;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_7 = var_native_exts_obj;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = var_i;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_fe1ab9327216940b89ff10309b7e559c->m_frame.f_lineno = 1031;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_args_element_name_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_sk_X509_EXTENSION_value, call_args );
    }

    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1031;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    frame_fe1ab9327216940b89ff10309b7e559c->m_frame.f_lineno = 1030;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1030;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_extension;
        var_extension = tmp_assign_source_8;
        Py_XDECREF( old );
    }

    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1033;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_gc );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1033;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_9 = var_extension;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1033;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_EXTENSION_free );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1033;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    frame_fe1ab9327216940b89ff10309b7e559c->m_frame.f_lineno = 1033;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1033;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_assattr_target_1 = var_ext;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__extension, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1033;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_called_instance_4 = var_exts;

    CHECK_OBJECT( tmp_called_instance_4 );
    tmp_args_element_name_11 = var_ext;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_fe1ab9327216940b89ff10309b7e559c->m_frame.f_lineno = 1034;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1034;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1028;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fe1ab9327216940b89ff10309b7e559c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fe1ab9327216940b89ff10309b7e559c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fe1ab9327216940b89ff10309b7e559c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fe1ab9327216940b89ff10309b7e559c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fe1ab9327216940b89ff10309b7e559c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fe1ab9327216940b89ff10309b7e559c,
        type_description_1,
        par_self,
        var_exts,
        var_extension,
        var_i,
        var_ext,
        var_native_exts_obj
    );


    // Release cached frame.
    if ( frame_fe1ab9327216940b89ff10309b7e559c == cache_frame_fe1ab9327216940b89ff10309b7e559c )
    {
        Py_DECREF( frame_fe1ab9327216940b89ff10309b7e559c );
    }
    cache_frame_fe1ab9327216940b89ff10309b7e559c = NULL;

    assertFrameObject( frame_fe1ab9327216940b89ff10309b7e559c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = var_exts;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_50_get_extensions );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_exts );
    Py_DECREF( var_exts );
    var_exts = NULL;

    Py_XDECREF( var_extension );
    var_extension = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    CHECK_OBJECT( (PyObject *)var_native_exts_obj );
    Py_DECREF( var_native_exts_obj );
    var_native_exts_obj = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)var_exts );
    Py_DECREF( var_exts );
    var_exts = NULL;

    Py_XDECREF( var_extension );
    var_extension = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    Py_XDECREF( var_native_exts_obj );
    var_native_exts_obj = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_50_get_extensions );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_50_get_extensions$$$function_1_lambda( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_40177b130baad3068ebe5a951155469e = NULL;

    struct Nuitka_FrameObject *frame_40177b130baad3068ebe5a951155469e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_40177b130baad3068ebe5a951155469e, codeobj_40177b130baad3068ebe5a951155469e, module_OpenSSL$crypto, sizeof(void *) );
    frame_40177b130baad3068ebe5a951155469e = cache_frame_40177b130baad3068ebe5a951155469e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_40177b130baad3068ebe5a951155469e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_40177b130baad3068ebe5a951155469e ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1022;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_sk_X509_EXTENSION_pop_free );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1022;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_x;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1024;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_addressof );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1024;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1024;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__original_lib );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1024;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = const_str_plain_X509_EXTENSION_free;
    frame_40177b130baad3068ebe5a951155469e->m_frame.f_lineno = 1024;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1024;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_40177b130baad3068ebe5a951155469e->m_frame.f_lineno = 1022;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1022;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40177b130baad3068ebe5a951155469e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_40177b130baad3068ebe5a951155469e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40177b130baad3068ebe5a951155469e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_40177b130baad3068ebe5a951155469e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_40177b130baad3068ebe5a951155469e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_40177b130baad3068ebe5a951155469e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_40177b130baad3068ebe5a951155469e,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_40177b130baad3068ebe5a951155469e == cache_frame_40177b130baad3068ebe5a951155469e )
    {
        Py_DECREF( frame_40177b130baad3068ebe5a951155469e );
    }
    cache_frame_40177b130baad3068ebe5a951155469e = NULL;

    assertFrameObject( frame_40177b130baad3068ebe5a951155469e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_50_get_extensions$$$function_1_lambda );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_50_get_extensions$$$function_1_lambda );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_51_sign( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *par_digest = python_pars[ 2 ];
    PyObject *var_digest_obj = NULL;
    PyObject *var_sign_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_a3b1f8e833aa031bd6d706c06d21fefb = NULL;

    struct Nuitka_FrameObject *frame_a3b1f8e833aa031bd6d706c06d21fefb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a3b1f8e833aa031bd6d706c06d21fefb, codeobj_a3b1f8e833aa031bd6d706c06d21fefb, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a3b1f8e833aa031bd6d706c06d21fefb = cache_frame_a3b1f8e833aa031bd6d706c06d21fefb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a3b1f8e833aa031bd6d706c06d21fefb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a3b1f8e833aa031bd6d706c06d21fefb ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_pkey;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__only_public );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1048;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1048;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_8aae826f04ca2a5df2a0de1a103a1f13;
    frame_a3b1f8e833aa031bd6d706c06d21fefb->m_frame.f_lineno = 1049;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1049;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_2 = par_pkey;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_cond_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__initialized );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1051;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 1051;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e;
    frame_a3b1f8e833aa031bd6d706c06d21fefb->m_frame.f_lineno = 1052;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 1052;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1054;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_EVP_get_digestbyname );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1054;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
    }

    if ( tmp_called_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
        exception_tb = NULL;

        exception_lineno = 1054;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_digest;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_a3b1f8e833aa031bd6d706c06d21fefb->m_frame.f_lineno = 1054;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1054;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_a3b1f8e833aa031bd6d706c06d21fefb->m_frame.f_lineno = 1054;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1054;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_digest_obj == NULL );
    var_digest_obj = tmp_assign_source_1;

    tmp_compare_left_1 = var_digest_obj;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1055;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1055;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1055;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_3 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
    frame_a3b1f8e833aa031bd6d706c06d21fefb->m_frame.f_lineno = 1056;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 1056;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1058;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_REQ_sign );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1058;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__req );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1058;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_pkey;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1058;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_digest_obj;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_a3b1f8e833aa031bd6d706c06d21fefb->m_frame.f_lineno = 1058;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1058;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_sign_result == NULL );
    var_sign_result = tmp_assign_source_2;

    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1059;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_sign_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_6 = RICH_COMPARE_GT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1059;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_a3b1f8e833aa031bd6d706c06d21fefb->m_frame.f_lineno = 1059;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1059;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a3b1f8e833aa031bd6d706c06d21fefb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a3b1f8e833aa031bd6d706c06d21fefb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a3b1f8e833aa031bd6d706c06d21fefb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a3b1f8e833aa031bd6d706c06d21fefb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a3b1f8e833aa031bd6d706c06d21fefb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a3b1f8e833aa031bd6d706c06d21fefb,
        type_description_1,
        par_self,
        par_pkey,
        par_digest,
        var_digest_obj,
        var_sign_result
    );


    // Release cached frame.
    if ( frame_a3b1f8e833aa031bd6d706c06d21fefb == cache_frame_a3b1f8e833aa031bd6d706c06d21fefb )
    {
        Py_DECREF( frame_a3b1f8e833aa031bd6d706c06d21fefb );
    }
    cache_frame_a3b1f8e833aa031bd6d706c06d21fefb = NULL;

    assertFrameObject( frame_a3b1f8e833aa031bd6d706c06d21fefb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_51_sign );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_digest_obj );
    Py_DECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)var_sign_result );
    Py_DECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_digest_obj );
    var_digest_obj = NULL;

    Py_XDECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_51_sign );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_52_verify( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_LtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_84aebb049548e459b85da103bbfd2471 = NULL;

    struct Nuitka_FrameObject *frame_84aebb049548e459b85da103bbfd2471;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_84aebb049548e459b85da103bbfd2471, codeobj_84aebb049548e459b85da103bbfd2471, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_84aebb049548e459b85da103bbfd2471 = cache_frame_84aebb049548e459b85da103bbfd2471;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_84aebb049548e459b85da103bbfd2471 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_84aebb049548e459b85da103bbfd2471 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_pkey;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 1073;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
    frame_84aebb049548e459b85da103bbfd2471->m_frame.f_lineno = 1074;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1074;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1076;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REQ_verify );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1076;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__req );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1076;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_pkey;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1076;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_84aebb049548e459b85da103bbfd2471->m_frame.f_lineno = 1076;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1076;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_compare_left_1 = var_result;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_LtE_1 = RICH_COMPARE_BOOL_LE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_LtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1077;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_LtE_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1078;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_84aebb049548e459b85da103bbfd2471->m_frame.f_lineno = 1078;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1078;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84aebb049548e459b85da103bbfd2471 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84aebb049548e459b85da103bbfd2471 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_84aebb049548e459b85da103bbfd2471, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_84aebb049548e459b85da103bbfd2471->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_84aebb049548e459b85da103bbfd2471, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_84aebb049548e459b85da103bbfd2471,
        type_description_1,
        par_self,
        par_pkey,
        var_result
    );


    // Release cached frame.
    if ( frame_84aebb049548e459b85da103bbfd2471 == cache_frame_84aebb049548e459b85da103bbfd2471 )
    {
        Py_DECREF( frame_84aebb049548e459b85da103bbfd2471 );
    }
    cache_frame_84aebb049548e459b85da103bbfd2471 = NULL;

    assertFrameObject( frame_84aebb049548e459b85da103bbfd2471 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_52_verify );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_52_verify );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_53___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_x509 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_1c0cae65699467a80d94f781d6c3d9b1 = NULL;

    struct Nuitka_FrameObject *frame_1c0cae65699467a80d94f781d6c3d9b1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1c0cae65699467a80d94f781d6c3d9b1, codeobj_1c0cae65699467a80d94f781d6c3d9b1, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_1c0cae65699467a80d94f781d6c3d9b1 = cache_frame_1c0cae65699467a80d94f781d6c3d9b1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1c0cae65699467a80d94f781d6c3d9b1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1c0cae65699467a80d94f781d6c3d9b1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1089;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_1c0cae65699467a80d94f781d6c3d9b1->m_frame.f_lineno = 1089;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_new );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1089;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_x509 == NULL );
    var_x509 = tmp_assign_source_1;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1090;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_x509;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1090;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1090;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1090;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_1c0cae65699467a80d94f781d6c3d9b1->m_frame.f_lineno = 1090;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1090;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1091;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_gc );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1091;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_x509;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1091;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_free );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1091;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_1c0cae65699467a80d94f781d6c3d9b1->m_frame.f_lineno = 1091;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1091;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__x509, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1091;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_X509NameInvalidator" );
        exception_tb = NULL;

        exception_lineno = 1093;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_1c0cae65699467a80d94f781d6c3d9b1->m_frame.f_lineno = 1093;
    tmp_assattr_name_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1093;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__issuer_invalidator, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 1093;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_X509NameInvalidator" );
        exception_tb = NULL;

        exception_lineno = 1094;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_1c0cae65699467a80d94f781d6c3d9b1->m_frame.f_lineno = 1094;
    tmp_assattr_name_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_assattr_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1094;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__subject_invalidator, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_3 );

        exception_lineno = 1094;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_3 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1c0cae65699467a80d94f781d6c3d9b1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1c0cae65699467a80d94f781d6c3d9b1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1c0cae65699467a80d94f781d6c3d9b1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1c0cae65699467a80d94f781d6c3d9b1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1c0cae65699467a80d94f781d6c3d9b1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1c0cae65699467a80d94f781d6c3d9b1,
        type_description_1,
        par_self,
        var_x509
    );


    // Release cached frame.
    if ( frame_1c0cae65699467a80d94f781d6c3d9b1 == cache_frame_1c0cae65699467a80d94f781d6c3d9b1 )
    {
        Py_DECREF( frame_1c0cae65699467a80d94f781d6c3d9b1 );
    }
    cache_frame_1c0cae65699467a80d94f781d6c3d9b1 = NULL;

    assertFrameObject( frame_1c0cae65699467a80d94f781d6c3d9b1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_53___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_x509 );
    Py_DECREF( var_x509 );
    var_x509 = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x509 );
    var_x509 = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_53___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_54__from_raw_x509_ptr( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_x509 = python_pars[ 1 ];
    PyObject *var_cert = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_474b942d1079d7aa7b5b630fd0d8885f = NULL;

    struct Nuitka_FrameObject *frame_474b942d1079d7aa7b5b630fd0d8885f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_474b942d1079d7aa7b5b630fd0d8885f, codeobj_474b942d1079d7aa7b5b630fd0d8885f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_474b942d1079d7aa7b5b630fd0d8885f = cache_frame_474b942d1079d7aa7b5b630fd0d8885f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_474b942d1079d7aa7b5b630fd0d8885f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_474b942d1079d7aa7b5b630fd0d8885f ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_cls;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_cls;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_474b942d1079d7aa7b5b630fd0d8885f->m_frame.f_lineno = 1098;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___new__, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1098;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_cert == NULL );
    var_cert = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1099;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1099;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_x509;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1099;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_free );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1099;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_474b942d1079d7aa7b5b630fd0d8885f->m_frame.f_lineno = 1099;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1099;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_cert;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__x509, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1099;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_X509NameInvalidator" );
        exception_tb = NULL;

        exception_lineno = 1100;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_474b942d1079d7aa7b5b630fd0d8885f->m_frame.f_lineno = 1100;
    tmp_assattr_name_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1100;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = var_cert;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__issuer_invalidator, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 1100;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_X509NameInvalidator" );
        exception_tb = NULL;

        exception_lineno = 1101;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_474b942d1079d7aa7b5b630fd0d8885f->m_frame.f_lineno = 1101;
    tmp_assattr_name_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_assattr_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1101;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_3 = var_cert;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__subject_invalidator, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_3 );

        exception_lineno = 1101;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_3 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_474b942d1079d7aa7b5b630fd0d8885f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_474b942d1079d7aa7b5b630fd0d8885f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_474b942d1079d7aa7b5b630fd0d8885f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_474b942d1079d7aa7b5b630fd0d8885f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_474b942d1079d7aa7b5b630fd0d8885f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_474b942d1079d7aa7b5b630fd0d8885f,
        type_description_1,
        par_cls,
        par_x509,
        var_cert
    );


    // Release cached frame.
    if ( frame_474b942d1079d7aa7b5b630fd0d8885f == cache_frame_474b942d1079d7aa7b5b630fd0d8885f )
    {
        Py_DECREF( frame_474b942d1079d7aa7b5b630fd0d8885f );
    }
    cache_frame_474b942d1079d7aa7b5b630fd0d8885f = NULL;

    assertFrameObject( frame_474b942d1079d7aa7b5b630fd0d8885f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_cert;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_54__from_raw_x509_ptr );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x509 );
    Py_DECREF( par_x509 );
    par_x509 = NULL;

    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x509 );
    Py_DECREF( par_x509 );
    par_x509 = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_54__from_raw_x509_ptr );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_55_to_cryptography( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var__Certificate = NULL;
    PyObject *var_backend = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_6f232e0892e44270bff4d47905df44dc = NULL;

    struct Nuitka_FrameObject *frame_6f232e0892e44270bff4d47905df44dc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6f232e0892e44270bff4d47905df44dc, codeobj_6f232e0892e44270bff4d47905df44dc, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6f232e0892e44270bff4d47905df44dc = cache_frame_6f232e0892e44270bff4d47905df44dc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6f232e0892e44270bff4d47905df44dc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6f232e0892e44270bff4d47905df44dc ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_2b6a6c0099f1f1dd77d2725acd0722df;
    tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain__Certificate_tuple;
    frame_6f232e0892e44270bff4d47905df44dc->m_frame.f_lineno = 1112;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1112;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain__Certificate );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1112;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var__Certificate == NULL );
    var__Certificate = tmp_assign_source_1;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__get_backend );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_get_backend" );
        exception_tb = NULL;

        exception_lineno = 1114;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_6f232e0892e44270bff4d47905df44dc->m_frame.f_lineno = 1114;
    tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1114;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_backend == NULL );
    var_backend = tmp_assign_source_2;

    tmp_called_name_2 = var__Certificate;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_args_element_name_1 = var_backend;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__x509 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_6f232e0892e44270bff4d47905df44dc->m_frame.f_lineno = 1115;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f232e0892e44270bff4d47905df44dc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f232e0892e44270bff4d47905df44dc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f232e0892e44270bff4d47905df44dc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6f232e0892e44270bff4d47905df44dc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6f232e0892e44270bff4d47905df44dc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6f232e0892e44270bff4d47905df44dc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6f232e0892e44270bff4d47905df44dc,
        type_description_1,
        par_self,
        var__Certificate,
        var_backend
    );


    // Release cached frame.
    if ( frame_6f232e0892e44270bff4d47905df44dc == cache_frame_6f232e0892e44270bff4d47905df44dc )
    {
        Py_DECREF( frame_6f232e0892e44270bff4d47905df44dc );
    }
    cache_frame_6f232e0892e44270bff4d47905df44dc = NULL;

    assertFrameObject( frame_6f232e0892e44270bff4d47905df44dc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_55_to_cryptography );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var__Certificate );
    Py_DECREF( var__Certificate );
    var__Certificate = NULL;

    CHECK_OBJECT( (PyObject *)var_backend );
    Py_DECREF( var_backend );
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var__Certificate );
    var__Certificate = NULL;

    Py_XDECREF( var_backend );
    var_backend = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_55_to_cryptography );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_56_from_cryptography( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_crypto_cert = python_pars[ 1 ];
    PyObject *var_cert = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_e1bd12349b684047b31907a697c36274 = NULL;

    struct Nuitka_FrameObject *frame_e1bd12349b684047b31907a697c36274;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e1bd12349b684047b31907a697c36274, codeobj_e1bd12349b684047b31907a697c36274, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e1bd12349b684047b31907a697c36274 = cache_frame_e1bd12349b684047b31907a697c36274;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e1bd12349b684047b31907a697c36274 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e1bd12349b684047b31907a697c36274 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_crypto_cert;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_x509 );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_x509 );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "x509" );
        exception_tb = NULL;

        exception_lineno = 1129;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Certificate );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1129;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1129;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_6674ab14e1178de501dfb968278a50b9;
    frame_e1bd12349b684047b31907a697c36274->m_frame.f_lineno = 1130;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1130;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_called_name_1 = par_cls;

    CHECK_OBJECT( tmp_called_name_1 );
    frame_e1bd12349b684047b31907a697c36274->m_frame.f_lineno = 1132;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1132;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_cert == NULL );
    var_cert = tmp_assign_source_1;

    tmp_source_name_2 = par_crypto_cert;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1133;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_cert;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__x509, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1133;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e1bd12349b684047b31907a697c36274 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e1bd12349b684047b31907a697c36274 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e1bd12349b684047b31907a697c36274, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e1bd12349b684047b31907a697c36274->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e1bd12349b684047b31907a697c36274, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e1bd12349b684047b31907a697c36274,
        type_description_1,
        par_cls,
        par_crypto_cert,
        var_cert
    );


    // Release cached frame.
    if ( frame_e1bd12349b684047b31907a697c36274 == cache_frame_e1bd12349b684047b31907a697c36274 )
    {
        Py_DECREF( frame_e1bd12349b684047b31907a697c36274 );
    }
    cache_frame_e1bd12349b684047b31907a697c36274 = NULL;

    assertFrameObject( frame_e1bd12349b684047b31907a697c36274 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_cert;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_56_from_cryptography );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_crypto_cert );
    Py_DECREF( par_crypto_cert );
    par_crypto_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_crypto_cert );
    Py_DECREF( par_crypto_cert );
    par_crypto_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_56_from_cryptography );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_57_set_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_version = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_d41d40838f88795a151b0b852e40ee1b = NULL;

    struct Nuitka_FrameObject *frame_d41d40838f88795a151b0b852e40ee1b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d41d40838f88795a151b0b852e40ee1b, codeobj_d41d40838f88795a151b0b852e40ee1b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_d41d40838f88795a151b0b852e40ee1b = cache_frame_d41d40838f88795a151b0b852e40ee1b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d41d40838f88795a151b0b852e40ee1b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d41d40838f88795a151b0b852e40ee1b ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_version;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1146;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_2dbcbe3e7da77178b4a9da40244d072a;
    frame_d41d40838f88795a151b0b852e40ee1b->m_frame.f_lineno = 1147;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1147;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1149;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_set_version );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1149;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1149;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_version;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_d41d40838f88795a151b0b852e40ee1b->m_frame.f_lineno = 1149;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1149;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d41d40838f88795a151b0b852e40ee1b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d41d40838f88795a151b0b852e40ee1b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d41d40838f88795a151b0b852e40ee1b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d41d40838f88795a151b0b852e40ee1b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d41d40838f88795a151b0b852e40ee1b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d41d40838f88795a151b0b852e40ee1b,
        type_description_1,
        par_self,
        par_version
    );


    // Release cached frame.
    if ( frame_d41d40838f88795a151b0b852e40ee1b == cache_frame_d41d40838f88795a151b0b852e40ee1b )
    {
        Py_DECREF( frame_d41d40838f88795a151b0b852e40ee1b );
    }
    cache_frame_d41d40838f88795a151b0b852e40ee1b = NULL;

    assertFrameObject( frame_d41d40838f88795a151b0b852e40ee1b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_57_set_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_version );
    Py_DECREF( par_version );
    par_version = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_version );
    Py_DECREF( par_version );
    par_version = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_57_set_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_58_get_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_21af353ae645ab8ee28b6adbc1ad3978 = NULL;

    struct Nuitka_FrameObject *frame_21af353ae645ab8ee28b6adbc1ad3978;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_21af353ae645ab8ee28b6adbc1ad3978, codeobj_21af353ae645ab8ee28b6adbc1ad3978, module_OpenSSL$crypto, sizeof(void *) );
    frame_21af353ae645ab8ee28b6adbc1ad3978 = cache_frame_21af353ae645ab8ee28b6adbc1ad3978;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_21af353ae645ab8ee28b6adbc1ad3978 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_21af353ae645ab8ee28b6adbc1ad3978 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1158;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_get_version );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1158;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1158;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_21af353ae645ab8ee28b6adbc1ad3978->m_frame.f_lineno = 1158;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1158;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_21af353ae645ab8ee28b6adbc1ad3978 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_21af353ae645ab8ee28b6adbc1ad3978 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_21af353ae645ab8ee28b6adbc1ad3978 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_21af353ae645ab8ee28b6adbc1ad3978, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_21af353ae645ab8ee28b6adbc1ad3978->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_21af353ae645ab8ee28b6adbc1ad3978, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_21af353ae645ab8ee28b6adbc1ad3978,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_21af353ae645ab8ee28b6adbc1ad3978 == cache_frame_21af353ae645ab8ee28b6adbc1ad3978 )
    {
        Py_DECREF( frame_21af353ae645ab8ee28b6adbc1ad3978 );
    }
    cache_frame_21af353ae645ab8ee28b6adbc1ad3978 = NULL;

    assertFrameObject( frame_21af353ae645ab8ee28b6adbc1ad3978 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_58_get_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_58_get_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_59_get_pubkey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_pkey = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b = NULL;

    struct Nuitka_FrameObject *frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b, codeobj_f442bcbb68e2ecc7a7ffb9f1ee7dc59b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b = cache_frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 1167;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1167;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_args_element_name_1 == NULL ))
    {
        tmp_args_element_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 1167;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b->m_frame.f_lineno = 1167;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1167;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_pkey == NULL );
    var_pkey = tmp_assign_source_1;

    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1168;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_get_pubkey );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1168;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__x509 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1168;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b->m_frame.f_lineno = 1168;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1168;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1168;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_source_name_4 = var_pkey;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__pkey );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1169;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_compare_left_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1169;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1169;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1169;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1170;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b->m_frame.f_lineno = 1170;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1170;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1171;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_gc );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1171;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = var_pkey;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1171;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1171;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_EVP_PKEY_free );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1171;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b->m_frame.f_lineno = 1171;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1171;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__pkey, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 1171;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_assattr_name_3 = Py_True;
    tmp_assattr_target_3 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__only_public, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1172;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b,
        type_description_1,
        par_self,
        var_pkey
    );


    // Release cached frame.
    if ( frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b == cache_frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b )
    {
        Py_DECREF( frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b );
    }
    cache_frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b = NULL;

    assertFrameObject( frame_f442bcbb68e2ecc7a7ffb9f1ee7dc59b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_pkey;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_59_get_pubkey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_59_get_pubkey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_60_set_pubkey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *var_set_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_335819dcf5f2ff177db72f200198965d = NULL;

    struct Nuitka_FrameObject *frame_335819dcf5f2ff177db72f200198965d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_335819dcf5f2ff177db72f200198965d, codeobj_335819dcf5f2ff177db72f200198965d, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_335819dcf5f2ff177db72f200198965d = cache_frame_335819dcf5f2ff177db72f200198965d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_335819dcf5f2ff177db72f200198965d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_335819dcf5f2ff177db72f200198965d ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_pkey;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 1184;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1184;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
    frame_335819dcf5f2ff177db72f200198965d->m_frame.f_lineno = 1185;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1185;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1187;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_set_pubkey );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1187;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1187;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_pkey;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1187;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_335819dcf5f2ff177db72f200198965d->m_frame.f_lineno = 1187;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1187;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_set_result == NULL );
    var_set_result = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1188;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_set_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_3 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1188;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_335819dcf5f2ff177db72f200198965d->m_frame.f_lineno = 1188;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1188;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_335819dcf5f2ff177db72f200198965d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_335819dcf5f2ff177db72f200198965d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_335819dcf5f2ff177db72f200198965d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_335819dcf5f2ff177db72f200198965d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_335819dcf5f2ff177db72f200198965d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_335819dcf5f2ff177db72f200198965d,
        type_description_1,
        par_self,
        par_pkey,
        var_set_result
    );


    // Release cached frame.
    if ( frame_335819dcf5f2ff177db72f200198965d == cache_frame_335819dcf5f2ff177db72f200198965d )
    {
        Py_DECREF( frame_335819dcf5f2ff177db72f200198965d );
    }
    cache_frame_335819dcf5f2ff177db72f200198965d = NULL;

    assertFrameObject( frame_335819dcf5f2ff177db72f200198965d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_60_set_pubkey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_60_set_pubkey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_61_sign( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *par_digest = python_pars[ 2 ];
    PyObject *var_sign_result = NULL;
    PyObject *var_evp_md = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_make_exception_arg_4;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_raise_type_4;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_62b37b398cca624e1da0cba42e8c2fbe = NULL;

    struct Nuitka_FrameObject *frame_62b37b398cca624e1da0cba42e8c2fbe;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_62b37b398cca624e1da0cba42e8c2fbe, codeobj_62b37b398cca624e1da0cba42e8c2fbe, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_62b37b398cca624e1da0cba42e8c2fbe = cache_frame_62b37b398cca624e1da0cba42e8c2fbe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_62b37b398cca624e1da0cba42e8c2fbe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_62b37b398cca624e1da0cba42e8c2fbe ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_pkey;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 1202;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1202;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
    frame_62b37b398cca624e1da0cba42e8c2fbe->m_frame.f_lineno = 1203;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1203;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_pkey;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__only_public );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1205;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1205;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_dc44ec2c02bcac7fac23b8eea57aa5d6;
    frame_62b37b398cca624e1da0cba42e8c2fbe->m_frame.f_lineno = 1206;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 1206;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_source_name_2 = par_pkey;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_cond_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__initialized );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1208;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 1208;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_3 = const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e;
    frame_62b37b398cca624e1da0cba42e8c2fbe->m_frame.f_lineno = 1209;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 1209;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1211;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_EVP_get_digestbyname );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1211;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
    }

    if ( tmp_called_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
        exception_tb = NULL;

        exception_lineno = 1211;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_digest;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_62b37b398cca624e1da0cba42e8c2fbe->m_frame.f_lineno = 1211;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1211;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_62b37b398cca624e1da0cba42e8c2fbe->m_frame.f_lineno = 1211;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1211;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_evp_md == NULL );
    var_evp_md = tmp_assign_source_1;

    tmp_compare_left_1 = var_evp_md;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1212;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1212;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_make_exception_arg_4 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
    frame_62b37b398cca624e1da0cba42e8c2fbe->m_frame.f_lineno = 1213;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_4 };
        tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_4 != NULL );
    exception_type = tmp_raise_type_4;
    exception_lineno = 1213;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_4:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1215;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_sign );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1215;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__x509 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1215;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_pkey;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1215;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_evp_md;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_62b37b398cca624e1da0cba42e8c2fbe->m_frame.f_lineno = 1215;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1215;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_sign_result == NULL );
    var_sign_result = tmp_assign_source_2;

    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1216;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_sign_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_6 = RICH_COMPARE_GT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1216;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_62b37b398cca624e1da0cba42e8c2fbe->m_frame.f_lineno = 1216;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1216;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_62b37b398cca624e1da0cba42e8c2fbe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_62b37b398cca624e1da0cba42e8c2fbe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_62b37b398cca624e1da0cba42e8c2fbe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_62b37b398cca624e1da0cba42e8c2fbe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_62b37b398cca624e1da0cba42e8c2fbe, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_62b37b398cca624e1da0cba42e8c2fbe,
        type_description_1,
        par_self,
        par_pkey,
        par_digest,
        var_sign_result,
        var_evp_md
    );


    // Release cached frame.
    if ( frame_62b37b398cca624e1da0cba42e8c2fbe == cache_frame_62b37b398cca624e1da0cba42e8c2fbe )
    {
        Py_DECREF( frame_62b37b398cca624e1da0cba42e8c2fbe );
    }
    cache_frame_62b37b398cca624e1da0cba42e8c2fbe = NULL;

    assertFrameObject( frame_62b37b398cca624e1da0cba42e8c2fbe );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_61_sign );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_sign_result );
    Py_DECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    CHECK_OBJECT( (PyObject *)var_evp_md );
    Py_DECREF( var_evp_md );
    var_evp_md = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    Py_XDECREF( var_evp_md );
    var_evp_md = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_61_sign );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_62_get_signature_algorithm( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_algor = NULL;
    PyObject *var_nid = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    static struct Nuitka_FrameObject *cache_frame_80b295e7b075bea47091b563200e78b8 = NULL;

    struct Nuitka_FrameObject *frame_80b295e7b075bea47091b563200e78b8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_80b295e7b075bea47091b563200e78b8, codeobj_80b295e7b075bea47091b563200e78b8, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_80b295e7b075bea47091b563200e78b8 = cache_frame_80b295e7b075bea47091b563200e78b8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_80b295e7b075bea47091b563200e78b8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_80b295e7b075bea47091b563200e78b8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1229;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_get0_tbs_sigalg );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1229;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1229;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_80b295e7b075bea47091b563200e78b8->m_frame.f_lineno = 1229;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1229;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_algor == NULL );
    var_algor = tmp_assign_source_1;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1230;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_OBJ_obj2nid );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1230;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = var_algor;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_algorithm );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1230;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_80b295e7b075bea47091b563200e78b8->m_frame.f_lineno = 1230;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1230;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_nid == NULL );
    var_nid = tmp_assign_source_2;

    tmp_compare_left_1 = var_nid;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1231;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NID_undef );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1231;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1231;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_79dac080796da8f8fc9c66ebe460ce2f;
    frame_80b295e7b075bea47091b563200e78b8->m_frame.f_lineno = 1232;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1232;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1233;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_string );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1233;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1233;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = var_nid;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_80b295e7b075bea47091b563200e78b8->m_frame.f_lineno = 1233;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_OBJ_nid2ln, call_args );
    }

    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1233;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_80b295e7b075bea47091b563200e78b8->m_frame.f_lineno = 1233;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1233;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_80b295e7b075bea47091b563200e78b8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_80b295e7b075bea47091b563200e78b8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_80b295e7b075bea47091b563200e78b8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_80b295e7b075bea47091b563200e78b8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_80b295e7b075bea47091b563200e78b8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_80b295e7b075bea47091b563200e78b8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_80b295e7b075bea47091b563200e78b8,
        type_description_1,
        par_self,
        var_algor,
        var_nid
    );


    // Release cached frame.
    if ( frame_80b295e7b075bea47091b563200e78b8 == cache_frame_80b295e7b075bea47091b563200e78b8 )
    {
        Py_DECREF( frame_80b295e7b075bea47091b563200e78b8 );
    }
    cache_frame_80b295e7b075bea47091b563200e78b8 = NULL;

    assertFrameObject( frame_80b295e7b075bea47091b563200e78b8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_62_get_signature_algorithm );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_algor );
    Py_DECREF( var_algor );
    var_algor = NULL;

    CHECK_OBJECT( (PyObject *)var_nid );
    Py_DECREF( var_nid );
    var_nid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_algor );
    var_algor = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_62_get_signature_algorithm );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_63_digest( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_digest_name = python_pars[ 1 ];
    PyObject *var_digest_result = NULL;
    PyObject *var_ch = NULL;
    PyObject *var_result_length = NULL;
    PyObject *var_result_buffer = NULL;
    PyObject *var_digest = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_39cfa03514a1d73dd0565fdcb05e6808 = NULL;

    struct Nuitka_FrameObject *frame_39cfa03514a1d73dd0565fdcb05e6808;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_39cfa03514a1d73dd0565fdcb05e6808, codeobj_39cfa03514a1d73dd0565fdcb05e6808, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_39cfa03514a1d73dd0565fdcb05e6808 = cache_frame_39cfa03514a1d73dd0565fdcb05e6808;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_39cfa03514a1d73dd0565fdcb05e6808 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_39cfa03514a1d73dd0565fdcb05e6808 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1246;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EVP_get_digestbyname );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1246;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
    }

    if ( tmp_called_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
        exception_tb = NULL;

        exception_lineno = 1246;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_digest_name;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_39cfa03514a1d73dd0565fdcb05e6808->m_frame.f_lineno = 1246;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1246;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_39cfa03514a1d73dd0565fdcb05e6808->m_frame.f_lineno = 1246;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1246;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_digest == NULL );
    var_digest = tmp_assign_source_1;

    tmp_compare_left_1 = var_digest;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1247;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1247;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1247;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
    frame_39cfa03514a1d73dd0565fdcb05e6808->m_frame.f_lineno = 1248;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1248;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1250;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_new );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1250;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1250;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_EVP_MAX_MD_SIZE );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1250;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_39cfa03514a1d73dd0565fdcb05e6808->m_frame.f_lineno = 1250;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1250;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_buffer == NULL );
    var_result_buffer = tmp_assign_source_2;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1251;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    frame_39cfa03514a1d73dd0565fdcb05e6808->m_frame.f_lineno = 1251;
    tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_bc7a2d385ac0b4ca6f6caa64ccb6a3b9_int_pos_1_tuple, 0 ) );

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1251;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_length == NULL );
    var_result_length = tmp_assign_source_3;

    tmp_len_arg_1 = var_result_buffer;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_ass_subvalue_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1252;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = var_result_length;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1252;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1254;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_digest );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1254;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__x509 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1255;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_digest;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = var_result_buffer;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = var_result_length;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_39cfa03514a1d73dd0565fdcb05e6808->m_frame.f_lineno = 1254;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1254;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_digest_result == NULL );
    var_digest_result = tmp_assign_source_4;

    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1257;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_digest_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_9 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1257;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_39cfa03514a1d73dd0565fdcb05e6808->m_frame.f_lineno = 1257;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1257;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_7 = const_str_chr_58;
    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_join );
    assert( tmp_called_name_6 != NULL );
    // Tried code:
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1262;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_buffer );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1262;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_11 = var_result_buffer;

    CHECK_OBJECT( tmp_args_element_name_11 );
    tmp_subscribed_name_1 = var_result_length;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_args_element_name_12 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 1262;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    frame_39cfa03514a1d73dd0565fdcb05e6808->m_frame.f_lineno = 1262;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_12 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1262;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1261;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    assert( tmp_list_contraction_1__$0 == NULL );
    tmp_list_contraction_1__$0 = tmp_assign_source_5;

    tmp_assign_source_6 = PyList_New( 0 );
    assert( tmp_list_contraction_1__contraction_result == NULL );
    tmp_list_contraction_1__contraction_result = tmp_assign_source_6;

    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_list_contraction_1__$0;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_7 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_7 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooooo";
        exception_lineno = 1261;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_list_contraction_1__iter_value_0;
        tmp_list_contraction_1__iter_value_0 = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_2 = exception_keeper_type_1;
    tmp_compare_right_2 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1261;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_2;
    branch_no_2:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_2:;
    // End of try:
    try_end_1:;
    tmp_assign_source_8 = tmp_list_contraction_1__iter_value_0;

    CHECK_OBJECT( tmp_assign_source_8 );
    {
        PyObject *old = var_ch;
        var_ch = tmp_assign_source_8;
        Py_INCREF( var_ch );
        Py_XDECREF( old );
    }

    tmp_append_list_1 = tmp_list_contraction_1__contraction_result;

    CHECK_OBJECT( tmp_append_list_1 );
    tmp_called_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_b16encode );

    if (unlikely( tmp_called_name_8 == NULL ))
    {
        tmp_called_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_b16encode );
    }

    if ( tmp_called_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "b16encode" );
        exception_tb = NULL;

        exception_lineno = 1261;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_13 = var_ch;

    CHECK_OBJECT( tmp_args_element_name_13 );
    frame_39cfa03514a1d73dd0565fdcb05e6808->m_frame.f_lineno = 1261;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_called_instance_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
    }

    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1261;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    frame_39cfa03514a1d73dd0565fdcb05e6808->m_frame.f_lineno = 1261;
    tmp_append_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_upper );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_append_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1261;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    Py_DECREF( tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1261;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1261;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_outline_return_value_1 = tmp_list_contraction_1__contraction_result;

    CHECK_OBJECT( tmp_outline_return_value_1 );
    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_63_digest );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__$0 );
    Py_DECREF( tmp_list_contraction_1__$0 );
    tmp_list_contraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__contraction_result );
    Py_DECREF( tmp_list_contraction_1__contraction_result );
    tmp_list_contraction_1__contraction_result = NULL;

    Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
    tmp_list_contraction_1__iter_value_0 = NULL;

    goto outline_result_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_list_contraction_1__$0 );
    tmp_list_contraction_1__$0 = NULL;

    Py_XDECREF( tmp_list_contraction_1__contraction_result );
    tmp_list_contraction_1__contraction_result = NULL;

    Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
    tmp_list_contraction_1__iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_63_digest );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_10 = tmp_outline_return_value_1;
    frame_39cfa03514a1d73dd0565fdcb05e6808->m_frame.f_lineno = 1259;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1259;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_39cfa03514a1d73dd0565fdcb05e6808 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_39cfa03514a1d73dd0565fdcb05e6808 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_39cfa03514a1d73dd0565fdcb05e6808 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_39cfa03514a1d73dd0565fdcb05e6808, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_39cfa03514a1d73dd0565fdcb05e6808->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_39cfa03514a1d73dd0565fdcb05e6808, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_39cfa03514a1d73dd0565fdcb05e6808,
        type_description_1,
        par_self,
        par_digest_name,
        var_digest_result,
        var_ch,
        var_result_length,
        var_result_buffer,
        var_digest
    );


    // Release cached frame.
    if ( frame_39cfa03514a1d73dd0565fdcb05e6808 == cache_frame_39cfa03514a1d73dd0565fdcb05e6808 )
    {
        Py_DECREF( frame_39cfa03514a1d73dd0565fdcb05e6808 );
    }
    cache_frame_39cfa03514a1d73dd0565fdcb05e6808 = NULL;

    assertFrameObject( frame_39cfa03514a1d73dd0565fdcb05e6808 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_63_digest );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_digest_result );
    Py_DECREF( var_digest_result );
    var_digest_result = NULL;

    Py_XDECREF( var_ch );
    var_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_digest_name );
    Py_DECREF( par_digest_name );
    par_digest_name = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_result_length );
    Py_DECREF( var_result_length );
    var_result_length = NULL;

    CHECK_OBJECT( (PyObject *)var_result_buffer );
    Py_DECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_digest );
    Py_DECREF( var_digest );
    var_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_digest_result );
    var_digest_result = NULL;

    Py_XDECREF( var_ch );
    var_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_digest_name );
    Py_DECREF( par_digest_name );
    par_digest_name = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result_length );
    var_result_length = NULL;

    Py_XDECREF( var_result_buffer );
    var_result_buffer = NULL;

    Py_XDECREF( var_digest );
    var_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_63_digest );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_64_subject_name_hash( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_8a05448908bde9009224b5554b838346 = NULL;

    struct Nuitka_FrameObject *frame_8a05448908bde9009224b5554b838346;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8a05448908bde9009224b5554b838346, codeobj_8a05448908bde9009224b5554b838346, module_OpenSSL$crypto, sizeof(void *) );
    frame_8a05448908bde9009224b5554b838346 = cache_frame_8a05448908bde9009224b5554b838346;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8a05448908bde9009224b5554b838346 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8a05448908bde9009224b5554b838346 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1273;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_subject_name_hash );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1273;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1273;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_8a05448908bde9009224b5554b838346->m_frame.f_lineno = 1273;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1273;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a05448908bde9009224b5554b838346 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a05448908bde9009224b5554b838346 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a05448908bde9009224b5554b838346 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8a05448908bde9009224b5554b838346, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8a05448908bde9009224b5554b838346->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8a05448908bde9009224b5554b838346, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8a05448908bde9009224b5554b838346,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8a05448908bde9009224b5554b838346 == cache_frame_8a05448908bde9009224b5554b838346 )
    {
        Py_DECREF( frame_8a05448908bde9009224b5554b838346 );
    }
    cache_frame_8a05448908bde9009224b5554b838346 = NULL;

    assertFrameObject( frame_8a05448908bde9009224b5554b838346 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_64_subject_name_hash );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_64_subject_name_hash );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_65_set_serial_number( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_serial = python_pars[ 1 ];
    PyObject *var_asn1_serial = NULL;
    PyObject *var_bignum_serial = NULL;
    PyObject *var_set_result = NULL;
    PyObject *var_small_serial = NULL;
    PyObject *var_hex_serial = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_hex_arg_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_ece9e443ce0480c90f4788350c457a64 = NULL;

    struct Nuitka_FrameObject *frame_ece9e443ce0480c90f4788350c457a64;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ece9e443ce0480c90f4788350c457a64, codeobj_ece9e443ce0480c90f4788350c457a64, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ece9e443ce0480c90f4788350c457a64 = cache_frame_ece9e443ce0480c90f4788350c457a64;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ece9e443ce0480c90f4788350c457a64 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ece9e443ce0480c90f4788350c457a64 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_serial;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__integer_types );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__integer_types );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_integer_types" );
        exception_tb = NULL;

        exception_lineno = 1284;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1284;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_b1f5a355e1403668d0044e1a65ec29ce;
    frame_ece9e443ce0480c90f4788350c457a64->m_frame.f_lineno = 1285;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1285;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_sliceslicedel_index_lower_1 = 2;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_hex_arg_1 = par_serial;

    CHECK_OBJECT( tmp_hex_arg_1 );
    tmp_slice_source_1 = BUILTIN_HEX( tmp_hex_arg_1 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1287;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1287;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_hex_serial == NULL );
    var_hex_serial = tmp_assign_source_1;

    tmp_isinstance_inst_2 = var_hex_serial;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_isinstance_cls_2 = (PyObject *)&PyString_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1288;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_called_instance_1 = var_hex_serial;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_ece9e443ce0480c90f4788350c457a64->m_frame.f_lineno = 1289;
    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1289;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_hex_serial;
        assert( old != NULL );
        var_hex_serial = tmp_assign_source_2;
        Py_DECREF( old );
    }

    branch_no_2:;
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1291;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    frame_ece9e443ce0480c90f4788350c457a64->m_frame.f_lineno = 1291;
    tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple, 0 ) );

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1291;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bignum_serial == NULL );
    var_bignum_serial = tmp_assign_source_3;

    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1296;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = var_bignum_serial;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = var_hex_serial;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_ece9e443ce0480c90f4788350c457a64->m_frame.f_lineno = 1296;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_BN_hex2bn, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1296;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_small_serial == NULL );
    var_small_serial = tmp_assign_source_4;

    tmp_subscribed_name_1 = var_bignum_serial;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_compare_left_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1298;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_compare_left_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1298;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1298;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1298;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1299;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_ASN1_INTEGER_set );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1299;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1300;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_get_serialNumber );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1300;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__x509 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1300;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_ece9e443ce0480c90f4788350c457a64->m_frame.f_lineno = 1300;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1300;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_small_serial;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_ece9e443ce0480c90f4788350c457a64->m_frame.f_lineno = 1299;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_5 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1299;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_set_result == NULL );
    var_set_result = tmp_assign_source_5;

    tmp_cond_value_1 = var_set_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1302;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1304;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    frame_ece9e443ce0480c90f4788350c457a64->m_frame.f_lineno = 1304;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1304;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    goto branch_end_3;
    branch_no_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1306;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_BN_to_ASN1_INTEGER );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1306;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = var_bignum_serial;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_0;
    tmp_args_element_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1306;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1306;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_6 );

        exception_lineno = 1306;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_ece9e443ce0480c90f4788350c457a64->m_frame.f_lineno = 1306;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1306;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_asn1_serial == NULL );
    var_asn1_serial = tmp_assign_source_6;

    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1307;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_BN_free );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1307;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = var_bignum_serial;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_0;
    tmp_args_element_name_8 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1307;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_ece9e443ce0480c90f4788350c457a64->m_frame.f_lineno = 1307;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1307;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_compare_left_2 = var_asn1_serial;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1308;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_NULL );
    if ( tmp_compare_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1308;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 1308;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1310;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    frame_ece9e443ce0480c90f4788350c457a64->m_frame.f_lineno = 1310;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1310;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1311;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_gc );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1311;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_asn1_serial;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1311;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_ASN1_INTEGER_free );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 1311;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_ece9e443ce0480c90f4788350c457a64->m_frame.f_lineno = 1311;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1311;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_asn1_serial;
        assert( old != NULL );
        var_asn1_serial = tmp_assign_source_7;
        Py_DECREF( old );
    }

    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1312;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_X509_set_serialNumber );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1312;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_12 = par_self;

    CHECK_OBJECT( tmp_source_name_12 );
    tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain__x509 );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );

        exception_lineno = 1312;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_12 = var_asn1_serial;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_ece9e443ce0480c90f4788350c457a64->m_frame.f_lineno = 1312;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_called_name_8 );
    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1312;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_set_result == NULL );
    var_set_result = tmp_assign_source_8;

    tmp_called_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_9 == NULL ))
    {
        tmp_called_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1313;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_set_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_13 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1313;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_ece9e443ce0480c90f4788350c457a64->m_frame.f_lineno = 1313;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_args_element_name_13 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1313;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ece9e443ce0480c90f4788350c457a64 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ece9e443ce0480c90f4788350c457a64 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ece9e443ce0480c90f4788350c457a64, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ece9e443ce0480c90f4788350c457a64->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ece9e443ce0480c90f4788350c457a64, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ece9e443ce0480c90f4788350c457a64,
        type_description_1,
        par_self,
        par_serial,
        var_asn1_serial,
        var_bignum_serial,
        var_set_result,
        var_small_serial,
        var_hex_serial
    );


    // Release cached frame.
    if ( frame_ece9e443ce0480c90f4788350c457a64 == cache_frame_ece9e443ce0480c90f4788350c457a64 )
    {
        Py_DECREF( frame_ece9e443ce0480c90f4788350c457a64 );
    }
    cache_frame_ece9e443ce0480c90f4788350c457a64 = NULL;

    assertFrameObject( frame_ece9e443ce0480c90f4788350c457a64 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_65_set_serial_number );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_asn1_serial );
    var_asn1_serial = NULL;

    CHECK_OBJECT( (PyObject *)var_bignum_serial );
    Py_DECREF( var_bignum_serial );
    var_bignum_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    CHECK_OBJECT( (PyObject *)var_small_serial );
    Py_DECREF( var_small_serial );
    var_small_serial = NULL;

    CHECK_OBJECT( (PyObject *)var_hex_serial );
    Py_DECREF( var_hex_serial );
    var_hex_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_serial );
    Py_DECREF( par_serial );
    par_serial = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_asn1_serial );
    var_asn1_serial = NULL;

    Py_XDECREF( var_bignum_serial );
    var_bignum_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    Py_XDECREF( var_small_serial );
    var_small_serial = NULL;

    Py_XDECREF( var_hex_serial );
    var_hex_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_serial );
    Py_DECREF( par_serial );
    par_serial = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_65_set_serial_number );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_66_get_serial_number( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_bignum_serial = NULL;
    PyObject *var_hexstring_serial = NULL;
    PyObject *var_asn1_serial = NULL;
    PyObject *var_hex_serial = NULL;
    PyObject *var_serial = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_base_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_cd8026d8c03981ef7b359feb3aa91a02 = NULL;

    struct Nuitka_FrameObject *frame_cd8026d8c03981ef7b359feb3aa91a02;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cd8026d8c03981ef7b359feb3aa91a02, codeobj_cd8026d8c03981ef7b359feb3aa91a02, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_cd8026d8c03981ef7b359feb3aa91a02 = cache_frame_cd8026d8c03981ef7b359feb3aa91a02;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cd8026d8c03981ef7b359feb3aa91a02 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cd8026d8c03981ef7b359feb3aa91a02 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1322;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_get_serialNumber );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1322;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1322;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_cd8026d8c03981ef7b359feb3aa91a02->m_frame.f_lineno = 1322;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1322;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_asn1_serial == NULL );
    var_asn1_serial = tmp_assign_source_1;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1323;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_ASN1_INTEGER_to_BN );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1323;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_asn1_serial;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1323;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1323;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_cd8026d8c03981ef7b359feb3aa91a02->m_frame.f_lineno = 1323;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1323;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bignum_serial == NULL );
    var_bignum_serial = tmp_assign_source_2;

    // Tried code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1325;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_4 = var_bignum_serial;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_cd8026d8c03981ef7b359feb3aa91a02->m_frame.f_lineno = 1325;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_BN_bn2hex, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1325;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    assert( var_hex_serial == NULL );
    var_hex_serial = tmp_assign_source_3;

    // Tried code:
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1327;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }

    tmp_args_element_name_5 = var_hex_serial;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_cd8026d8c03981ef7b359feb3aa91a02->m_frame.f_lineno = 1327;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_string, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1327;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    assert( var_hexstring_serial == NULL );
    var_hexstring_serial = tmp_assign_source_4;

    tmp_value_name_1 = var_hexstring_serial;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_base_name_1 = const_int_pos_16;
    tmp_assign_source_5 = TO_INT2( tmp_value_name_1, tmp_base_name_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1328;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    assert( var_serial == NULL );
    var_serial = tmp_assign_source_5;

    tmp_return_value = var_serial;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_66_get_serial_number );
    return NULL;
    // Return handler code:
    try_return_handler_3:;
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1331;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_6 = var_hex_serial;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_cd8026d8c03981ef7b359feb3aa91a02->m_frame.f_lineno = 1331;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_OPENSSL_free, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1331;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto try_return_handler_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1331;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_7 = var_hex_serial;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_cd8026d8c03981ef7b359feb3aa91a02->m_frame.f_lineno = 1331;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_OPENSSL_free, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1331;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_66_get_serial_number );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    tmp_called_instance_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_5 == NULL ))
    {
        tmp_called_instance_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1333;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = var_bignum_serial;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_cd8026d8c03981ef7b359feb3aa91a02->m_frame.f_lineno = 1333;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_BN_free, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1333;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_called_instance_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_6 == NULL ))
    {
        tmp_called_instance_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_6 == NULL )
    {

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1333;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_9 = var_bignum_serial;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_cd8026d8c03981ef7b359feb3aa91a02->m_frame.f_lineno = 1333;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_BN_free, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 1333;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd8026d8c03981ef7b359feb3aa91a02 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd8026d8c03981ef7b359feb3aa91a02 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd8026d8c03981ef7b359feb3aa91a02 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cd8026d8c03981ef7b359feb3aa91a02, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cd8026d8c03981ef7b359feb3aa91a02->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cd8026d8c03981ef7b359feb3aa91a02, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cd8026d8c03981ef7b359feb3aa91a02,
        type_description_1,
        par_self,
        var_bignum_serial,
        var_hexstring_serial,
        var_asn1_serial,
        var_hex_serial,
        var_serial
    );


    // Release cached frame.
    if ( frame_cd8026d8c03981ef7b359feb3aa91a02 == cache_frame_cd8026d8c03981ef7b359feb3aa91a02 )
    {
        Py_DECREF( frame_cd8026d8c03981ef7b359feb3aa91a02 );
    }
    cache_frame_cd8026d8c03981ef7b359feb3aa91a02 = NULL;

    assertFrameObject( frame_cd8026d8c03981ef7b359feb3aa91a02 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_66_get_serial_number );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bignum_serial );
    Py_DECREF( var_bignum_serial );
    var_bignum_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_hexstring_serial );
    Py_DECREF( var_hexstring_serial );
    var_hexstring_serial = NULL;

    CHECK_OBJECT( (PyObject *)var_asn1_serial );
    Py_DECREF( var_asn1_serial );
    var_asn1_serial = NULL;

    CHECK_OBJECT( (PyObject *)var_hex_serial );
    Py_DECREF( var_hex_serial );
    var_hex_serial = NULL;

    CHECK_OBJECT( (PyObject *)var_serial );
    Py_DECREF( var_serial );
    var_serial = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bignum_serial );
    var_bignum_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_hexstring_serial );
    var_hexstring_serial = NULL;

    Py_XDECREF( var_asn1_serial );
    var_asn1_serial = NULL;

    Py_XDECREF( var_hex_serial );
    var_hex_serial = NULL;

    Py_XDECREF( var_serial );
    var_serial = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_66_get_serial_number );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_amount = python_pars[ 1 ];
    PyObject *var_notAfter = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_b6e7e7435391bc9113c1cc9764c3e6e3 = NULL;

    struct Nuitka_FrameObject *frame_b6e7e7435391bc9113c1cc9764c3e6e3;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b6e7e7435391bc9113c1cc9764c3e6e3, codeobj_b6e7e7435391bc9113c1cc9764c3e6e3, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b6e7e7435391bc9113c1cc9764c3e6e3 = cache_frame_b6e7e7435391bc9113c1cc9764c3e6e3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b6e7e7435391bc9113c1cc9764c3e6e3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b6e7e7435391bc9113c1cc9764c3e6e3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_amount;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1343;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_117006b03ff8e10f330ac900a6cd41e8;
    frame_b6e7e7435391bc9113c1cc9764c3e6e3->m_frame.f_lineno = 1344;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1344;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1346;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_getm_notAfter );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1346;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1346;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_b6e7e7435391bc9113c1cc9764c3e6e3->m_frame.f_lineno = 1346;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1346;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_notAfter == NULL );
    var_notAfter = tmp_assign_source_1;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1347;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_notAfter;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_amount;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_b6e7e7435391bc9113c1cc9764c3e6e3->m_frame.f_lineno = 1347;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_X509_gmtime_adj, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1347;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b6e7e7435391bc9113c1cc9764c3e6e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b6e7e7435391bc9113c1cc9764c3e6e3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b6e7e7435391bc9113c1cc9764c3e6e3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b6e7e7435391bc9113c1cc9764c3e6e3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b6e7e7435391bc9113c1cc9764c3e6e3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b6e7e7435391bc9113c1cc9764c3e6e3,
        type_description_1,
        par_self,
        par_amount,
        var_notAfter
    );


    // Release cached frame.
    if ( frame_b6e7e7435391bc9113c1cc9764c3e6e3 == cache_frame_b6e7e7435391bc9113c1cc9764c3e6e3 )
    {
        Py_DECREF( frame_b6e7e7435391bc9113c1cc9764c3e6e3 );
    }
    cache_frame_b6e7e7435391bc9113c1cc9764c3e6e3 = NULL;

    assertFrameObject( frame_b6e7e7435391bc9113c1cc9764c3e6e3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_67_gmtime_adj_notAfter );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_amount );
    Py_DECREF( par_amount );
    par_amount = NULL;

    CHECK_OBJECT( (PyObject *)var_notAfter );
    Py_DECREF( var_notAfter );
    var_notAfter = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_amount );
    Py_DECREF( par_amount );
    par_amount = NULL;

    Py_XDECREF( var_notAfter );
    var_notAfter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_67_gmtime_adj_notAfter );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_amount = python_pars[ 1 ];
    PyObject *var_notBefore = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_a797f2541923bcc6c680cbf8841d85e0 = NULL;

    struct Nuitka_FrameObject *frame_a797f2541923bcc6c680cbf8841d85e0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a797f2541923bcc6c680cbf8841d85e0, codeobj_a797f2541923bcc6c680cbf8841d85e0, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a797f2541923bcc6c680cbf8841d85e0 = cache_frame_a797f2541923bcc6c680cbf8841d85e0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a797f2541923bcc6c680cbf8841d85e0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a797f2541923bcc6c680cbf8841d85e0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_amount;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1356;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_117006b03ff8e10f330ac900a6cd41e8;
    frame_a797f2541923bcc6c680cbf8841d85e0->m_frame.f_lineno = 1357;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1357;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1359;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_getm_notBefore );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1359;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1359;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_a797f2541923bcc6c680cbf8841d85e0->m_frame.f_lineno = 1359;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1359;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_notBefore == NULL );
    var_notBefore = tmp_assign_source_1;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1360;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_notBefore;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_amount;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_a797f2541923bcc6c680cbf8841d85e0->m_frame.f_lineno = 1360;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_X509_gmtime_adj, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1360;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a797f2541923bcc6c680cbf8841d85e0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a797f2541923bcc6c680cbf8841d85e0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a797f2541923bcc6c680cbf8841d85e0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a797f2541923bcc6c680cbf8841d85e0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a797f2541923bcc6c680cbf8841d85e0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a797f2541923bcc6c680cbf8841d85e0,
        type_description_1,
        par_self,
        par_amount,
        var_notBefore
    );


    // Release cached frame.
    if ( frame_a797f2541923bcc6c680cbf8841d85e0 == cache_frame_a797f2541923bcc6c680cbf8841d85e0 )
    {
        Py_DECREF( frame_a797f2541923bcc6c680cbf8841d85e0 );
    }
    cache_frame_a797f2541923bcc6c680cbf8841d85e0 = NULL;

    assertFrameObject( frame_a797f2541923bcc6c680cbf8841d85e0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_68_gmtime_adj_notBefore );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_amount );
    Py_DECREF( par_amount );
    par_amount = NULL;

    CHECK_OBJECT( (PyObject *)var_notBefore );
    Py_DECREF( var_notBefore );
    var_notBefore = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_amount );
    Py_DECREF( par_amount );
    par_amount = NULL;

    Py_XDECREF( var_notBefore );
    var_notBefore = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_68_gmtime_adj_notBefore );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_69_has_expired( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_not_after = NULL;
    PyObject *var_time_string = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_4dcbd11112592d2548a66b42db5772e6 = NULL;

    struct Nuitka_FrameObject *frame_4dcbd11112592d2548a66b42db5772e6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4dcbd11112592d2548a66b42db5772e6, codeobj_4dcbd11112592d2548a66b42db5772e6, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_4dcbd11112592d2548a66b42db5772e6 = cache_frame_4dcbd11112592d2548a66b42db5772e6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4dcbd11112592d2548a66b42db5772e6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4dcbd11112592d2548a66b42db5772e6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
        exception_tb = NULL;

        exception_lineno = 1369;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_4dcbd11112592d2548a66b42db5772e6->m_frame.f_lineno = 1369;
    tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_get_notAfter );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1369;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_4dcbd11112592d2548a66b42db5772e6->m_frame.f_lineno = 1369;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1369;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_time_string == NULL );
    var_time_string = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_datetime );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_datetime );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "datetime" );
        exception_tb = NULL;

        exception_lineno = 1370;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_datetime );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1370;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_time_string;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = const_str_digest_9838c39bdf9fdb401c17b0106d8660a3;
    frame_4dcbd11112592d2548a66b42db5772e6->m_frame.f_lineno = 1370;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_strptime, call_args );
    }

    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1370;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_not_after == NULL );
    var_not_after = tmp_assign_source_2;

    tmp_compexpr_left_1 = var_not_after;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_datetime );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_datetime );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "datetime" );
        exception_tb = NULL;

        exception_lineno = 1372;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_datetime );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1372;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_4dcbd11112592d2548a66b42db5772e6->m_frame.f_lineno = 1372;
    tmp_compexpr_right_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_utcnow );
    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1372;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_LT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1372;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4dcbd11112592d2548a66b42db5772e6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4dcbd11112592d2548a66b42db5772e6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4dcbd11112592d2548a66b42db5772e6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4dcbd11112592d2548a66b42db5772e6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4dcbd11112592d2548a66b42db5772e6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4dcbd11112592d2548a66b42db5772e6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4dcbd11112592d2548a66b42db5772e6,
        type_description_1,
        par_self,
        var_not_after,
        var_time_string
    );


    // Release cached frame.
    if ( frame_4dcbd11112592d2548a66b42db5772e6 == cache_frame_4dcbd11112592d2548a66b42db5772e6 )
    {
        Py_DECREF( frame_4dcbd11112592d2548a66b42db5772e6 );
    }
    cache_frame_4dcbd11112592d2548a66b42db5772e6 = NULL;

    assertFrameObject( frame_4dcbd11112592d2548a66b42db5772e6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_69_has_expired );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_not_after );
    Py_DECREF( var_not_after );
    var_not_after = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_time_string );
    Py_DECREF( var_time_string );
    var_time_string = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_not_after );
    var_not_after = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_time_string );
    var_time_string = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_69_has_expired );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_70__get_boundary_time( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_which = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_d2e6aa63601547b6b03bc44158eb1f5e = NULL;

    struct Nuitka_FrameObject *frame_d2e6aa63601547b6b03bc44158eb1f5e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d2e6aa63601547b6b03bc44158eb1f5e, codeobj_d2e6aa63601547b6b03bc44158eb1f5e, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_d2e6aa63601547b6b03bc44158eb1f5e = cache_frame_d2e6aa63601547b6b03bc44158eb1f5e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d2e6aa63601547b6b03bc44158eb1f5e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d2e6aa63601547b6b03bc44158eb1f5e ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_asn1_time );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__get_asn1_time );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_get_asn1_time" );
        exception_tb = NULL;

        exception_lineno = 1375;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = par_which;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__x509 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1375;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_d2e6aa63601547b6b03bc44158eb1f5e->m_frame.f_lineno = 1375;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1375;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_d2e6aa63601547b6b03bc44158eb1f5e->m_frame.f_lineno = 1375;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1375;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d2e6aa63601547b6b03bc44158eb1f5e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d2e6aa63601547b6b03bc44158eb1f5e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d2e6aa63601547b6b03bc44158eb1f5e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d2e6aa63601547b6b03bc44158eb1f5e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d2e6aa63601547b6b03bc44158eb1f5e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d2e6aa63601547b6b03bc44158eb1f5e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d2e6aa63601547b6b03bc44158eb1f5e,
        type_description_1,
        par_self,
        par_which
    );


    // Release cached frame.
    if ( frame_d2e6aa63601547b6b03bc44158eb1f5e == cache_frame_d2e6aa63601547b6b03bc44158eb1f5e )
    {
        Py_DECREF( frame_d2e6aa63601547b6b03bc44158eb1f5e );
    }
    cache_frame_d2e6aa63601547b6b03bc44158eb1f5e = NULL;

    assertFrameObject( frame_d2e6aa63601547b6b03bc44158eb1f5e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_70__get_boundary_time );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_70__get_boundary_time );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_71_get_notBefore( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_70910ab61c2a9a1468d98c3214045299 = NULL;

    struct Nuitka_FrameObject *frame_70910ab61c2a9a1468d98c3214045299;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_70910ab61c2a9a1468d98c3214045299, codeobj_70910ab61c2a9a1468d98c3214045299, module_OpenSSL$crypto, sizeof(void *) );
    frame_70910ab61c2a9a1468d98c3214045299 = cache_frame_70910ab61c2a9a1468d98c3214045299;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_70910ab61c2a9a1468d98c3214045299 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_70910ab61c2a9a1468d98c3214045299 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_boundary_time );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1388;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1388;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_getm_notBefore );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1388;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_70910ab61c2a9a1468d98c3214045299->m_frame.f_lineno = 1388;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1388;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_70910ab61c2a9a1468d98c3214045299 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_70910ab61c2a9a1468d98c3214045299 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_70910ab61c2a9a1468d98c3214045299 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_70910ab61c2a9a1468d98c3214045299, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_70910ab61c2a9a1468d98c3214045299->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_70910ab61c2a9a1468d98c3214045299, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_70910ab61c2a9a1468d98c3214045299,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_70910ab61c2a9a1468d98c3214045299 == cache_frame_70910ab61c2a9a1468d98c3214045299 )
    {
        Py_DECREF( frame_70910ab61c2a9a1468d98c3214045299 );
    }
    cache_frame_70910ab61c2a9a1468d98c3214045299 = NULL;

    assertFrameObject( frame_70910ab61c2a9a1468d98c3214045299 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_71_get_notBefore );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_71_get_notBefore );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_72__set_boundary_time( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_which = python_pars[ 1 ];
    PyObject *par_when = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_a856bd49c4603c5e0e8b903888741c02 = NULL;

    struct Nuitka_FrameObject *frame_a856bd49c4603c5e0e8b903888741c02;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a856bd49c4603c5e0e8b903888741c02, codeobj_a856bd49c4603c5e0e8b903888741c02, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a856bd49c4603c5e0e8b903888741c02 = cache_frame_a856bd49c4603c5e0e8b903888741c02;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a856bd49c4603c5e0e8b903888741c02 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a856bd49c4603c5e0e8b903888741c02 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__set_asn1_time );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__set_asn1_time );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_set_asn1_time" );
        exception_tb = NULL;

        exception_lineno = 1391;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = par_which;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__x509 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1391;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_a856bd49c4603c5e0e8b903888741c02->m_frame.f_lineno = 1391;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1391;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_when;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_a856bd49c4603c5e0e8b903888741c02->m_frame.f_lineno = 1391;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1391;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a856bd49c4603c5e0e8b903888741c02 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a856bd49c4603c5e0e8b903888741c02 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a856bd49c4603c5e0e8b903888741c02 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a856bd49c4603c5e0e8b903888741c02, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a856bd49c4603c5e0e8b903888741c02->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a856bd49c4603c5e0e8b903888741c02, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a856bd49c4603c5e0e8b903888741c02,
        type_description_1,
        par_self,
        par_which,
        par_when
    );


    // Release cached frame.
    if ( frame_a856bd49c4603c5e0e8b903888741c02 == cache_frame_a856bd49c4603c5e0e8b903888741c02 )
    {
        Py_DECREF( frame_a856bd49c4603c5e0e8b903888741c02 );
    }
    cache_frame_a856bd49c4603c5e0e8b903888741c02 = NULL;

    assertFrameObject( frame_a856bd49c4603c5e0e8b903888741c02 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_72__set_boundary_time );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_72__set_boundary_time );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_73_set_notBefore( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_when = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_60d95cc23d60386c3b98865d2e08e264 = NULL;

    struct Nuitka_FrameObject *frame_60d95cc23d60386c3b98865d2e08e264;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_60d95cc23d60386c3b98865d2e08e264, codeobj_60d95cc23d60386c3b98865d2e08e264, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_60d95cc23d60386c3b98865d2e08e264 = cache_frame_60d95cc23d60386c3b98865d2e08e264;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_60d95cc23d60386c3b98865d2e08e264 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_60d95cc23d60386c3b98865d2e08e264 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__set_boundary_time );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1404;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1404;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_getm_notBefore );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1404;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_when;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_60d95cc23d60386c3b98865d2e08e264->m_frame.f_lineno = 1404;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1404;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_60d95cc23d60386c3b98865d2e08e264 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_60d95cc23d60386c3b98865d2e08e264 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_60d95cc23d60386c3b98865d2e08e264 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_60d95cc23d60386c3b98865d2e08e264, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_60d95cc23d60386c3b98865d2e08e264->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_60d95cc23d60386c3b98865d2e08e264, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_60d95cc23d60386c3b98865d2e08e264,
        type_description_1,
        par_self,
        par_when
    );


    // Release cached frame.
    if ( frame_60d95cc23d60386c3b98865d2e08e264 == cache_frame_60d95cc23d60386c3b98865d2e08e264 )
    {
        Py_DECREF( frame_60d95cc23d60386c3b98865d2e08e264 );
    }
    cache_frame_60d95cc23d60386c3b98865d2e08e264 = NULL;

    assertFrameObject( frame_60d95cc23d60386c3b98865d2e08e264 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_73_set_notBefore );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_73_set_notBefore );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_74_get_notAfter( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_1455e3e00773aae57fb3dc956853d9a5 = NULL;

    struct Nuitka_FrameObject *frame_1455e3e00773aae57fb3dc956853d9a5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1455e3e00773aae57fb3dc956853d9a5, codeobj_1455e3e00773aae57fb3dc956853d9a5, module_OpenSSL$crypto, sizeof(void *) );
    frame_1455e3e00773aae57fb3dc956853d9a5 = cache_frame_1455e3e00773aae57fb3dc956853d9a5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1455e3e00773aae57fb3dc956853d9a5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1455e3e00773aae57fb3dc956853d9a5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_boundary_time );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1417;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1417;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_getm_notAfter );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1417;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_1455e3e00773aae57fb3dc956853d9a5->m_frame.f_lineno = 1417;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1417;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1455e3e00773aae57fb3dc956853d9a5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1455e3e00773aae57fb3dc956853d9a5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1455e3e00773aae57fb3dc956853d9a5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1455e3e00773aae57fb3dc956853d9a5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1455e3e00773aae57fb3dc956853d9a5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1455e3e00773aae57fb3dc956853d9a5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1455e3e00773aae57fb3dc956853d9a5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_1455e3e00773aae57fb3dc956853d9a5 == cache_frame_1455e3e00773aae57fb3dc956853d9a5 )
    {
        Py_DECREF( frame_1455e3e00773aae57fb3dc956853d9a5 );
    }
    cache_frame_1455e3e00773aae57fb3dc956853d9a5 = NULL;

    assertFrameObject( frame_1455e3e00773aae57fb3dc956853d9a5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_74_get_notAfter );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_74_get_notAfter );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_75_set_notAfter( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_when = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_7616cad37f05a65bcb8c1a4729346ad9 = NULL;

    struct Nuitka_FrameObject *frame_7616cad37f05a65bcb8c1a4729346ad9;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7616cad37f05a65bcb8c1a4729346ad9, codeobj_7616cad37f05a65bcb8c1a4729346ad9, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_7616cad37f05a65bcb8c1a4729346ad9 = cache_frame_7616cad37f05a65bcb8c1a4729346ad9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7616cad37f05a65bcb8c1a4729346ad9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7616cad37f05a65bcb8c1a4729346ad9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__set_boundary_time );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1430;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1430;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_getm_notAfter );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1430;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_when;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_7616cad37f05a65bcb8c1a4729346ad9->m_frame.f_lineno = 1430;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1430;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7616cad37f05a65bcb8c1a4729346ad9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7616cad37f05a65bcb8c1a4729346ad9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7616cad37f05a65bcb8c1a4729346ad9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7616cad37f05a65bcb8c1a4729346ad9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7616cad37f05a65bcb8c1a4729346ad9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7616cad37f05a65bcb8c1a4729346ad9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7616cad37f05a65bcb8c1a4729346ad9,
        type_description_1,
        par_self,
        par_when
    );


    // Release cached frame.
    if ( frame_7616cad37f05a65bcb8c1a4729346ad9 == cache_frame_7616cad37f05a65bcb8c1a4729346ad9 )
    {
        Py_DECREF( frame_7616cad37f05a65bcb8c1a4729346ad9 );
    }
    cache_frame_7616cad37f05a65bcb8c1a4729346ad9 = NULL;

    assertFrameObject( frame_7616cad37f05a65bcb8c1a4729346ad9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_75_set_notAfter );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_75_set_notAfter );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_76__get_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_which = python_pars[ 1 ];
    PyObject *var_name = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_31cede2371f8cc0be31721e82cc1d349 = NULL;

    struct Nuitka_FrameObject *frame_31cede2371f8cc0be31721e82cc1d349;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_31cede2371f8cc0be31721e82cc1d349, codeobj_31cede2371f8cc0be31721e82cc1d349, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_31cede2371f8cc0be31721e82cc1d349 = cache_frame_31cede2371f8cc0be31721e82cc1d349;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_31cede2371f8cc0be31721e82cc1d349 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_31cede2371f8cc0be31721e82cc1d349 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
        exception_tb = NULL;

        exception_lineno = 1433;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1433;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

    if (unlikely( tmp_args_element_name_1 == NULL ))
    {
        tmp_args_element_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
        exception_tb = NULL;

        exception_lineno = 1433;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_31cede2371f8cc0be31721e82cc1d349->m_frame.f_lineno = 1433;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1433;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_name == NULL );
    var_name = tmp_assign_source_1;

    tmp_called_name_2 = par_which;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1434;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_31cede2371f8cc0be31721e82cc1d349->m_frame.f_lineno = 1434;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1434;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_name;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1434;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1435;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_3 = var_name;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__name );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1435;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_compexpr_left_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1435;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1435;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1435;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_31cede2371f8cc0be31721e82cc1d349->m_frame.f_lineno = 1435;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1435;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_2 = par_self;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = var_name;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__owner, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1439;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_31cede2371f8cc0be31721e82cc1d349 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_31cede2371f8cc0be31721e82cc1d349 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_31cede2371f8cc0be31721e82cc1d349, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_31cede2371f8cc0be31721e82cc1d349->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_31cede2371f8cc0be31721e82cc1d349, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_31cede2371f8cc0be31721e82cc1d349,
        type_description_1,
        par_self,
        par_which,
        var_name
    );


    // Release cached frame.
    if ( frame_31cede2371f8cc0be31721e82cc1d349 == cache_frame_31cede2371f8cc0be31721e82cc1d349 )
    {
        Py_DECREF( frame_31cede2371f8cc0be31721e82cc1d349 );
    }
    cache_frame_31cede2371f8cc0be31721e82cc1d349 = NULL;

    assertFrameObject( frame_31cede2371f8cc0be31721e82cc1d349 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_name;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_76__get_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_name );
    Py_DECREF( var_name );
    var_name = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_76__get_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_77__set_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_which = python_pars[ 1 ];
    PyObject *par_name = python_pars[ 2 ];
    PyObject *var_set_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_57a4f44f27b7dd0a656889214e64bb91 = NULL;

    struct Nuitka_FrameObject *frame_57a4f44f27b7dd0a656889214e64bb91;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_57a4f44f27b7dd0a656889214e64bb91, codeobj_57a4f44f27b7dd0a656889214e64bb91, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_57a4f44f27b7dd0a656889214e64bb91 = cache_frame_57a4f44f27b7dd0a656889214e64bb91;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_57a4f44f27b7dd0a656889214e64bb91 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_57a4f44f27b7dd0a656889214e64bb91 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_name;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
        exception_tb = NULL;

        exception_lineno = 1444;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1444;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_b3f225987bb27e065a500d7fe8bd7c70;
    frame_57a4f44f27b7dd0a656889214e64bb91->m_frame.f_lineno = 1445;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1445;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_called_name_1 = par_which;

    CHECK_OBJECT( tmp_called_name_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__x509 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1446;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_name;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1446;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_57a4f44f27b7dd0a656889214e64bb91->m_frame.f_lineno = 1446;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1446;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_set_result == NULL );
    var_set_result = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1447;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_set_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_3 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1447;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_57a4f44f27b7dd0a656889214e64bb91->m_frame.f_lineno = 1447;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1447;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_57a4f44f27b7dd0a656889214e64bb91 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_57a4f44f27b7dd0a656889214e64bb91 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_57a4f44f27b7dd0a656889214e64bb91, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_57a4f44f27b7dd0a656889214e64bb91->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_57a4f44f27b7dd0a656889214e64bb91, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_57a4f44f27b7dd0a656889214e64bb91,
        type_description_1,
        par_self,
        par_which,
        par_name,
        var_set_result
    );


    // Release cached frame.
    if ( frame_57a4f44f27b7dd0a656889214e64bb91 == cache_frame_57a4f44f27b7dd0a656889214e64bb91 )
    {
        Py_DECREF( frame_57a4f44f27b7dd0a656889214e64bb91 );
    }
    cache_frame_57a4f44f27b7dd0a656889214e64bb91 = NULL;

    assertFrameObject( frame_57a4f44f27b7dd0a656889214e64bb91 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_77__set_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_77__set_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_78_get_issuer( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_name = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_8ba34bf3bdf107b089c685c0ea45312d = NULL;

    struct Nuitka_FrameObject *frame_8ba34bf3bdf107b089c685c0ea45312d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8ba34bf3bdf107b089c685c0ea45312d, codeobj_8ba34bf3bdf107b089c685c0ea45312d, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_8ba34bf3bdf107b089c685c0ea45312d = cache_frame_8ba34bf3bdf107b089c685c0ea45312d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8ba34bf3bdf107b089c685c0ea45312d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8ba34bf3bdf107b089c685c0ea45312d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_name );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1461;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1461;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_get_issuer_name );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1461;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_8ba34bf3bdf107b089c685c0ea45312d->m_frame.f_lineno = 1461;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1461;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_name == NULL );
    var_name = tmp_assign_source_1;

    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__issuer_invalidator );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1462;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_name;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_8ba34bf3bdf107b089c685c0ea45312d->m_frame.f_lineno = 1462;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_add, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1462;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8ba34bf3bdf107b089c685c0ea45312d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8ba34bf3bdf107b089c685c0ea45312d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8ba34bf3bdf107b089c685c0ea45312d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8ba34bf3bdf107b089c685c0ea45312d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8ba34bf3bdf107b089c685c0ea45312d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8ba34bf3bdf107b089c685c0ea45312d,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if ( frame_8ba34bf3bdf107b089c685c0ea45312d == cache_frame_8ba34bf3bdf107b089c685c0ea45312d )
    {
        Py_DECREF( frame_8ba34bf3bdf107b089c685c0ea45312d );
    }
    cache_frame_8ba34bf3bdf107b089c685c0ea45312d = NULL;

    assertFrameObject( frame_8ba34bf3bdf107b089c685c0ea45312d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_name;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_78_get_issuer );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_name );
    Py_DECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_78_get_issuer );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_79_set_issuer( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_issuer = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_d0171732bc26f9a167787680f68c98bf = NULL;

    struct Nuitka_FrameObject *frame_d0171732bc26f9a167787680f68c98bf;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d0171732bc26f9a167787680f68c98bf, codeobj_d0171732bc26f9a167787680f68c98bf, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_d0171732bc26f9a167787680f68c98bf = cache_frame_d0171732bc26f9a167787680f68c98bf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d0171732bc26f9a167787680f68c98bf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d0171732bc26f9a167787680f68c98bf ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__set_name );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1474;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1474;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_set_issuer_name );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1474;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_issuer;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_d0171732bc26f9a167787680f68c98bf->m_frame.f_lineno = 1474;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1474;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__issuer_invalidator );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1475;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_d0171732bc26f9a167787680f68c98bf->m_frame.f_lineno = 1475;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_clear );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1475;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0171732bc26f9a167787680f68c98bf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0171732bc26f9a167787680f68c98bf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d0171732bc26f9a167787680f68c98bf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d0171732bc26f9a167787680f68c98bf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d0171732bc26f9a167787680f68c98bf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d0171732bc26f9a167787680f68c98bf,
        type_description_1,
        par_self,
        par_issuer
    );


    // Release cached frame.
    if ( frame_d0171732bc26f9a167787680f68c98bf == cache_frame_d0171732bc26f9a167787680f68c98bf )
    {
        Py_DECREF( frame_d0171732bc26f9a167787680f68c98bf );
    }
    cache_frame_d0171732bc26f9a167787680f68c98bf = NULL;

    assertFrameObject( frame_d0171732bc26f9a167787680f68c98bf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_79_set_issuer );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer );
    Py_DECREF( par_issuer );
    par_issuer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer );
    Py_DECREF( par_issuer );
    par_issuer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_79_set_issuer );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_80_get_subject( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_name = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_4f8ed7f420c0ac066c4fb9a1c956cabc = NULL;

    struct Nuitka_FrameObject *frame_4f8ed7f420c0ac066c4fb9a1c956cabc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4f8ed7f420c0ac066c4fb9a1c956cabc, codeobj_4f8ed7f420c0ac066c4fb9a1c956cabc, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_4f8ed7f420c0ac066c4fb9a1c956cabc = cache_frame_4f8ed7f420c0ac066c4fb9a1c956cabc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4f8ed7f420c0ac066c4fb9a1c956cabc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4f8ed7f420c0ac066c4fb9a1c956cabc ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_name );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1489;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1489;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_get_subject_name );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1489;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_4f8ed7f420c0ac066c4fb9a1c956cabc->m_frame.f_lineno = 1489;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1489;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_name == NULL );
    var_name = tmp_assign_source_1;

    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__subject_invalidator );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1490;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_name;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_4f8ed7f420c0ac066c4fb9a1c956cabc->m_frame.f_lineno = 1490;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_add, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1490;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4f8ed7f420c0ac066c4fb9a1c956cabc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4f8ed7f420c0ac066c4fb9a1c956cabc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4f8ed7f420c0ac066c4fb9a1c956cabc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4f8ed7f420c0ac066c4fb9a1c956cabc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4f8ed7f420c0ac066c4fb9a1c956cabc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4f8ed7f420c0ac066c4fb9a1c956cabc,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if ( frame_4f8ed7f420c0ac066c4fb9a1c956cabc == cache_frame_4f8ed7f420c0ac066c4fb9a1c956cabc )
    {
        Py_DECREF( frame_4f8ed7f420c0ac066c4fb9a1c956cabc );
    }
    cache_frame_4f8ed7f420c0ac066c4fb9a1c956cabc = NULL;

    assertFrameObject( frame_4f8ed7f420c0ac066c4fb9a1c956cabc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_name;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_80_get_subject );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_name );
    Py_DECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_80_get_subject );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_81_set_subject( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_subject = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_be33a06b1200d059a460c969c87bf108 = NULL;

    struct Nuitka_FrameObject *frame_be33a06b1200d059a460c969c87bf108;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_be33a06b1200d059a460c969c87bf108, codeobj_be33a06b1200d059a460c969c87bf108, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_be33a06b1200d059a460c969c87bf108 = cache_frame_be33a06b1200d059a460c969c87bf108;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_be33a06b1200d059a460c969c87bf108 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_be33a06b1200d059a460c969c87bf108 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__set_name );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1502;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1502;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_set_subject_name );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1502;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_subject;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_be33a06b1200d059a460c969c87bf108->m_frame.f_lineno = 1502;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1502;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__subject_invalidator );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1503;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_be33a06b1200d059a460c969c87bf108->m_frame.f_lineno = 1503;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_clear );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1503;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_be33a06b1200d059a460c969c87bf108 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_be33a06b1200d059a460c969c87bf108 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_be33a06b1200d059a460c969c87bf108, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_be33a06b1200d059a460c969c87bf108->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_be33a06b1200d059a460c969c87bf108, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_be33a06b1200d059a460c969c87bf108,
        type_description_1,
        par_self,
        par_subject
    );


    // Release cached frame.
    if ( frame_be33a06b1200d059a460c969c87bf108 == cache_frame_be33a06b1200d059a460c969c87bf108 )
    {
        Py_DECREF( frame_be33a06b1200d059a460c969c87bf108 );
    }
    cache_frame_be33a06b1200d059a460c969c87bf108 = NULL;

    assertFrameObject( frame_be33a06b1200d059a460c969c87bf108 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_81_set_subject );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_subject );
    Py_DECREF( par_subject );
    par_subject = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_subject );
    Py_DECREF( par_subject );
    par_subject = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_81_set_subject );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_82_get_extension_count( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_52692d97d9af6bf5d9cdd4e751d8736f = NULL;

    struct Nuitka_FrameObject *frame_52692d97d9af6bf5d9cdd4e751d8736f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_52692d97d9af6bf5d9cdd4e751d8736f, codeobj_52692d97d9af6bf5d9cdd4e751d8736f, module_OpenSSL$crypto, sizeof(void *) );
    frame_52692d97d9af6bf5d9cdd4e751d8736f = cache_frame_52692d97d9af6bf5d9cdd4e751d8736f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_52692d97d9af6bf5d9cdd4e751d8736f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_52692d97d9af6bf5d9cdd4e751d8736f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1514;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_get_ext_count );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1514;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1514;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_52692d97d9af6bf5d9cdd4e751d8736f->m_frame.f_lineno = 1514;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1514;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_52692d97d9af6bf5d9cdd4e751d8736f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_52692d97d9af6bf5d9cdd4e751d8736f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_52692d97d9af6bf5d9cdd4e751d8736f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_52692d97d9af6bf5d9cdd4e751d8736f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_52692d97d9af6bf5d9cdd4e751d8736f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_52692d97d9af6bf5d9cdd4e751d8736f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_52692d97d9af6bf5d9cdd4e751d8736f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_52692d97d9af6bf5d9cdd4e751d8736f == cache_frame_52692d97d9af6bf5d9cdd4e751d8736f )
    {
        Py_DECREF( frame_52692d97d9af6bf5d9cdd4e751d8736f );
    }
    cache_frame_52692d97d9af6bf5d9cdd4e751d8736f = NULL;

    assertFrameObject( frame_52692d97d9af6bf5d9cdd4e751d8736f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_82_get_extension_count );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_82_get_extension_count );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_83_add_extensions( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_extensions = python_pars[ 1 ];
    PyObject *var_ext = NULL;
    PyObject *var_add_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_9f2b9ad144beb7aa9e8cd5e09d9fa943 = NULL;

    struct Nuitka_FrameObject *frame_9f2b9ad144beb7aa9e8cd5e09d9fa943;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9f2b9ad144beb7aa9e8cd5e09d9fa943, codeobj_9f2b9ad144beb7aa9e8cd5e09d9fa943, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9f2b9ad144beb7aa9e8cd5e09d9fa943 = cache_frame_9f2b9ad144beb7aa9e8cd5e09d9fa943;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9f2b9ad144beb7aa9e8cd5e09d9fa943 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9f2b9ad144beb7aa9e8cd5e09d9fa943 ) == 2 ); // Frame stack

    // Framed code:
    tmp_iter_arg_1 = par_extensions;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1524;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooo";
        exception_lineno = 1524;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1524;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_ext;
        var_ext = tmp_assign_source_3;
        Py_INCREF( var_ext );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_ext;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Extension" );
        exception_tb = NULL;

        exception_lineno = 1525;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1525;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_1 = const_str_digest_c57795fb6a9ac3d47e928f9a8b608571;
    frame_9f2b9ad144beb7aa9e8cd5e09d9fa943->m_frame.f_lineno = 1526;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1526;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto try_except_handler_2;
    branch_no_2:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1528;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_add_ext );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1528;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1528;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_source_name_3 = var_ext;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__extension );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1528;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_3 = const_int_neg_1;
    frame_9f2b9ad144beb7aa9e8cd5e09d9fa943->m_frame.f_lineno = 1528;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1528;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_add_result;
        var_add_result = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_cond_value_1 = var_add_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1529;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1530;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    frame_9f2b9ad144beb7aa9e8cd5e09d9fa943->m_frame.f_lineno = 1530;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1530;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1524;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9f2b9ad144beb7aa9e8cd5e09d9fa943 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9f2b9ad144beb7aa9e8cd5e09d9fa943 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9f2b9ad144beb7aa9e8cd5e09d9fa943, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9f2b9ad144beb7aa9e8cd5e09d9fa943->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9f2b9ad144beb7aa9e8cd5e09d9fa943, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9f2b9ad144beb7aa9e8cd5e09d9fa943,
        type_description_1,
        par_self,
        par_extensions,
        var_ext,
        var_add_result
    );


    // Release cached frame.
    if ( frame_9f2b9ad144beb7aa9e8cd5e09d9fa943 == cache_frame_9f2b9ad144beb7aa9e8cd5e09d9fa943 )
    {
        Py_DECREF( frame_9f2b9ad144beb7aa9e8cd5e09d9fa943 );
    }
    cache_frame_9f2b9ad144beb7aa9e8cd5e09d9fa943 = NULL;

    assertFrameObject( frame_9f2b9ad144beb7aa9e8cd5e09d9fa943 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_83_add_extensions );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_extensions );
    Py_DECREF( par_extensions );
    par_extensions = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_extensions );
    Py_DECREF( par_extensions );
    par_extensions = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_83_add_extensions );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_84_get_extension( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_index = python_pars[ 1 ];
    PyObject *var_ext = NULL;
    PyObject *var_extension = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    static struct Nuitka_FrameObject *cache_frame_05bd525e51ba5f81f7baedbcb28010d8 = NULL;

    struct Nuitka_FrameObject *frame_05bd525e51ba5f81f7baedbcb28010d8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_05bd525e51ba5f81f7baedbcb28010d8, codeobj_05bd525e51ba5f81f7baedbcb28010d8, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_05bd525e51ba5f81f7baedbcb28010d8 = cache_frame_05bd525e51ba5f81f7baedbcb28010d8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_05bd525e51ba5f81f7baedbcb28010d8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_05bd525e51ba5f81f7baedbcb28010d8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Extension" );
        exception_tb = NULL;

        exception_lineno = 1546;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1546;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension );

    if (unlikely( tmp_args_element_name_1 == NULL ))
    {
        tmp_args_element_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Extension" );
        exception_tb = NULL;

        exception_lineno = 1546;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_05bd525e51ba5f81f7baedbcb28010d8->m_frame.f_lineno = 1546;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1546;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_ext == NULL );
    var_ext = tmp_assign_source_1;

    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1547;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_get_ext );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1547;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__x509 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1547;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_index;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_05bd525e51ba5f81f7baedbcb28010d8->m_frame.f_lineno = 1547;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1547;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_ext;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__extension, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1547;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_source_name_4 = var_ext;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__extension );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1548;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_compare_left_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1548;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1548;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1548;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_7a5005a2e44b5258634f5b2837cd8b81;
    frame_05bd525e51ba5f81f7baedbcb28010d8->m_frame.f_lineno = 1549;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_IndexError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1549;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1551;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_EXTENSION_dup );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1551;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = var_ext;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__extension );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1551;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_05bd525e51ba5f81f7baedbcb28010d8->m_frame.f_lineno = 1551;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1551;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_extension == NULL );
    var_extension = tmp_assign_source_2;

    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1552;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_gc );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1552;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_extension;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1552;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_X509_EXTENSION_free );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1552;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_05bd525e51ba5f81f7baedbcb28010d8->m_frame.f_lineno = 1552;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1552;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = var_ext;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__extension, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 1552;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_05bd525e51ba5f81f7baedbcb28010d8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_05bd525e51ba5f81f7baedbcb28010d8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_05bd525e51ba5f81f7baedbcb28010d8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_05bd525e51ba5f81f7baedbcb28010d8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_05bd525e51ba5f81f7baedbcb28010d8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_05bd525e51ba5f81f7baedbcb28010d8,
        type_description_1,
        par_self,
        par_index,
        var_ext,
        var_extension
    );


    // Release cached frame.
    if ( frame_05bd525e51ba5f81f7baedbcb28010d8 == cache_frame_05bd525e51ba5f81f7baedbcb28010d8 )
    {
        Py_DECREF( frame_05bd525e51ba5f81f7baedbcb28010d8 );
    }
    cache_frame_05bd525e51ba5f81f7baedbcb28010d8 = NULL;

    assertFrameObject( frame_05bd525e51ba5f81f7baedbcb28010d8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_ext;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_84_get_extension );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_index );
    Py_DECREF( par_index );
    par_index = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ext );
    Py_DECREF( var_ext );
    var_ext = NULL;

    CHECK_OBJECT( (PyObject *)var_extension );
    Py_DECREF( var_extension );
    var_extension = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_index );
    Py_DECREF( par_index );
    par_index = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    Py_XDECREF( var_extension );
    var_extension = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_84_get_extension );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_85___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_store = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_cf52b2979abc3841b63feac291ec11ae = NULL;

    struct Nuitka_FrameObject *frame_cf52b2979abc3841b63feac291ec11ae;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cf52b2979abc3841b63feac291ec11ae, codeobj_cf52b2979abc3841b63feac291ec11ae, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_cf52b2979abc3841b63feac291ec11ae = cache_frame_cf52b2979abc3841b63feac291ec11ae;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cf52b2979abc3841b63feac291ec11ae );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cf52b2979abc3841b63feac291ec11ae ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1595;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_cf52b2979abc3841b63feac291ec11ae->m_frame.f_lineno = 1595;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_STORE_new );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1595;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_store == NULL );
    var_store = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1596;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1596;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_store;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1596;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_STORE_free );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1596;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_cf52b2979abc3841b63feac291ec11ae->m_frame.f_lineno = 1596;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1596;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__store, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1596;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cf52b2979abc3841b63feac291ec11ae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cf52b2979abc3841b63feac291ec11ae );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cf52b2979abc3841b63feac291ec11ae, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cf52b2979abc3841b63feac291ec11ae->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cf52b2979abc3841b63feac291ec11ae, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cf52b2979abc3841b63feac291ec11ae,
        type_description_1,
        par_self,
        var_store
    );


    // Release cached frame.
    if ( frame_cf52b2979abc3841b63feac291ec11ae == cache_frame_cf52b2979abc3841b63feac291ec11ae )
    {
        Py_DECREF( frame_cf52b2979abc3841b63feac291ec11ae );
    }
    cache_frame_cf52b2979abc3841b63feac291ec11ae = NULL;

    assertFrameObject( frame_cf52b2979abc3841b63feac291ec11ae );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_85___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_store );
    Py_DECREF( var_store );
    var_store = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_store );
    var_store = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_85___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_86_add_cert( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cert = python_pars[ 1 ];
    PyObject *var_res = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_fb7171180cafea0f8feff8daea432726 = NULL;

    struct Nuitka_FrameObject *frame_fb7171180cafea0f8feff8daea432726;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fb7171180cafea0f8feff8daea432726, codeobj_fb7171180cafea0f8feff8daea432726, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_fb7171180cafea0f8feff8daea432726 = cache_frame_fb7171180cafea0f8feff8daea432726;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fb7171180cafea0f8feff8daea432726 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fb7171180cafea0f8feff8daea432726 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_cert;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 1614;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1614;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    frame_fb7171180cafea0f8feff8daea432726->m_frame.f_lineno = 1615;
    tmp_raise_type_1 = CALL_FUNCTION_NO_ARGS( PyExc_TypeError );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1615;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1617;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_STORE_add_cert );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1617;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1617;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_cert;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__x509 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1617;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_fb7171180cafea0f8feff8daea432726->m_frame.f_lineno = 1617;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1617;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_res == NULL );
    var_res = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1618;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_res;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_3 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1618;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_fb7171180cafea0f8feff8daea432726->m_frame.f_lineno = 1618;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1618;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fb7171180cafea0f8feff8daea432726 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fb7171180cafea0f8feff8daea432726 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fb7171180cafea0f8feff8daea432726, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fb7171180cafea0f8feff8daea432726->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fb7171180cafea0f8feff8daea432726, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fb7171180cafea0f8feff8daea432726,
        type_description_1,
        par_self,
        par_cert,
        var_res
    );


    // Release cached frame.
    if ( frame_fb7171180cafea0f8feff8daea432726 == cache_frame_fb7171180cafea0f8feff8daea432726 )
    {
        Py_DECREF( frame_fb7171180cafea0f8feff8daea432726 );
    }
    cache_frame_fb7171180cafea0f8feff8daea432726 = NULL;

    assertFrameObject( frame_fb7171180cafea0f8feff8daea432726 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_86_add_cert );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_res );
    Py_DECREF( var_res );
    var_res = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_res );
    var_res = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_86_add_cert );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_87_add_crl( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_crl = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_7c89e32ae632b40579beca91c3fdd7c2 = NULL;

    struct Nuitka_FrameObject *frame_7c89e32ae632b40579beca91c3fdd7c2;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7c89e32ae632b40579beca91c3fdd7c2, codeobj_7c89e32ae632b40579beca91c3fdd7c2, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_7c89e32ae632b40579beca91c3fdd7c2 = cache_frame_7c89e32ae632b40579beca91c3fdd7c2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7c89e32ae632b40579beca91c3fdd7c2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7c89e32ae632b40579beca91c3fdd7c2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1634;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1634;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_STORE_add_crl );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1634;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1634;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_crl;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__crl );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1634;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_7c89e32ae632b40579beca91c3fdd7c2->m_frame.f_lineno = 1634;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1634;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_1 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1634;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_7c89e32ae632b40579beca91c3fdd7c2->m_frame.f_lineno = 1634;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1634;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7c89e32ae632b40579beca91c3fdd7c2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7c89e32ae632b40579beca91c3fdd7c2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7c89e32ae632b40579beca91c3fdd7c2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7c89e32ae632b40579beca91c3fdd7c2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7c89e32ae632b40579beca91c3fdd7c2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7c89e32ae632b40579beca91c3fdd7c2,
        type_description_1,
        par_self,
        par_crl
    );


    // Release cached frame.
    if ( frame_7c89e32ae632b40579beca91c3fdd7c2 == cache_frame_7c89e32ae632b40579beca91c3fdd7c2 )
    {
        Py_DECREF( frame_7c89e32ae632b40579beca91c3fdd7c2 );
    }
    cache_frame_7c89e32ae632b40579beca91c3fdd7c2 = NULL;

    assertFrameObject( frame_7c89e32ae632b40579beca91c3fdd7c2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_87_add_crl );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_crl );
    Py_DECREF( par_crl );
    par_crl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_crl );
    Py_DECREF( par_crl );
    par_crl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_87_add_crl );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_88_set_flags( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_flags = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_e56da31fff9a5ba5ac59532a15df82d5 = NULL;

    struct Nuitka_FrameObject *frame_e56da31fff9a5ba5ac59532a15df82d5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e56da31fff9a5ba5ac59532a15df82d5, codeobj_e56da31fff9a5ba5ac59532a15df82d5, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_e56da31fff9a5ba5ac59532a15df82d5 = cache_frame_e56da31fff9a5ba5ac59532a15df82d5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e56da31fff9a5ba5ac59532a15df82d5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e56da31fff9a5ba5ac59532a15df82d5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1658;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1658;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_STORE_set_flags );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1658;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1658;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_flags;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_e56da31fff9a5ba5ac59532a15df82d5->m_frame.f_lineno = 1658;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1658;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_1 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1658;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_e56da31fff9a5ba5ac59532a15df82d5->m_frame.f_lineno = 1658;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1658;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e56da31fff9a5ba5ac59532a15df82d5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e56da31fff9a5ba5ac59532a15df82d5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e56da31fff9a5ba5ac59532a15df82d5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e56da31fff9a5ba5ac59532a15df82d5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e56da31fff9a5ba5ac59532a15df82d5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e56da31fff9a5ba5ac59532a15df82d5,
        type_description_1,
        par_self,
        par_flags
    );


    // Release cached frame.
    if ( frame_e56da31fff9a5ba5ac59532a15df82d5 == cache_frame_e56da31fff9a5ba5ac59532a15df82d5 )
    {
        Py_DECREF( frame_e56da31fff9a5ba5ac59532a15df82d5 );
    }
    cache_frame_e56da31fff9a5ba5ac59532a15df82d5 = NULL;

    assertFrameObject( frame_e56da31fff9a5ba5ac59532a15df82d5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_88_set_flags );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_88_set_flags );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_89_set_time( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_vfy_time = python_pars[ 1 ];
    PyObject *var_param = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_b357cc9e906b9722fc07e8962b40d11d = NULL;

    struct Nuitka_FrameObject *frame_b357cc9e906b9722fc07e8962b40d11d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b357cc9e906b9722fc07e8962b40d11d, codeobj_b357cc9e906b9722fc07e8962b40d11d, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b357cc9e906b9722fc07e8962b40d11d = cache_frame_b357cc9e906b9722fc07e8962b40d11d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b357cc9e906b9722fc07e8962b40d11d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b357cc9e906b9722fc07e8962b40d11d ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1676;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_b357cc9e906b9722fc07e8962b40d11d->m_frame.f_lineno = 1676;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_VERIFY_PARAM_new );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1676;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_param == NULL );
    var_param = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1677;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1677;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_param;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1677;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_VERIFY_PARAM_free );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1677;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_b357cc9e906b9722fc07e8962b40d11d->m_frame.f_lineno = 1677;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1677;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_param;
        assert( old != NULL );
        var_param = tmp_assign_source_2;
        Py_DECREF( old );
    }

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1679;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_VERIFY_PARAM_set_time );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1679;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_param;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_calendar );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_calendar );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "calendar" );
        exception_tb = NULL;

        exception_lineno = 1680;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_timegm );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1680;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_2 = par_vfy_time;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_b357cc9e906b9722fc07e8962b40d11d->m_frame.f_lineno = 1680;
    tmp_args_element_name_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_timetuple );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1680;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_b357cc9e906b9722fc07e8962b40d11d->m_frame.f_lineno = 1680;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_args_element_name_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1680;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_b357cc9e906b9722fc07e8962b40d11d->m_frame.f_lineno = 1679;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1679;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1682;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1682;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_STORE_set1_param );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1682;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__store );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1682;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = var_param;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_b357cc9e906b9722fc07e8962b40d11d->m_frame.f_lineno = 1682;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1682;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_6 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1682;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_b357cc9e906b9722fc07e8962b40d11d->m_frame.f_lineno = 1682;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1682;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b357cc9e906b9722fc07e8962b40d11d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b357cc9e906b9722fc07e8962b40d11d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b357cc9e906b9722fc07e8962b40d11d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b357cc9e906b9722fc07e8962b40d11d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b357cc9e906b9722fc07e8962b40d11d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b357cc9e906b9722fc07e8962b40d11d,
        type_description_1,
        par_self,
        par_vfy_time,
        var_param
    );


    // Release cached frame.
    if ( frame_b357cc9e906b9722fc07e8962b40d11d == cache_frame_b357cc9e906b9722fc07e8962b40d11d )
    {
        Py_DECREF( frame_b357cc9e906b9722fc07e8962b40d11d );
    }
    cache_frame_b357cc9e906b9722fc07e8962b40d11d = NULL;

    assertFrameObject( frame_b357cc9e906b9722fc07e8962b40d11d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_89_set_time );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_vfy_time );
    Py_DECREF( par_vfy_time );
    par_vfy_time = NULL;

    CHECK_OBJECT( (PyObject *)var_param );
    Py_DECREF( var_param );
    var_param = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_vfy_time );
    Py_DECREF( par_vfy_time );
    par_vfy_time = NULL;

    Py_XDECREF( var_param );
    var_param = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_89_set_time );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_90_load_locations( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cafile = python_pars[ 1 ];
    PyObject *par_capath = python_pars[ 2 ];
    PyObject *var_load_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    bool tmp_is_1;
    bool tmp_is_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_2709b5b328fe0d9822af3023feb7896a = NULL;

    struct Nuitka_FrameObject *frame_2709b5b328fe0d9822af3023feb7896a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2709b5b328fe0d9822af3023feb7896a, codeobj_2709b5b328fe0d9822af3023feb7896a, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_2709b5b328fe0d9822af3023feb7896a = cache_frame_2709b5b328fe0d9822af3023feb7896a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2709b5b328fe0d9822af3023feb7896a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2709b5b328fe0d9822af3023feb7896a ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_cafile;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1716;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1716;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_cafile;
        assert( old != NULL );
        par_cafile = tmp_assign_source_1;
        Py_DECREF( old );
    }

    goto branch_end_1;
    branch_no_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__path_string );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
        exception_tb = NULL;

        exception_lineno = 1718;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_cafile;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_2709b5b328fe0d9822af3023feb7896a->m_frame.f_lineno = 1718;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1718;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_cafile;
        assert( old != NULL );
        par_cafile = tmp_assign_source_2;
        Py_DECREF( old );
    }

    branch_end_1:;
    tmp_compare_left_2 = par_capath;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = Py_None;
    tmp_is_2 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    if ( tmp_is_2 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1721;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1721;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_capath;
        assert( old != NULL );
        par_capath = tmp_assign_source_3;
        Py_DECREF( old );
    }

    goto branch_end_2;
    branch_no_2:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__path_string );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
        exception_tb = NULL;

        exception_lineno = 1723;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_capath;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_2709b5b328fe0d9822af3023feb7896a->m_frame.f_lineno = 1723;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1723;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_capath;
        assert( old != NULL );
        par_capath = tmp_assign_source_4;
        Py_DECREF( old );
    }

    branch_end_2:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1725;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_STORE_load_locations );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1725;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__store );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1726;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_cafile;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_args_element_name_5 = par_capath;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_2709b5b328fe0d9822af3023feb7896a->m_frame.f_lineno = 1725;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1725;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_load_result == NULL );
    var_load_result = tmp_assign_source_5;

    tmp_cond_value_1 = var_load_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1728;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1729;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_2709b5b328fe0d9822af3023feb7896a->m_frame.f_lineno = 1729;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1729;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2709b5b328fe0d9822af3023feb7896a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2709b5b328fe0d9822af3023feb7896a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2709b5b328fe0d9822af3023feb7896a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2709b5b328fe0d9822af3023feb7896a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2709b5b328fe0d9822af3023feb7896a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2709b5b328fe0d9822af3023feb7896a,
        type_description_1,
        par_self,
        par_cafile,
        par_capath,
        var_load_result
    );


    // Release cached frame.
    if ( frame_2709b5b328fe0d9822af3023feb7896a == cache_frame_2709b5b328fe0d9822af3023feb7896a )
    {
        Py_DECREF( frame_2709b5b328fe0d9822af3023feb7896a );
    }
    cache_frame_2709b5b328fe0d9822af3023feb7896a = NULL;

    assertFrameObject( frame_2709b5b328fe0d9822af3023feb7896a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_90_load_locations );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_capath );
    Py_DECREF( par_capath );
    par_capath = NULL;

    CHECK_OBJECT( (PyObject *)par_cafile );
    Py_DECREF( par_cafile );
    par_cafile = NULL;

    CHECK_OBJECT( (PyObject *)var_load_result );
    Py_DECREF( var_load_result );
    var_load_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_capath );
    par_capath = NULL;

    Py_XDECREF( par_cafile );
    par_cafile = NULL;

    Py_XDECREF( var_load_result );
    var_load_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_90_load_locations );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_91___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_message = python_pars[ 1 ];
    PyObject *par_certificate = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_object_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_type_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_4e3b06b88584206930ad4ab3fea731d0 = NULL;

    struct Nuitka_FrameObject *frame_4e3b06b88584206930ad4ab3fea731d0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4e3b06b88584206930ad4ab3fea731d0, codeobj_4e3b06b88584206930ad4ab3fea731d0, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_4e3b06b88584206930ad4ab3fea731d0 = cache_frame_4e3b06b88584206930ad4ab3fea731d0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4e3b06b88584206930ad4ab3fea731d0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4e3b06b88584206930ad4ab3fea731d0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_type_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreContextError );

    if (unlikely( tmp_type_name_1 == NULL ))
    {
        tmp_type_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509StoreContextError );
    }

    if ( tmp_type_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509StoreContextError" );
        exception_tb = NULL;

        exception_lineno = 1742;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_object_name_1 = par_self;

    CHECK_OBJECT( tmp_object_name_1 );
    tmp_called_instance_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1742;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_message;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_4e3b06b88584206930ad4ab3fea731d0->m_frame.f_lineno = 1742;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1742;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_1 = par_certificate;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_certificate, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1743;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4e3b06b88584206930ad4ab3fea731d0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4e3b06b88584206930ad4ab3fea731d0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4e3b06b88584206930ad4ab3fea731d0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4e3b06b88584206930ad4ab3fea731d0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4e3b06b88584206930ad4ab3fea731d0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4e3b06b88584206930ad4ab3fea731d0,
        type_description_1,
        par_self,
        par_message,
        par_certificate
    );


    // Release cached frame.
    if ( frame_4e3b06b88584206930ad4ab3fea731d0 == cache_frame_4e3b06b88584206930ad4ab3fea731d0 )
    {
        Py_DECREF( frame_4e3b06b88584206930ad4ab3fea731d0 );
    }
    cache_frame_4e3b06b88584206930ad4ab3fea731d0 = NULL;

    assertFrameObject( frame_4e3b06b88584206930ad4ab3fea731d0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_91___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_message );
    Py_DECREF( par_message );
    par_message = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate );
    Py_DECREF( par_certificate );
    par_certificate = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_message );
    Py_DECREF( par_message );
    par_message = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate );
    Py_DECREF( par_certificate );
    par_certificate = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_91___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_92___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_store = python_pars[ 1 ];
    PyObject *par_certificate = python_pars[ 2 ];
    PyObject *par_chain = python_pars[ 3 ];
    PyObject *var_store_ctx = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_cc4235dd9f43b9c9542b53c88b8e6a03 = NULL;

    struct Nuitka_FrameObject *frame_cc4235dd9f43b9c9542b53c88b8e6a03;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cc4235dd9f43b9c9542b53c88b8e6a03, codeobj_cc4235dd9f43b9c9542b53c88b8e6a03, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_cc4235dd9f43b9c9542b53c88b8e6a03 = cache_frame_cc4235dd9f43b9c9542b53c88b8e6a03;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cc4235dd9f43b9c9542b53c88b8e6a03 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cc4235dd9f43b9c9542b53c88b8e6a03 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1769;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_cc4235dd9f43b9c9542b53c88b8e6a03->m_frame.f_lineno = 1769;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_STORE_CTX_new );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1769;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_store_ctx == NULL );
    var_store_ctx = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1770;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1770;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_store_ctx;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1770;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_STORE_CTX_free );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1770;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_cc4235dd9f43b9c9542b53c88b8e6a03->m_frame.f_lineno = 1770;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1770;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__store_ctx, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1770;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_assattr_name_2 = par_store;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__store, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1771;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = par_certificate;

    CHECK_OBJECT( tmp_assattr_name_3 );
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__cert, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1772;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_3 = par_chain;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_cc4235dd9f43b9c9542b53c88b8e6a03->m_frame.f_lineno = 1773;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assattr_name_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__build_certificate_stack, call_args );
    }

    if ( tmp_assattr_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1773;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_4 = par_self;

    CHECK_OBJECT( tmp_assattr_target_4 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__chain, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_4 );

        exception_lineno = 1773;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_4 );
    tmp_called_instance_3 = par_self;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_cc4235dd9f43b9c9542b53c88b8e6a03->m_frame.f_lineno = 1777;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain__init );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1777;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cc4235dd9f43b9c9542b53c88b8e6a03 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cc4235dd9f43b9c9542b53c88b8e6a03 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cc4235dd9f43b9c9542b53c88b8e6a03, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cc4235dd9f43b9c9542b53c88b8e6a03->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cc4235dd9f43b9c9542b53c88b8e6a03, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cc4235dd9f43b9c9542b53c88b8e6a03,
        type_description_1,
        par_self,
        par_store,
        par_certificate,
        par_chain,
        var_store_ctx
    );


    // Release cached frame.
    if ( frame_cc4235dd9f43b9c9542b53c88b8e6a03 == cache_frame_cc4235dd9f43b9c9542b53c88b8e6a03 )
    {
        Py_DECREF( frame_cc4235dd9f43b9c9542b53c88b8e6a03 );
    }
    cache_frame_cc4235dd9f43b9c9542b53c88b8e6a03 = NULL;

    assertFrameObject( frame_cc4235dd9f43b9c9542b53c88b8e6a03 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_92___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_chain );
    Py_DECREF( par_chain );
    par_chain = NULL;

    CHECK_OBJECT( (PyObject *)var_store_ctx );
    Py_DECREF( var_store_ctx );
    var_store_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate );
    Py_DECREF( par_certificate );
    par_certificate = NULL;

    CHECK_OBJECT( (PyObject *)par_store );
    Py_DECREF( par_store );
    par_store = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_chain );
    Py_DECREF( par_chain );
    par_chain = NULL;

    Py_XDECREF( var_store_ctx );
    var_store_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate );
    Py_DECREF( par_certificate );
    par_certificate = NULL;

    CHECK_OBJECT( (PyObject *)par_store );
    Py_DECREF( par_store );
    par_store = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_92___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_93__build_certificate_stack( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_certificates = python_pars[ 0 ];
    PyObject *var_cert = NULL;
    PyObject *var_cleanup = NULL;
    PyObject *var_stack = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cmp_LtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_left_4;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    PyObject *tmp_compexpr_right_4;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_make_exception_arg_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_83f6355a0f982176162b7419981e2765 = NULL;

    struct Nuitka_FrameObject *frame_83f6355a0f982176162b7419981e2765;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = MAKE_FUNCTION_OpenSSL$crypto$$$function_93__build_certificate_stack$$$function_1_cleanup(  );
    assert( var_cleanup == NULL );
    var_cleanup = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_83f6355a0f982176162b7419981e2765, codeobj_83f6355a0f982176162b7419981e2765, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_83f6355a0f982176162b7419981e2765 = cache_frame_83f6355a0f982176162b7419981e2765;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_83f6355a0f982176162b7419981e2765 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_83f6355a0f982176162b7419981e2765 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_certificates;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = Py_None;
    tmp_or_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 == tmp_compexpr_right_1 );
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    assert( !(tmp_or_left_truth_1 == -1) );
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    tmp_len_arg_1 = par_certificates;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compexpr_left_2 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1789;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_2 = const_int_0;
    tmp_or_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1789;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    Py_INCREF( tmp_or_left_value_1 );
    tmp_cond_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1789;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1790;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1790;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1792;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_83f6355a0f982176162b7419981e2765->m_frame.f_lineno = 1792;
    tmp_assign_source_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_sk_X509_new_null );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1792;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_stack == NULL );
    var_stack = tmp_assign_source_2;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1793;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_3 = var_stack;

    CHECK_OBJECT( tmp_compexpr_left_3 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1793;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_compexpr_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1793;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = RICH_COMPARE_NE( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    Py_DECREF( tmp_compexpr_right_3 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1793;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_83f6355a0f982176162b7419981e2765->m_frame.f_lineno = 1793;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1793;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1794;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_stack;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = var_cleanup;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_83f6355a0f982176162b7419981e2765->m_frame.f_lineno = 1794;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_gc, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1794;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_stack;
        assert( old != NULL );
        var_stack = tmp_assign_source_3;
        Py_DECREF( old );
    }

    tmp_iter_arg_1 = par_certificates;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1796;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_4;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_5 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooo";
        exception_lineno = 1796;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1796;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_2;
    branch_no_2:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_2:;
    // End of try:
    try_end_1:;
    tmp_assign_source_6 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_6 );
    {
        PyObject *old = var_cert;
        var_cert = tmp_assign_source_6;
        Py_INCREF( var_cert );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_cert;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 1797;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1797;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_1 = const_str_digest_624de773f1e3dc72be54266a02c1df41;
    frame_83f6355a0f982176162b7419981e2765->m_frame.f_lineno = 1798;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1798;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto try_except_handler_2;
    branch_no_3:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1800;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1800;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_up_ref );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1800;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_source_name_4 = var_cert;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__x509 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1800;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    frame_83f6355a0f982176162b7419981e2765->m_frame.f_lineno = 1800;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_compexpr_left_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_compexpr_left_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1800;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_compexpr_right_4 = const_int_0;
    tmp_args_element_name_4 = RICH_COMPARE_GT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
    Py_DECREF( tmp_compexpr_left_4 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1800;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    frame_83f6355a0f982176162b7419981e2765->m_frame.f_lineno = 1800;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1800;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_sk_X509_push );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_6 = var_stack;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_source_name_6 = var_cert;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__x509 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    frame_83f6355a0f982176162b7419981e2765->m_frame.f_lineno = 1801;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_compare_left_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_compare_right_2 = const_int_0;
    tmp_cmp_LtE_1 = RICH_COMPARE_BOOL_LE( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_LtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_LtE_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1802;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_X509_free );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1802;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_source_name_8 = var_cert;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__x509 );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1802;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    frame_83f6355a0f982176162b7419981e2765->m_frame.f_lineno = 1802;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1802;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1803;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    frame_83f6355a0f982176162b7419981e2765->m_frame.f_lineno = 1803;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1803;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1796;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_83f6355a0f982176162b7419981e2765 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_83f6355a0f982176162b7419981e2765 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_83f6355a0f982176162b7419981e2765 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_83f6355a0f982176162b7419981e2765, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_83f6355a0f982176162b7419981e2765->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_83f6355a0f982176162b7419981e2765, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_83f6355a0f982176162b7419981e2765,
        type_description_1,
        par_certificates,
        var_cert,
        var_cleanup,
        var_stack
    );


    // Release cached frame.
    if ( frame_83f6355a0f982176162b7419981e2765 == cache_frame_83f6355a0f982176162b7419981e2765 )
    {
        Py_DECREF( frame_83f6355a0f982176162b7419981e2765 );
    }
    cache_frame_83f6355a0f982176162b7419981e2765 = NULL;

    assertFrameObject( frame_83f6355a0f982176162b7419981e2765 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = var_stack;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_93__build_certificate_stack );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_certificates );
    Py_DECREF( par_certificates );
    par_certificates = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)var_cleanup );
    Py_DECREF( var_cleanup );
    var_cleanup = NULL;

    Py_XDECREF( var_stack );
    var_stack = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_certificates );
    Py_DECREF( par_certificates );
    par_certificates = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)var_cleanup );
    Py_DECREF( var_cleanup );
    var_cleanup = NULL;

    Py_XDECREF( var_stack );
    var_stack = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_93__build_certificate_stack );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_93__build_certificate_stack$$$function_1_cleanup( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_s = python_pars[ 0 ];
    PyObject *var_i = NULL;
    PyObject *var_x = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_range_arg_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_dbceb89b1b1d3b1149b72b5d9f552b47 = NULL;

    struct Nuitka_FrameObject *frame_dbceb89b1b1d3b1149b72b5d9f552b47;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dbceb89b1b1d3b1149b72b5d9f552b47, codeobj_dbceb89b1b1d3b1149b72b5d9f552b47, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_dbceb89b1b1d3b1149b72b5d9f552b47 = cache_frame_dbceb89b1b1d3b1149b72b5d9f552b47;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dbceb89b1b1d3b1149b72b5d9f552b47 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dbceb89b1b1d3b1149b72b5d9f552b47 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1784;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_s;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_dbceb89b1b1d3b1149b72b5d9f552b47->m_frame.f_lineno = 1784;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_sk_X509_num, call_args );
    }

    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1784;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1784;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1784;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooo";
        exception_lineno = 1784;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1784;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_3;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1785;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_2 = par_s;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = var_i;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_dbceb89b1b1d3b1149b72b5d9f552b47->m_frame.f_lineno = 1785;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_sk_X509_value, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1785;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1786;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_4 = var_x;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_dbceb89b1b1d3b1149b72b5d9f552b47->m_frame.f_lineno = 1786;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_X509_free, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1786;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1784;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1787;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = par_s;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_dbceb89b1b1d3b1149b72b5d9f552b47->m_frame.f_lineno = 1787;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_sk_X509_free, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1787;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbceb89b1b1d3b1149b72b5d9f552b47 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbceb89b1b1d3b1149b72b5d9f552b47 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dbceb89b1b1d3b1149b72b5d9f552b47, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dbceb89b1b1d3b1149b72b5d9f552b47->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dbceb89b1b1d3b1149b72b5d9f552b47, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dbceb89b1b1d3b1149b72b5d9f552b47,
        type_description_1,
        par_s,
        var_i,
        var_x
    );


    // Release cached frame.
    if ( frame_dbceb89b1b1d3b1149b72b5d9f552b47 == cache_frame_dbceb89b1b1d3b1149b72b5d9f552b47 )
    {
        Py_DECREF( frame_dbceb89b1b1d3b1149b72b5d9f552b47 );
    }
    cache_frame_dbceb89b1b1d3b1149b72b5d9f552b47 = NULL;

    assertFrameObject( frame_dbceb89b1b1d3b1149b72b5d9f552b47 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_93__build_certificate_stack$$$function_1_cleanup );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;

    CHECK_OBJECT( (PyObject *)par_s );
    Py_DECREF( par_s );
    par_s = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;

    CHECK_OBJECT( (PyObject *)par_s );
    Py_DECREF( par_s );
    par_s = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_93__build_certificate_stack$$$function_1_cleanup );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_94__init( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_ret = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_LtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_939508a1e0496c5c137cc6f48b750d12 = NULL;

    struct Nuitka_FrameObject *frame_939508a1e0496c5c137cc6f48b750d12;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_939508a1e0496c5c137cc6f48b750d12, codeobj_939508a1e0496c5c137cc6f48b750d12, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_939508a1e0496c5c137cc6f48b750d12 = cache_frame_939508a1e0496c5c137cc6f48b750d12;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_939508a1e0496c5c137cc6f48b750d12 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_939508a1e0496c5c137cc6f48b750d12 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1814;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_STORE_CTX_init );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1814;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store_ctx );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1815;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__store );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1815;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__store );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1815;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_source_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__cert );
    if ( tmp_source_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1815;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__x509 );
    Py_DECREF( tmp_source_name_5 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1815;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__chain );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1815;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_939508a1e0496c5c137cc6f48b750d12->m_frame.f_lineno = 1814;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1814;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_ret == NULL );
    var_ret = tmp_assign_source_1;

    tmp_compare_left_1 = var_ret;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_LtE_1 = RICH_COMPARE_BOOL_LE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_LtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1817;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_LtE_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1818;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_939508a1e0496c5c137cc6f48b750d12->m_frame.f_lineno = 1818;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1818;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_939508a1e0496c5c137cc6f48b750d12 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_939508a1e0496c5c137cc6f48b750d12 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_939508a1e0496c5c137cc6f48b750d12, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_939508a1e0496c5c137cc6f48b750d12->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_939508a1e0496c5c137cc6f48b750d12, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_939508a1e0496c5c137cc6f48b750d12,
        type_description_1,
        par_self,
        var_ret
    );


    // Release cached frame.
    if ( frame_939508a1e0496c5c137cc6f48b750d12 == cache_frame_939508a1e0496c5c137cc6f48b750d12 )
    {
        Py_DECREF( frame_939508a1e0496c5c137cc6f48b750d12 );
    }
    cache_frame_939508a1e0496c5c137cc6f48b750d12 = NULL;

    assertFrameObject( frame_939508a1e0496c5c137cc6f48b750d12 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_94__init );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ret );
    Py_DECREF( var_ret );
    var_ret = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ret );
    var_ret = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_94__init );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_95__cleanup( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_6a070d2cef92fc76d5061d3f76c44171 = NULL;

    struct Nuitka_FrameObject *frame_6a070d2cef92fc76d5061d3f76c44171;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6a070d2cef92fc76d5061d3f76c44171, codeobj_6a070d2cef92fc76d5061d3f76c44171, module_OpenSSL$crypto, sizeof(void *) );
    frame_6a070d2cef92fc76d5061d3f76c44171 = cache_frame_6a070d2cef92fc76d5061d3f76c44171;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6a070d2cef92fc76d5061d3f76c44171 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6a070d2cef92fc76d5061d3f76c44171 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1826;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_STORE_CTX_cleanup );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1826;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store_ctx );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1826;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_6a070d2cef92fc76d5061d3f76c44171->m_frame.f_lineno = 1826;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1826;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a070d2cef92fc76d5061d3f76c44171 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a070d2cef92fc76d5061d3f76c44171 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6a070d2cef92fc76d5061d3f76c44171, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6a070d2cef92fc76d5061d3f76c44171->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6a070d2cef92fc76d5061d3f76c44171, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6a070d2cef92fc76d5061d3f76c44171,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6a070d2cef92fc76d5061d3f76c44171 == cache_frame_6a070d2cef92fc76d5061d3f76c44171 )
    {
        Py_DECREF( frame_6a070d2cef92fc76d5061d3f76c44171 );
    }
    cache_frame_6a070d2cef92fc76d5061d3f76c44171 = NULL;

    assertFrameObject( frame_6a070d2cef92fc76d5061d3f76c44171 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_95__cleanup );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_95__cleanup );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_96__exception_from_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_errors = NULL;
    PyObject *var__cert = NULL;
    PyObject *var_pycert = NULL;
    PyObject *var__x509 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    static struct Nuitka_FrameObject *cache_frame_22507613a2c65d750fef04b0041d1bcf = NULL;

    struct Nuitka_FrameObject *frame_22507613a2c65d750fef04b0041d1bcf;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_22507613a2c65d750fef04b0041d1bcf, codeobj_22507613a2c65d750fef04b0041d1bcf, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_22507613a2c65d750fef04b0041d1bcf = cache_frame_22507613a2c65d750fef04b0041d1bcf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_22507613a2c65d750fef04b0041d1bcf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_22507613a2c65d750fef04b0041d1bcf ) == 2 ); // Frame stack

    // Framed code:
    tmp_assign_source_1 = PyList_New( 3 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1837;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_STORE_CTX_get_error );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 1837;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store_ctx );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1837;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_22507613a2c65d750fef04b0041d1bcf->m_frame.f_lineno = 1837;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 1837;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_assign_source_1, 0, tmp_list_element_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1838;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_STORE_CTX_get_error_depth );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 1838;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__store_ctx );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1838;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_22507613a2c65d750fef04b0041d1bcf->m_frame.f_lineno = 1838;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 1838;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_assign_source_1, 1, tmp_list_element_1 );
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
    }

    if ( tmp_called_name_3 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
        exception_tb = NULL;

        exception_lineno = 1839;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1840;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_string );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 1840;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1841;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_verify_cert_error_string );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1841;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1842;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_X509_STORE_CTX_get_error );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1842;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = par_self;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__store_ctx );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 1842;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_22507613a2c65d750fef04b0041d1bcf->m_frame.f_lineno = 1842;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_args_element_name_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1842;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_22507613a2c65d750fef04b0041d1bcf->m_frame.f_lineno = 1841;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_args_element_name_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1841;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_22507613a2c65d750fef04b0041d1bcf->m_frame.f_lineno = 1840;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 1840;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_22507613a2c65d750fef04b0041d1bcf->m_frame.f_lineno = 1839;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 1839;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_assign_source_1, 2, tmp_list_element_1 );
    assert( var_errors == NULL );
    var_errors = tmp_assign_source_1;

    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1849;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_X509_STORE_CTX_get_current_cert );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1849;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_10 = par_self;

    CHECK_OBJECT( tmp_source_name_10 );
    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain__store_ctx );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 1849;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_22507613a2c65d750fef04b0041d1bcf->m_frame.f_lineno = 1849;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1849;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var__x509 == NULL );
    var__x509 = tmp_assign_source_2;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1850;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = var__x509;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_22507613a2c65d750fef04b0041d1bcf->m_frame.f_lineno = 1850;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_dup, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1850;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var__cert == NULL );
    var__cert = tmp_assign_source_3;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 1851;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_9 = var__cert;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_22507613a2c65d750fef04b0041d1bcf->m_frame.f_lineno = 1851;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__from_raw_x509_ptr, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1851;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pycert == NULL );
    var_pycert = tmp_assign_source_4;

    tmp_called_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreContextError );

    if (unlikely( tmp_called_name_8 == NULL ))
    {
        tmp_called_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509StoreContextError );
    }

    if ( tmp_called_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509StoreContextError" );
        exception_tb = NULL;

        exception_lineno = 1852;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = var_errors;

    CHECK_OBJECT( tmp_args_element_name_10 );
    tmp_args_element_name_11 = var_pycert;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_22507613a2c65d750fef04b0041d1bcf->m_frame.f_lineno = 1852;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_8, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1852;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_22507613a2c65d750fef04b0041d1bcf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_22507613a2c65d750fef04b0041d1bcf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_22507613a2c65d750fef04b0041d1bcf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_22507613a2c65d750fef04b0041d1bcf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_22507613a2c65d750fef04b0041d1bcf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_22507613a2c65d750fef04b0041d1bcf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_22507613a2c65d750fef04b0041d1bcf,
        type_description_1,
        par_self,
        var_errors,
        var__cert,
        var_pycert,
        var__x509
    );


    // Release cached frame.
    if ( frame_22507613a2c65d750fef04b0041d1bcf == cache_frame_22507613a2c65d750fef04b0041d1bcf )
    {
        Py_DECREF( frame_22507613a2c65d750fef04b0041d1bcf );
    }
    cache_frame_22507613a2c65d750fef04b0041d1bcf = NULL;

    assertFrameObject( frame_22507613a2c65d750fef04b0041d1bcf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_96__exception_from_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_errors );
    Py_DECREF( var_errors );
    var_errors = NULL;

    CHECK_OBJECT( (PyObject *)var__cert );
    Py_DECREF( var__cert );
    var__cert = NULL;

    CHECK_OBJECT( (PyObject *)var_pycert );
    Py_DECREF( var_pycert );
    var_pycert = NULL;

    CHECK_OBJECT( (PyObject *)var__x509 );
    Py_DECREF( var__x509 );
    var__x509 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_errors );
    var_errors = NULL;

    Py_XDECREF( var__cert );
    var__cert = NULL;

    Py_XDECREF( var_pycert );
    var_pycert = NULL;

    Py_XDECREF( var__x509 );
    var__x509 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_96__exception_from_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_97_set_store( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_store = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_deef68f99d6ac4c33ddafe5e7f7cd886 = NULL;

    struct Nuitka_FrameObject *frame_deef68f99d6ac4c33ddafe5e7f7cd886;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_deef68f99d6ac4c33ddafe5e7f7cd886, codeobj_deef68f99d6ac4c33ddafe5e7f7cd886, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_deef68f99d6ac4c33ddafe5e7f7cd886 = cache_frame_deef68f99d6ac4c33ddafe5e7f7cd886;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_deef68f99d6ac4c33ddafe5e7f7cd886 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_deef68f99d6ac4c33ddafe5e7f7cd886 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = par_store;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__store, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1863;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_deef68f99d6ac4c33ddafe5e7f7cd886 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_deef68f99d6ac4c33ddafe5e7f7cd886 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_deef68f99d6ac4c33ddafe5e7f7cd886, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_deef68f99d6ac4c33ddafe5e7f7cd886->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_deef68f99d6ac4c33ddafe5e7f7cd886, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_deef68f99d6ac4c33ddafe5e7f7cd886,
        type_description_1,
        par_self,
        par_store
    );


    // Release cached frame.
    if ( frame_deef68f99d6ac4c33ddafe5e7f7cd886 == cache_frame_deef68f99d6ac4c33ddafe5e7f7cd886 )
    {
        Py_DECREF( frame_deef68f99d6ac4c33ddafe5e7f7cd886 );
    }
    cache_frame_deef68f99d6ac4c33ddafe5e7f7cd886 = NULL;

    assertFrameObject( frame_deef68f99d6ac4c33ddafe5e7f7cd886 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_97_set_store );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_store );
    Py_DECREF( par_store );
    par_store = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_store );
    Py_DECREF( par_store );
    par_store = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_97_set_store );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_98_verify_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_ret = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    int tmp_cmp_LtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_6093350e55e88ba43a75d89738bbea61 = NULL;

    struct Nuitka_FrameObject *frame_6093350e55e88ba43a75d89738bbea61;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6093350e55e88ba43a75d89738bbea61, codeobj_6093350e55e88ba43a75d89738bbea61, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_6093350e55e88ba43a75d89738bbea61 = cache_frame_6093350e55e88ba43a75d89738bbea61;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6093350e55e88ba43a75d89738bbea61 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6093350e55e88ba43a75d89738bbea61 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_6093350e55e88ba43a75d89738bbea61->m_frame.f_lineno = 1880;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__cleanup );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1880;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_6093350e55e88ba43a75d89738bbea61->m_frame.f_lineno = 1881;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain__init );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1881;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1882;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_verify_cert );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1882;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store_ctx );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1882;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_6093350e55e88ba43a75d89738bbea61->m_frame.f_lineno = 1882;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1882;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_ret == NULL );
    var_ret = tmp_assign_source_1;

    tmp_called_instance_3 = par_self;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_6093350e55e88ba43a75d89738bbea61->m_frame.f_lineno = 1883;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain__cleanup );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1883;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_compare_left_1 = var_ret;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_LtE_1 = RICH_COMPARE_BOOL_LE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_LtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1884;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_LtE_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_6093350e55e88ba43a75d89738bbea61->m_frame.f_lineno = 1885;
    tmp_raise_type_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain__exception_from_context );
    if ( tmp_raise_type_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1885;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_1;
    exception_lineno = 1885;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6093350e55e88ba43a75d89738bbea61 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6093350e55e88ba43a75d89738bbea61 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6093350e55e88ba43a75d89738bbea61, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6093350e55e88ba43a75d89738bbea61->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6093350e55e88ba43a75d89738bbea61, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6093350e55e88ba43a75d89738bbea61,
        type_description_1,
        par_self,
        var_ret
    );


    // Release cached frame.
    if ( frame_6093350e55e88ba43a75d89738bbea61 == cache_frame_6093350e55e88ba43a75d89738bbea61 )
    {
        Py_DECREF( frame_6093350e55e88ba43a75d89738bbea61 );
    }
    cache_frame_6093350e55e88ba43a75d89738bbea61 = NULL;

    assertFrameObject( frame_6093350e55e88ba43a75d89738bbea61 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_98_verify_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ret );
    Py_DECREF( var_ret );
    var_ret = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ret );
    var_ret = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_98_verify_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_99_get_verified_chain( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_i = NULL;
    PyObject *var_cert_stack = NULL;
    PyObject *var_pycert = NULL;
    PyObject *var_ret = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_instance_10;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_LtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_range_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_b7cc71e6ff631f267fd48a1034a4d982 = NULL;

    struct Nuitka_FrameObject *frame_b7cc71e6ff631f267fd48a1034a4d982;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b7cc71e6ff631f267fd48a1034a4d982, codeobj_b7cc71e6ff631f267fd48a1034a4d982, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b7cc71e6ff631f267fd48a1034a4d982 = cache_frame_b7cc71e6ff631f267fd48a1034a4d982;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b7cc71e6ff631f267fd48a1034a4d982 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b7cc71e6ff631f267fd48a1034a4d982 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1903;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__cleanup );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1903;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1904;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain__init );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1904;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1905;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_verify_cert );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1905;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store_ctx );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1905;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1905;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1905;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_ret == NULL );
    var_ret = tmp_assign_source_1;

    tmp_compare_left_1 = var_ret;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_LtE_1 = RICH_COMPARE_BOOL_LE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_LtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1906;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_LtE_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_3 = par_self;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1907;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain__cleanup );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1907;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1908;
    tmp_raise_type_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain__exception_from_context );
    if ( tmp_raise_type_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1908;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_1;
    exception_lineno = 1908;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1911;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_STORE_CTX_get1_chain );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1911;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__store_ctx );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1911;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1911;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1911;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_cert_stack == NULL );
    var_cert_stack = tmp_assign_source_2;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1912;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_cert_stack;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1912;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1912;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1912;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1912;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1912;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_3 = PyList_New( 0 );
    assert( var_result == NULL );
    var_result = tmp_assign_source_3;

    tmp_called_instance_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_5 == NULL ))
    {
        tmp_called_instance_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1915;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = var_cert_stack;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1915;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_sk_X509_num, call_args );
    }

    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1915;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1915;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1915;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_4;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_5 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooooo";
        exception_lineno = 1915;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_2 = exception_keeper_type_1;
    tmp_compare_right_2 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1915;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_2;
    branch_no_2:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_2:;
    // End of try:
    try_end_1:;
    tmp_assign_source_6 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_6 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_6;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_called_instance_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_6 == NULL ))
    {
        tmp_called_instance_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1916;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_5 = var_cert_stack;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = var_i;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1916;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_6, const_str_plain_sk_X509_value, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1916;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_cert;
        var_cert = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1917;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_compexpr_left_2 = var_cert;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1917;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1917;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_7 = RICH_COMPARE_NE( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1917;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1917;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1917;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_called_instance_7 == NULL ))
    {
        tmp_called_instance_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_called_instance_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 1918;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_8 = var_cert;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1918;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_assign_source_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain__from_raw_x509_ptr, call_args );
    }

    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1918;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_pycert;
        var_pycert = tmp_assign_source_8;
        Py_XDECREF( old );
    }

    tmp_called_instance_8 = var_result;

    CHECK_OBJECT( tmp_called_instance_8 );
    tmp_args_element_name_9 = var_pycert;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1919;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_8, const_str_plain_append, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1919;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1915;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_called_instance_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_9 == NULL ))
    {
        tmp_called_instance_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1922;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = var_cert_stack;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1922;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_9, const_str_plain_sk_X509_free, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1922;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_10 = par_self;

    CHECK_OBJECT( tmp_called_instance_10 );
    frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame.f_lineno = 1923;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_10, const_str_plain__cleanup );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1923;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b7cc71e6ff631f267fd48a1034a4d982 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b7cc71e6ff631f267fd48a1034a4d982 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b7cc71e6ff631f267fd48a1034a4d982, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b7cc71e6ff631f267fd48a1034a4d982->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b7cc71e6ff631f267fd48a1034a4d982, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b7cc71e6ff631f267fd48a1034a4d982,
        type_description_1,
        par_self,
        var_i,
        var_cert_stack,
        var_pycert,
        var_ret,
        var_cert,
        var_result
    );


    // Release cached frame.
    if ( frame_b7cc71e6ff631f267fd48a1034a4d982 == cache_frame_b7cc71e6ff631f267fd48a1034a4d982 )
    {
        Py_DECREF( frame_b7cc71e6ff631f267fd48a1034a4d982 );
    }
    cache_frame_b7cc71e6ff631f267fd48a1034a4d982 = NULL;

    assertFrameObject( frame_b7cc71e6ff631f267fd48a1034a4d982 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_99_get_verified_chain );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)var_cert_stack );
    Py_DECREF( var_cert_stack );
    var_cert_stack = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_pycert );
    var_pycert = NULL;

    CHECK_OBJECT( (PyObject *)var_ret );
    Py_DECREF( var_ret );
    var_ret = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_cert_stack );
    var_cert_stack = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_pycert );
    var_pycert = NULL;

    Py_XDECREF( var_ret );
    var_ret = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_99_get_verified_chain );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_100_load_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_x509 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_49f65499044958fd105e8a41711525ee = NULL;

    struct Nuitka_FrameObject *frame_49f65499044958fd105e8a41711525ee;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_49f65499044958fd105e8a41711525ee, codeobj_49f65499044958fd105e8a41711525ee, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_49f65499044958fd105e8a41711525ee = cache_frame_49f65499044958fd105e8a41711525ee;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_49f65499044958fd105e8a41711525ee );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_49f65499044958fd105e8a41711525ee ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_buffer;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
        exception_tb = NULL;

        exception_lineno = 1938;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1938;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_buffer;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_49f65499044958fd105e8a41711525ee->m_frame.f_lineno = 1939;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1939;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_buffer;
        assert( old != NULL );
        par_buffer = tmp_assign_source_1;
        Py_DECREF( old );
    }

    branch_no_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 1941;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_buffer;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_49f65499044958fd105e8a41711525ee->m_frame.f_lineno = 1941;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1941;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_2;

    tmp_compare_left_1 = par_type;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 1943;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1943;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1944;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_read_bio_X509 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1944;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1944;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1944;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1944;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1944;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1944;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 1944;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_49f65499044958fd105e8a41711525ee->m_frame.f_lineno = 1944;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1944;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_x509 == NULL );
    var_x509 = tmp_assign_source_3;

    goto branch_end_2;
    branch_no_2:;
    tmp_compare_left_2 = par_type;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

    if (unlikely( tmp_compare_right_2 == NULL ))
    {
        tmp_compare_right_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
    }

    if ( tmp_compare_right_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
        exception_tb = NULL;

        exception_lineno = 1945;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1945;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1946;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_d2i_X509_bio );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1946;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1946;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1946;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_49f65499044958fd105e8a41711525ee->m_frame.f_lineno = 1946;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1946;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_x509 == NULL );
    var_x509 = tmp_assign_source_4;

    goto branch_end_3;
    branch_no_3:;
    tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
    frame_49f65499044958fd105e8a41711525ee->m_frame.f_lineno = 1948;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1948;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_end_3:;
    branch_end_2:;
    tmp_compare_left_3 = var_x509;

    if ( tmp_compare_left_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x509" );
        exception_tb = NULL;

        exception_lineno = 1950;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1950;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
    if ( tmp_compare_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1950;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_3 );

        exception_lineno = 1950;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1951;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_49f65499044958fd105e8a41711525ee->m_frame.f_lineno = 1951;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1951;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 1953;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__from_raw_x509_ptr );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1953;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = var_x509;

    if ( tmp_args_element_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x509" );
        exception_tb = NULL;

        exception_lineno = 1953;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_49f65499044958fd105e8a41711525ee->m_frame.f_lineno = 1953;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1953;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_49f65499044958fd105e8a41711525ee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_49f65499044958fd105e8a41711525ee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_49f65499044958fd105e8a41711525ee );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_49f65499044958fd105e8a41711525ee, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_49f65499044958fd105e8a41711525ee->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_49f65499044958fd105e8a41711525ee, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_49f65499044958fd105e8a41711525ee,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_x509
    );


    // Release cached frame.
    if ( frame_49f65499044958fd105e8a41711525ee == cache_frame_49f65499044958fd105e8a41711525ee )
    {
        Py_DECREF( frame_49f65499044958fd105e8a41711525ee );
    }
    cache_frame_49f65499044958fd105e8a41711525ee = NULL;

    assertFrameObject( frame_49f65499044958fd105e8a41711525ee );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_100_load_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_x509 );
    var_x509 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_x509 );
    var_x509 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_100_load_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_101_dump_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_cert = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_result_code = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_6a7a8eee239b6a4648d8651514b607eb = NULL;

    struct Nuitka_FrameObject *frame_6a7a8eee239b6a4648d8651514b607eb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6a7a8eee239b6a4648d8651514b607eb, codeobj_6a7a8eee239b6a4648d8651514b607eb, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6a7a8eee239b6a4648d8651514b607eb = cache_frame_6a7a8eee239b6a4648d8651514b607eb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6a7a8eee239b6a4648d8651514b607eb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6a7a8eee239b6a4648d8651514b607eb ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 1966;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_6a7a8eee239b6a4648d8651514b607eb->m_frame.f_lineno = 1966;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1966;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_1;

    tmp_compare_left_1 = par_type;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 1968;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1968;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1969;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_write_bio_X509 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1969;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = par_cert;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1969;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_6a7a8eee239b6a4648d8651514b607eb->m_frame.f_lineno = 1969;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1969;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_code == NULL );
    var_result_code = tmp_assign_source_2;

    goto branch_end_1;
    branch_no_1:;
    tmp_compare_left_2 = par_type;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

    if (unlikely( tmp_compare_right_2 == NULL ))
    {
        tmp_compare_right_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
    }

    if ( tmp_compare_right_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
        exception_tb = NULL;

        exception_lineno = 1970;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1970;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1971;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_i2d_X509_bio );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1971;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_source_name_4 = par_cert;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__x509 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1971;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_6a7a8eee239b6a4648d8651514b607eb->m_frame.f_lineno = 1971;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1971;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_code == NULL );
    var_result_code = tmp_assign_source_3;

    goto branch_end_2;
    branch_no_2:;
    tmp_compare_left_3 = par_type;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );

    if (unlikely( tmp_compare_right_3 == NULL ))
    {
        tmp_compare_right_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );
    }

    if ( tmp_compare_right_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_TEXT" );
        exception_tb = NULL;

        exception_lineno = 1972;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1972;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1973;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_print_ex );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1973;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_source_name_6 = par_cert;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__x509 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1973;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = const_int_0;
    tmp_args_element_name_8 = const_int_0;
    frame_6a7a8eee239b6a4648d8651514b607eb->m_frame.f_lineno = 1973;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1973;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_code == NULL );
    var_result_code = tmp_assign_source_4;

    goto branch_end_3;
    branch_no_3:;
    tmp_make_exception_arg_1 = const_str_digest_11c225ccbab9acffc38107dee9691702;
    frame_6a7a8eee239b6a4648d8651514b607eb->m_frame.f_lineno = 1975;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1975;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_end_3:;
    branch_end_2:;
    branch_end_1:;
    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1980;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_result_code;

    if ( tmp_compexpr_left_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result_code" );
        exception_tb = NULL;

        exception_lineno = 1980;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_9 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1980;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_6a7a8eee239b6a4648d8651514b607eb->m_frame.f_lineno = 1980;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1980;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
        exception_tb = NULL;

        exception_lineno = 1981;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_6a7a8eee239b6a4648d8651514b607eb->m_frame.f_lineno = 1981;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1981;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a7a8eee239b6a4648d8651514b607eb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a7a8eee239b6a4648d8651514b607eb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a7a8eee239b6a4648d8651514b607eb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6a7a8eee239b6a4648d8651514b607eb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6a7a8eee239b6a4648d8651514b607eb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6a7a8eee239b6a4648d8651514b607eb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6a7a8eee239b6a4648d8651514b607eb,
        type_description_1,
        par_type,
        par_cert,
        var_bio,
        var_result_code
    );


    // Release cached frame.
    if ( frame_6a7a8eee239b6a4648d8651514b607eb == cache_frame_6a7a8eee239b6a4648d8651514b607eb )
    {
        Py_DECREF( frame_6a7a8eee239b6a4648d8651514b607eb );
    }
    cache_frame_6a7a8eee239b6a4648d8651514b607eb = NULL;

    assertFrameObject( frame_6a7a8eee239b6a4648d8651514b607eb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_101_dump_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_101_dump_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_102_dump_publickey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *var_write_bio = NULL;
    PyObject *var_result_code = NULL;
    PyObject *var_bio = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_96feb5417aba60c65386efdfa05ffda6 = NULL;

    struct Nuitka_FrameObject *frame_96feb5417aba60c65386efdfa05ffda6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_96feb5417aba60c65386efdfa05ffda6, codeobj_96feb5417aba60c65386efdfa05ffda6, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_96feb5417aba60c65386efdfa05ffda6 = cache_frame_96feb5417aba60c65386efdfa05ffda6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_96feb5417aba60c65386efdfa05ffda6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_96feb5417aba60c65386efdfa05ffda6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 1994;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_96feb5417aba60c65386efdfa05ffda6->m_frame.f_lineno = 1994;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1994;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_1;

    tmp_compare_left_1 = par_type;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 1995;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1995;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1996;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_write_bio_PUBKEY );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1996;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_write_bio == NULL );
    var_write_bio = tmp_assign_source_2;

    goto branch_end_1;
    branch_no_1:;
    tmp_compare_left_2 = par_type;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

    if (unlikely( tmp_compare_right_2 == NULL ))
    {
        tmp_compare_right_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
    }

    if ( tmp_compare_right_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
        exception_tb = NULL;

        exception_lineno = 1997;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1997;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1998;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_i2d_PUBKEY_bio );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1998;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_write_bio == NULL );
    var_write_bio = tmp_assign_source_3;

    goto branch_end_2;
    branch_no_2:;
    tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
    frame_96feb5417aba60c65386efdfa05ffda6->m_frame.f_lineno = 2000;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2000;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_end_2:;
    branch_end_1:;
    tmp_called_name_2 = var_write_bio;

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "write_bio" );
        exception_tb = NULL;

        exception_lineno = 2002;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_3 = par_pkey;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2002;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_96feb5417aba60c65386efdfa05ffda6->m_frame.f_lineno = 2002;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2002;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_code == NULL );
    var_result_code = tmp_assign_source_4;

    tmp_compare_left_3 = var_result_code;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = const_int_pos_1;
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2003;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 2004;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_96feb5417aba60c65386efdfa05ffda6->m_frame.f_lineno = 2004;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2004;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
        exception_tb = NULL;

        exception_lineno = 2006;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_96feb5417aba60c65386efdfa05ffda6->m_frame.f_lineno = 2006;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2006;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_96feb5417aba60c65386efdfa05ffda6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_96feb5417aba60c65386efdfa05ffda6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_96feb5417aba60c65386efdfa05ffda6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_96feb5417aba60c65386efdfa05ffda6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_96feb5417aba60c65386efdfa05ffda6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_96feb5417aba60c65386efdfa05ffda6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_96feb5417aba60c65386efdfa05ffda6,
        type_description_1,
        par_type,
        par_pkey,
        var_write_bio,
        var_result_code,
        var_bio
    );


    // Release cached frame.
    if ( frame_96feb5417aba60c65386efdfa05ffda6 == cache_frame_96feb5417aba60c65386efdfa05ffda6 )
    {
        Py_DECREF( frame_96feb5417aba60c65386efdfa05ffda6 );
    }
    cache_frame_96feb5417aba60c65386efdfa05ffda6 = NULL;

    assertFrameObject( frame_96feb5417aba60c65386efdfa05ffda6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_102_dump_publickey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    Py_XDECREF( var_write_bio );
    var_write_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)var_result_code );
    Py_DECREF( var_result_code );
    var_result_code = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    Py_XDECREF( var_write_bio );
    var_write_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_102_dump_publickey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_103_dump_privatekey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *par_cipher = python_pars[ 2 ];
    PyObject *par_passphrase = python_pars[ 3 ];
    PyObject *var_helper = NULL;
    PyObject *var_bio = NULL;
    PyObject *var_cipher_obj = NULL;
    PyObject *var_rsa = NULL;
    PyObject *var_result_code = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_element_name_22;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    int tmp_cmp_Eq_4;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    bool tmp_isnot_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_make_exception_arg_4;
    PyObject *tmp_make_exception_arg_5;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_raise_type_4;
    PyObject *tmp_raise_type_5;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_2f75eb83f141c45e8429039b2cce5fd5 = NULL;

    struct Nuitka_FrameObject *frame_2f75eb83f141c45e8429039b2cce5fd5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2f75eb83f141c45e8429039b2cce5fd5, codeobj_2f75eb83f141c45e8429039b2cce5fd5, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_2f75eb83f141c45e8429039b2cce5fd5 = cache_frame_2f75eb83f141c45e8429039b2cce5fd5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2f75eb83f141c45e8429039b2cce5fd5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2f75eb83f141c45e8429039b2cce5fd5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 2025;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2025;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2025;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_1;

    tmp_isinstance_inst_1 = par_pkey;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 2027;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2027;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_bb334a0dc943b8e820be149d2c515af0;
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2028;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2028;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_compare_left_1 = par_cipher;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_compare_left_2 = par_passphrase;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = Py_None;
    tmp_is_1 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    if ( tmp_is_1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_2 = const_str_digest_014a797afcc3e1ad4f3e6e9aa4631a8a;
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2032;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 2032;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2036;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EVP_get_cipherbyname );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2036;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
    }

    if ( tmp_called_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
        exception_tb = NULL;

        exception_lineno = 2036;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_cipher;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2036;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2036;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2036;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2036;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_cipher_obj == NULL );
    var_cipher_obj = tmp_assign_source_2;

    tmp_compare_left_3 = var_cipher_obj;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2037;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_compare_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2037;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_3 );

        exception_lineno = 2037;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_3 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_make_exception_arg_3 = const_str_digest_fb60d21f52ae521da77e61851d566364;
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2038;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 2038;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooooo";
    goto frame_exception_exit_1;
    branch_no_4:;
    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2040;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2040;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_cipher_obj == NULL );
    var_cipher_obj = tmp_assign_source_3;

    branch_end_2:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PassphraseHelper );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PassphraseHelper );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_PassphraseHelper" );
        exception_tb = NULL;

        exception_lineno = 2042;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = par_type;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = par_passphrase;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2042;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2042;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_helper == NULL );
    var_helper = tmp_assign_source_4;

    tmp_compare_left_4 = par_type;

    CHECK_OBJECT( tmp_compare_left_4 );
    tmp_compare_right_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_compare_right_4 == NULL ))
    {
        tmp_compare_right_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_compare_right_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 2043;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_4, tmp_compare_right_4 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2043;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2044;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_PEM_write_bio_PrivateKey );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2044;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_source_name_5 = par_pkey;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__pkey );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 2046;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = var_cipher_obj;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2048;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_6 );

        exception_lineno = 2048;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = const_int_0;
    tmp_source_name_7 = var_helper;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_callback );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_6 );
        Py_DECREF( tmp_args_element_name_8 );

        exception_lineno = 2050;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = var_helper;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_callback_args );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_6 );
        Py_DECREF( tmp_args_element_name_8 );
        Py_DECREF( tmp_args_element_name_10 );

        exception_lineno = 2051;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2044;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS7( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    Py_DECREF( tmp_args_element_name_8 );
    Py_DECREF( tmp_args_element_name_10 );
    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2044;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_code == NULL );
    var_result_code = tmp_assign_source_5;

    tmp_called_instance_1 = var_helper;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2053;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_raise_if_problem );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2053;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_5;
    branch_no_5:;
    tmp_compare_left_5 = par_type;

    CHECK_OBJECT( tmp_compare_left_5 );
    tmp_compare_right_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

    if (unlikely( tmp_compare_right_5 == NULL ))
    {
        tmp_compare_right_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
    }

    if ( tmp_compare_right_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
        exception_tb = NULL;

        exception_lineno = 2054;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_5, tmp_compare_right_5 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2054;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2055;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_i2d_PrivateKey_bio );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2055;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_12 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_12 );
    tmp_source_name_10 = par_pkey;

    CHECK_OBJECT( tmp_source_name_10 );
    tmp_args_element_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain__pkey );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 2055;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2055;
    {
        PyObject *call_args[] = { tmp_args_element_name_12, tmp_args_element_name_13 };
        tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_13 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2055;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_code == NULL );
    var_result_code = tmp_assign_source_6;

    goto branch_end_6;
    branch_no_6:;
    tmp_compare_left_6 = par_type;

    CHECK_OBJECT( tmp_compare_left_6 );
    tmp_compare_right_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );

    if (unlikely( tmp_compare_right_6 == NULL ))
    {
        tmp_compare_right_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );
    }

    if ( tmp_compare_right_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_TEXT" );
        exception_tb = NULL;

        exception_lineno = 2056;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_4 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_6, tmp_compare_right_6 );
    if ( tmp_cmp_Eq_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2056;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_4 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2057;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_EVP_PKEY_id );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2057;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_12 = par_pkey;

    CHECK_OBJECT( tmp_source_name_12 );
    tmp_args_element_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain__pkey );
    if ( tmp_args_element_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 2057;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2057;
    {
        PyObject *call_args[] = { tmp_args_element_name_14 };
        tmp_compare_left_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_14 );
    if ( tmp_compare_left_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2057;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_13 == NULL ))
    {
        tmp_source_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_13 == NULL )
    {
        Py_DECREF( tmp_compare_left_7 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2057;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_7 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_EVP_PKEY_RSA );
    if ( tmp_compare_right_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_7 );

        exception_lineno = 2057;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_7, tmp_compare_right_7 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_7 );
        Py_DECREF( tmp_compare_right_7 );

        exception_lineno = 2057;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_7 );
    Py_DECREF( tmp_compare_right_7 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_make_exception_arg_4 = const_str_digest_3a45faa244ca861d389c340b29a28988;
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2058;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_4 };
        tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_4 != NULL );
    exception_type = tmp_raise_type_4;
    exception_lineno = 2058;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooooo";
    goto frame_exception_exit_1;
    branch_no_8:;
    tmp_source_name_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_14 == NULL ))
    {
        tmp_source_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2060;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_gc );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2060;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_15 == NULL ))
    {
        tmp_source_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_15 == NULL )
    {
        Py_DECREF( tmp_called_name_8 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2060;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_EVP_PKEY_get1_RSA );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );

        exception_lineno = 2060;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_16 = par_pkey;

    CHECK_OBJECT( tmp_source_name_16 );
    tmp_args_element_name_16 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain__pkey );
    if ( tmp_args_element_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_called_name_9 );

        exception_lineno = 2060;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2060;
    {
        PyObject *call_args[] = { tmp_args_element_name_16 };
        tmp_args_element_name_15 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_element_name_16 );
    if ( tmp_args_element_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );

        exception_lineno = 2060;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_17 == NULL ))
    {
        tmp_source_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_17 == NULL )
    {
        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_args_element_name_15 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2060;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_RSA_free );
    if ( tmp_args_element_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_args_element_name_15 );

        exception_lineno = 2060;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2060;
    {
        PyObject *call_args[] = { tmp_args_element_name_15, tmp_args_element_name_17 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_called_name_8 );
    Py_DECREF( tmp_args_element_name_15 );
    Py_DECREF( tmp_args_element_name_17 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2060;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_rsa == NULL );
    var_rsa = tmp_assign_source_7;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2061;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_18 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_18 );
    tmp_args_element_name_19 = var_rsa;

    CHECK_OBJECT( tmp_args_element_name_19 );
    tmp_args_element_name_20 = const_int_0;
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2061;
    {
        PyObject *call_args[] = { tmp_args_element_name_18, tmp_args_element_name_19, tmp_args_element_name_20 };
        tmp_assign_source_8 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_2, const_str_plain_RSA_print, call_args );
    }

    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2061;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_code == NULL );
    var_result_code = tmp_assign_source_8;

    goto branch_end_7;
    branch_no_7:;
    tmp_make_exception_arg_5 = const_str_digest_11c225ccbab9acffc38107dee9691702;
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2063;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_5 };
        tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_5 != NULL );
    exception_type = tmp_raise_type_5;
    exception_lineno = 2063;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooooo";
    goto frame_exception_exit_1;
    branch_end_7:;
    branch_end_6:;
    branch_end_5:;
    tmp_called_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_10 == NULL ))
    {
        tmp_called_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2068;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_result_code;

    if ( tmp_compexpr_left_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result_code" );
        exception_tb = NULL;

        exception_lineno = 2068;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_21 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2068;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2068;
    {
        PyObject *call_args[] = { tmp_args_element_name_21 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
    }

    Py_DECREF( tmp_args_element_name_21 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2068;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

    if (unlikely( tmp_called_name_11 == NULL ))
    {
        tmp_called_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
    }

    if ( tmp_called_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
        exception_tb = NULL;

        exception_lineno = 2070;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_22 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_22 );
    frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame.f_lineno = 2070;
    {
        PyObject *call_args[] = { tmp_args_element_name_22 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2070;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f75eb83f141c45e8429039b2cce5fd5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f75eb83f141c45e8429039b2cce5fd5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f75eb83f141c45e8429039b2cce5fd5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2f75eb83f141c45e8429039b2cce5fd5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2f75eb83f141c45e8429039b2cce5fd5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2f75eb83f141c45e8429039b2cce5fd5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f75eb83f141c45e8429039b2cce5fd5,
        type_description_1,
        par_type,
        par_pkey,
        par_cipher,
        par_passphrase,
        var_helper,
        var_bio,
        var_cipher_obj,
        var_rsa,
        var_result_code
    );


    // Release cached frame.
    if ( frame_2f75eb83f141c45e8429039b2cce5fd5 == cache_frame_2f75eb83f141c45e8429039b2cce5fd5 )
    {
        Py_DECREF( frame_2f75eb83f141c45e8429039b2cce5fd5 );
    }
    cache_frame_2f75eb83f141c45e8429039b2cce5fd5 = NULL;

    assertFrameObject( frame_2f75eb83f141c45e8429039b2cce5fd5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_103_dump_privatekey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)var_helper );
    Py_DECREF( var_helper );
    var_helper = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)var_cipher_obj );
    Py_DECREF( var_cipher_obj );
    var_cipher_obj = NULL;

    Py_XDECREF( var_rsa );
    var_rsa = NULL;

    CHECK_OBJECT( (PyObject *)par_cipher );
    Py_DECREF( par_cipher );
    par_cipher = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    Py_XDECREF( var_helper );
    var_helper = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_cipher_obj );
    var_cipher_obj = NULL;

    Py_XDECREF( var_rsa );
    var_rsa = NULL;

    CHECK_OBJECT( (PyObject *)par_cipher );
    Py_DECREF( par_cipher );
    par_cipher = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_103_dump_privatekey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_104___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_revoked = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_781624e00a9735ef39d890417814f755 = NULL;

    struct Nuitka_FrameObject *frame_781624e00a9735ef39d890417814f755;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_781624e00a9735ef39d890417814f755, codeobj_781624e00a9735ef39d890417814f755, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_781624e00a9735ef39d890417814f755 = cache_frame_781624e00a9735ef39d890417814f755;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_781624e00a9735ef39d890417814f755 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_781624e00a9735ef39d890417814f755 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2094;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_781624e00a9735ef39d890417814f755->m_frame.f_lineno = 2094;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_REVOKED_new );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2094;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_revoked == NULL );
    var_revoked = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2095;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2095;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_revoked;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2095;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_REVOKED_free );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2095;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_781624e00a9735ef39d890417814f755->m_frame.f_lineno = 2095;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2095;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__revoked, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 2095;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_781624e00a9735ef39d890417814f755 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_781624e00a9735ef39d890417814f755 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_781624e00a9735ef39d890417814f755, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_781624e00a9735ef39d890417814f755->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_781624e00a9735ef39d890417814f755, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_781624e00a9735ef39d890417814f755,
        type_description_1,
        par_self,
        var_revoked
    );


    // Release cached frame.
    if ( frame_781624e00a9735ef39d890417814f755 == cache_frame_781624e00a9735ef39d890417814f755 )
    {
        Py_DECREF( frame_781624e00a9735ef39d890417814f755 );
    }
    cache_frame_781624e00a9735ef39d890417814f755 = NULL;

    assertFrameObject( frame_781624e00a9735ef39d890417814f755 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_104___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_revoked );
    Py_DECREF( var_revoked );
    var_revoked = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_revoked );
    var_revoked = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_104___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_105_set_serial( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_hex_str = python_pars[ 1 ];
    PyObject *var_bignum_serial = NULL;
    PyObject *var_asn1_serial = NULL;
    PyObject *var_bn_result = NULL;
    PyObject *var_bignum_ptr = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_eaa8abaf1b913554e0e3552e860e2ed1 = NULL;

    struct Nuitka_FrameObject *frame_eaa8abaf1b913554e0e3552e860e2ed1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_eaa8abaf1b913554e0e3552e860e2ed1, codeobj_eaa8abaf1b913554e0e3552e860e2ed1, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_eaa8abaf1b913554e0e3552e860e2ed1 = cache_frame_eaa8abaf1b913554e0e3552e860e2ed1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_eaa8abaf1b913554e0e3552e860e2ed1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_eaa8abaf1b913554e0e3552e860e2ed1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2108;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2108;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2108;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_eaa8abaf1b913554e0e3552e860e2ed1->m_frame.f_lineno = 2108;
    tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_BN_new );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2108;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2108;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_BN_free );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 2108;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_eaa8abaf1b913554e0e3552e860e2ed1->m_frame.f_lineno = 2108;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2108;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bignum_serial == NULL );
    var_bignum_serial = tmp_assign_source_1;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2109;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_eaa8abaf1b913554e0e3552e860e2ed1->m_frame.f_lineno = 2109;
    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple, 0 ) );

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2109;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bignum_ptr == NULL );
    var_bignum_ptr = tmp_assign_source_2;

    tmp_ass_subvalue_1 = var_bignum_serial;

    CHECK_OBJECT( tmp_ass_subvalue_1 );
    tmp_ass_subscribed_1 = var_bignum_ptr;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2110;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2111;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_bignum_ptr;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = par_hex_str;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_eaa8abaf1b913554e0e3552e860e2ed1->m_frame.f_lineno = 2111;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_BN_hex2bn, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2111;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bn_result == NULL );
    var_bn_result = tmp_assign_source_3;

    tmp_cond_value_1 = var_bn_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2112;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_340717166d8c6af86f5d8a6e35ed5a7f;
    frame_eaa8abaf1b913554e0e3552e860e2ed1->m_frame.f_lineno = 2113;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2113;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2115;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_gc );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2115;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2116;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_BN_to_ASN1_INTEGER );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2116;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_bignum_serial;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2116;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 2116;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_eaa8abaf1b913554e0e3552e860e2ed1->m_frame.f_lineno = 2116;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_args_element_name_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2116;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2117;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_ASN1_INTEGER_free );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 2117;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_eaa8abaf1b913554e0e3552e860e2ed1->m_frame.f_lineno = 2115;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_8 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2115;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_asn1_serial == NULL );
    var_asn1_serial = tmp_assign_source_4;

    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2119;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_X509_REVOKED_set_serialNumber );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2119;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = par_self;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__revoked );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 2119;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = var_asn1_serial;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_eaa8abaf1b913554e0e3552e860e2ed1->m_frame.f_lineno = 2119;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2119;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eaa8abaf1b913554e0e3552e860e2ed1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eaa8abaf1b913554e0e3552e860e2ed1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_eaa8abaf1b913554e0e3552e860e2ed1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_eaa8abaf1b913554e0e3552e860e2ed1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_eaa8abaf1b913554e0e3552e860e2ed1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_eaa8abaf1b913554e0e3552e860e2ed1,
        type_description_1,
        par_self,
        par_hex_str,
        var_bignum_serial,
        var_asn1_serial,
        var_bn_result,
        var_bignum_ptr
    );


    // Release cached frame.
    if ( frame_eaa8abaf1b913554e0e3552e860e2ed1 == cache_frame_eaa8abaf1b913554e0e3552e860e2ed1 )
    {
        Py_DECREF( frame_eaa8abaf1b913554e0e3552e860e2ed1 );
    }
    cache_frame_eaa8abaf1b913554e0e3552e860e2ed1 = NULL;

    assertFrameObject( frame_eaa8abaf1b913554e0e3552e860e2ed1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_105_set_serial );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_hex_str );
    Py_DECREF( par_hex_str );
    par_hex_str = NULL;

    CHECK_OBJECT( (PyObject *)var_bignum_serial );
    Py_DECREF( var_bignum_serial );
    var_bignum_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_asn1_serial );
    Py_DECREF( var_asn1_serial );
    var_asn1_serial = NULL;

    CHECK_OBJECT( (PyObject *)var_bn_result );
    Py_DECREF( var_bn_result );
    var_bn_result = NULL;

    CHECK_OBJECT( (PyObject *)var_bignum_ptr );
    Py_DECREF( var_bignum_ptr );
    var_bignum_ptr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_hex_str );
    Py_DECREF( par_hex_str );
    par_hex_str = NULL;

    Py_XDECREF( var_bignum_serial );
    var_bignum_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_asn1_serial );
    var_asn1_serial = NULL;

    Py_XDECREF( var_bn_result );
    var_bn_result = NULL;

    Py_XDECREF( var_bignum_ptr );
    var_bignum_ptr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_105_set_serial );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_106_get_serial( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_bio = NULL;
    PyObject *var_result = NULL;
    PyObject *var_asn1_int = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_0612b9518d882fcbc0d3f58a38c9a868 = NULL;

    struct Nuitka_FrameObject *frame_0612b9518d882fcbc0d3f58a38c9a868;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0612b9518d882fcbc0d3f58a38c9a868, codeobj_0612b9518d882fcbc0d3f58a38c9a868, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0612b9518d882fcbc0d3f58a38c9a868 = cache_frame_0612b9518d882fcbc0d3f58a38c9a868;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0612b9518d882fcbc0d3f58a38c9a868 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0612b9518d882fcbc0d3f58a38c9a868 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 2131;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_0612b9518d882fcbc0d3f58a38c9a868->m_frame.f_lineno = 2131;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2131;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2133;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REVOKED_get0_serialNumber );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2133;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__revoked );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2133;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_0612b9518d882fcbc0d3f58a38c9a868->m_frame.f_lineno = 2133;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2133;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_asn1_int == NULL );
    var_asn1_int = tmp_assign_source_2;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2134;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_asn1_int;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2134;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2134;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2134;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_0612b9518d882fcbc0d3f58a38c9a868->m_frame.f_lineno = 2134;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2134;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2135;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = var_asn1_int;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_0612b9518d882fcbc0d3f58a38c9a868->m_frame.f_lineno = 2135;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_i2a_ASN1_INTEGER, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2135;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_3;

    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2136;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_2 = var_result;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = const_int_0;
    tmp_args_element_name_5 = RICH_COMPARE_GE( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2136;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_0612b9518d882fcbc0d3f58a38c9a868->m_frame.f_lineno = 2136;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2136;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
        exception_tb = NULL;

        exception_lineno = 2137;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_0612b9518d882fcbc0d3f58a38c9a868->m_frame.f_lineno = 2137;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2137;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0612b9518d882fcbc0d3f58a38c9a868 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0612b9518d882fcbc0d3f58a38c9a868 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0612b9518d882fcbc0d3f58a38c9a868 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0612b9518d882fcbc0d3f58a38c9a868, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0612b9518d882fcbc0d3f58a38c9a868->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0612b9518d882fcbc0d3f58a38c9a868, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0612b9518d882fcbc0d3f58a38c9a868,
        type_description_1,
        par_self,
        var_bio,
        var_result,
        var_asn1_int
    );


    // Release cached frame.
    if ( frame_0612b9518d882fcbc0d3f58a38c9a868 == cache_frame_0612b9518d882fcbc0d3f58a38c9a868 )
    {
        Py_DECREF( frame_0612b9518d882fcbc0d3f58a38c9a868 );
    }
    cache_frame_0612b9518d882fcbc0d3f58a38c9a868 = NULL;

    assertFrameObject( frame_0612b9518d882fcbc0d3f58a38c9a868 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_106_get_serial );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)var_asn1_int );
    Py_DECREF( var_asn1_int );
    var_asn1_int = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_asn1_int );
    var_asn1_int = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_106_get_serial );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_107__delete_reason( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_i = NULL;
    PyObject *var_obj = NULL;
    PyObject *var_ext = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_range_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_3786f0d21253e58936f662cecbfc0803 = NULL;

    struct Nuitka_FrameObject *frame_3786f0d21253e58936f662cecbfc0803;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3786f0d21253e58936f662cecbfc0803, codeobj_3786f0d21253e58936f662cecbfc0803, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3786f0d21253e58936f662cecbfc0803 = cache_frame_3786f0d21253e58936f662cecbfc0803;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3786f0d21253e58936f662cecbfc0803 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3786f0d21253e58936f662cecbfc0803 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2140;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REVOKED_get_ext_count );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2140;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__revoked );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2140;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_3786f0d21253e58936f662cecbfc0803->m_frame.f_lineno = 2140;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_range_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2140;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2140;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2140;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooo";
        exception_lineno = 2140;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 2140;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_3;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2141;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_REVOKED_get_ext );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2141;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__revoked );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2141;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_3 = var_i;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_3786f0d21253e58936f662cecbfc0803->m_frame.f_lineno = 2141;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2141;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_ext;
        var_ext = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2142;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_4 = var_ext;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_3786f0d21253e58936f662cecbfc0803->m_frame.f_lineno = 2142;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_EXTENSION_get_object, call_args );
    }

    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2142;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_obj;
        var_obj = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2143;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_5 = var_obj;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_3786f0d21253e58936f662cecbfc0803->m_frame.f_lineno = 2143;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_compare_left_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_OBJ_obj2nid, call_args );
    }

    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2143;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_compare_left_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2143;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_compare_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NID_crl_reason );
    if ( tmp_compare_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 2143;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 2143;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_left_2 );
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2144;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_6 = var_ext;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_3786f0d21253e58936f662cecbfc0803->m_frame.f_lineno = 2144;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_X509_EXTENSION_free, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2144;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2145;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_REVOKED_delete_ext );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2145;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__revoked );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 2145;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_8 = var_i;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_3786f0d21253e58936f662cecbfc0803->m_frame.f_lineno = 2145;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2145;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto loop_end_1;
    branch_no_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2140;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3786f0d21253e58936f662cecbfc0803 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3786f0d21253e58936f662cecbfc0803 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3786f0d21253e58936f662cecbfc0803, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3786f0d21253e58936f662cecbfc0803->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3786f0d21253e58936f662cecbfc0803, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3786f0d21253e58936f662cecbfc0803,
        type_description_1,
        par_self,
        var_i,
        var_obj,
        var_ext
    );


    // Release cached frame.
    if ( frame_3786f0d21253e58936f662cecbfc0803 == cache_frame_3786f0d21253e58936f662cecbfc0803 )
    {
        Py_DECREF( frame_3786f0d21253e58936f662cecbfc0803 );
    }
    cache_frame_3786f0d21253e58936f662cecbfc0803 = NULL;

    assertFrameObject( frame_3786f0d21253e58936f662cecbfc0803 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_107__delete_reason );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_107__delete_reason );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_108_set_reason( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_reason = python_pars[ 1 ];
    PyObject *var_reason_code = NULL;
    PyObject *var_set_result = NULL;
    PyObject *var_r = NULL;
    PyObject *var_add_result = NULL;
    PyObject *var_new_reason_ext = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    int tmp_exc_match_exception_match_1;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_b3244c50c8c54c5da547fc5b29816352 = NULL;

    struct Nuitka_FrameObject *frame_b3244c50c8c54c5da547fc5b29816352;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b3244c50c8c54c5da547fc5b29816352, codeobj_b3244c50c8c54c5da547fc5b29816352, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b3244c50c8c54c5da547fc5b29816352 = cache_frame_b3244c50c8c54c5da547fc5b29816352;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b3244c50c8c54c5da547fc5b29816352 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b3244c50c8c54c5da547fc5b29816352 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_reason;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2165;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__delete_reason );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2165;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_1;
    branch_no_1:;
    tmp_isinstance_inst_1 = par_reason;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2166;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_1 = const_str_digest_9ae52cddf69d053d9518f458a81ffa1b;
    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2167;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2167;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooo";
    goto frame_exception_exit_1;
    goto branch_end_2;
    branch_no_2:;
    tmp_called_instance_3 = par_reason;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2169;
    tmp_called_instance_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_lower );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2169;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2169;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_replace, &PyTuple_GET_ITEM( const_tuple_str_space_str_empty_tuple, 0 ) );

    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2169;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_reason;
        assert( old != NULL );
        par_reason = tmp_assign_source_1;
        Py_DECREF( old );
    }

    // Tried code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__crl_reasons );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2170;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2170;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    assert( tmp_list_contraction_1__$0 == NULL );
    tmp_list_contraction_1__$0 = tmp_assign_source_3;

    tmp_assign_source_4 = PyList_New( 0 );
    assert( tmp_list_contraction_1__contraction_result == NULL );
    tmp_list_contraction_1__contraction_result = tmp_assign_source_4;

    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_list_contraction_1__$0;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_5 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooooo";
        exception_lineno = 2170;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_list_contraction_1__iter_value_0;
        tmp_list_contraction_1__iter_value_0 = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_2 = exception_keeper_type_1;
    tmp_compare_right_2 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 2170;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_3;
    branch_no_3:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_3:;
    // End of try:
    try_end_1:;
    tmp_assign_source_6 = tmp_list_contraction_1__iter_value_0;

    CHECK_OBJECT( tmp_assign_source_6 );
    {
        PyObject *old = var_r;
        var_r = tmp_assign_source_6;
        Py_INCREF( var_r );
        Py_XDECREF( old );
    }

    tmp_append_list_1 = tmp_list_contraction_1__contraction_result;

    CHECK_OBJECT( tmp_append_list_1 );
    tmp_called_instance_5 = var_r;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2170;
    tmp_append_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_lower );
    if ( tmp_append_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2170;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    Py_DECREF( tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2170;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2170;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_outline_return_value_1 = tmp_list_contraction_1__contraction_result;

    CHECK_OBJECT( tmp_outline_return_value_1 );
    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_108_set_reason );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__$0 );
    Py_DECREF( tmp_list_contraction_1__$0 );
    tmp_list_contraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__contraction_result );
    Py_DECREF( tmp_list_contraction_1__contraction_result );
    tmp_list_contraction_1__contraction_result = NULL;

    Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
    tmp_list_contraction_1__iter_value_0 = NULL;

    goto outline_result_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_list_contraction_1__$0 );
    tmp_list_contraction_1__$0 = NULL;

    Py_XDECREF( tmp_list_contraction_1__contraction_result );
    tmp_list_contraction_1__contraction_result = NULL;

    Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
    tmp_list_contraction_1__iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_108_set_reason );
    return NULL;
    outline_result_1:;
    tmp_called_instance_4 = tmp_outline_return_value_1;
    tmp_args_element_name_1 = par_reason;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2170;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_index, call_args );
    }

    Py_DECREF( tmp_called_instance_4 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2170;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_reason_code == NULL );
    var_reason_code = tmp_assign_source_2;

    tmp_called_instance_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_6 == NULL ))
    {
        tmp_called_instance_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2172;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2172;
    tmp_assign_source_7 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_ASN1_ENUMERATED_new );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2172;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_new_reason_ext == NULL );
    var_new_reason_ext = tmp_assign_source_7;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2173;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_new_reason_ext;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2173;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2173;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2173;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2173;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2173;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2174;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_gc );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2174;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_new_reason_ext;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2174;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_ASN1_ENUMERATED_free );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2174;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2174;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2174;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_new_reason_ext;
        assert( old != NULL );
        var_new_reason_ext = tmp_assign_source_8;
        Py_DECREF( old );
    }

    tmp_called_instance_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_7 == NULL ))
    {
        tmp_called_instance_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2176;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = var_new_reason_ext;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = var_reason_code;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2176;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_9 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_7, const_str_plain_ASN1_ENUMERATED_set, call_args );
    }

    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2176;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_set_result == NULL );
    var_set_result = tmp_assign_source_9;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2177;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_2 = var_set_result;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2177;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2177;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = RICH_COMPARE_NE( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2177;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2177;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2177;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_8 = par_self;

    CHECK_OBJECT( tmp_called_instance_8 );
    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2179;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_8, const_str_plain__delete_reason );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2179;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2180;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_REVOKED_add1_ext_i2d );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2180;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__revoked );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 2181;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_8 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2181;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_NID_crl_reason );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_8 );

        exception_lineno = 2181;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = var_new_reason_ext;

    CHECK_OBJECT( tmp_args_element_name_10 );
    tmp_args_element_name_11 = const_int_0;
    tmp_args_element_name_12 = const_int_0;
    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2180;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_assign_source_10 = CALL_FUNCTION_WITH_ARGS5( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_8 );
    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2180;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_add_result == NULL );
    var_add_result = tmp_assign_source_10;

    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2183;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_3 = var_add_result;

    CHECK_OBJECT( tmp_compexpr_left_3 );
    tmp_compexpr_right_3 = const_int_pos_1;
    tmp_args_element_name_13 = RICH_COMPARE_EQ( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2183;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_b3244c50c8c54c5da547fc5b29816352->m_frame.f_lineno = 2183;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_args_element_name_13 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2183;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_2:;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b3244c50c8c54c5da547fc5b29816352 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b3244c50c8c54c5da547fc5b29816352 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b3244c50c8c54c5da547fc5b29816352, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b3244c50c8c54c5da547fc5b29816352->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b3244c50c8c54c5da547fc5b29816352, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b3244c50c8c54c5da547fc5b29816352,
        type_description_1,
        par_self,
        par_reason,
        var_reason_code,
        var_set_result,
        var_r,
        var_add_result,
        var_new_reason_ext
    );


    // Release cached frame.
    if ( frame_b3244c50c8c54c5da547fc5b29816352 == cache_frame_b3244c50c8c54c5da547fc5b29816352 )
    {
        Py_DECREF( frame_b3244c50c8c54c5da547fc5b29816352 );
    }
    cache_frame_b3244c50c8c54c5da547fc5b29816352 = NULL;

    assertFrameObject( frame_b3244c50c8c54c5da547fc5b29816352 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_108_set_reason );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_reason_code );
    var_reason_code = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    Py_XDECREF( par_reason );
    par_reason = NULL;

    Py_XDECREF( var_r );
    var_r = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    Py_XDECREF( var_new_reason_ext );
    var_new_reason_ext = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_reason_code );
    var_reason_code = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    CHECK_OBJECT( (PyObject *)par_reason );
    Py_DECREF( par_reason );
    par_reason = NULL;

    Py_XDECREF( var_r );
    var_r = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    Py_XDECREF( var_new_reason_ext );
    var_new_reason_ext = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_108_set_reason );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_109_get_reason( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_bio = NULL;
    PyObject *var_obj = NULL;
    PyObject *var_print_result = NULL;
    PyObject *var_i = NULL;
    PyObject *var_ext = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_range_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_d092a227600410e01a6b811aac2b1868 = NULL;

    struct Nuitka_FrameObject *frame_d092a227600410e01a6b811aac2b1868;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d092a227600410e01a6b811aac2b1868, codeobj_d092a227600410e01a6b811aac2b1868, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d092a227600410e01a6b811aac2b1868 = cache_frame_d092a227600410e01a6b811aac2b1868;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d092a227600410e01a6b811aac2b1868 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d092a227600410e01a6b811aac2b1868 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2197;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REVOKED_get_ext_count );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2197;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__revoked );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2197;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_d092a227600410e01a6b811aac2b1868->m_frame.f_lineno = 2197;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_range_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2197;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2197;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2197;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooo";
        exception_lineno = 2197;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 2197;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_3;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2198;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_REVOKED_get_ext );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2198;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__revoked );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2198;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_3 = var_i;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_d092a227600410e01a6b811aac2b1868->m_frame.f_lineno = 2198;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2198;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_ext;
        var_ext = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2199;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_4 = var_ext;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_d092a227600410e01a6b811aac2b1868->m_frame.f_lineno = 2199;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_EXTENSION_get_object, call_args );
    }

    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2199;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_obj;
        var_obj = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2200;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_5 = var_obj;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_d092a227600410e01a6b811aac2b1868->m_frame.f_lineno = 2200;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_compare_left_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_OBJ_obj2nid, call_args );
    }

    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2200;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_compare_left_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2200;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_compare_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NID_crl_reason );
    if ( tmp_compare_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 2200;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 2200;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_left_2 );
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 2201;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    frame_d092a227600410e01a6b811aac2b1868->m_frame.f_lineno = 2201;
    tmp_assign_source_6 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2201;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_6;

    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2203;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_6 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = var_ext;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = const_int_0;
    tmp_args_element_name_9 = const_int_0;
    frame_d092a227600410e01a6b811aac2b1868->m_frame.f_lineno = 2203;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS4( tmp_called_instance_3, const_str_plain_X509V3_EXT_print, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2203;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    assert( var_print_result == NULL );
    var_print_result = tmp_assign_source_7;

    tmp_cond_value_1 = var_print_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2204;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2205;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_M_ASN1_OCTET_STRING_print );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2205;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_10 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_10 );
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2206;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_12 = var_ext;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_d092a227600410e01a6b811aac2b1868->m_frame.f_lineno = 2206;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_args_element_name_11 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_X509_EXTENSION_get_data, call_args );
    }

    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 2206;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    frame_d092a227600410e01a6b811aac2b1868->m_frame.f_lineno = 2205;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2205;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_print_result;
        assert( old != NULL );
        var_print_result = tmp_assign_source_8;
        Py_DECREF( old );
    }

    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2208;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_compexpr_left_1 = var_print_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_13 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2208;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    frame_d092a227600410e01a6b811aac2b1868->m_frame.f_lineno = 2208;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_args_element_name_13 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2208;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
        exception_tb = NULL;

        exception_lineno = 2210;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_14 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_14 );
    frame_d092a227600410e01a6b811aac2b1868->m_frame.f_lineno = 2210;
    {
        PyObject *call_args[] = { tmp_args_element_name_14 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2210;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    goto try_return_handler_2;
    branch_no_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2197;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__iter_value );
    Py_DECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d092a227600410e01a6b811aac2b1868 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d092a227600410e01a6b811aac2b1868 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d092a227600410e01a6b811aac2b1868 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d092a227600410e01a6b811aac2b1868, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d092a227600410e01a6b811aac2b1868->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d092a227600410e01a6b811aac2b1868, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d092a227600410e01a6b811aac2b1868,
        type_description_1,
        par_self,
        var_bio,
        var_obj,
        var_print_result,
        var_i,
        var_ext
    );


    // Release cached frame.
    if ( frame_d092a227600410e01a6b811aac2b1868 == cache_frame_d092a227600410e01a6b811aac2b1868 )
    {
        Py_DECREF( frame_d092a227600410e01a6b811aac2b1868 );
    }
    cache_frame_d092a227600410e01a6b811aac2b1868 = NULL;

    assertFrameObject( frame_d092a227600410e01a6b811aac2b1868 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_109_get_reason );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    Py_XDECREF( var_print_result );
    var_print_result = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    Py_XDECREF( var_print_result );
    var_print_result = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_109_get_reason );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_110_all_reasons( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_d51c13718977056415bef87cf9ca74e3 = NULL;

    struct Nuitka_FrameObject *frame_d51c13718977056415bef87cf9ca74e3;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d51c13718977056415bef87cf9ca74e3, codeobj_d51c13718977056415bef87cf9ca74e3, module_OpenSSL$crypto, sizeof(void *) );
    frame_d51c13718977056415bef87cf9ca74e3 = cache_frame_d51c13718977056415bef87cf9ca74e3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d51c13718977056415bef87cf9ca74e3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d51c13718977056415bef87cf9ca74e3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_slice_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__crl_reasons );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2222;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2222;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d51c13718977056415bef87cf9ca74e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d51c13718977056415bef87cf9ca74e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d51c13718977056415bef87cf9ca74e3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d51c13718977056415bef87cf9ca74e3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d51c13718977056415bef87cf9ca74e3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d51c13718977056415bef87cf9ca74e3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d51c13718977056415bef87cf9ca74e3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d51c13718977056415bef87cf9ca74e3 == cache_frame_d51c13718977056415bef87cf9ca74e3 )
    {
        Py_DECREF( frame_d51c13718977056415bef87cf9ca74e3 );
    }
    cache_frame_d51c13718977056415bef87cf9ca74e3 = NULL;

    assertFrameObject( frame_d51c13718977056415bef87cf9ca74e3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_110_all_reasons );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_110_all_reasons );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_111_set_rev_date( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_when = python_pars[ 1 ];
    PyObject *var_dt = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_9bb39077dd2210e297f9b293e3ba3d43 = NULL;

    struct Nuitka_FrameObject *frame_9bb39077dd2210e297f9b293e3ba3d43;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9bb39077dd2210e297f9b293e3ba3d43, codeobj_9bb39077dd2210e297f9b293e3ba3d43, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9bb39077dd2210e297f9b293e3ba3d43 = cache_frame_9bb39077dd2210e297f9b293e3ba3d43;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9bb39077dd2210e297f9b293e3ba3d43 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9bb39077dd2210e297f9b293e3ba3d43 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2232;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REVOKED_get0_revocationDate );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2232;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__revoked );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2232;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_9bb39077dd2210e297f9b293e3ba3d43->m_frame.f_lineno = 2232;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2232;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_dt == NULL );
    var_dt = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__set_asn1_time );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__set_asn1_time );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_set_asn1_time" );
        exception_tb = NULL;

        exception_lineno = 2233;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_dt;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_when;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_9bb39077dd2210e297f9b293e3ba3d43->m_frame.f_lineno = 2233;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2233;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9bb39077dd2210e297f9b293e3ba3d43 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9bb39077dd2210e297f9b293e3ba3d43 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9bb39077dd2210e297f9b293e3ba3d43 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9bb39077dd2210e297f9b293e3ba3d43, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9bb39077dd2210e297f9b293e3ba3d43->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9bb39077dd2210e297f9b293e3ba3d43, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9bb39077dd2210e297f9b293e3ba3d43,
        type_description_1,
        par_self,
        par_when,
        var_dt
    );


    // Release cached frame.
    if ( frame_9bb39077dd2210e297f9b293e3ba3d43 == cache_frame_9bb39077dd2210e297f9b293e3ba3d43 )
    {
        Py_DECREF( frame_9bb39077dd2210e297f9b293e3ba3d43 );
    }
    cache_frame_9bb39077dd2210e297f9b293e3ba3d43 = NULL;

    assertFrameObject( frame_9bb39077dd2210e297f9b293e3ba3d43 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_111_set_rev_date );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    CHECK_OBJECT( (PyObject *)var_dt );
    Py_DECREF( var_dt );
    var_dt = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    Py_XDECREF( var_dt );
    var_dt = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_111_set_rev_date );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_112_get_rev_date( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_dt = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_ed069d1a9991feb4397571ea46f32f1d = NULL;

    struct Nuitka_FrameObject *frame_ed069d1a9991feb4397571ea46f32f1d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ed069d1a9991feb4397571ea46f32f1d, codeobj_ed069d1a9991feb4397571ea46f32f1d, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_ed069d1a9991feb4397571ea46f32f1d = cache_frame_ed069d1a9991feb4397571ea46f32f1d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ed069d1a9991feb4397571ea46f32f1d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ed069d1a9991feb4397571ea46f32f1d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2242;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REVOKED_get0_revocationDate );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2242;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__revoked );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2242;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_ed069d1a9991feb4397571ea46f32f1d->m_frame.f_lineno = 2242;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2242;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_dt == NULL );
    var_dt = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_asn1_time );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__get_asn1_time );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_get_asn1_time" );
        exception_tb = NULL;

        exception_lineno = 2243;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_dt;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_ed069d1a9991feb4397571ea46f32f1d->m_frame.f_lineno = 2243;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2243;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ed069d1a9991feb4397571ea46f32f1d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ed069d1a9991feb4397571ea46f32f1d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ed069d1a9991feb4397571ea46f32f1d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ed069d1a9991feb4397571ea46f32f1d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ed069d1a9991feb4397571ea46f32f1d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ed069d1a9991feb4397571ea46f32f1d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ed069d1a9991feb4397571ea46f32f1d,
        type_description_1,
        par_self,
        var_dt
    );


    // Release cached frame.
    if ( frame_ed069d1a9991feb4397571ea46f32f1d == cache_frame_ed069d1a9991feb4397571ea46f32f1d )
    {
        Py_DECREF( frame_ed069d1a9991feb4397571ea46f32f1d );
    }
    cache_frame_ed069d1a9991feb4397571ea46f32f1d = NULL;

    assertFrameObject( frame_ed069d1a9991feb4397571ea46f32f1d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_112_get_rev_date );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_dt );
    Py_DECREF( var_dt );
    var_dt = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_dt );
    var_dt = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_112_get_rev_date );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_113___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_crl = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_2043efb2389ea54ec41185bb817d4d92 = NULL;

    struct Nuitka_FrameObject *frame_2043efb2389ea54ec41185bb817d4d92;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2043efb2389ea54ec41185bb817d4d92, codeobj_2043efb2389ea54ec41185bb817d4d92, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_2043efb2389ea54ec41185bb817d4d92 = cache_frame_2043efb2389ea54ec41185bb817d4d92;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2043efb2389ea54ec41185bb817d4d92 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2043efb2389ea54ec41185bb817d4d92 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2252;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_2043efb2389ea54ec41185bb817d4d92->m_frame.f_lineno = 2252;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_CRL_new );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2252;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_crl == NULL );
    var_crl = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2253;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2253;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_crl;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2253;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_CRL_free );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2253;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_2043efb2389ea54ec41185bb817d4d92->m_frame.f_lineno = 2253;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2253;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__crl, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 2253;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2043efb2389ea54ec41185bb817d4d92 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2043efb2389ea54ec41185bb817d4d92 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2043efb2389ea54ec41185bb817d4d92, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2043efb2389ea54ec41185bb817d4d92->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2043efb2389ea54ec41185bb817d4d92, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2043efb2389ea54ec41185bb817d4d92,
        type_description_1,
        par_self,
        var_crl
    );


    // Release cached frame.
    if ( frame_2043efb2389ea54ec41185bb817d4d92 == cache_frame_2043efb2389ea54ec41185bb817d4d92 )
    {
        Py_DECREF( frame_2043efb2389ea54ec41185bb817d4d92 );
    }
    cache_frame_2043efb2389ea54ec41185bb817d4d92 = NULL;

    assertFrameObject( frame_2043efb2389ea54ec41185bb817d4d92 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_113___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_crl );
    Py_DECREF( var_crl );
    var_crl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_crl );
    var_crl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_113___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_114_to_cryptography( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var__CertificateRevocationList = NULL;
    PyObject *var_backend = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_753e3dd3d02b58575f16808234de0cc5 = NULL;

    struct Nuitka_FrameObject *frame_753e3dd3d02b58575f16808234de0cc5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_753e3dd3d02b58575f16808234de0cc5, codeobj_753e3dd3d02b58575f16808234de0cc5, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_753e3dd3d02b58575f16808234de0cc5 = cache_frame_753e3dd3d02b58575f16808234de0cc5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_753e3dd3d02b58575f16808234de0cc5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_753e3dd3d02b58575f16808234de0cc5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_2b6a6c0099f1f1dd77d2725acd0722df;
    tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain__CertificateRevocationList_tuple;
    frame_753e3dd3d02b58575f16808234de0cc5->m_frame.f_lineno = 2263;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2263;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain__CertificateRevocationList );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2263;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var__CertificateRevocationList == NULL );
    var__CertificateRevocationList = tmp_assign_source_1;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__get_backend );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_get_backend" );
        exception_tb = NULL;

        exception_lineno = 2267;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_753e3dd3d02b58575f16808234de0cc5->m_frame.f_lineno = 2267;
    tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2267;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_backend == NULL );
    var_backend = tmp_assign_source_2;

    tmp_called_name_2 = var__CertificateRevocationList;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_args_element_name_1 = var_backend;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__crl );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2268;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_753e3dd3d02b58575f16808234de0cc5->m_frame.f_lineno = 2268;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2268;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_753e3dd3d02b58575f16808234de0cc5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_753e3dd3d02b58575f16808234de0cc5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_753e3dd3d02b58575f16808234de0cc5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_753e3dd3d02b58575f16808234de0cc5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_753e3dd3d02b58575f16808234de0cc5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_753e3dd3d02b58575f16808234de0cc5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_753e3dd3d02b58575f16808234de0cc5,
        type_description_1,
        par_self,
        var__CertificateRevocationList,
        var_backend
    );


    // Release cached frame.
    if ( frame_753e3dd3d02b58575f16808234de0cc5 == cache_frame_753e3dd3d02b58575f16808234de0cc5 )
    {
        Py_DECREF( frame_753e3dd3d02b58575f16808234de0cc5 );
    }
    cache_frame_753e3dd3d02b58575f16808234de0cc5 = NULL;

    assertFrameObject( frame_753e3dd3d02b58575f16808234de0cc5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_114_to_cryptography );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var__CertificateRevocationList );
    Py_DECREF( var__CertificateRevocationList );
    var__CertificateRevocationList = NULL;

    CHECK_OBJECT( (PyObject *)var_backend );
    Py_DECREF( var_backend );
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var__CertificateRevocationList );
    var__CertificateRevocationList = NULL;

    Py_XDECREF( var_backend );
    var_backend = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_114_to_cryptography );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_115_from_cryptography( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_crypto_crl = python_pars[ 1 ];
    PyObject *var_crl = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_89c93e5d81ce22610ffc5a6402eaa2b2 = NULL;

    struct Nuitka_FrameObject *frame_89c93e5d81ce22610ffc5a6402eaa2b2;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_89c93e5d81ce22610ffc5a6402eaa2b2, codeobj_89c93e5d81ce22610ffc5a6402eaa2b2, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_89c93e5d81ce22610ffc5a6402eaa2b2 = cache_frame_89c93e5d81ce22610ffc5a6402eaa2b2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_89c93e5d81ce22610ffc5a6402eaa2b2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_89c93e5d81ce22610ffc5a6402eaa2b2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_crypto_crl;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_x509 );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_x509 );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "x509" );
        exception_tb = NULL;

        exception_lineno = 2282;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_CertificateRevocationList );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2282;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2282;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_35f6b1c1261cd55e34a5b00d6cb8d5ea;
    frame_89c93e5d81ce22610ffc5a6402eaa2b2->m_frame.f_lineno = 2283;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2283;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_called_name_1 = par_cls;

    CHECK_OBJECT( tmp_called_name_1 );
    frame_89c93e5d81ce22610ffc5a6402eaa2b2->m_frame.f_lineno = 2285;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2285;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_crl == NULL );
    var_crl = tmp_assign_source_1;

    tmp_source_name_2 = par_crypto_crl;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509_crl );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2286;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_crl;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__crl, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 2286;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_89c93e5d81ce22610ffc5a6402eaa2b2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_89c93e5d81ce22610ffc5a6402eaa2b2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_89c93e5d81ce22610ffc5a6402eaa2b2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_89c93e5d81ce22610ffc5a6402eaa2b2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_89c93e5d81ce22610ffc5a6402eaa2b2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_89c93e5d81ce22610ffc5a6402eaa2b2,
        type_description_1,
        par_cls,
        par_crypto_crl,
        var_crl
    );


    // Release cached frame.
    if ( frame_89c93e5d81ce22610ffc5a6402eaa2b2 == cache_frame_89c93e5d81ce22610ffc5a6402eaa2b2 )
    {
        Py_DECREF( frame_89c93e5d81ce22610ffc5a6402eaa2b2 );
    }
    cache_frame_89c93e5d81ce22610ffc5a6402eaa2b2 = NULL;

    assertFrameObject( frame_89c93e5d81ce22610ffc5a6402eaa2b2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_crl;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_115_from_cryptography );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_crypto_crl );
    Py_DECREF( par_crypto_crl );
    par_crypto_crl = NULL;

    CHECK_OBJECT( (PyObject *)var_crl );
    Py_DECREF( var_crl );
    var_crl = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_crypto_crl );
    Py_DECREF( par_crypto_crl );
    par_crypto_crl = NULL;

    Py_XDECREF( var_crl );
    var_crl = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_115_from_cryptography );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_116_get_revoked( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_revoked = NULL;
    PyObject *var_i = NULL;
    PyObject *var_pyrev = NULL;
    PyObject *var_results = NULL;
    PyObject *var_revoked_stack = NULL;
    PyObject *var_revoked_copy = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_range_arg_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_tuple_arg_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_7abef46ac5fd5222e8eee23d9d0de8fa = NULL;

    struct Nuitka_FrameObject *frame_7abef46ac5fd5222e8eee23d9d0de8fa;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PyList_New( 0 );
    assert( var_results == NULL );
    var_results = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7abef46ac5fd5222e8eee23d9d0de8fa, codeobj_7abef46ac5fd5222e8eee23d9d0de8fa, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7abef46ac5fd5222e8eee23d9d0de8fa = cache_frame_7abef46ac5fd5222e8eee23d9d0de8fa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7abef46ac5fd5222e8eee23d9d0de8fa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7abef46ac5fd5222e8eee23d9d0de8fa ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2300;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_CRL_get_REVOKED );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2300;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__crl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2300;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_7abef46ac5fd5222e8eee23d9d0de8fa->m_frame.f_lineno = 2300;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2300;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_revoked_stack == NULL );
    var_revoked_stack = tmp_assign_source_2;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2301;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_revoked_stack;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_7abef46ac5fd5222e8eee23d9d0de8fa->m_frame.f_lineno = 2301;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_sk_X509_REVOKED_num, call_args );
    }

    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2301;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2301;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2301;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_3;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_4 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooooo";
        exception_lineno = 2301;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 2301;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_5 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_5 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_5;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2302;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_3 = var_revoked_stack;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = var_i;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_7abef46ac5fd5222e8eee23d9d0de8fa->m_frame.f_lineno = 2302;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_sk_X509_REVOKED_value, call_args );
    }

    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2302;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_revoked;
        var_revoked = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2303;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_5 = var_revoked;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_7abef46ac5fd5222e8eee23d9d0de8fa->m_frame.f_lineno = 2303;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_Cryptography_X509_REVOKED_dup, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2303;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_revoked_copy;
        var_revoked_copy = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Revoked );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Revoked );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Revoked" );
        exception_tb = NULL;

        exception_lineno = 2304;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___new__ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2304;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Revoked );

    if (unlikely( tmp_args_element_name_6 == NULL ))
    {
        tmp_args_element_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Revoked );
    }

    if ( tmp_args_element_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Revoked" );
        exception_tb = NULL;

        exception_lineno = 2304;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    frame_7abef46ac5fd5222e8eee23d9d0de8fa->m_frame.f_lineno = 2304;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2304;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_pyrev;
        var_pyrev = tmp_assign_source_8;
        Py_XDECREF( old );
    }

    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2305;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_gc );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2305;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_7 = var_revoked_copy;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2305;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_REVOKED_free );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 2305;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    frame_7abef46ac5fd5222e8eee23d9d0de8fa->m_frame.f_lineno = 2305;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2305;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_assattr_target_1 = var_pyrev;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__revoked, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 2305;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_called_instance_4 = var_results;

    CHECK_OBJECT( tmp_called_instance_4 );
    tmp_args_element_name_9 = var_pyrev;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_7abef46ac5fd5222e8eee23d9d0de8fa->m_frame.f_lineno = 2306;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2306;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2301;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_cond_value_1 = var_results;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2307;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_tuple_arg_1 = var_results;

    CHECK_OBJECT( tmp_tuple_arg_1 );
    tmp_return_value = PySequence_Tuple( tmp_tuple_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2308;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7abef46ac5fd5222e8eee23d9d0de8fa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7abef46ac5fd5222e8eee23d9d0de8fa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7abef46ac5fd5222e8eee23d9d0de8fa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7abef46ac5fd5222e8eee23d9d0de8fa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7abef46ac5fd5222e8eee23d9d0de8fa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7abef46ac5fd5222e8eee23d9d0de8fa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7abef46ac5fd5222e8eee23d9d0de8fa,
        type_description_1,
        par_self,
        var_revoked,
        var_i,
        var_pyrev,
        var_results,
        var_revoked_stack,
        var_revoked_copy
    );


    // Release cached frame.
    if ( frame_7abef46ac5fd5222e8eee23d9d0de8fa == cache_frame_7abef46ac5fd5222e8eee23d9d0de8fa )
    {
        Py_DECREF( frame_7abef46ac5fd5222e8eee23d9d0de8fa );
    }
    cache_frame_7abef46ac5fd5222e8eee23d9d0de8fa = NULL;

    assertFrameObject( frame_7abef46ac5fd5222e8eee23d9d0de8fa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_116_get_revoked );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_revoked );
    var_revoked = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_pyrev );
    var_pyrev = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_results );
    Py_DECREF( var_results );
    var_results = NULL;

    CHECK_OBJECT( (PyObject *)var_revoked_stack );
    Py_DECREF( var_revoked_stack );
    var_revoked_stack = NULL;

    Py_XDECREF( var_revoked_copy );
    var_revoked_copy = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_revoked );
    var_revoked = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_pyrev );
    var_pyrev = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_results );
    Py_DECREF( var_results );
    var_results = NULL;

    Py_XDECREF( var_revoked_stack );
    var_revoked_stack = NULL;

    Py_XDECREF( var_revoked_copy );
    var_revoked_copy = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_116_get_revoked );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_117_add_revoked( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_revoked = python_pars[ 1 ];
    PyObject *var_copy = NULL;
    PyObject *var_add_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_22c8795b049654d8bc8a72f08c1a0691 = NULL;

    struct Nuitka_FrameObject *frame_22c8795b049654d8bc8a72f08c1a0691;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_22c8795b049654d8bc8a72f08c1a0691, codeobj_22c8795b049654d8bc8a72f08c1a0691, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_22c8795b049654d8bc8a72f08c1a0691 = cache_frame_22c8795b049654d8bc8a72f08c1a0691;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_22c8795b049654d8bc8a72f08c1a0691 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_22c8795b049654d8bc8a72f08c1a0691 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2321;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Cryptography_X509_REVOKED_dup );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2321;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_revoked;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__revoked );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2321;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_22c8795b049654d8bc8a72f08c1a0691->m_frame.f_lineno = 2321;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2321;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_copy == NULL );
    var_copy = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2322;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_copy;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2322;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2322;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2322;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_22c8795b049654d8bc8a72f08c1a0691->m_frame.f_lineno = 2322;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2322;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2324;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_CRL_add0_revoked );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2324;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__crl );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 2324;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = var_copy;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_22c8795b049654d8bc8a72f08c1a0691->m_frame.f_lineno = 2324;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2324;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_add_result == NULL );
    var_add_result = tmp_assign_source_2;

    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2325;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_2 = var_add_result;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = const_int_0;
    tmp_args_element_name_5 = RICH_COMPARE_NE( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2325;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_22c8795b049654d8bc8a72f08c1a0691->m_frame.f_lineno = 2325;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2325;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_22c8795b049654d8bc8a72f08c1a0691 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_22c8795b049654d8bc8a72f08c1a0691 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_22c8795b049654d8bc8a72f08c1a0691, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_22c8795b049654d8bc8a72f08c1a0691->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_22c8795b049654d8bc8a72f08c1a0691, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_22c8795b049654d8bc8a72f08c1a0691,
        type_description_1,
        par_self,
        par_revoked,
        var_copy,
        var_add_result
    );


    // Release cached frame.
    if ( frame_22c8795b049654d8bc8a72f08c1a0691 == cache_frame_22c8795b049654d8bc8a72f08c1a0691 )
    {
        Py_DECREF( frame_22c8795b049654d8bc8a72f08c1a0691 );
    }
    cache_frame_22c8795b049654d8bc8a72f08c1a0691 = NULL;

    assertFrameObject( frame_22c8795b049654d8bc8a72f08c1a0691 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_117_add_revoked );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_copy );
    Py_DECREF( var_copy );
    var_copy = NULL;

    CHECK_OBJECT( (PyObject *)par_revoked );
    Py_DECREF( par_revoked );
    par_revoked = NULL;

    CHECK_OBJECT( (PyObject *)var_add_result );
    Py_DECREF( var_add_result );
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_copy );
    var_copy = NULL;

    CHECK_OBJECT( (PyObject *)par_revoked );
    Py_DECREF( par_revoked );
    par_revoked = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_117_add_revoked );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_118_get_issuer( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var__issuer = NULL;
    PyObject *var_issuer = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_ebf7313f23a0eb07511542b17ec730a1 = NULL;

    struct Nuitka_FrameObject *frame_ebf7313f23a0eb07511542b17ec730a1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ebf7313f23a0eb07511542b17ec730a1, codeobj_ebf7313f23a0eb07511542b17ec730a1, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ebf7313f23a0eb07511542b17ec730a1 = cache_frame_ebf7313f23a0eb07511542b17ec730a1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ebf7313f23a0eb07511542b17ec730a1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ebf7313f23a0eb07511542b17ec730a1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2335;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_NAME_dup );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2335;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2335;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_CRL_get_issuer );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2335;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__crl );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2335;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_ebf7313f23a0eb07511542b17ec730a1->m_frame.f_lineno = 2335;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2335;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_ebf7313f23a0eb07511542b17ec730a1->m_frame.f_lineno = 2335;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2335;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var__issuer == NULL );
    var__issuer = tmp_assign_source_1;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2336;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var__issuer;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2336;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2336;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2336;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_ebf7313f23a0eb07511542b17ec730a1->m_frame.f_lineno = 2336;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2336;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2337;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_gc );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2337;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = var__issuer;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2337;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_NAME_free );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 2337;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_ebf7313f23a0eb07511542b17ec730a1->m_frame.f_lineno = 2337;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2337;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var__issuer;
        assert( old != NULL );
        var__issuer = tmp_assign_source_2;
        Py_DECREF( old );
    }

    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
        exception_tb = NULL;

        exception_lineno = 2338;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain___new__ );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2338;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

    if (unlikely( tmp_args_element_name_6 == NULL ))
    {
        tmp_args_element_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
    }

    if ( tmp_args_element_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
        exception_tb = NULL;

        exception_lineno = 2338;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_ebf7313f23a0eb07511542b17ec730a1->m_frame.f_lineno = 2338;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2338;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_issuer == NULL );
    var_issuer = tmp_assign_source_3;

    tmp_assattr_name_1 = var__issuer;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = var_issuer;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2339;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ebf7313f23a0eb07511542b17ec730a1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ebf7313f23a0eb07511542b17ec730a1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ebf7313f23a0eb07511542b17ec730a1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ebf7313f23a0eb07511542b17ec730a1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ebf7313f23a0eb07511542b17ec730a1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ebf7313f23a0eb07511542b17ec730a1,
        type_description_1,
        par_self,
        var__issuer,
        var_issuer
    );


    // Release cached frame.
    if ( frame_ebf7313f23a0eb07511542b17ec730a1 == cache_frame_ebf7313f23a0eb07511542b17ec730a1 )
    {
        Py_DECREF( frame_ebf7313f23a0eb07511542b17ec730a1 );
    }
    cache_frame_ebf7313f23a0eb07511542b17ec730a1 = NULL;

    assertFrameObject( frame_ebf7313f23a0eb07511542b17ec730a1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_issuer;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_118_get_issuer );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var__issuer );
    Py_DECREF( var__issuer );
    var__issuer = NULL;

    CHECK_OBJECT( (PyObject *)var_issuer );
    Py_DECREF( var_issuer );
    var_issuer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var__issuer );
    var__issuer = NULL;

    Py_XDECREF( var_issuer );
    var_issuer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_118_get_issuer );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_119_set_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_version = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_1611b903c9b5e6e33168f01f5ca2e18f = NULL;

    struct Nuitka_FrameObject *frame_1611b903c9b5e6e33168f01f5ca2e18f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1611b903c9b5e6e33168f01f5ca2e18f, codeobj_1611b903c9b5e6e33168f01f5ca2e18f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_1611b903c9b5e6e33168f01f5ca2e18f = cache_frame_1611b903c9b5e6e33168f01f5ca2e18f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1611b903c9b5e6e33168f01f5ca2e18f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1611b903c9b5e6e33168f01f5ca2e18f ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2351;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2351;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_CRL_set_version );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2351;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__crl );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2351;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_version;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_1611b903c9b5e6e33168f01f5ca2e18f->m_frame.f_lineno = 2351;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2351;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_1 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2351;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_1611b903c9b5e6e33168f01f5ca2e18f->m_frame.f_lineno = 2351;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2351;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1611b903c9b5e6e33168f01f5ca2e18f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1611b903c9b5e6e33168f01f5ca2e18f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1611b903c9b5e6e33168f01f5ca2e18f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1611b903c9b5e6e33168f01f5ca2e18f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1611b903c9b5e6e33168f01f5ca2e18f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1611b903c9b5e6e33168f01f5ca2e18f,
        type_description_1,
        par_self,
        par_version
    );


    // Release cached frame.
    if ( frame_1611b903c9b5e6e33168f01f5ca2e18f == cache_frame_1611b903c9b5e6e33168f01f5ca2e18f )
    {
        Py_DECREF( frame_1611b903c9b5e6e33168f01f5ca2e18f );
    }
    cache_frame_1611b903c9b5e6e33168f01f5ca2e18f = NULL;

    assertFrameObject( frame_1611b903c9b5e6e33168f01f5ca2e18f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_119_set_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_version );
    Py_DECREF( par_version );
    par_version = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_version );
    Py_DECREF( par_version );
    par_version = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_119_set_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_120__set_boundary_time( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_which = python_pars[ 1 ];
    PyObject *par_when = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_06807d7bae8f316ff9a9e8ff657f7c28 = NULL;

    struct Nuitka_FrameObject *frame_06807d7bae8f316ff9a9e8ff657f7c28;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_06807d7bae8f316ff9a9e8ff657f7c28, codeobj_06807d7bae8f316ff9a9e8ff657f7c28, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_06807d7bae8f316ff9a9e8ff657f7c28 = cache_frame_06807d7bae8f316ff9a9e8ff657f7c28;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_06807d7bae8f316ff9a9e8ff657f7c28 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_06807d7bae8f316ff9a9e8ff657f7c28 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__set_asn1_time );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__set_asn1_time );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_set_asn1_time" );
        exception_tb = NULL;

        exception_lineno = 2354;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = par_which;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__crl );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2354;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_06807d7bae8f316ff9a9e8ff657f7c28->m_frame.f_lineno = 2354;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2354;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_when;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_06807d7bae8f316ff9a9e8ff657f7c28->m_frame.f_lineno = 2354;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2354;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_06807d7bae8f316ff9a9e8ff657f7c28 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_06807d7bae8f316ff9a9e8ff657f7c28 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_06807d7bae8f316ff9a9e8ff657f7c28 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_06807d7bae8f316ff9a9e8ff657f7c28, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_06807d7bae8f316ff9a9e8ff657f7c28->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_06807d7bae8f316ff9a9e8ff657f7c28, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_06807d7bae8f316ff9a9e8ff657f7c28,
        type_description_1,
        par_self,
        par_which,
        par_when
    );


    // Release cached frame.
    if ( frame_06807d7bae8f316ff9a9e8ff657f7c28 == cache_frame_06807d7bae8f316ff9a9e8ff657f7c28 )
    {
        Py_DECREF( frame_06807d7bae8f316ff9a9e8ff657f7c28 );
    }
    cache_frame_06807d7bae8f316ff9a9e8ff657f7c28 = NULL;

    assertFrameObject( frame_06807d7bae8f316ff9a9e8ff657f7c28 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_120__set_boundary_time );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_120__set_boundary_time );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_121_set_lastUpdate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_when = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_b39bc7f4b92f008bf056168e2d35a0b3 = NULL;

    struct Nuitka_FrameObject *frame_b39bc7f4b92f008bf056168e2d35a0b3;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b39bc7f4b92f008bf056168e2d35a0b3, codeobj_b39bc7f4b92f008bf056168e2d35a0b3, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_b39bc7f4b92f008bf056168e2d35a0b3 = cache_frame_b39bc7f4b92f008bf056168e2d35a0b3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b39bc7f4b92f008bf056168e2d35a0b3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b39bc7f4b92f008bf056168e2d35a0b3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__set_boundary_time );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2369;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2369;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_CRL_get_lastUpdate );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2369;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_when;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_b39bc7f4b92f008bf056168e2d35a0b3->m_frame.f_lineno = 2369;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2369;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b39bc7f4b92f008bf056168e2d35a0b3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b39bc7f4b92f008bf056168e2d35a0b3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b39bc7f4b92f008bf056168e2d35a0b3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b39bc7f4b92f008bf056168e2d35a0b3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b39bc7f4b92f008bf056168e2d35a0b3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b39bc7f4b92f008bf056168e2d35a0b3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b39bc7f4b92f008bf056168e2d35a0b3,
        type_description_1,
        par_self,
        par_when
    );


    // Release cached frame.
    if ( frame_b39bc7f4b92f008bf056168e2d35a0b3 == cache_frame_b39bc7f4b92f008bf056168e2d35a0b3 )
    {
        Py_DECREF( frame_b39bc7f4b92f008bf056168e2d35a0b3 );
    }
    cache_frame_b39bc7f4b92f008bf056168e2d35a0b3 = NULL;

    assertFrameObject( frame_b39bc7f4b92f008bf056168e2d35a0b3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_121_set_lastUpdate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_121_set_lastUpdate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_122_set_nextUpdate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_when = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_83c24878a9b5a5e8cf8af59795ee05c6 = NULL;

    struct Nuitka_FrameObject *frame_83c24878a9b5a5e8cf8af59795ee05c6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_83c24878a9b5a5e8cf8af59795ee05c6, codeobj_83c24878a9b5a5e8cf8af59795ee05c6, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_83c24878a9b5a5e8cf8af59795ee05c6 = cache_frame_83c24878a9b5a5e8cf8af59795ee05c6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_83c24878a9b5a5e8cf8af59795ee05c6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_83c24878a9b5a5e8cf8af59795ee05c6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__set_boundary_time );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2384;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2384;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_CRL_get_nextUpdate );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2384;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_when;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_83c24878a9b5a5e8cf8af59795ee05c6->m_frame.f_lineno = 2384;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2384;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_83c24878a9b5a5e8cf8af59795ee05c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_83c24878a9b5a5e8cf8af59795ee05c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_83c24878a9b5a5e8cf8af59795ee05c6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_83c24878a9b5a5e8cf8af59795ee05c6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_83c24878a9b5a5e8cf8af59795ee05c6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_83c24878a9b5a5e8cf8af59795ee05c6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_83c24878a9b5a5e8cf8af59795ee05c6,
        type_description_1,
        par_self,
        par_when
    );


    // Release cached frame.
    if ( frame_83c24878a9b5a5e8cf8af59795ee05c6 == cache_frame_83c24878a9b5a5e8cf8af59795ee05c6 )
    {
        Py_DECREF( frame_83c24878a9b5a5e8cf8af59795ee05c6 );
    }
    cache_frame_83c24878a9b5a5e8cf8af59795ee05c6 = NULL;

    assertFrameObject( frame_83c24878a9b5a5e8cf8af59795ee05c6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_122_set_nextUpdate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_122_set_nextUpdate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_123_sign( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_issuer_cert = python_pars[ 1 ];
    PyObject *par_issuer_key = python_pars[ 2 ];
    PyObject *par_digest = python_pars[ 3 ];
    PyObject *var_digest_obj = NULL;
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_99e4ea9ef8921a672a5c09e7667ef6af = NULL;

    struct Nuitka_FrameObject *frame_99e4ea9ef8921a672a5c09e7667ef6af;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_99e4ea9ef8921a672a5c09e7667ef6af, codeobj_99e4ea9ef8921a672a5c09e7667ef6af, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_99e4ea9ef8921a672a5c09e7667ef6af = cache_frame_99e4ea9ef8921a672a5c09e7667ef6af;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_99e4ea9ef8921a672a5c09e7667ef6af );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_99e4ea9ef8921a672a5c09e7667ef6af ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2403;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_digest;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_99e4ea9ef8921a672a5c09e7667ef6af->m_frame.f_lineno = 2403;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_EVP_get_digestbyname, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2403;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_digest_obj == NULL );
    var_digest_obj = tmp_assign_source_1;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2404;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_digest_obj;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2404;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2404;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2404;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_99e4ea9ef8921a672a5c09e7667ef6af->m_frame.f_lineno = 2404;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2404;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2405;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_CRL_set_issuer_name );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2405;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__crl );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2406;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2406;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_get_subject_name );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 2406;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_issuer_cert;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__x509 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 2406;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_99e4ea9ef8921a672a5c09e7667ef6af->m_frame.f_lineno = 2406;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_args_element_name_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 2406;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_99e4ea9ef8921a672a5c09e7667ef6af->m_frame.f_lineno = 2405;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2405;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2408;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_CRL_sort );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2408;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__crl );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 2408;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_99e4ea9ef8921a672a5c09e7667ef6af->m_frame.f_lineno = 2408;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2408;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2409;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_X509_CRL_sign );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2409;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_9 = par_self;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__crl );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 2409;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_10 = par_issuer_key;

    CHECK_OBJECT( tmp_source_name_10 );
    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain__pkey );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_7 );

        exception_lineno = 2409;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_digest_obj;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_99e4ea9ef8921a672a5c09e7667ef6af->m_frame.f_lineno = 2409;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_7 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2409;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_2;

    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2410;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_2 = var_result;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = const_int_0;
    tmp_args_element_name_10 = RICH_COMPARE_NE( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2410;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_99e4ea9ef8921a672a5c09e7667ef6af->m_frame.f_lineno = 2410;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2410;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_99e4ea9ef8921a672a5c09e7667ef6af );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_99e4ea9ef8921a672a5c09e7667ef6af );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_99e4ea9ef8921a672a5c09e7667ef6af, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_99e4ea9ef8921a672a5c09e7667ef6af->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_99e4ea9ef8921a672a5c09e7667ef6af, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_99e4ea9ef8921a672a5c09e7667ef6af,
        type_description_1,
        par_self,
        par_issuer_cert,
        par_issuer_key,
        par_digest,
        var_digest_obj,
        var_result
    );


    // Release cached frame.
    if ( frame_99e4ea9ef8921a672a5c09e7667ef6af == cache_frame_99e4ea9ef8921a672a5c09e7667ef6af )
    {
        Py_DECREF( frame_99e4ea9ef8921a672a5c09e7667ef6af );
    }
    cache_frame_99e4ea9ef8921a672a5c09e7667ef6af = NULL;

    assertFrameObject( frame_99e4ea9ef8921a672a5c09e7667ef6af );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_123_sign );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer_cert );
    Py_DECREF( par_issuer_cert );
    par_issuer_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer_key );
    Py_DECREF( par_issuer_key );
    par_issuer_key = NULL;

    CHECK_OBJECT( (PyObject *)var_digest_obj );
    Py_DECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer_cert );
    Py_DECREF( par_issuer_cert );
    par_issuer_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer_key );
    Py_DECREF( par_issuer_key );
    par_issuer_key = NULL;

    Py_XDECREF( var_digest_obj );
    var_digest_obj = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_123_sign );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_124_export( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cert = python_pars[ 1 ];
    PyObject *par_key = python_pars[ 2 ];
    PyObject *par_type = python_pars[ 3 ];
    PyObject *par_days = python_pars[ 4 ];
    PyObject *par_digest = python_pars[ 5 ];
    PyObject *var_bio = NULL;
    PyObject *var_sometime = NULL;
    PyObject *var_digest_obj = NULL;
    PyObject *var_sign_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_cls_3;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_isinstance_inst_3;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_make_exception_arg_4;
    PyObject *tmp_make_exception_arg_5;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_raise_type_4;
    PyObject *tmp_raise_type_5;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_e2d69c1085f8607b608690a912064382 = NULL;

    struct Nuitka_FrameObject *frame_e2d69c1085f8607b608690a912064382;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e2d69c1085f8607b608690a912064382, codeobj_e2d69c1085f8607b608690a912064382, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e2d69c1085f8607b608690a912064382 = cache_frame_e2d69c1085f8607b608690a912064382;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e2d69c1085f8607b608690a912064382 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e2d69c1085f8607b608690a912064382 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_cert;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 2428;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2428;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_c804b213c384a15865e18bf31cfff70e;
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2429;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2429;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_isinstance_inst_2 = par_key;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_isinstance_cls_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_isinstance_cls_2 == NULL ))
    {
        tmp_isinstance_cls_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_isinstance_cls_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 2430;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2430;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_0226e12d6e09b849c37787a1a7ec35a4;
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2431;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 2431;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_isinstance_inst_3 = par_type;

    CHECK_OBJECT( tmp_isinstance_inst_3 );
    tmp_isinstance_cls_3 = (PyObject *)&PyInt_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2432;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_3 = const_str_digest_50f07d7dbc7dc060eb5685744b92c007;
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2433;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 2433;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    tmp_compare_left_1 = par_digest;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_UNSPECIFIED" );
        exception_tb = NULL;

        exception_lineno = 2435;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_make_exception_arg_4 = const_str_digest_e19f4eaf61167e65441aca909fe75b36;
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2436;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_4 };
        tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_4 != NULL );
    exception_type = tmp_raise_type_4;
    exception_lineno = 2436;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooooo";
    goto frame_exception_exit_1;
    branch_no_4:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2438;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_digest;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2438;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_EVP_get_digestbyname, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2438;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_digest_obj == NULL );
    var_digest_obj = tmp_assign_source_1;

    tmp_compare_left_2 = var_digest_obj;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2439;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
    if ( tmp_compare_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2439;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 2439;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_make_exception_arg_5 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2440;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_5 };
        tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_5 != NULL );
    exception_type = tmp_raise_type_5;
    exception_lineno = 2440;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooooo";
    goto frame_exception_exit_1;
    branch_no_5:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2442;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_BIO_new );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2442;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2442;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2442;
    tmp_args_element_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_BIO_s_mem );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2442;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2442;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2442;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_2;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2443;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_bio;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2443;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2443;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2443;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2443;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2443;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2447;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2447;
    tmp_assign_source_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_ASN1_TIME_new );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2447;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_sometime == NULL );
    var_sometime = tmp_assign_source_3;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2448;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_2 = var_sometime;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2448;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2448;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = RICH_COMPARE_NE( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2448;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2448;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2448;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2450;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = var_sometime;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = const_int_0;
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2450;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_4, const_str_plain_X509_gmtime_adj, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2450;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2451;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_CRL_set_lastUpdate );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2451;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__crl );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 2451;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = var_sometime;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2451;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2451;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2453;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_X509_gmtime_adj );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2453;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_sometime;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_left_name_3 = par_days;

    CHECK_OBJECT( tmp_left_name_3 );
    tmp_right_name_1 = const_int_pos_24;
    tmp_left_name_2 = BINARY_OPERATION_MUL( tmp_left_name_3, tmp_right_name_1 );
    if ( tmp_left_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 2453;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_2 = const_int_pos_60;
    tmp_left_name_1 = BINARY_OPERATION_MUL( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_left_name_2 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 2453;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_3 = const_int_pos_60;
    tmp_args_element_name_10 = BINARY_OPERATION_MUL( tmp_left_name_1, tmp_right_name_3 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 2453;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2453;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2453;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2454;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_X509_CRL_set_nextUpdate );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2454;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_9 = par_self;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__crl );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 2454;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_12 = var_sometime;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2454;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2454;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2456;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_X509_CRL_set_issuer_name );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2456;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_11 = par_self;

    CHECK_OBJECT( tmp_source_name_11 );
    tmp_args_element_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__crl );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 2457;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_12 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_13 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2457;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_X509_get_subject_name );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_13 );

        exception_lineno = 2457;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_13 = par_cert;

    CHECK_OBJECT( tmp_source_name_13 );
    tmp_args_element_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain__x509 );
    if ( tmp_args_element_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_13 );
        Py_DECREF( tmp_called_name_8 );

        exception_lineno = 2457;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2457;
    {
        PyObject *call_args[] = { tmp_args_element_name_15 };
        tmp_args_element_name_14 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_called_name_8 );
    Py_DECREF( tmp_args_element_name_15 );
    if ( tmp_args_element_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_13 );

        exception_lineno = 2457;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2456;
    {
        PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_13 );
    Py_DECREF( tmp_args_element_name_14 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2456;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_14 == NULL ))
    {
        tmp_source_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2460;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_X509_CRL_sign );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2460;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_15 = par_self;

    CHECK_OBJECT( tmp_source_name_15 );
    tmp_args_element_name_16 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain__crl );
    if ( tmp_args_element_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );

        exception_lineno = 2460;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_16 = par_key;

    CHECK_OBJECT( tmp_source_name_16 );
    tmp_args_element_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain__pkey );
    if ( tmp_args_element_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_16 );

        exception_lineno = 2460;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_18 = var_digest_obj;

    CHECK_OBJECT( tmp_args_element_name_18 );
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2460;
    {
        PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_element_name_16 );
    Py_DECREF( tmp_args_element_name_17 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2460;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_sign_result == NULL );
    var_sign_result = tmp_assign_source_4;

    tmp_cond_value_1 = var_sign_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2461;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_6;
    }
    else
    {
        goto branch_yes_6;
    }
    branch_yes_6:;
    tmp_called_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_10 == NULL ))
    {
        tmp_called_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 2462;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2462;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_10 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2462;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_6:;
    tmp_called_name_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_crl );

    if (unlikely( tmp_called_name_11 == NULL ))
    {
        tmp_called_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_dump_crl );
    }

    if ( tmp_called_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "dump_crl" );
        exception_tb = NULL;

        exception_lineno = 2464;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_19 = par_type;

    CHECK_OBJECT( tmp_args_element_name_19 );
    tmp_args_element_name_20 = par_self;

    CHECK_OBJECT( tmp_args_element_name_20 );
    frame_e2d69c1085f8607b608690a912064382->m_frame.f_lineno = 2464;
    {
        PyObject *call_args[] = { tmp_args_element_name_19, tmp_args_element_name_20 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_11, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2464;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2d69c1085f8607b608690a912064382 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2d69c1085f8607b608690a912064382 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2d69c1085f8607b608690a912064382 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e2d69c1085f8607b608690a912064382, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e2d69c1085f8607b608690a912064382->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e2d69c1085f8607b608690a912064382, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e2d69c1085f8607b608690a912064382,
        type_description_1,
        par_self,
        par_cert,
        par_key,
        par_type,
        par_days,
        par_digest,
        var_bio,
        var_sometime,
        var_digest_obj,
        var_sign_result
    );


    // Release cached frame.
    if ( frame_e2d69c1085f8607b608690a912064382 == cache_frame_e2d69c1085f8607b608690a912064382 )
    {
        Py_DECREF( frame_e2d69c1085f8607b608690a912064382 );
    }
    cache_frame_e2d69c1085f8607b608690a912064382 = NULL;

    assertFrameObject( frame_e2d69c1085f8607b608690a912064382 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_124_export );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_days );
    Py_DECREF( par_days );
    par_days = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    CHECK_OBJECT( (PyObject *)var_sometime );
    Py_DECREF( var_sometime );
    var_sometime = NULL;

    CHECK_OBJECT( (PyObject *)var_digest_obj );
    Py_DECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)var_sign_result );
    Py_DECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_days );
    Py_DECREF( par_days );
    par_days = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    Py_XDECREF( var_sometime );
    var_sometime = NULL;

    Py_XDECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_124_export );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_125_type_is_signed( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_bool_arg_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_28c84ee70c601df7b191b6f7900ba260 = NULL;

    struct Nuitka_FrameObject *frame_28c84ee70c601df7b191b6f7900ba260;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_28c84ee70c601df7b191b6f7900ba260, codeobj_28c84ee70c601df7b191b6f7900ba260, module_OpenSSL$crypto, sizeof(void *) );
    frame_28c84ee70c601df7b191b6f7900ba260 = cache_frame_28c84ee70c601df7b191b6f7900ba260;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_28c84ee70c601df7b191b6f7900ba260 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_28c84ee70c601df7b191b6f7900ba260 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2474;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PKCS7_type_is_signed );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2474;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__pkcs7 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2474;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_28c84ee70c601df7b191b6f7900ba260->m_frame.f_lineno = 2474;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_bool_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_bool_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2474;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = TO_BOOL( tmp_bool_arg_1 );
    Py_DECREF( tmp_bool_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2474;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_28c84ee70c601df7b191b6f7900ba260 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_28c84ee70c601df7b191b6f7900ba260 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_28c84ee70c601df7b191b6f7900ba260 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_28c84ee70c601df7b191b6f7900ba260, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_28c84ee70c601df7b191b6f7900ba260->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_28c84ee70c601df7b191b6f7900ba260, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_28c84ee70c601df7b191b6f7900ba260,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_28c84ee70c601df7b191b6f7900ba260 == cache_frame_28c84ee70c601df7b191b6f7900ba260 )
    {
        Py_DECREF( frame_28c84ee70c601df7b191b6f7900ba260 );
    }
    cache_frame_28c84ee70c601df7b191b6f7900ba260 = NULL;

    assertFrameObject( frame_28c84ee70c601df7b191b6f7900ba260 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_125_type_is_signed );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_125_type_is_signed );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_126_type_is_enveloped( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_bool_arg_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_827362a983b7474d6f375edfc3634b35 = NULL;

    struct Nuitka_FrameObject *frame_827362a983b7474d6f375edfc3634b35;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_827362a983b7474d6f375edfc3634b35, codeobj_827362a983b7474d6f375edfc3634b35, module_OpenSSL$crypto, sizeof(void *) );
    frame_827362a983b7474d6f375edfc3634b35 = cache_frame_827362a983b7474d6f375edfc3634b35;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_827362a983b7474d6f375edfc3634b35 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_827362a983b7474d6f375edfc3634b35 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2482;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PKCS7_type_is_enveloped );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2482;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__pkcs7 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2482;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_827362a983b7474d6f375edfc3634b35->m_frame.f_lineno = 2482;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_bool_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_bool_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2482;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = TO_BOOL( tmp_bool_arg_1 );
    Py_DECREF( tmp_bool_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2482;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_827362a983b7474d6f375edfc3634b35 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_827362a983b7474d6f375edfc3634b35 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_827362a983b7474d6f375edfc3634b35 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_827362a983b7474d6f375edfc3634b35, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_827362a983b7474d6f375edfc3634b35->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_827362a983b7474d6f375edfc3634b35, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_827362a983b7474d6f375edfc3634b35,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_827362a983b7474d6f375edfc3634b35 == cache_frame_827362a983b7474d6f375edfc3634b35 )
    {
        Py_DECREF( frame_827362a983b7474d6f375edfc3634b35 );
    }
    cache_frame_827362a983b7474d6f375edfc3634b35 = NULL;

    assertFrameObject( frame_827362a983b7474d6f375edfc3634b35 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_126_type_is_enveloped );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_126_type_is_enveloped );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_127_type_is_signedAndEnveloped( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_bool_arg_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_d5256ae10053b2c8525f915629371344 = NULL;

    struct Nuitka_FrameObject *frame_d5256ae10053b2c8525f915629371344;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d5256ae10053b2c8525f915629371344, codeobj_d5256ae10053b2c8525f915629371344, module_OpenSSL$crypto, sizeof(void *) );
    frame_d5256ae10053b2c8525f915629371344 = cache_frame_d5256ae10053b2c8525f915629371344;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d5256ae10053b2c8525f915629371344 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d5256ae10053b2c8525f915629371344 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2490;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PKCS7_type_is_signedAndEnveloped );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2490;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__pkcs7 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2490;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_d5256ae10053b2c8525f915629371344->m_frame.f_lineno = 2490;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_bool_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_bool_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2490;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = TO_BOOL( tmp_bool_arg_1 );
    Py_DECREF( tmp_bool_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2490;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d5256ae10053b2c8525f915629371344 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d5256ae10053b2c8525f915629371344 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d5256ae10053b2c8525f915629371344 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d5256ae10053b2c8525f915629371344, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d5256ae10053b2c8525f915629371344->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d5256ae10053b2c8525f915629371344, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d5256ae10053b2c8525f915629371344,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d5256ae10053b2c8525f915629371344 == cache_frame_d5256ae10053b2c8525f915629371344 )
    {
        Py_DECREF( frame_d5256ae10053b2c8525f915629371344 );
    }
    cache_frame_d5256ae10053b2c8525f915629371344 = NULL;

    assertFrameObject( frame_d5256ae10053b2c8525f915629371344 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_127_type_is_signedAndEnveloped );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_127_type_is_signedAndEnveloped );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_128_type_is_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_bool_arg_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_7349adb7b143cb067732bf2b6a832926 = NULL;

    struct Nuitka_FrameObject *frame_7349adb7b143cb067732bf2b6a832926;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7349adb7b143cb067732bf2b6a832926, codeobj_7349adb7b143cb067732bf2b6a832926, module_OpenSSL$crypto, sizeof(void *) );
    frame_7349adb7b143cb067732bf2b6a832926 = cache_frame_7349adb7b143cb067732bf2b6a832926;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7349adb7b143cb067732bf2b6a832926 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7349adb7b143cb067732bf2b6a832926 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2498;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PKCS7_type_is_data );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2498;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__pkcs7 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2498;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_7349adb7b143cb067732bf2b6a832926->m_frame.f_lineno = 2498;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_bool_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_bool_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2498;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = TO_BOOL( tmp_bool_arg_1 );
    Py_DECREF( tmp_bool_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2498;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7349adb7b143cb067732bf2b6a832926 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7349adb7b143cb067732bf2b6a832926 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7349adb7b143cb067732bf2b6a832926 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7349adb7b143cb067732bf2b6a832926, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7349adb7b143cb067732bf2b6a832926->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7349adb7b143cb067732bf2b6a832926, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7349adb7b143cb067732bf2b6a832926,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_7349adb7b143cb067732bf2b6a832926 == cache_frame_7349adb7b143cb067732bf2b6a832926 )
    {
        Py_DECREF( frame_7349adb7b143cb067732bf2b6a832926 );
    }
    cache_frame_7349adb7b143cb067732bf2b6a832926 = NULL;

    assertFrameObject( frame_7349adb7b143cb067732bf2b6a832926 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_128_type_is_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_128_type_is_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_129_get_type_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_string_type = NULL;
    PyObject *var_nid = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_17894a2bd573cf70312dff7783ba8c00 = NULL;

    struct Nuitka_FrameObject *frame_17894a2bd573cf70312dff7783ba8c00;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_17894a2bd573cf70312dff7783ba8c00, codeobj_17894a2bd573cf70312dff7783ba8c00, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_17894a2bd573cf70312dff7783ba8c00 = cache_frame_17894a2bd573cf70312dff7783ba8c00;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_17894a2bd573cf70312dff7783ba8c00 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_17894a2bd573cf70312dff7783ba8c00 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2506;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_OBJ_obj2nid );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2506;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkcs7 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2506;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_type );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2506;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_17894a2bd573cf70312dff7783ba8c00->m_frame.f_lineno = 2506;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2506;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_nid == NULL );
    var_nid = tmp_assign_source_1;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2507;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_nid;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_17894a2bd573cf70312dff7783ba8c00->m_frame.f_lineno = 2507;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_OBJ_nid2sn, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2507;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_string_type == NULL );
    var_string_type = tmp_assign_source_2;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2508;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_string_type;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_17894a2bd573cf70312dff7783ba8c00->m_frame.f_lineno = 2508;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_string, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2508;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_17894a2bd573cf70312dff7783ba8c00 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_17894a2bd573cf70312dff7783ba8c00 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_17894a2bd573cf70312dff7783ba8c00 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_17894a2bd573cf70312dff7783ba8c00, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_17894a2bd573cf70312dff7783ba8c00->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_17894a2bd573cf70312dff7783ba8c00, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_17894a2bd573cf70312dff7783ba8c00,
        type_description_1,
        par_self,
        var_string_type,
        var_nid
    );


    // Release cached frame.
    if ( frame_17894a2bd573cf70312dff7783ba8c00 == cache_frame_17894a2bd573cf70312dff7783ba8c00 )
    {
        Py_DECREF( frame_17894a2bd573cf70312dff7783ba8c00 );
    }
    cache_frame_17894a2bd573cf70312dff7783ba8c00 = NULL;

    assertFrameObject( frame_17894a2bd573cf70312dff7783ba8c00 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_129_get_type_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_string_type );
    Py_DECREF( var_string_type );
    var_string_type = NULL;

    CHECK_OBJECT( (PyObject *)var_nid );
    Py_DECREF( var_nid );
    var_nid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_string_type );
    var_string_type = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_129_get_type_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_130___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_d792dc0a2b4ceb48a62671146c8bf0d7 = NULL;

    struct Nuitka_FrameObject *frame_d792dc0a2b4ceb48a62671146c8bf0d7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d792dc0a2b4ceb48a62671146c8bf0d7, codeobj_d792dc0a2b4ceb48a62671146c8bf0d7, module_OpenSSL$crypto, sizeof(void *) );
    frame_d792dc0a2b4ceb48a62671146c8bf0d7 = cache_frame_d792dc0a2b4ceb48a62671146c8bf0d7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d792dc0a2b4ceb48a62671146c8bf0d7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d792dc0a2b4ceb48a62671146c8bf0d7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = Py_None;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2517;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = Py_None;
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__cert, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2518;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = Py_None;
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__cacerts, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2519;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_4 = Py_None;
    tmp_assattr_target_4 = par_self;

    CHECK_OBJECT( tmp_assattr_target_4 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__friendlyname, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2520;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d792dc0a2b4ceb48a62671146c8bf0d7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d792dc0a2b4ceb48a62671146c8bf0d7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d792dc0a2b4ceb48a62671146c8bf0d7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d792dc0a2b4ceb48a62671146c8bf0d7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d792dc0a2b4ceb48a62671146c8bf0d7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d792dc0a2b4ceb48a62671146c8bf0d7,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d792dc0a2b4ceb48a62671146c8bf0d7 == cache_frame_d792dc0a2b4ceb48a62671146c8bf0d7 )
    {
        Py_DECREF( frame_d792dc0a2b4ceb48a62671146c8bf0d7 );
    }
    cache_frame_d792dc0a2b4ceb48a62671146c8bf0d7 = NULL;

    assertFrameObject( frame_d792dc0a2b4ceb48a62671146c8bf0d7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_130___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_130___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_131_get_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_0c82a5452c5febb9099bd8db0c10394d = NULL;

    struct Nuitka_FrameObject *frame_0c82a5452c5febb9099bd8db0c10394d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0c82a5452c5febb9099bd8db0c10394d, codeobj_0c82a5452c5febb9099bd8db0c10394d, module_OpenSSL$crypto, sizeof(void *) );
    frame_0c82a5452c5febb9099bd8db0c10394d = cache_frame_0c82a5452c5febb9099bd8db0c10394d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0c82a5452c5febb9099bd8db0c10394d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0c82a5452c5febb9099bd8db0c10394d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__cert );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2529;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c82a5452c5febb9099bd8db0c10394d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c82a5452c5febb9099bd8db0c10394d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c82a5452c5febb9099bd8db0c10394d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0c82a5452c5febb9099bd8db0c10394d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0c82a5452c5febb9099bd8db0c10394d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0c82a5452c5febb9099bd8db0c10394d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0c82a5452c5febb9099bd8db0c10394d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_0c82a5452c5febb9099bd8db0c10394d == cache_frame_0c82a5452c5febb9099bd8db0c10394d )
    {
        Py_DECREF( frame_0c82a5452c5febb9099bd8db0c10394d );
    }
    cache_frame_0c82a5452c5febb9099bd8db0c10394d = NULL;

    assertFrameObject( frame_0c82a5452c5febb9099bd8db0c10394d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_131_get_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_131_get_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_132_set_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cert = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_aa37b9cbdf49270d594d1c8bbf09fed2 = NULL;

    struct Nuitka_FrameObject *frame_aa37b9cbdf49270d594d1c8bbf09fed2;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_aa37b9cbdf49270d594d1c8bbf09fed2, codeobj_aa37b9cbdf49270d594d1c8bbf09fed2, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_aa37b9cbdf49270d594d1c8bbf09fed2 = cache_frame_aa37b9cbdf49270d594d1c8bbf09fed2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_aa37b9cbdf49270d594d1c8bbf09fed2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_aa37b9cbdf49270d594d1c8bbf09fed2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_cert;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 2540;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2540;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_c804b213c384a15865e18bf31cfff70e;
    frame_aa37b9cbdf49270d594d1c8bbf09fed2->m_frame.f_lineno = 2541;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2541;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_cert;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__cert, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2542;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aa37b9cbdf49270d594d1c8bbf09fed2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aa37b9cbdf49270d594d1c8bbf09fed2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_aa37b9cbdf49270d594d1c8bbf09fed2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_aa37b9cbdf49270d594d1c8bbf09fed2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_aa37b9cbdf49270d594d1c8bbf09fed2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_aa37b9cbdf49270d594d1c8bbf09fed2,
        type_description_1,
        par_self,
        par_cert
    );


    // Release cached frame.
    if ( frame_aa37b9cbdf49270d594d1c8bbf09fed2 == cache_frame_aa37b9cbdf49270d594d1c8bbf09fed2 )
    {
        Py_DECREF( frame_aa37b9cbdf49270d594d1c8bbf09fed2 );
    }
    cache_frame_aa37b9cbdf49270d594d1c8bbf09fed2 = NULL;

    assertFrameObject( frame_aa37b9cbdf49270d594d1c8bbf09fed2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_132_set_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_132_set_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_133_get_privatekey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_297408a0aa65f790cf77d6f0ddab5fc4 = NULL;

    struct Nuitka_FrameObject *frame_297408a0aa65f790cf77d6f0ddab5fc4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_297408a0aa65f790cf77d6f0ddab5fc4, codeobj_297408a0aa65f790cf77d6f0ddab5fc4, module_OpenSSL$crypto, sizeof(void *) );
    frame_297408a0aa65f790cf77d6f0ddab5fc4 = cache_frame_297408a0aa65f790cf77d6f0ddab5fc4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_297408a0aa65f790cf77d6f0ddab5fc4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_297408a0aa65f790cf77d6f0ddab5fc4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__pkey );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2551;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_297408a0aa65f790cf77d6f0ddab5fc4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_297408a0aa65f790cf77d6f0ddab5fc4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_297408a0aa65f790cf77d6f0ddab5fc4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_297408a0aa65f790cf77d6f0ddab5fc4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_297408a0aa65f790cf77d6f0ddab5fc4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_297408a0aa65f790cf77d6f0ddab5fc4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_297408a0aa65f790cf77d6f0ddab5fc4,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_297408a0aa65f790cf77d6f0ddab5fc4 == cache_frame_297408a0aa65f790cf77d6f0ddab5fc4 )
    {
        Py_DECREF( frame_297408a0aa65f790cf77d6f0ddab5fc4 );
    }
    cache_frame_297408a0aa65f790cf77d6f0ddab5fc4 = NULL;

    assertFrameObject( frame_297408a0aa65f790cf77d6f0ddab5fc4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_133_get_privatekey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_133_get_privatekey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_134_set_privatekey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_27ff3ab34ec54fd0321637ec5b9468ab = NULL;

    struct Nuitka_FrameObject *frame_27ff3ab34ec54fd0321637ec5b9468ab;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_27ff3ab34ec54fd0321637ec5b9468ab, codeobj_27ff3ab34ec54fd0321637ec5b9468ab, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_27ff3ab34ec54fd0321637ec5b9468ab = cache_frame_27ff3ab34ec54fd0321637ec5b9468ab;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_27ff3ab34ec54fd0321637ec5b9468ab );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_27ff3ab34ec54fd0321637ec5b9468ab ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_pkey;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 2562;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2562;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
    frame_27ff3ab34ec54fd0321637ec5b9468ab->m_frame.f_lineno = 2563;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2563;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_pkey;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2564;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27ff3ab34ec54fd0321637ec5b9468ab );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27ff3ab34ec54fd0321637ec5b9468ab );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_27ff3ab34ec54fd0321637ec5b9468ab, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_27ff3ab34ec54fd0321637ec5b9468ab->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_27ff3ab34ec54fd0321637ec5b9468ab, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_27ff3ab34ec54fd0321637ec5b9468ab,
        type_description_1,
        par_self,
        par_pkey
    );


    // Release cached frame.
    if ( frame_27ff3ab34ec54fd0321637ec5b9468ab == cache_frame_27ff3ab34ec54fd0321637ec5b9468ab )
    {
        Py_DECREF( frame_27ff3ab34ec54fd0321637ec5b9468ab );
    }
    cache_frame_27ff3ab34ec54fd0321637ec5b9468ab = NULL;

    assertFrameObject( frame_27ff3ab34ec54fd0321637ec5b9468ab );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_134_set_privatekey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_134_set_privatekey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_135_get_ca_certificates( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_isnot_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_tuple_arg_1;
    static struct Nuitka_FrameObject *cache_frame_9b12eba053e44d5fd15b6e0ac3462f9f = NULL;

    struct Nuitka_FrameObject *frame_9b12eba053e44d5fd15b6e0ac3462f9f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9b12eba053e44d5fd15b6e0ac3462f9f, codeobj_9b12eba053e44d5fd15b6e0ac3462f9f, module_OpenSSL$crypto, sizeof(void *) );
    frame_9b12eba053e44d5fd15b6e0ac3462f9f = cache_frame_9b12eba053e44d5fd15b6e0ac3462f9f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9b12eba053e44d5fd15b6e0ac3462f9f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9b12eba053e44d5fd15b6e0ac3462f9f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__cacerts );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2574;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__cacerts );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2575;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2575;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9b12eba053e44d5fd15b6e0ac3462f9f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9b12eba053e44d5fd15b6e0ac3462f9f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9b12eba053e44d5fd15b6e0ac3462f9f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9b12eba053e44d5fd15b6e0ac3462f9f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9b12eba053e44d5fd15b6e0ac3462f9f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9b12eba053e44d5fd15b6e0ac3462f9f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9b12eba053e44d5fd15b6e0ac3462f9f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_9b12eba053e44d5fd15b6e0ac3462f9f == cache_frame_9b12eba053e44d5fd15b6e0ac3462f9f )
    {
        Py_DECREF( frame_9b12eba053e44d5fd15b6e0ac3462f9f );
    }
    cache_frame_9b12eba053e44d5fd15b6e0ac3462f9f = NULL;

    assertFrameObject( frame_9b12eba053e44d5fd15b6e0ac3462f9f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_135_get_ca_certificates );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_135_get_ca_certificates );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_136_set_ca_certificates( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cacerts = python_pars[ 1 ];
    PyObject *var_cert = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_exc_match_exception_match_1;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_ff2082c1effa87cca79f7de3b6f33a05 = NULL;

    struct Nuitka_FrameObject *frame_ff2082c1effa87cca79f7de3b6f33a05;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ff2082c1effa87cca79f7de3b6f33a05, codeobj_ff2082c1effa87cca79f7de3b6f33a05, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ff2082c1effa87cca79f7de3b6f33a05 = cache_frame_ff2082c1effa87cca79f7de3b6f33a05;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ff2082c1effa87cca79f7de3b6f33a05 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ff2082c1effa87cca79f7de3b6f33a05 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_cacerts;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assattr_name_1 = Py_None;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__cacerts, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2588;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_list_arg_1 = par_cacerts;

    CHECK_OBJECT( tmp_list_arg_1 );
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2590;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_cacerts;
        assert( old != NULL );
        par_cacerts = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_iter_arg_1 = par_cacerts;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2591;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooo";
        exception_lineno = 2591;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_2 = exception_keeper_type_1;
    tmp_compare_right_2 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 2591;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_2;
    branch_no_2:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_2:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_cert;
        var_cert = tmp_assign_source_4;
        Py_INCREF( var_cert );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_cert;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 2592;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2592;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_1 = const_str_digest_1691c1bfd96a22cfc48aca410da45814;
    frame_ff2082c1effa87cca79f7de3b6f33a05->m_frame.f_lineno = 2593;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2593;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto try_except_handler_2;
    branch_no_3:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2591;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_assattr_name_2 = par_cacerts;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__cacerts, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2596;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff2082c1effa87cca79f7de3b6f33a05 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff2082c1effa87cca79f7de3b6f33a05 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ff2082c1effa87cca79f7de3b6f33a05, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ff2082c1effa87cca79f7de3b6f33a05->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ff2082c1effa87cca79f7de3b6f33a05, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ff2082c1effa87cca79f7de3b6f33a05,
        type_description_1,
        par_self,
        par_cacerts,
        var_cert
    );


    // Release cached frame.
    if ( frame_ff2082c1effa87cca79f7de3b6f33a05 == cache_frame_ff2082c1effa87cca79f7de3b6f33a05 )
    {
        Py_DECREF( frame_ff2082c1effa87cca79f7de3b6f33a05 );
    }
    cache_frame_ff2082c1effa87cca79f7de3b6f33a05 = NULL;

    assertFrameObject( frame_ff2082c1effa87cca79f7de3b6f33a05 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_136_set_ca_certificates );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_cacerts );
    Py_DECREF( par_cacerts );
    par_cacerts = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_cacerts );
    Py_DECREF( par_cacerts );
    par_cacerts = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_136_set_ca_certificates );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_137_set_friendlyname( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_fba8564faf4c03ce4d5b0d189ce6194b = NULL;

    struct Nuitka_FrameObject *frame_fba8564faf4c03ce4d5b0d189ce6194b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fba8564faf4c03ce4d5b0d189ce6194b, codeobj_fba8564faf4c03ce4d5b0d189ce6194b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_fba8564faf4c03ce4d5b0d189ce6194b = cache_frame_fba8564faf4c03ce4d5b0d189ce6194b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fba8564faf4c03ce4d5b0d189ce6194b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fba8564faf4c03ce4d5b0d189ce6194b ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_name;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assattr_name_1 = Py_None;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__friendlyname, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2608;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_isinstance_inst_1 = par_name;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2609;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_left_name_1 = const_str_digest_d7980f3a0e05fb43bc9ed0fa0707a2f9;
    tmp_right_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_name;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2611;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_fba8564faf4c03ce4d5b0d189ce6194b->m_frame.f_lineno = 2610;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2610;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_2:;
    branch_end_1:;
    tmp_assattr_name_2 = par_name;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__friendlyname, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2613;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fba8564faf4c03ce4d5b0d189ce6194b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fba8564faf4c03ce4d5b0d189ce6194b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fba8564faf4c03ce4d5b0d189ce6194b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fba8564faf4c03ce4d5b0d189ce6194b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fba8564faf4c03ce4d5b0d189ce6194b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fba8564faf4c03ce4d5b0d189ce6194b,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if ( frame_fba8564faf4c03ce4d5b0d189ce6194b == cache_frame_fba8564faf4c03ce4d5b0d189ce6194b )
    {
        Py_DECREF( frame_fba8564faf4c03ce4d5b0d189ce6194b );
    }
    cache_frame_fba8564faf4c03ce4d5b0d189ce6194b = NULL;

    assertFrameObject( frame_fba8564faf4c03ce4d5b0d189ce6194b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_137_set_friendlyname );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_137_set_friendlyname );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_138_get_friendlyname( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_b1486947c5a61e6df127599c97e465e7 = NULL;

    struct Nuitka_FrameObject *frame_b1486947c5a61e6df127599c97e465e7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b1486947c5a61e6df127599c97e465e7, codeobj_b1486947c5a61e6df127599c97e465e7, module_OpenSSL$crypto, sizeof(void *) );
    frame_b1486947c5a61e6df127599c97e465e7 = cache_frame_b1486947c5a61e6df127599c97e465e7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b1486947c5a61e6df127599c97e465e7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b1486947c5a61e6df127599c97e465e7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__friendlyname );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2622;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b1486947c5a61e6df127599c97e465e7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b1486947c5a61e6df127599c97e465e7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b1486947c5a61e6df127599c97e465e7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b1486947c5a61e6df127599c97e465e7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b1486947c5a61e6df127599c97e465e7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b1486947c5a61e6df127599c97e465e7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b1486947c5a61e6df127599c97e465e7,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b1486947c5a61e6df127599c97e465e7 == cache_frame_b1486947c5a61e6df127599c97e465e7 )
    {
        Py_DECREF( frame_b1486947c5a61e6df127599c97e465e7 );
    }
    cache_frame_b1486947c5a61e6df127599c97e465e7 = NULL;

    assertFrameObject( frame_b1486947c5a61e6df127599c97e465e7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_138_get_friendlyname );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_138_get_friendlyname );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_139_export( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_passphrase = python_pars[ 1 ];
    PyObject *par_iter = python_pars[ 2 ];
    PyObject *par_maciter = python_pars[ 3 ];
    PyObject *var_pkey = NULL;
    PyObject *var_bio = NULL;
    PyObject *var_cacerts = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_friendlyname = NULL;
    PyObject *var_pkcs12 = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    int tmp_exc_match_exception_match_1;
    bool tmp_is_1;
    bool tmp_is_2;
    bool tmp_is_3;
    bool tmp_is_4;
    bool tmp_is_5;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    PyObject *tmp_source_name_19;
    PyObject *tmp_source_name_20;
    PyObject *tmp_source_name_21;
    PyObject *tmp_source_name_22;
    PyObject *tmp_source_name_23;
    PyObject *tmp_source_name_24;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_1a7304e9294486f283f111b9533e37ac = NULL;

    struct Nuitka_FrameObject *frame_1a7304e9294486f283f111b9533e37ac;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1a7304e9294486f283f111b9533e37ac, codeobj_1a7304e9294486f283f111b9533e37ac, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1a7304e9294486f283f111b9533e37ac = cache_frame_1a7304e9294486f283f111b9533e37ac;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1a7304e9294486f283f111b9533e37ac );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1a7304e9294486f283f111b9533e37ac ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
        exception_tb = NULL;

        exception_lineno = 2644;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_plain_passphrase;
    tmp_args_element_name_2 = par_passphrase;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_1a7304e9294486f283f111b9533e37ac->m_frame.f_lineno = 2644;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2644;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_passphrase;
        assert( old != NULL );
        par_passphrase = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__cacerts );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2646;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2647;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2647;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_cacerts == NULL );
    var_cacerts = tmp_assign_source_2;

    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2649;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    frame_1a7304e9294486f283f111b9533e37ac->m_frame.f_lineno = 2649;
    tmp_assign_source_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_sk_X509_new_null );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2649;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_cacerts == NULL );
    var_cacerts = tmp_assign_source_3;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2650;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_gc );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2650;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_cacerts;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2650;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_sk_X509_free );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2650;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    frame_1a7304e9294486f283f111b9533e37ac->m_frame.f_lineno = 2650;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2650;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_cacerts;
        assert( old != NULL );
        var_cacerts = tmp_assign_source_4;
        Py_DECREF( old );
    }

    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__cacerts );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2651;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2651;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_5;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_6 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_6 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooooo";
        exception_lineno = 2651;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_2 = exception_keeper_type_1;
    tmp_compare_right_2 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 2651;
        type_description_1 = "oooooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_2;
    branch_no_2:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_2:;
    // End of try:
    try_end_1:;
    tmp_assign_source_7 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_7 );
    {
        PyObject *old = var_cert;
        var_cert = tmp_assign_source_7;
        Py_INCREF( var_cert );
        Py_XDECREF( old );
    }

    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2652;
        type_description_1 = "oooooooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_sk_X509_push );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2652;
        type_description_1 = "oooooooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_5 = var_cacerts;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_source_name_7 = var_cert;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__x509 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 2652;
        type_description_1 = "oooooooooo";
        goto try_except_handler_2;
    }
    frame_1a7304e9294486f283f111b9533e37ac->m_frame.f_lineno = 2652;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2652;
        type_description_1 = "oooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2651;
        type_description_1 = "oooooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    branch_end_1:;
    tmp_compare_left_3 = par_passphrase;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = Py_None;
    tmp_is_2 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_2 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2655;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_NULL );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2655;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_passphrase;
        assert( old != NULL );
        par_passphrase = tmp_assign_source_8;
        Py_DECREF( old );
    }

    branch_no_3:;
    tmp_source_name_9 = par_self;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_assign_source_9 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__friendlyname );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2657;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_friendlyname == NULL );
    var_friendlyname = tmp_assign_source_9;

    tmp_compare_left_4 = var_friendlyname;

    CHECK_OBJECT( tmp_compare_left_4 );
    tmp_compare_right_4 = Py_None;
    tmp_is_3 = ( tmp_compare_left_4 == tmp_compare_right_4 );
    if ( tmp_is_3 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2659;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_10 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_NULL );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2659;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_friendlyname;
        assert( old != NULL );
        var_friendlyname = tmp_assign_source_10;
        Py_DECREF( old );
    }

    branch_no_4:;
    tmp_source_name_11 = par_self;

    CHECK_OBJECT( tmp_source_name_11 );
    tmp_compare_left_5 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__pkey );
    if ( tmp_compare_left_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2661;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_5 = Py_None;
    tmp_is_4 = ( tmp_compare_left_5 == tmp_compare_right_5 );
    Py_DECREF( tmp_compare_left_5 );
    if ( tmp_is_4 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2662;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_11 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_NULL );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2662;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pkey == NULL );
    var_pkey = tmp_assign_source_11;

    goto branch_end_5;
    branch_no_5:;
    tmp_source_name_14 = par_self;

    CHECK_OBJECT( tmp_source_name_14 );
    tmp_source_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain__pkey );
    if ( tmp_source_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2664;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_12 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain__pkey );
    Py_DECREF( tmp_source_name_13 );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2664;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pkey == NULL );
    var_pkey = tmp_assign_source_12;

    branch_end_5:;
    tmp_source_name_15 = par_self;

    CHECK_OBJECT( tmp_source_name_15 );
    tmp_compare_left_6 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain__cert );
    if ( tmp_compare_left_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2666;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_6 = Py_None;
    tmp_is_5 = ( tmp_compare_left_6 == tmp_compare_right_6 );
    Py_DECREF( tmp_compare_left_6 );
    if ( tmp_is_5 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_source_name_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_16 == NULL ))
    {
        tmp_source_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2667;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_13 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_NULL );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2667;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_cert;
        var_cert = tmp_assign_source_13;
        Py_XDECREF( old );
    }

    goto branch_end_6;
    branch_no_6:;
    tmp_source_name_18 = par_self;

    CHECK_OBJECT( tmp_source_name_18 );
    tmp_source_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain__cert );
    if ( tmp_source_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2669;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_14 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain__x509 );
    Py_DECREF( tmp_source_name_17 );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2669;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_cert;
        var_cert = tmp_assign_source_14;
        Py_XDECREF( old );
    }

    branch_end_6:;
    tmp_source_name_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_19 == NULL ))
    {
        tmp_source_name_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_19 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2671;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_PKCS12_create );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2671;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = par_passphrase;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = var_friendlyname;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_args_element_name_9 = var_pkey;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_args_element_name_10 = var_cert;

    CHECK_OBJECT( tmp_args_element_name_10 );
    tmp_args_element_name_11 = var_cacerts;

    CHECK_OBJECT( tmp_args_element_name_11 );
    tmp_source_name_20 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_20 == NULL ))
    {
        tmp_source_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_20 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2677;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_NID_pbe_WithSHA1And3_Key_TripleDES_CBC );
    if ( tmp_args_element_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 2677;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_21 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_21 == NULL ))
    {
        tmp_source_name_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_21 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_12 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2678;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_21, const_str_plain_NID_pbe_WithSHA1And3_Key_TripleDES_CBC );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_12 );

        exception_lineno = 2678;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_14 = par_iter;

    CHECK_OBJECT( tmp_args_element_name_14 );
    tmp_args_element_name_15 = par_maciter;

    CHECK_OBJECT( tmp_args_element_name_15 );
    tmp_args_element_name_16 = const_int_0;
    frame_1a7304e9294486f283f111b9533e37ac->m_frame.f_lineno = 2671;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12, tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15, tmp_args_element_name_16 };
        tmp_assign_source_15 = CALL_FUNCTION_WITH_ARGS10( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_12 );
    Py_DECREF( tmp_args_element_name_13 );
    if ( tmp_assign_source_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2671;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pkcs12 == NULL );
    var_pkcs12 = tmp_assign_source_15;

    tmp_compare_left_7 = var_pkcs12;

    CHECK_OBJECT( tmp_compare_left_7 );
    tmp_source_name_22 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_22 == NULL ))
    {
        tmp_source_name_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_22 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2683;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_7 = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain_NULL );
    if ( tmp_compare_right_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2683;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_7, tmp_compare_right_7 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_7 );

        exception_lineno = 2683;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_7 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 2684;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    frame_1a7304e9294486f283f111b9533e37ac->m_frame.f_lineno = 2684;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2684;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_7:;
    tmp_source_name_23 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_23 == NULL ))
    {
        tmp_source_name_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_23 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2685;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain_gc );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2685;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_17 = var_pkcs12;

    CHECK_OBJECT( tmp_args_element_name_17 );
    tmp_source_name_24 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_24 == NULL ))
    {
        tmp_source_name_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_24 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2685;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_18 = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain_PKCS12_free );
    if ( tmp_args_element_name_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 2685;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    frame_1a7304e9294486f283f111b9533e37ac->m_frame.f_lineno = 2685;
    {
        PyObject *call_args[] = { tmp_args_element_name_17, tmp_args_element_name_18 };
        tmp_assign_source_16 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_18 );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2685;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_pkcs12;
        assert( old != NULL );
        var_pkcs12 = tmp_assign_source_16;
        Py_DECREF( old );
    }

    tmp_called_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_7 == NULL ))
    {
        tmp_called_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 2687;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    frame_1a7304e9294486f283f111b9533e37ac->m_frame.f_lineno = 2687;
    tmp_assign_source_17 = CALL_FUNCTION_NO_ARGS( tmp_called_name_7 );
    if ( tmp_assign_source_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2687;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_17;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2688;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_19 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_19 );
    tmp_args_element_name_20 = var_pkcs12;

    CHECK_OBJECT( tmp_args_element_name_20 );
    frame_1a7304e9294486f283f111b9533e37ac->m_frame.f_lineno = 2688;
    {
        PyObject *call_args[] = { tmp_args_element_name_19, tmp_args_element_name_20 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_i2d_PKCS12_bio, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2688;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

    if (unlikely( tmp_called_name_8 == NULL ))
    {
        tmp_called_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
    }

    if ( tmp_called_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
        exception_tb = NULL;

        exception_lineno = 2689;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_21 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_21 );
    frame_1a7304e9294486f283f111b9533e37ac->m_frame.f_lineno = 2689;
    {
        PyObject *call_args[] = { tmp_args_element_name_21 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2689;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1a7304e9294486f283f111b9533e37ac );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1a7304e9294486f283f111b9533e37ac );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1a7304e9294486f283f111b9533e37ac );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1a7304e9294486f283f111b9533e37ac, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1a7304e9294486f283f111b9533e37ac->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1a7304e9294486f283f111b9533e37ac, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1a7304e9294486f283f111b9533e37ac,
        type_description_1,
        par_self,
        par_passphrase,
        par_iter,
        par_maciter,
        var_pkey,
        var_bio,
        var_cacerts,
        var_cert,
        var_friendlyname,
        var_pkcs12
    );


    // Release cached frame.
    if ( frame_1a7304e9294486f283f111b9533e37ac == cache_frame_1a7304e9294486f283f111b9533e37ac )
    {
        Py_DECREF( frame_1a7304e9294486f283f111b9533e37ac );
    }
    cache_frame_1a7304e9294486f283f111b9533e37ac = NULL;

    assertFrameObject( frame_1a7304e9294486f283f111b9533e37ac );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_139_export );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_cacerts );
    Py_DECREF( var_cacerts );
    var_cacerts = NULL;

    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_maciter );
    Py_DECREF( par_maciter );
    par_maciter = NULL;

    CHECK_OBJECT( (PyObject *)par_iter );
    Py_DECREF( par_iter );
    par_iter = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    CHECK_OBJECT( (PyObject *)var_friendlyname );
    Py_DECREF( var_friendlyname );
    var_friendlyname = NULL;

    CHECK_OBJECT( (PyObject *)var_pkcs12 );
    Py_DECREF( var_pkcs12 );
    var_pkcs12 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cacerts );
    var_cacerts = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_maciter );
    Py_DECREF( par_maciter );
    par_maciter = NULL;

    CHECK_OBJECT( (PyObject *)par_iter );
    Py_DECREF( par_iter );
    par_iter = NULL;

    Py_XDECREF( par_passphrase );
    par_passphrase = NULL;

    Py_XDECREF( var_friendlyname );
    var_friendlyname = NULL;

    Py_XDECREF( var_pkcs12 );
    var_pkcs12 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_139_export );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_140___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_spki = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_459d1e2f5259dad1fd69735ed07121a4 = NULL;

    struct Nuitka_FrameObject *frame_459d1e2f5259dad1fd69735ed07121a4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_459d1e2f5259dad1fd69735ed07121a4, codeobj_459d1e2f5259dad1fd69735ed07121a4, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_459d1e2f5259dad1fd69735ed07121a4 = cache_frame_459d1e2f5259dad1fd69735ed07121a4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_459d1e2f5259dad1fd69735ed07121a4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_459d1e2f5259dad1fd69735ed07121a4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2698;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_459d1e2f5259dad1fd69735ed07121a4->m_frame.f_lineno = 2698;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_NETSCAPE_SPKI_new );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2698;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_spki == NULL );
    var_spki = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2699;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2699;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_spki;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2699;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NETSCAPE_SPKI_free );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2699;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_459d1e2f5259dad1fd69735ed07121a4->m_frame.f_lineno = 2699;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2699;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__spki, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 2699;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_459d1e2f5259dad1fd69735ed07121a4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_459d1e2f5259dad1fd69735ed07121a4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_459d1e2f5259dad1fd69735ed07121a4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_459d1e2f5259dad1fd69735ed07121a4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_459d1e2f5259dad1fd69735ed07121a4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_459d1e2f5259dad1fd69735ed07121a4,
        type_description_1,
        par_self,
        var_spki
    );


    // Release cached frame.
    if ( frame_459d1e2f5259dad1fd69735ed07121a4 == cache_frame_459d1e2f5259dad1fd69735ed07121a4 )
    {
        Py_DECREF( frame_459d1e2f5259dad1fd69735ed07121a4 );
    }
    cache_frame_459d1e2f5259dad1fd69735ed07121a4 = NULL;

    assertFrameObject( frame_459d1e2f5259dad1fd69735ed07121a4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_140___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_spki );
    Py_DECREF( var_spki );
    var_spki = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_spki );
    var_spki = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_140___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_141_sign( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *par_digest = python_pars[ 2 ];
    PyObject *var_digest_obj = NULL;
    PyObject *var_sign_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_8eb0152ada49813b33550455d2f476e6 = NULL;

    struct Nuitka_FrameObject *frame_8eb0152ada49813b33550455d2f476e6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8eb0152ada49813b33550455d2f476e6, codeobj_8eb0152ada49813b33550455d2f476e6, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8eb0152ada49813b33550455d2f476e6 = cache_frame_8eb0152ada49813b33550455d2f476e6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8eb0152ada49813b33550455d2f476e6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8eb0152ada49813b33550455d2f476e6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_pkey;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__only_public );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2713;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 2713;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_8aae826f04ca2a5df2a0de1a103a1f13;
    frame_8eb0152ada49813b33550455d2f476e6->m_frame.f_lineno = 2714;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2714;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_2 = par_pkey;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_cond_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__initialized );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2716;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 2716;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e;
    frame_8eb0152ada49813b33550455d2f476e6->m_frame.f_lineno = 2717;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 2717;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2719;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_EVP_get_digestbyname );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2719;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
    }

    if ( tmp_called_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
        exception_tb = NULL;

        exception_lineno = 2719;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_digest;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_8eb0152ada49813b33550455d2f476e6->m_frame.f_lineno = 2719;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2719;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_8eb0152ada49813b33550455d2f476e6->m_frame.f_lineno = 2719;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2719;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_digest_obj == NULL );
    var_digest_obj = tmp_assign_source_1;

    tmp_compare_left_1 = var_digest_obj;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2720;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2720;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 2720;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_3 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
    frame_8eb0152ada49813b33550455d2f476e6->m_frame.f_lineno = 2721;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 2721;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2723;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NETSCAPE_SPKI_sign );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2723;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__spki );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 2724;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_pkey;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 2724;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_digest_obj;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_8eb0152ada49813b33550455d2f476e6->m_frame.f_lineno = 2723;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2723;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_sign_result == NULL );
    var_sign_result = tmp_assign_source_2;

    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2726;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_sign_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_6 = RICH_COMPARE_GT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2726;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_8eb0152ada49813b33550455d2f476e6->m_frame.f_lineno = 2726;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2726;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8eb0152ada49813b33550455d2f476e6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8eb0152ada49813b33550455d2f476e6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8eb0152ada49813b33550455d2f476e6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8eb0152ada49813b33550455d2f476e6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8eb0152ada49813b33550455d2f476e6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8eb0152ada49813b33550455d2f476e6,
        type_description_1,
        par_self,
        par_pkey,
        par_digest,
        var_digest_obj,
        var_sign_result
    );


    // Release cached frame.
    if ( frame_8eb0152ada49813b33550455d2f476e6 == cache_frame_8eb0152ada49813b33550455d2f476e6 )
    {
        Py_DECREF( frame_8eb0152ada49813b33550455d2f476e6 );
    }
    cache_frame_8eb0152ada49813b33550455d2f476e6 = NULL;

    assertFrameObject( frame_8eb0152ada49813b33550455d2f476e6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_141_sign );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_digest_obj );
    Py_DECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)var_sign_result );
    Py_DECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_digest_obj );
    var_digest_obj = NULL;

    Py_XDECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_141_sign );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_142_verify( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *var_answer = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_LtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_33a88964d744834d19cbcd47d9aefd1b = NULL;

    struct Nuitka_FrameObject *frame_33a88964d744834d19cbcd47d9aefd1b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_33a88964d744834d19cbcd47d9aefd1b, codeobj_33a88964d744834d19cbcd47d9aefd1b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_33a88964d744834d19cbcd47d9aefd1b = cache_frame_33a88964d744834d19cbcd47d9aefd1b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_33a88964d744834d19cbcd47d9aefd1b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_33a88964d744834d19cbcd47d9aefd1b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2740;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NETSCAPE_SPKI_verify );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2740;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__spki );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2740;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_key;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 2740;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_33a88964d744834d19cbcd47d9aefd1b->m_frame.f_lineno = 2740;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2740;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_answer == NULL );
    var_answer = tmp_assign_source_1;

    tmp_compare_left_1 = var_answer;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_LtE_1 = RICH_COMPARE_BOOL_LE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_LtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2741;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_LtE_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 2742;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_33a88964d744834d19cbcd47d9aefd1b->m_frame.f_lineno = 2742;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2742;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_33a88964d744834d19cbcd47d9aefd1b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_33a88964d744834d19cbcd47d9aefd1b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_33a88964d744834d19cbcd47d9aefd1b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_33a88964d744834d19cbcd47d9aefd1b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_33a88964d744834d19cbcd47d9aefd1b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_33a88964d744834d19cbcd47d9aefd1b,
        type_description_1,
        par_self,
        par_key,
        var_answer
    );


    // Release cached frame.
    if ( frame_33a88964d744834d19cbcd47d9aefd1b == cache_frame_33a88964d744834d19cbcd47d9aefd1b )
    {
        Py_DECREF( frame_33a88964d744834d19cbcd47d9aefd1b );
    }
    cache_frame_33a88964d744834d19cbcd47d9aefd1b = NULL;

    assertFrameObject( frame_33a88964d744834d19cbcd47d9aefd1b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_142_verify );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_answer );
    Py_DECREF( var_answer );
    var_answer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_answer );
    var_answer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_142_verify );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_143_b64_encode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_encoded = NULL;
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_119480fb0feb54a4f011bffa2f21182e = NULL;

    struct Nuitka_FrameObject *frame_119480fb0feb54a4f011bffa2f21182e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_119480fb0feb54a4f011bffa2f21182e, codeobj_119480fb0feb54a4f011bffa2f21182e, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_119480fb0feb54a4f011bffa2f21182e = cache_frame_119480fb0feb54a4f011bffa2f21182e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_119480fb0feb54a4f011bffa2f21182e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_119480fb0feb54a4f011bffa2f21182e ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2752;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NETSCAPE_SPKI_b64_encode );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2752;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__spki );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2752;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_119480fb0feb54a4f011bffa2f21182e->m_frame.f_lineno = 2752;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2752;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_encoded == NULL );
    var_encoded = tmp_assign_source_1;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2753;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_encoded;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_119480fb0feb54a4f011bffa2f21182e->m_frame.f_lineno = 2753;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_string, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2753;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_2;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2754;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_encoded;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_119480fb0feb54a4f011bffa2f21182e->m_frame.f_lineno = 2754;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_OPENSSL_free, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2754;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_119480fb0feb54a4f011bffa2f21182e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_119480fb0feb54a4f011bffa2f21182e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_119480fb0feb54a4f011bffa2f21182e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_119480fb0feb54a4f011bffa2f21182e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_119480fb0feb54a4f011bffa2f21182e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_119480fb0feb54a4f011bffa2f21182e,
        type_description_1,
        par_self,
        var_encoded,
        var_result
    );


    // Release cached frame.
    if ( frame_119480fb0feb54a4f011bffa2f21182e == cache_frame_119480fb0feb54a4f011bffa2f21182e )
    {
        Py_DECREF( frame_119480fb0feb54a4f011bffa2f21182e );
    }
    cache_frame_119480fb0feb54a4f011bffa2f21182e = NULL;

    assertFrameObject( frame_119480fb0feb54a4f011bffa2f21182e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_143_b64_encode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_encoded );
    Py_DECREF( var_encoded );
    var_encoded = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_encoded );
    var_encoded = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_143_b64_encode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_144_get_pubkey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_pkey = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_e7ae04d16d91e8d239c7d8ea0b0f0b05 = NULL;

    struct Nuitka_FrameObject *frame_e7ae04d16d91e8d239c7d8ea0b0f0b05;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e7ae04d16d91e8d239c7d8ea0b0f0b05, codeobj_e7ae04d16d91e8d239c7d8ea0b0f0b05, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_e7ae04d16d91e8d239c7d8ea0b0f0b05 = cache_frame_e7ae04d16d91e8d239c7d8ea0b0f0b05;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e7ae04d16d91e8d239c7d8ea0b0f0b05 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e7ae04d16d91e8d239c7d8ea0b0f0b05 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 2764;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2764;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_args_element_name_1 == NULL ))
    {
        tmp_args_element_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 2764;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_e7ae04d16d91e8d239c7d8ea0b0f0b05->m_frame.f_lineno = 2764;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2764;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_pkey == NULL );
    var_pkey = tmp_assign_source_1;

    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2765;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NETSCAPE_SPKI_get_pubkey );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2765;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__spki );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2765;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_e7ae04d16d91e8d239c7d8ea0b0f0b05->m_frame.f_lineno = 2765;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2765;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 2765;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2766;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_4 = var_pkey;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__pkey );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2766;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_compexpr_left_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2766;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 2766;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2766;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_e7ae04d16d91e8d239c7d8ea0b0f0b05->m_frame.f_lineno = 2766;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2766;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2767;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_gc );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2767;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = var_pkey;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 2767;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2767;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_EVP_PKEY_free );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 2767;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_e7ae04d16d91e8d239c7d8ea0b0f0b05->m_frame.f_lineno = 2767;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2767;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__pkey, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 2767;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_assattr_name_3 = Py_True;
    tmp_assattr_target_3 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__only_public, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2768;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e7ae04d16d91e8d239c7d8ea0b0f0b05 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e7ae04d16d91e8d239c7d8ea0b0f0b05 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e7ae04d16d91e8d239c7d8ea0b0f0b05, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e7ae04d16d91e8d239c7d8ea0b0f0b05->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e7ae04d16d91e8d239c7d8ea0b0f0b05, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e7ae04d16d91e8d239c7d8ea0b0f0b05,
        type_description_1,
        par_self,
        var_pkey
    );


    // Release cached frame.
    if ( frame_e7ae04d16d91e8d239c7d8ea0b0f0b05 == cache_frame_e7ae04d16d91e8d239c7d8ea0b0f0b05 )
    {
        Py_DECREF( frame_e7ae04d16d91e8d239c7d8ea0b0f0b05 );
    }
    cache_frame_e7ae04d16d91e8d239c7d8ea0b0f0b05 = NULL;

    assertFrameObject( frame_e7ae04d16d91e8d239c7d8ea0b0f0b05 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_pkey;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_144_get_pubkey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_144_get_pubkey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_145_set_pubkey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *var_set_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_8288a95eb966387b5a4b6507bc1f1a0b = NULL;

    struct Nuitka_FrameObject *frame_8288a95eb966387b5a4b6507bc1f1a0b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8288a95eb966387b5a4b6507bc1f1a0b, codeobj_8288a95eb966387b5a4b6507bc1f1a0b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8288a95eb966387b5a4b6507bc1f1a0b = cache_frame_8288a95eb966387b5a4b6507bc1f1a0b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8288a95eb966387b5a4b6507bc1f1a0b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8288a95eb966387b5a4b6507bc1f1a0b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2778;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NETSCAPE_SPKI_set_pubkey );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2778;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__spki );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2778;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_pkey;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 2778;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_8288a95eb966387b5a4b6507bc1f1a0b->m_frame.f_lineno = 2778;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2778;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_set_result == NULL );
    var_set_result = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2779;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_set_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_3 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2779;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_8288a95eb966387b5a4b6507bc1f1a0b->m_frame.f_lineno = 2779;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2779;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8288a95eb966387b5a4b6507bc1f1a0b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8288a95eb966387b5a4b6507bc1f1a0b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8288a95eb966387b5a4b6507bc1f1a0b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8288a95eb966387b5a4b6507bc1f1a0b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8288a95eb966387b5a4b6507bc1f1a0b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8288a95eb966387b5a4b6507bc1f1a0b,
        type_description_1,
        par_self,
        par_pkey,
        var_set_result
    );


    // Release cached frame.
    if ( frame_8288a95eb966387b5a4b6507bc1f1a0b == cache_frame_8288a95eb966387b5a4b6507bc1f1a0b )
    {
        Py_DECREF( frame_8288a95eb966387b5a4b6507bc1f1a0b );
    }
    cache_frame_8288a95eb966387b5a4b6507bc1f1a0b = NULL;

    assertFrameObject( frame_8288a95eb966387b5a4b6507bc1f1a0b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_145_set_pubkey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_145_set_pubkey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_146___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_type = python_pars[ 1 ];
    PyObject *par_passphrase = python_pars[ 2 ];
    PyObject *par_more_args = python_pars[ 3 ];
    PyObject *par_truncate = python_pars[ 4 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_e284a8d70714fdb79809fb1913c8d00d = NULL;

    struct Nuitka_FrameObject *frame_e284a8d70714fdb79809fb1913c8d00d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e284a8d70714fdb79809fb1913c8d00d, codeobj_e284a8d70714fdb79809fb1913c8d00d, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e284a8d70714fdb79809fb1913c8d00d = cache_frame_e284a8d70714fdb79809fb1913c8d00d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e284a8d70714fdb79809fb1913c8d00d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e284a8d70714fdb79809fb1913c8d00d ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_type;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_compexpr_right_1 == NULL ))
    {
        tmp_compexpr_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_compexpr_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 2784;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_and_left_value_1 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2784;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 2784;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_compexpr_left_2 = par_passphrase;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = Py_None;
    tmp_and_right_value_1 = BOOL_FROM( tmp_compexpr_left_2 != tmp_compexpr_right_2 );
    Py_INCREF( tmp_and_right_value_1 );
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 2784;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_d546905f9a7fd3b3fc24a90a7432aa72;
    frame_e284a8d70714fdb79809fb1913c8d00d->m_frame.f_lineno = 2785;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2785;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = par_passphrase;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__passphrase, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2788;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_more_args;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__more_args, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2789;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = par_truncate;

    CHECK_OBJECT( tmp_assattr_name_3 );
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__truncate, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2790;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_4 = PyList_New( 0 );
    tmp_assattr_target_4 = par_self;

    CHECK_OBJECT( tmp_assattr_target_4 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__problems, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_4 );

        exception_lineno = 2791;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_4 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e284a8d70714fdb79809fb1913c8d00d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e284a8d70714fdb79809fb1913c8d00d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e284a8d70714fdb79809fb1913c8d00d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e284a8d70714fdb79809fb1913c8d00d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e284a8d70714fdb79809fb1913c8d00d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e284a8d70714fdb79809fb1913c8d00d,
        type_description_1,
        par_self,
        par_type,
        par_passphrase,
        par_more_args,
        par_truncate
    );


    // Release cached frame.
    if ( frame_e284a8d70714fdb79809fb1913c8d00d == cache_frame_e284a8d70714fdb79809fb1913c8d00d )
    {
        Py_DECREF( frame_e284a8d70714fdb79809fb1913c8d00d );
    }
    cache_frame_e284a8d70714fdb79809fb1913c8d00d = NULL;

    assertFrameObject( frame_e284a8d70714fdb79809fb1913c8d00d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_146___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_more_args );
    Py_DECREF( par_more_args );
    par_more_args = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)par_truncate );
    Py_DECREF( par_truncate );
    par_truncate = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_more_args );
    Py_DECREF( par_more_args );
    par_more_args = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)par_truncate );
    Py_DECREF( par_truncate );
    par_truncate = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_146___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_147_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    static struct Nuitka_FrameObject *cache_frame_b937f289fb17e79995f422e1b9152e9d = NULL;

    struct Nuitka_FrameObject *frame_b937f289fb17e79995f422e1b9152e9d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b937f289fb17e79995f422e1b9152e9d, codeobj_b937f289fb17e79995f422e1b9152e9d, module_OpenSSL$crypto, sizeof(void *) );
    frame_b937f289fb17e79995f422e1b9152e9d = cache_frame_b937f289fb17e79995f422e1b9152e9d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b937f289fb17e79995f422e1b9152e9d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b937f289fb17e79995f422e1b9152e9d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__passphrase );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2795;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2796;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2796;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_isinstance_inst_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__passphrase );
    if ( tmp_isinstance_inst_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2797;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
    tmp_or_left_value_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_inst_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2797;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2797;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_callable );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__passphrase );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2797;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_b937f289fb17e79995f422e1b9152e9d->m_frame.f_lineno = 2797;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_or_right_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2797;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    Py_INCREF( tmp_or_left_value_1 );
    tmp_cond_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 2797;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2798;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_callback );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2798;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = const_str_plain_pem_password_cb;
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__read_passphrase );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2798;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_b937f289fb17e79995f422e1b9152e9d->m_frame.f_lineno = 2798;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2798;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_2;
    branch_no_2:;
    tmp_make_exception_arg_1 = const_str_digest_7db2dd03172a07cae912434bb4ced82e;
    frame_b937f289fb17e79995f422e1b9152e9d->m_frame.f_lineno = 2800;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2800;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "o";
    goto frame_exception_exit_1;
    branch_end_2:;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b937f289fb17e79995f422e1b9152e9d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b937f289fb17e79995f422e1b9152e9d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b937f289fb17e79995f422e1b9152e9d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b937f289fb17e79995f422e1b9152e9d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b937f289fb17e79995f422e1b9152e9d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b937f289fb17e79995f422e1b9152e9d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b937f289fb17e79995f422e1b9152e9d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b937f289fb17e79995f422e1b9152e9d == cache_frame_b937f289fb17e79995f422e1b9152e9d )
    {
        Py_DECREF( frame_b937f289fb17e79995f422e1b9152e9d );
    }
    cache_frame_b937f289fb17e79995f422e1b9152e9d = NULL;

    assertFrameObject( frame_b937f289fb17e79995f422e1b9152e9d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_147_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_147_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_148_callback_args( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    static struct Nuitka_FrameObject *cache_frame_74cde753c21d561d79e5c3fb8ec14b96 = NULL;

    struct Nuitka_FrameObject *frame_74cde753c21d561d79e5c3fb8ec14b96;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_74cde753c21d561d79e5c3fb8ec14b96, codeobj_74cde753c21d561d79e5c3fb8ec14b96, module_OpenSSL$crypto, sizeof(void *) );
    frame_74cde753c21d561d79e5c3fb8ec14b96 = cache_frame_74cde753c21d561d79e5c3fb8ec14b96;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_74cde753c21d561d79e5c3fb8ec14b96 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_74cde753c21d561d79e5c3fb8ec14b96 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__passphrase );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2806;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2807;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2807;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_isinstance_inst_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__passphrase );
    if ( tmp_isinstance_inst_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2808;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
    tmp_or_left_value_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_inst_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2808;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2808;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_callable );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__passphrase );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2808;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_74cde753c21d561d79e5c3fb8ec14b96->m_frame.f_lineno = 2808;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_or_right_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2808;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    Py_INCREF( tmp_or_left_value_1 );
    tmp_cond_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 2808;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2809;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2809;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_2;
    branch_no_2:;
    tmp_make_exception_arg_1 = const_str_digest_7db2dd03172a07cae912434bb4ced82e;
    frame_74cde753c21d561d79e5c3fb8ec14b96->m_frame.f_lineno = 2811;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2811;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "o";
    goto frame_exception_exit_1;
    branch_end_2:;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_74cde753c21d561d79e5c3fb8ec14b96 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_74cde753c21d561d79e5c3fb8ec14b96 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_74cde753c21d561d79e5c3fb8ec14b96 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_74cde753c21d561d79e5c3fb8ec14b96, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_74cde753c21d561d79e5c3fb8ec14b96->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_74cde753c21d561d79e5c3fb8ec14b96, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_74cde753c21d561d79e5c3fb8ec14b96,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_74cde753c21d561d79e5c3fb8ec14b96 == cache_frame_74cde753c21d561d79e5c3fb8ec14b96 )
    {
        Py_DECREF( frame_74cde753c21d561d79e5c3fb8ec14b96 );
    }
    cache_frame_74cde753c21d561d79e5c3fb8ec14b96 = NULL;

    assertFrameObject( frame_74cde753c21d561d79e5c3fb8ec14b96 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_148_callback_args );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_148_callback_args );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_149_raise_if_problem( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_exceptionType = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_81d019b3ef51f73c296d9bd966429c42 = NULL;

    struct Nuitka_FrameObject *frame_81d019b3ef51f73c296d9bd966429c42;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_81d019b3ef51f73c296d9bd966429c42, codeobj_81d019b3ef51f73c296d9bd966429c42, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_81d019b3ef51f73c296d9bd966429c42 = cache_frame_81d019b3ef51f73c296d9bd966429c42;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_81d019b3ef51f73c296d9bd966429c42 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_81d019b3ef51f73c296d9bd966429c42 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__problems );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2816;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 2816;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    // Tried code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_exception_from_error_queue" );
        exception_tb = NULL;

        exception_lineno = 2820;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_1 = par_exceptionType;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_81d019b3ef51f73c296d9bd966429c42->m_frame.f_lineno = 2820;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2820;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_81d019b3ef51f73c296d9bd966429c42 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_81d019b3ef51f73c296d9bd966429c42, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_81d019b3ef51f73c296d9bd966429c42, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = par_exceptionType;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2821;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 2819;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_81d019b3ef51f73c296d9bd966429c42->m_frame) frame_81d019b3ef51f73c296d9bd966429c42->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_2:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_149_raise_if_problem );
    return NULL;
    // End of try:
    try_end_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__problems );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2824;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_81d019b3ef51f73c296d9bd966429c42->m_frame.f_lineno = 2824;
    tmp_raise_type_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_pop, &PyTuple_GET_ITEM( const_tuple_int_0_tuple, 0 ) );

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_raise_type_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2824;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_1;
    exception_lineno = 2824;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_81d019b3ef51f73c296d9bd966429c42 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_81d019b3ef51f73c296d9bd966429c42 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_81d019b3ef51f73c296d9bd966429c42, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_81d019b3ef51f73c296d9bd966429c42->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_81d019b3ef51f73c296d9bd966429c42, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_81d019b3ef51f73c296d9bd966429c42,
        type_description_1,
        par_self,
        par_exceptionType
    );


    // Release cached frame.
    if ( frame_81d019b3ef51f73c296d9bd966429c42 == cache_frame_81d019b3ef51f73c296d9bd966429c42 )
    {
        Py_DECREF( frame_81d019b3ef51f73c296d9bd966429c42 );
    }
    cache_frame_81d019b3ef51f73c296d9bd966429c42 = NULL;

    assertFrameObject( frame_81d019b3ef51f73c296d9bd966429c42 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_149_raise_if_problem );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exceptionType );
    Py_DECREF( par_exceptionType );
    par_exceptionType = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exceptionType );
    Py_DECREF( par_exceptionType );
    par_exceptionType = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_149_raise_if_problem );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_150__read_passphrase( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buf = python_pars[ 1 ];
    PyObject *par_size = python_pars[ 2 ];
    PyObject *par_rwflag = python_pars[ 3 ];
    PyObject *par_userdata = python_pars[ 4 ];
    PyObject *var_e = NULL;
    PyObject *var_i = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    PyObject *tmp_len_arg_3;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_range_arg_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_slice_lower_1;
    PyObject *tmp_slice_source_1;
    PyObject *tmp_slice_source_2;
    PyObject *tmp_slice_upper_1;
    PyObject *tmp_slice_upper_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_aa80a5d36a11ceafba5ad49aa16e30e0 = NULL;

    struct Nuitka_FrameObject *frame_aa80a5d36a11ceafba5ad49aa16e30e0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_aa80a5d36a11ceafba5ad49aa16e30e0, codeobj_aa80a5d36a11ceafba5ad49aa16e30e0, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_aa80a5d36a11ceafba5ad49aa16e30e0 = cache_frame_aa80a5d36a11ceafba5ad49aa16e30e0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_aa80a5d36a11ceafba5ad49aa16e30e0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_aa80a5d36a11ceafba5ad49aa16e30e0 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_callable );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__passphrase );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2828;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    frame_aa80a5d36a11ceafba5ad49aa16e30e0->m_frame.f_lineno = 2828;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2828;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 2828;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_cond_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__more_args );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2829;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 2829;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_2 = par_size;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_rwflag;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = par_userdata;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_aa80a5d36a11ceafba5ad49aa16e30e0->m_frame.f_lineno = 2830;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain__passphrase, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2830;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    goto branch_end_2;
    branch_no_2:;
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_5 = par_rwflag;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_aa80a5d36a11ceafba5ad49aa16e30e0->m_frame.f_lineno = 2832;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__passphrase, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2832;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_2;

    branch_end_2:;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__passphrase );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2834;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_3;

    branch_end_1:;
    tmp_isinstance_inst_1 = var_result;

    if ( tmp_isinstance_inst_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;

        exception_lineno = 2835;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }

    tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2835;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_1 = const_str_digest_517da8fff62752bad266dd317b6fd3d1;
    frame_aa80a5d36a11ceafba5ad49aa16e30e0->m_frame.f_lineno = 2836;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2836;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooo";
    goto try_except_handler_2;
    branch_no_3:;
    tmp_len_arg_1 = var_result;

    if ( tmp_len_arg_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;

        exception_lineno = 2837;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }

    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2837;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    tmp_compare_right_1 = par_size;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 2837;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_cond_value_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__truncate );
    if ( tmp_cond_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2838;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 2838;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_slice_source_1 = var_result;

    if ( tmp_slice_source_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;

        exception_lineno = 2839;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }

    tmp_slice_upper_1 = par_size;

    CHECK_OBJECT( tmp_slice_upper_1 );
    tmp_assign_source_4 = LOOKUP_SLICE( tmp_slice_source_1, Py_None, tmp_slice_upper_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2839;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_result;
        var_result = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    goto branch_end_5;
    branch_no_5:;
    tmp_make_exception_arg_2 = const_str_digest_9cb57ebafd0926d1746d2e66a6198efe;
    frame_aa80a5d36a11ceafba5ad49aa16e30e0->m_frame.f_lineno = 2841;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 2841;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooo";
    goto try_except_handler_2;
    branch_end_5:;
    branch_no_4:;
    tmp_len_arg_2 = var_result;

    if ( tmp_len_arg_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;

        exception_lineno = 2844;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }

    tmp_range_arg_1 = BUILTIN_LEN( tmp_len_arg_2 );
    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2844;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2844;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2844;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_5;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_6 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_6 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooo";
        exception_lineno = 2844;
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_2 = exception_keeper_type_1;
    tmp_compare_right_2 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 2844;
        type_description_1 = "oooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_6;
    branch_no_6:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_3;
    branch_end_6:;
    // End of try:
    try_end_1:;
    tmp_assign_source_7 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_7 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_7;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_slice_source_2 = var_result;

    if ( tmp_slice_source_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;

        exception_lineno = 2845;
        type_description_1 = "oooooooo";
        goto try_except_handler_3;
    }

    tmp_slice_lower_1 = var_i;

    CHECK_OBJECT( tmp_slice_lower_1 );
    tmp_left_name_1 = var_i;

    CHECK_OBJECT( tmp_left_name_1 );
    tmp_right_name_1 = const_int_pos_1;
    tmp_slice_upper_2 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_slice_upper_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2845;
        type_description_1 = "oooooooo";
        goto try_except_handler_3;
    }
    tmp_ass_subvalue_1 = LOOKUP_SLICE( tmp_slice_source_2, tmp_slice_lower_1, tmp_slice_upper_2 );
    Py_DECREF( tmp_slice_upper_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2845;
        type_description_1 = "oooooooo";
        goto try_except_handler_3;
    }
    tmp_ass_subscribed_1 = par_buf;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = var_i;

    CHECK_OBJECT( tmp_ass_subscript_1 );
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2845;
        type_description_1 = "oooooooo";
        goto try_except_handler_3;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2844;
        type_description_1 = "oooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_len_arg_3 = var_result;

    if ( tmp_len_arg_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;

        exception_lineno = 2846;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }

    tmp_return_value = BUILTIN_LEN( tmp_len_arg_3 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2846;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    goto frame_return_exit_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_150__read_passphrase );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_aa80a5d36a11ceafba5ad49aa16e30e0 );
    if ( exception_keeper_tb_3 == NULL )
    {
        exception_keeper_tb_3 = MAKE_TRACEBACK( frame_aa80a5d36a11ceafba5ad49aa16e30e0, exception_keeper_lineno_3 );
    }
    else if ( exception_keeper_lineno_3 != 0 )
    {
        exception_keeper_tb_3 = ADD_TRACEBACK( exception_keeper_tb_3, frame_aa80a5d36a11ceafba5ad49aa16e30e0, exception_keeper_lineno_3 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    PUBLISH_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    tmp_compare_left_3 = PyThreadState_GET()->exc_type;
    tmp_compare_right_3 = PyExc_Exception;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2847;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_assign_source_8 = PyThreadState_GET()->exc_value;
    assert( var_e == NULL );
    Py_INCREF( tmp_assign_source_8 );
    var_e = tmp_assign_source_8;

    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__problems );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2848;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_e;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_aa80a5d36a11ceafba5ad49aa16e30e0->m_frame.f_lineno = 2848;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_append, call_args );
    }

    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2848;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_7;
    branch_no_7:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 2827;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_aa80a5d36a11ceafba5ad49aa16e30e0->m_frame) frame_aa80a5d36a11ceafba5ad49aa16e30e0->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooooooo";
    goto frame_exception_exit_1;
    branch_end_7:;
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_aa80a5d36a11ceafba5ad49aa16e30e0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_aa80a5d36a11ceafba5ad49aa16e30e0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_aa80a5d36a11ceafba5ad49aa16e30e0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_aa80a5d36a11ceafba5ad49aa16e30e0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_aa80a5d36a11ceafba5ad49aa16e30e0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_aa80a5d36a11ceafba5ad49aa16e30e0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_aa80a5d36a11ceafba5ad49aa16e30e0,
        type_description_1,
        par_self,
        par_buf,
        par_size,
        par_rwflag,
        par_userdata,
        var_e,
        var_i,
        var_result
    );


    // Release cached frame.
    if ( frame_aa80a5d36a11ceafba5ad49aa16e30e0 == cache_frame_aa80a5d36a11ceafba5ad49aa16e30e0 )
    {
        Py_DECREF( frame_aa80a5d36a11ceafba5ad49aa16e30e0 );
    }
    cache_frame_aa80a5d36a11ceafba5ad49aa16e30e0 = NULL;

    assertFrameObject( frame_aa80a5d36a11ceafba5ad49aa16e30e0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_150__read_passphrase );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_userdata );
    Py_DECREF( par_userdata );
    par_userdata = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)par_rwflag );
    Py_DECREF( par_rwflag );
    par_rwflag = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    CHECK_OBJECT( (PyObject *)par_size );
    Py_DECREF( par_size );
    par_size = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_userdata );
    Py_DECREF( par_userdata );
    par_userdata = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)par_rwflag );
    Py_DECREF( par_rwflag );
    par_rwflag = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    CHECK_OBJECT( (PyObject *)par_size );
    Py_DECREF( par_size );
    par_size = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_150__read_passphrase );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_151_load_publickey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_pkey = NULL;
    PyObject *var_evp_pkey = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_95e8045ab91a3cf5ec43d09da1cff4dc = NULL;

    struct Nuitka_FrameObject *frame_95e8045ab91a3cf5ec43d09da1cff4dc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_95e8045ab91a3cf5ec43d09da1cff4dc, codeobj_95e8045ab91a3cf5ec43d09da1cff4dc, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_95e8045ab91a3cf5ec43d09da1cff4dc = cache_frame_95e8045ab91a3cf5ec43d09da1cff4dc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_95e8045ab91a3cf5ec43d09da1cff4dc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_95e8045ab91a3cf5ec43d09da1cff4dc ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_buffer;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
        exception_tb = NULL;

        exception_lineno = 2863;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2863;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_buffer;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_95e8045ab91a3cf5ec43d09da1cff4dc->m_frame.f_lineno = 2864;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2864;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_buffer;
        assert( old != NULL );
        par_buffer = tmp_assign_source_1;
        Py_DECREF( old );
    }

    branch_no_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 2866;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_buffer;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_95e8045ab91a3cf5ec43d09da1cff4dc->m_frame.f_lineno = 2866;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2866;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_2;

    tmp_compare_left_1 = par_type;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 2868;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2868;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2869;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_read_bio_PUBKEY );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2869;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2870;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2870;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2870;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 2870;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2870;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 2870;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_95e8045ab91a3cf5ec43d09da1cff4dc->m_frame.f_lineno = 2869;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2869;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_evp_pkey == NULL );
    var_evp_pkey = tmp_assign_source_3;

    goto branch_end_2;
    branch_no_2:;
    tmp_compare_left_2 = par_type;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

    if (unlikely( tmp_compare_right_2 == NULL ))
    {
        tmp_compare_right_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
    }

    if ( tmp_compare_right_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
        exception_tb = NULL;

        exception_lineno = 2872;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2872;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2873;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_d2i_PUBKEY_bio );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2873;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2873;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 2873;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_95e8045ab91a3cf5ec43d09da1cff4dc->m_frame.f_lineno = 2873;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2873;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_evp_pkey == NULL );
    var_evp_pkey = tmp_assign_source_4;

    goto branch_end_3;
    branch_no_3:;
    tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
    frame_95e8045ab91a3cf5ec43d09da1cff4dc->m_frame.f_lineno = 2875;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2875;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_end_3:;
    branch_end_2:;
    tmp_compare_left_3 = var_evp_pkey;

    if ( tmp_compare_left_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "evp_pkey" );
        exception_tb = NULL;

        exception_lineno = 2877;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2877;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
    if ( tmp_compare_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2877;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_3 );

        exception_lineno = 2877;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 2878;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_95e8045ab91a3cf5ec43d09da1cff4dc->m_frame.f_lineno = 2878;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2878;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 2880;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain___new__ );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2880;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_args_element_name_8 == NULL ))
    {
        tmp_args_element_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_args_element_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 2880;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_95e8045ab91a3cf5ec43d09da1cff4dc->m_frame.f_lineno = 2880;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2880;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pkey == NULL );
    var_pkey = tmp_assign_source_5;

    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2881;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_gc );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2881;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_evp_pkey;

    if ( tmp_args_element_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "evp_pkey" );
        exception_tb = NULL;

        exception_lineno = 2881;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2881;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_EVP_PKEY_free );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 2881;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_95e8045ab91a3cf5ec43d09da1cff4dc->m_frame.f_lineno = 2881;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2881;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 2881;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_assattr_name_2 = Py_True;
    tmp_assattr_target_2 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__only_public, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2882;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_95e8045ab91a3cf5ec43d09da1cff4dc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_95e8045ab91a3cf5ec43d09da1cff4dc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_95e8045ab91a3cf5ec43d09da1cff4dc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_95e8045ab91a3cf5ec43d09da1cff4dc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_95e8045ab91a3cf5ec43d09da1cff4dc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_95e8045ab91a3cf5ec43d09da1cff4dc,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_pkey,
        var_evp_pkey
    );


    // Release cached frame.
    if ( frame_95e8045ab91a3cf5ec43d09da1cff4dc == cache_frame_95e8045ab91a3cf5ec43d09da1cff4dc )
    {
        Py_DECREF( frame_95e8045ab91a3cf5ec43d09da1cff4dc );
    }
    cache_frame_95e8045ab91a3cf5ec43d09da1cff4dc = NULL;

    assertFrameObject( frame_95e8045ab91a3cf5ec43d09da1cff4dc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_pkey;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_151_load_publickey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    Py_XDECREF( var_evp_pkey );
    var_evp_pkey = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    Py_XDECREF( var_evp_pkey );
    var_evp_pkey = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_151_load_publickey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_152_load_privatekey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *par_passphrase = python_pars[ 2 ];
    PyObject *var_bio = NULL;
    PyObject *var_helper = NULL;
    PyObject *var_pkey = NULL;
    PyObject *var_evp_pkey = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_ee8c5e94f6b2bf50cc0c751599edbbf4 = NULL;

    struct Nuitka_FrameObject *frame_ee8c5e94f6b2bf50cc0c751599edbbf4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ee8c5e94f6b2bf50cc0c751599edbbf4, codeobj_ee8c5e94f6b2bf50cc0c751599edbbf4, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ee8c5e94f6b2bf50cc0c751599edbbf4 = cache_frame_ee8c5e94f6b2bf50cc0c751599edbbf4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ee8c5e94f6b2bf50cc0c751599edbbf4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ee8c5e94f6b2bf50cc0c751599edbbf4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_buffer;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
        exception_tb = NULL;

        exception_lineno = 2899;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2899;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_buffer;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_ee8c5e94f6b2bf50cc0c751599edbbf4->m_frame.f_lineno = 2900;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2900;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_buffer;
        assert( old != NULL );
        par_buffer = tmp_assign_source_1;
        Py_DECREF( old );
    }

    branch_no_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 2902;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_buffer;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_ee8c5e94f6b2bf50cc0c751599edbbf4->m_frame.f_lineno = 2902;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2902;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_2;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PassphraseHelper );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PassphraseHelper );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_PassphraseHelper" );
        exception_tb = NULL;

        exception_lineno = 2904;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_type;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_passphrase;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_ee8c5e94f6b2bf50cc0c751599edbbf4->m_frame.f_lineno = 2904;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2904;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_helper == NULL );
    var_helper = tmp_assign_source_3;

    tmp_compare_left_1 = par_type;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 2905;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2905;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2906;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_read_bio_PrivateKey );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2906;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2907;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 2907;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = var_helper;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_callback );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 2907;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = var_helper;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_callback_args );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );

        exception_lineno = 2907;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_ee8c5e94f6b2bf50cc0c751599edbbf4->m_frame.f_lineno = 2906;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2906;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_evp_pkey == NULL );
    var_evp_pkey = tmp_assign_source_4;

    tmp_called_instance_2 = var_helper;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_ee8c5e94f6b2bf50cc0c751599edbbf4->m_frame.f_lineno = 2909;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_raise_if_problem );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2909;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_2;
    branch_no_2:;
    tmp_compare_left_2 = par_type;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

    if (unlikely( tmp_compare_right_2 == NULL ))
    {
        tmp_compare_right_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
    }

    if ( tmp_compare_right_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
        exception_tb = NULL;

        exception_lineno = 2910;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2910;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2911;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_d2i_PrivateKey_bio );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2911;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2911;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 2911;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_ee8c5e94f6b2bf50cc0c751599edbbf4->m_frame.f_lineno = 2911;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2911;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_evp_pkey == NULL );
    var_evp_pkey = tmp_assign_source_5;

    goto branch_end_3;
    branch_no_3:;
    tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
    frame_ee8c5e94f6b2bf50cc0c751599edbbf4->m_frame.f_lineno = 2913;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2913;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooo";
    goto frame_exception_exit_1;
    branch_end_3:;
    branch_end_2:;
    tmp_compare_left_3 = var_evp_pkey;

    if ( tmp_compare_left_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "evp_pkey" );
        exception_tb = NULL;

        exception_lineno = 2915;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2915;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
    if ( tmp_compare_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2915;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_3 );

        exception_lineno = 2915;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 2916;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    frame_ee8c5e94f6b2bf50cc0c751599edbbf4->m_frame.f_lineno = 2916;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2916;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 2918;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain___new__ );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2918;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_args_element_name_10 == NULL ))
    {
        tmp_args_element_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_args_element_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 2918;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    frame_ee8c5e94f6b2bf50cc0c751599edbbf4->m_frame.f_lineno = 2918;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2918;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pkey == NULL );
    var_pkey = tmp_assign_source_6;

    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2919;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_gc );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2919;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_11 = var_evp_pkey;

    if ( tmp_args_element_name_11 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "evp_pkey" );
        exception_tb = NULL;

        exception_lineno = 2919;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2919;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_EVP_PKEY_free );
    if ( tmp_args_element_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 2919;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_ee8c5e94f6b2bf50cc0c751599edbbf4->m_frame.f_lineno = 2919;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_12 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2919;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_pkey;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 2919;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ee8c5e94f6b2bf50cc0c751599edbbf4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ee8c5e94f6b2bf50cc0c751599edbbf4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ee8c5e94f6b2bf50cc0c751599edbbf4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ee8c5e94f6b2bf50cc0c751599edbbf4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ee8c5e94f6b2bf50cc0c751599edbbf4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ee8c5e94f6b2bf50cc0c751599edbbf4,
        type_description_1,
        par_type,
        par_buffer,
        par_passphrase,
        var_bio,
        var_helper,
        var_pkey,
        var_evp_pkey
    );


    // Release cached frame.
    if ( frame_ee8c5e94f6b2bf50cc0c751599edbbf4 == cache_frame_ee8c5e94f6b2bf50cc0c751599edbbf4 )
    {
        Py_DECREF( frame_ee8c5e94f6b2bf50cc0c751599edbbf4 );
    }
    cache_frame_ee8c5e94f6b2bf50cc0c751599edbbf4 = NULL;

    assertFrameObject( frame_ee8c5e94f6b2bf50cc0c751599edbbf4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_pkey;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_152_load_privatekey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)var_helper );
    Py_DECREF( var_helper );
    var_helper = NULL;

    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_evp_pkey );
    var_evp_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_helper );
    var_helper = NULL;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_evp_pkey );
    var_evp_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_152_load_privatekey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_153_dump_certificate_request( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_req = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_result_code = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_0a9fc1297fc6ce588e759c7014f8b308 = NULL;

    struct Nuitka_FrameObject *frame_0a9fc1297fc6ce588e759c7014f8b308;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0a9fc1297fc6ce588e759c7014f8b308, codeobj_0a9fc1297fc6ce588e759c7014f8b308, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0a9fc1297fc6ce588e759c7014f8b308 = cache_frame_0a9fc1297fc6ce588e759c7014f8b308;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0a9fc1297fc6ce588e759c7014f8b308 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0a9fc1297fc6ce588e759c7014f8b308 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 2932;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_0a9fc1297fc6ce588e759c7014f8b308->m_frame.f_lineno = 2932;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2932;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_1;

    tmp_compare_left_1 = par_type;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 2934;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2934;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2935;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_write_bio_X509_REQ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2935;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = par_req;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__req );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2935;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_0a9fc1297fc6ce588e759c7014f8b308->m_frame.f_lineno = 2935;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2935;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_code == NULL );
    var_result_code = tmp_assign_source_2;

    goto branch_end_1;
    branch_no_1:;
    tmp_compare_left_2 = par_type;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

    if (unlikely( tmp_compare_right_2 == NULL ))
    {
        tmp_compare_right_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
    }

    if ( tmp_compare_right_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
        exception_tb = NULL;

        exception_lineno = 2936;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2936;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2937;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_i2d_X509_REQ_bio );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2937;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_source_name_4 = par_req;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__req );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 2937;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_0a9fc1297fc6ce588e759c7014f8b308->m_frame.f_lineno = 2937;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2937;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_code == NULL );
    var_result_code = tmp_assign_source_3;

    goto branch_end_2;
    branch_no_2:;
    tmp_compare_left_3 = par_type;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );

    if (unlikely( tmp_compare_right_3 == NULL ))
    {
        tmp_compare_right_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );
    }

    if ( tmp_compare_right_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_TEXT" );
        exception_tb = NULL;

        exception_lineno = 2938;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2938;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2939;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_REQ_print_ex );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2939;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_source_name_6 = par_req;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__req );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 2939;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = const_int_0;
    tmp_args_element_name_8 = const_int_0;
    frame_0a9fc1297fc6ce588e759c7014f8b308->m_frame.f_lineno = 2939;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2939;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_result_code == NULL );
    var_result_code = tmp_assign_source_4;

    goto branch_end_3;
    branch_no_3:;
    tmp_make_exception_arg_1 = const_str_digest_11c225ccbab9acffc38107dee9691702;
    frame_0a9fc1297fc6ce588e759c7014f8b308->m_frame.f_lineno = 2941;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2941;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_end_3:;
    branch_end_2:;
    branch_end_1:;
    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2946;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_result_code;

    if ( tmp_compexpr_left_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result_code" );
        exception_tb = NULL;

        exception_lineno = 2946;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_9 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2946;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_0a9fc1297fc6ce588e759c7014f8b308->m_frame.f_lineno = 2946;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2946;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
        exception_tb = NULL;

        exception_lineno = 2948;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_0a9fc1297fc6ce588e759c7014f8b308->m_frame.f_lineno = 2948;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2948;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0a9fc1297fc6ce588e759c7014f8b308 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0a9fc1297fc6ce588e759c7014f8b308 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0a9fc1297fc6ce588e759c7014f8b308 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0a9fc1297fc6ce588e759c7014f8b308, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0a9fc1297fc6ce588e759c7014f8b308->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0a9fc1297fc6ce588e759c7014f8b308, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0a9fc1297fc6ce588e759c7014f8b308,
        type_description_1,
        par_type,
        par_req,
        var_bio,
        var_result_code
    );


    // Release cached frame.
    if ( frame_0a9fc1297fc6ce588e759c7014f8b308 == cache_frame_0a9fc1297fc6ce588e759c7014f8b308 )
    {
        Py_DECREF( frame_0a9fc1297fc6ce588e759c7014f8b308 );
    }
    cache_frame_0a9fc1297fc6ce588e759c7014f8b308 = NULL;

    assertFrameObject( frame_0a9fc1297fc6ce588e759c7014f8b308 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_153_dump_certificate_request );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_req );
    Py_DECREF( par_req );
    par_req = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_req );
    Py_DECREF( par_req );
    par_req = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_153_dump_certificate_request );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_154_load_certificate_request( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_req = NULL;
    PyObject *var_x509req = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_14c48645ee3ca3c857b7652479da20fc = NULL;

    struct Nuitka_FrameObject *frame_14c48645ee3ca3c857b7652479da20fc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_14c48645ee3ca3c857b7652479da20fc, codeobj_14c48645ee3ca3c857b7652479da20fc, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_14c48645ee3ca3c857b7652479da20fc = cache_frame_14c48645ee3ca3c857b7652479da20fc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_14c48645ee3ca3c857b7652479da20fc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_14c48645ee3ca3c857b7652479da20fc ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_buffer;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
        exception_tb = NULL;

        exception_lineno = 2960;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2960;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_buffer;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_14c48645ee3ca3c857b7652479da20fc->m_frame.f_lineno = 2961;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2961;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_buffer;
        assert( old != NULL );
        par_buffer = tmp_assign_source_1;
        Py_DECREF( old );
    }

    branch_no_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 2963;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_buffer;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_14c48645ee3ca3c857b7652479da20fc->m_frame.f_lineno = 2963;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2963;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_2;

    tmp_compare_left_1 = par_type;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 2965;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2965;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2966;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_read_bio_X509_REQ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2966;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2966;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2966;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2966;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 2966;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2966;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 2966;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_14c48645ee3ca3c857b7652479da20fc->m_frame.f_lineno = 2966;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2966;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_req == NULL );
    var_req = tmp_assign_source_3;

    goto branch_end_2;
    branch_no_2:;
    tmp_compare_left_2 = par_type;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

    if (unlikely( tmp_compare_right_2 == NULL ))
    {
        tmp_compare_right_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
    }

    if ( tmp_compare_right_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
        exception_tb = NULL;

        exception_lineno = 2967;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2967;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2968;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_d2i_X509_REQ_bio );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2968;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2968;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 2968;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_14c48645ee3ca3c857b7652479da20fc->m_frame.f_lineno = 2968;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2968;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_req == NULL );
    var_req = tmp_assign_source_4;

    goto branch_end_3;
    branch_no_3:;
    tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
    frame_14c48645ee3ca3c857b7652479da20fc->m_frame.f_lineno = 2970;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2970;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_end_3:;
    branch_end_2:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2972;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_req;

    if ( tmp_compexpr_left_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "req" );
        exception_tb = NULL;

        exception_lineno = 2972;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2972;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2972;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2972;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_14c48645ee3ca3c857b7652479da20fc->m_frame.f_lineno = 2972;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2972;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Req );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Req );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Req" );
        exception_tb = NULL;

        exception_lineno = 2974;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain___new__ );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2974;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Req );

    if (unlikely( tmp_args_element_name_9 == NULL ))
    {
        tmp_args_element_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Req );
    }

    if ( tmp_args_element_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Req" );
        exception_tb = NULL;

        exception_lineno = 2974;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_14c48645ee3ca3c857b7652479da20fc->m_frame.f_lineno = 2974;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2974;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_x509req == NULL );
    var_x509req = tmp_assign_source_5;

    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2975;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_gc );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2975;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = var_req;

    if ( tmp_args_element_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "req" );
        exception_tb = NULL;

        exception_lineno = 2975;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2975;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_X509_REQ_free );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 2975;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_14c48645ee3ca3c857b7652479da20fc->m_frame.f_lineno = 2975;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2975;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_x509req;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__req, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 2975;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_14c48645ee3ca3c857b7652479da20fc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_14c48645ee3ca3c857b7652479da20fc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_14c48645ee3ca3c857b7652479da20fc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_14c48645ee3ca3c857b7652479da20fc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_14c48645ee3ca3c857b7652479da20fc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_14c48645ee3ca3c857b7652479da20fc,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_req,
        var_x509req
    );


    // Release cached frame.
    if ( frame_14c48645ee3ca3c857b7652479da20fc == cache_frame_14c48645ee3ca3c857b7652479da20fc )
    {
        Py_DECREF( frame_14c48645ee3ca3c857b7652479da20fc );
    }
    cache_frame_14c48645ee3ca3c857b7652479da20fc = NULL;

    assertFrameObject( frame_14c48645ee3ca3c857b7652479da20fc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_x509req;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_154_load_certificate_request );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_req );
    var_req = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)var_x509req );
    Py_DECREF( var_x509req );
    var_x509req = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_req );
    var_req = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_x509req );
    var_x509req = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_154_load_certificate_request );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_155_sign( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_pkey = python_pars[ 0 ];
    PyObject *par_data = python_pars[ 1 ];
    PyObject *par_digest = python_pars[ 2 ];
    PyObject *var_final_result = NULL;
    PyObject *var_signature_length = NULL;
    PyObject *var_length = NULL;
    PyObject *var_digest_obj = NULL;
    PyObject *var_signature_buffer = NULL;
    PyObject *var_md_ctx = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_element_name_22;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_ea1b89400f70df5f265adb95fc821fef = NULL;

    struct Nuitka_FrameObject *frame_ea1b89400f70df5f265adb95fc821fef;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ea1b89400f70df5f265adb95fc821fef, codeobj_ea1b89400f70df5f265adb95fc821fef, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ea1b89400f70df5f265adb95fc821fef = cache_frame_ea1b89400f70df5f265adb95fc821fef;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ea1b89400f70df5f265adb95fc821fef );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ea1b89400f70df5f265adb95fc821fef ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
        exception_tb = NULL;

        exception_lineno = 2990;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_plain_data;
    tmp_args_element_name_2 = par_data;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 2990;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2990;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_data;
        assert( old != NULL );
        par_data = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2992;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EVP_get_digestbyname );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2992;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
    }

    if ( tmp_called_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
        exception_tb = NULL;

        exception_lineno = 2992;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = par_digest;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 2992;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2992;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 2992;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2992;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_digest_obj == NULL );
    var_digest_obj = tmp_assign_source_2;

    tmp_compare_left_1 = var_digest_obj;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2993;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2993;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 2993;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 2994;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2994;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2996;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 2996;
    tmp_assign_source_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_Cryptography_EVP_MD_CTX_new );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2996;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_md_ctx == NULL );
    var_md_ctx = tmp_assign_source_3;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2997;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_gc );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2997;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_md_ctx;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2997;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_Cryptography_EVP_MD_CTX_free );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 2997;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 2997;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2997;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_md_ctx;
        assert( old != NULL );
        var_md_ctx = tmp_assign_source_4;
        Py_DECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2999;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = var_md_ctx;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = var_digest_obj;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 2999;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_EVP_SignInit, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2999;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3000;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_EVP_SignUpdate );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3000;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_md_ctx;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_args_element_name_10 = par_data;

    CHECK_OBJECT( tmp_args_element_name_10 );
    tmp_len_arg_1 = par_data;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_args_element_name_11 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 3000;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 3000;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3000;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3002;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_EVP_PKEY_size );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3002;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_pkey;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
    if ( tmp_args_element_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 3002;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 3002;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_12 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3002;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_length == NULL );
    var_length = tmp_assign_source_5;

    tmp_called_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_7 == NULL ))
    {
        tmp_called_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 3003;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_length;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_13 = RICH_COMPARE_GT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3003;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 3003;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_args_element_name_13 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3003;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3004;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_14 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
    tmp_args_element_name_15 = var_length;

    CHECK_OBJECT( tmp_args_element_name_15 );
    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 3004;
    {
        PyObject *call_args[] = { tmp_args_element_name_14, tmp_args_element_name_15 };
        tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_new, call_args );
    }

    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3004;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_signature_buffer == NULL );
    var_signature_buffer = tmp_assign_source_6;

    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3005;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 3005;
    tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple, 0 ) );

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3005;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_signature_length == NULL );
    var_signature_length = tmp_assign_source_7;

    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3006;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_EVP_SignFinal );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3006;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_16 = var_md_ctx;

    CHECK_OBJECT( tmp_args_element_name_16 );
    tmp_args_element_name_17 = var_signature_buffer;

    CHECK_OBJECT( tmp_args_element_name_17 );
    tmp_args_element_name_18 = var_signature_length;

    CHECK_OBJECT( tmp_args_element_name_18 );
    tmp_source_name_9 = par_pkey;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_args_element_name_19 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__pkey );
    if ( tmp_args_element_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );

        exception_lineno = 3007;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 3006;
    {
        PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_called_name_8 );
    Py_DECREF( tmp_args_element_name_19 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3006;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_final_result == NULL );
    var_final_result = tmp_assign_source_8;

    tmp_called_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_9 == NULL ))
    {
        tmp_called_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 3009;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_2 = var_final_result;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = const_int_pos_1;
    tmp_args_element_name_20 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    if ( tmp_args_element_name_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3009;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 3009;
    {
        PyObject *call_args[] = { tmp_args_element_name_20 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_args_element_name_20 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3009;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3011;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_buffer );
    if ( tmp_called_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3011;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_21 = var_signature_buffer;

    CHECK_OBJECT( tmp_args_element_name_21 );
    tmp_subscribed_name_1 = var_signature_length;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_args_element_name_22 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_10 );

        exception_lineno = 3011;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_ea1b89400f70df5f265adb95fc821fef->m_frame.f_lineno = 3011;
    {
        PyObject *call_args[] = { tmp_args_element_name_21, tmp_args_element_name_22 };
        tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_10, call_args );
    }

    Py_DECREF( tmp_called_name_10 );
    Py_DECREF( tmp_args_element_name_22 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3011;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3011;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ea1b89400f70df5f265adb95fc821fef );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ea1b89400f70df5f265adb95fc821fef );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ea1b89400f70df5f265adb95fc821fef );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ea1b89400f70df5f265adb95fc821fef, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ea1b89400f70df5f265adb95fc821fef->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ea1b89400f70df5f265adb95fc821fef, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ea1b89400f70df5f265adb95fc821fef,
        type_description_1,
        par_pkey,
        par_data,
        par_digest,
        var_final_result,
        var_signature_length,
        var_length,
        var_digest_obj,
        var_signature_buffer,
        var_md_ctx
    );


    // Release cached frame.
    if ( frame_ea1b89400f70df5f265adb95fc821fef == cache_frame_ea1b89400f70df5f265adb95fc821fef )
    {
        Py_DECREF( frame_ea1b89400f70df5f265adb95fc821fef );
    }
    cache_frame_ea1b89400f70df5f265adb95fc821fef = NULL;

    assertFrameObject( frame_ea1b89400f70df5f265adb95fc821fef );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_155_sign );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_final_result );
    Py_DECREF( var_final_result );
    var_final_result = NULL;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)var_signature_length );
    Py_DECREF( var_signature_length );
    var_signature_length = NULL;

    CHECK_OBJECT( (PyObject *)var_length );
    Py_DECREF( var_length );
    var_length = NULL;

    CHECK_OBJECT( (PyObject *)var_digest_obj );
    Py_DECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)var_signature_buffer );
    Py_DECREF( var_signature_buffer );
    var_signature_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_md_ctx );
    Py_DECREF( var_md_ctx );
    var_md_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_final_result );
    var_final_result = NULL;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    Py_XDECREF( var_signature_length );
    var_signature_length = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    Py_XDECREF( var_digest_obj );
    var_digest_obj = NULL;

    Py_XDECREF( var_signature_buffer );
    var_signature_buffer = NULL;

    Py_XDECREF( var_md_ctx );
    var_md_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_155_sign );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_156_verify( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cert = python_pars[ 0 ];
    PyObject *par_signature = python_pars[ 1 ];
    PyObject *par_data = python_pars[ 2 ];
    PyObject *par_digest = python_pars[ 3 ];
    PyObject *var_pkey = NULL;
    PyObject *var_digest_obj = NULL;
    PyObject *var_verify_result = NULL;
    PyObject *var_md_ctx = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    int tmp_cmp_Eq_1;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_16d689f7baaa9ade885f0b9a9d240d0e = NULL;

    struct Nuitka_FrameObject *frame_16d689f7baaa9ade885f0b9a9d240d0e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_16d689f7baaa9ade885f0b9a9d240d0e, codeobj_16d689f7baaa9ade885f0b9a9d240d0e, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_16d689f7baaa9ade885f0b9a9d240d0e = cache_frame_16d689f7baaa9ade885f0b9a9d240d0e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_16d689f7baaa9ade885f0b9a9d240d0e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_16d689f7baaa9ade885f0b9a9d240d0e ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
        exception_tb = NULL;

        exception_lineno = 3027;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_plain_data;
    tmp_args_element_name_2 = par_data;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame.f_lineno = 3027;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3027;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_data;
        assert( old != NULL );
        par_data = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3029;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EVP_get_digestbyname );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3029;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
    }

    if ( tmp_called_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
        exception_tb = NULL;

        exception_lineno = 3029;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = par_digest;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame.f_lineno = 3029;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 3029;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame.f_lineno = 3029;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3029;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_digest_obj == NULL );
    var_digest_obj = tmp_assign_source_2;

    tmp_compare_left_1 = var_digest_obj;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3030;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3030;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 3030;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
    frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame.f_lineno = 3031;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 3031;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3033;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_get_pubkey );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3033;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_cert;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__x509 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 3033;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame.f_lineno = 3033;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3033;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pkey == NULL );
    var_pkey = tmp_assign_source_3;

    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 3034;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_pkey;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3034;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3034;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3034;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame.f_lineno = 3034;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3034;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3035;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_gc );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3035;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = var_pkey;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3035;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_EVP_PKEY_free );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 3035;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame.f_lineno = 3035;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3035;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_pkey;
        assert( old != NULL );
        var_pkey = tmp_assign_source_4;
        Py_DECREF( old );
    }

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3037;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame.f_lineno = 3037;
    tmp_assign_source_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_Cryptography_EVP_MD_CTX_new );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3037;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_md_ctx == NULL );
    var_md_ctx = tmp_assign_source_5;

    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3038;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_gc );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3038;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_md_ctx;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3038;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_Cryptography_EVP_MD_CTX_free );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 3038;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame.f_lineno = 3038;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3038;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_md_ctx;
        assert( old != NULL );
        var_md_ctx = tmp_assign_source_6;
        Py_DECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3040;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = var_md_ctx;

    CHECK_OBJECT( tmp_args_element_name_11 );
    tmp_args_element_name_12 = var_digest_obj;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame.f_lineno = 3040;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_EVP_VerifyInit, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3040;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3041;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_EVP_VerifyUpdate );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3041;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_13 = var_md_ctx;

    CHECK_OBJECT( tmp_args_element_name_13 );
    tmp_args_element_name_14 = par_data;

    CHECK_OBJECT( tmp_args_element_name_14 );
    tmp_len_arg_1 = par_data;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_args_element_name_15 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_args_element_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );

        exception_lineno = 3041;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame.f_lineno = 3041;
    {
        PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_called_name_8 );
    Py_DECREF( tmp_args_element_name_15 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3041;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3042;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_EVP_VerifyFinal );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3042;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_16 = var_md_ctx;

    CHECK_OBJECT( tmp_args_element_name_16 );
    tmp_args_element_name_17 = par_signature;

    CHECK_OBJECT( tmp_args_element_name_17 );
    tmp_len_arg_2 = par_signature;

    CHECK_OBJECT( tmp_len_arg_2 );
    tmp_args_element_name_18 = BUILTIN_LEN( tmp_len_arg_2 );
    if ( tmp_args_element_name_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );

        exception_lineno = 3043;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_19 = var_pkey;

    CHECK_OBJECT( tmp_args_element_name_19 );
    frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame.f_lineno = 3042;
    {
        PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_element_name_18 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3042;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_verify_result == NULL );
    var_verify_result = tmp_assign_source_7;

    tmp_compare_left_2 = var_verify_result;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = const_int_pos_1;
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3046;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_10 == NULL ))
    {
        tmp_called_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 3047;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame.f_lineno = 3047;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_10 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3047;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_16d689f7baaa9ade885f0b9a9d240d0e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_16d689f7baaa9ade885f0b9a9d240d0e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_16d689f7baaa9ade885f0b9a9d240d0e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_16d689f7baaa9ade885f0b9a9d240d0e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_16d689f7baaa9ade885f0b9a9d240d0e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_16d689f7baaa9ade885f0b9a9d240d0e,
        type_description_1,
        par_cert,
        par_signature,
        par_data,
        par_digest,
        var_pkey,
        var_digest_obj,
        var_verify_result,
        var_md_ctx
    );


    // Release cached frame.
    if ( frame_16d689f7baaa9ade885f0b9a9d240d0e == cache_frame_16d689f7baaa9ade885f0b9a9d240d0e )
    {
        Py_DECREF( frame_16d689f7baaa9ade885f0b9a9d240d0e );
    }
    cache_frame_16d689f7baaa9ade885f0b9a9d240d0e = NULL;

    assertFrameObject( frame_16d689f7baaa9ade885f0b9a9d240d0e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_156_verify );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    CHECK_OBJECT( (PyObject *)var_digest_obj );
    Py_DECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_signature );
    Py_DECREF( par_signature );
    par_signature = NULL;

    CHECK_OBJECT( (PyObject *)var_verify_result );
    Py_DECREF( var_verify_result );
    var_verify_result = NULL;

    CHECK_OBJECT( (PyObject *)var_md_ctx );
    Py_DECREF( var_md_ctx );
    var_md_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    Py_XDECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_signature );
    Py_DECREF( par_signature );
    par_signature = NULL;

    Py_XDECREF( var_verify_result );
    var_verify_result = NULL;

    Py_XDECREF( var_md_ctx );
    var_md_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_156_verify );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_157_dump_crl( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_crl = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_ret = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_7189c655d187dba7fe5d32c5a002d947 = NULL;

    struct Nuitka_FrameObject *frame_7189c655d187dba7fe5d32c5a002d947;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7189c655d187dba7fe5d32c5a002d947, codeobj_7189c655d187dba7fe5d32c5a002d947, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7189c655d187dba7fe5d32c5a002d947 = cache_frame_7189c655d187dba7fe5d32c5a002d947;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7189c655d187dba7fe5d32c5a002d947 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7189c655d187dba7fe5d32c5a002d947 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 3061;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_7189c655d187dba7fe5d32c5a002d947->m_frame.f_lineno = 3061;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3061;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_1;

    tmp_compare_left_1 = par_type;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 3063;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3063;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3064;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_write_bio_X509_CRL );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3064;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_2 = par_crl;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__crl );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 3064;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_7189c655d187dba7fe5d32c5a002d947->m_frame.f_lineno = 3064;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3064;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_ret == NULL );
    var_ret = tmp_assign_source_2;

    goto branch_end_1;
    branch_no_1:;
    tmp_compare_left_2 = par_type;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

    if (unlikely( tmp_compare_right_2 == NULL ))
    {
        tmp_compare_right_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
    }

    if ( tmp_compare_right_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
        exception_tb = NULL;

        exception_lineno = 3065;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3065;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3066;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_i2d_X509_CRL_bio );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3066;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_source_name_4 = par_crl;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__crl );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 3066;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_7189c655d187dba7fe5d32c5a002d947->m_frame.f_lineno = 3066;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3066;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_ret == NULL );
    var_ret = tmp_assign_source_3;

    goto branch_end_2;
    branch_no_2:;
    tmp_compare_left_3 = par_type;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );

    if (unlikely( tmp_compare_right_3 == NULL ))
    {
        tmp_compare_right_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );
    }

    if ( tmp_compare_right_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_TEXT" );
        exception_tb = NULL;

        exception_lineno = 3067;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3067;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3068;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_CRL_print );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3068;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_source_name_6 = par_crl;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__crl );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 3068;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_7189c655d187dba7fe5d32c5a002d947->m_frame.f_lineno = 3068;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3068;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_ret == NULL );
    var_ret = tmp_assign_source_4;

    goto branch_end_3;
    branch_no_3:;
    tmp_make_exception_arg_1 = const_str_digest_11c225ccbab9acffc38107dee9691702;
    frame_7189c655d187dba7fe5d32c5a002d947->m_frame.f_lineno = 3070;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 3070;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_end_3:;
    branch_end_2:;
    branch_end_1:;
    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 3075;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_ret;

    if ( tmp_compexpr_left_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "ret" );
        exception_tb = NULL;

        exception_lineno = 3075;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_7 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3075;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_7189c655d187dba7fe5d32c5a002d947->m_frame.f_lineno = 3075;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3075;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
        exception_tb = NULL;

        exception_lineno = 3076;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_7189c655d187dba7fe5d32c5a002d947->m_frame.f_lineno = 3076;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3076;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7189c655d187dba7fe5d32c5a002d947 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7189c655d187dba7fe5d32c5a002d947 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7189c655d187dba7fe5d32c5a002d947 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7189c655d187dba7fe5d32c5a002d947, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7189c655d187dba7fe5d32c5a002d947->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7189c655d187dba7fe5d32c5a002d947, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7189c655d187dba7fe5d32c5a002d947,
        type_description_1,
        par_type,
        par_crl,
        var_bio,
        var_ret
    );


    // Release cached frame.
    if ( frame_7189c655d187dba7fe5d32c5a002d947 == cache_frame_7189c655d187dba7fe5d32c5a002d947 )
    {
        Py_DECREF( frame_7189c655d187dba7fe5d32c5a002d947 );
    }
    cache_frame_7189c655d187dba7fe5d32c5a002d947 = NULL;

    assertFrameObject( frame_7189c655d187dba7fe5d32c5a002d947 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_157_dump_crl );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_ret );
    var_ret = NULL;

    CHECK_OBJECT( (PyObject *)par_crl );
    Py_DECREF( par_crl );
    par_crl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_ret );
    var_ret = NULL;

    CHECK_OBJECT( (PyObject *)par_crl );
    Py_DECREF( par_crl );
    par_crl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_157_dump_crl );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_158_load_crl( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_result = NULL;
    PyObject *var_crl = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_2f3ff2ef3c95694bc7821e44dd686feb = NULL;

    struct Nuitka_FrameObject *frame_2f3ff2ef3c95694bc7821e44dd686feb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2f3ff2ef3c95694bc7821e44dd686feb, codeobj_2f3ff2ef3c95694bc7821e44dd686feb, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_2f3ff2ef3c95694bc7821e44dd686feb = cache_frame_2f3ff2ef3c95694bc7821e44dd686feb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2f3ff2ef3c95694bc7821e44dd686feb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2f3ff2ef3c95694bc7821e44dd686feb ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_buffer;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
        exception_tb = NULL;

        exception_lineno = 3089;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3089;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_buffer;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_2f3ff2ef3c95694bc7821e44dd686feb->m_frame.f_lineno = 3090;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3090;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_buffer;
        assert( old != NULL );
        par_buffer = tmp_assign_source_1;
        Py_DECREF( old );
    }

    branch_no_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 3092;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_buffer;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_2f3ff2ef3c95694bc7821e44dd686feb->m_frame.f_lineno = 3092;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3092;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_2;

    tmp_compare_left_1 = par_type;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 3094;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3094;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3095;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_read_bio_X509_CRL );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3095;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3095;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 3095;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3095;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 3095;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3095;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 3095;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_2f3ff2ef3c95694bc7821e44dd686feb->m_frame.f_lineno = 3095;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3095;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_crl == NULL );
    var_crl = tmp_assign_source_3;

    goto branch_end_2;
    branch_no_2:;
    tmp_compare_left_2 = par_type;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

    if (unlikely( tmp_compare_right_2 == NULL ))
    {
        tmp_compare_right_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
    }

    if ( tmp_compare_right_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
        exception_tb = NULL;

        exception_lineno = 3096;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3096;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3097;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_d2i_X509_CRL_bio );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3097;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3097;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 3097;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_2f3ff2ef3c95694bc7821e44dd686feb->m_frame.f_lineno = 3097;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3097;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_crl == NULL );
    var_crl = tmp_assign_source_4;

    goto branch_end_3;
    branch_no_3:;
    tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
    frame_2f3ff2ef3c95694bc7821e44dd686feb->m_frame.f_lineno = 3099;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 3099;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_end_3:;
    branch_end_2:;
    tmp_compare_left_3 = var_crl;

    if ( tmp_compare_left_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "crl" );
        exception_tb = NULL;

        exception_lineno = 3101;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3101;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
    if ( tmp_compare_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3101;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_3 );

        exception_lineno = 3101;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 3102;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_2f3ff2ef3c95694bc7821e44dd686feb->m_frame.f_lineno = 3102;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3102;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_CRL );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CRL );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "CRL" );
        exception_tb = NULL;

        exception_lineno = 3104;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain___new__ );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3104;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_CRL );

    if (unlikely( tmp_args_element_name_8 == NULL ))
    {
        tmp_args_element_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CRL );
    }

    if ( tmp_args_element_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "CRL" );
        exception_tb = NULL;

        exception_lineno = 3104;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_2f3ff2ef3c95694bc7821e44dd686feb->m_frame.f_lineno = 3104;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3104;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_5;

    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3105;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_gc );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3105;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_crl;

    if ( tmp_args_element_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "crl" );
        exception_tb = NULL;

        exception_lineno = 3105;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3105;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_X509_CRL_free );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 3105;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_2f3ff2ef3c95694bc7821e44dd686feb->m_frame.f_lineno = 3105;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3105;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_result;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__crl, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 3105;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f3ff2ef3c95694bc7821e44dd686feb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f3ff2ef3c95694bc7821e44dd686feb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2f3ff2ef3c95694bc7821e44dd686feb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2f3ff2ef3c95694bc7821e44dd686feb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2f3ff2ef3c95694bc7821e44dd686feb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f3ff2ef3c95694bc7821e44dd686feb,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_result,
        var_crl
    );


    // Release cached frame.
    if ( frame_2f3ff2ef3c95694bc7821e44dd686feb == cache_frame_2f3ff2ef3c95694bc7821e44dd686feb )
    {
        Py_DECREF( frame_2f3ff2ef3c95694bc7821e44dd686feb );
    }
    cache_frame_2f3ff2ef3c95694bc7821e44dd686feb = NULL;

    assertFrameObject( frame_2f3ff2ef3c95694bc7821e44dd686feb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_158_load_crl );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_crl );
    var_crl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_crl );
    var_crl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_158_load_crl );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_159_load_pkcs7_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_pypkcs7 = NULL;
    PyObject *var_pkcs7 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_a88924701bcd8a1d6541ab7a94a691c9 = NULL;

    struct Nuitka_FrameObject *frame_a88924701bcd8a1d6541ab7a94a691c9;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a88924701bcd8a1d6541ab7a94a691c9, codeobj_a88924701bcd8a1d6541ab7a94a691c9, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a88924701bcd8a1d6541ab7a94a691c9 = cache_frame_a88924701bcd8a1d6541ab7a94a691c9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a88924701bcd8a1d6541ab7a94a691c9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a88924701bcd8a1d6541ab7a94a691c9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_buffer;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
        exception_tb = NULL;

        exception_lineno = 3118;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3118;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_buffer;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_a88924701bcd8a1d6541ab7a94a691c9->m_frame.f_lineno = 3119;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3119;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_buffer;
        assert( old != NULL );
        par_buffer = tmp_assign_source_1;
        Py_DECREF( old );
    }

    branch_no_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 3121;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_buffer;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_a88924701bcd8a1d6541ab7a94a691c9->m_frame.f_lineno = 3121;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3121;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_2;

    tmp_compare_left_1 = par_type;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 3123;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3123;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3124;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_read_bio_PKCS7 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3124;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3124;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 3124;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3124;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 3124;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3124;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 3124;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_a88924701bcd8a1d6541ab7a94a691c9->m_frame.f_lineno = 3124;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3124;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pkcs7 == NULL );
    var_pkcs7 = tmp_assign_source_3;

    goto branch_end_2;
    branch_no_2:;
    tmp_compare_left_2 = par_type;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

    if (unlikely( tmp_compare_right_2 == NULL ))
    {
        tmp_compare_right_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
    }

    if ( tmp_compare_right_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
        exception_tb = NULL;

        exception_lineno = 3125;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3125;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3126;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_d2i_PKCS7_bio );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3126;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3126;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 3126;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_a88924701bcd8a1d6541ab7a94a691c9->m_frame.f_lineno = 3126;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3126;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pkcs7 == NULL );
    var_pkcs7 = tmp_assign_source_4;

    goto branch_end_3;
    branch_no_3:;
    tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
    frame_a88924701bcd8a1d6541ab7a94a691c9->m_frame.f_lineno = 3128;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 3128;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_end_3:;
    branch_end_2:;
    tmp_compare_left_3 = var_pkcs7;

    if ( tmp_compare_left_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "pkcs7" );
        exception_tb = NULL;

        exception_lineno = 3130;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3130;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
    if ( tmp_compare_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3130;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_3 );

        exception_lineno = 3130;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 3131;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_a88924701bcd8a1d6541ab7a94a691c9->m_frame.f_lineno = 3131;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3131;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS7 );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS7 );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKCS7" );
        exception_tb = NULL;

        exception_lineno = 3133;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain___new__ );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3133;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS7 );

    if (unlikely( tmp_args_element_name_8 == NULL ))
    {
        tmp_args_element_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS7 );
    }

    if ( tmp_args_element_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKCS7" );
        exception_tb = NULL;

        exception_lineno = 3133;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_a88924701bcd8a1d6541ab7a94a691c9->m_frame.f_lineno = 3133;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3133;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pypkcs7 == NULL );
    var_pypkcs7 = tmp_assign_source_5;

    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3134;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_gc );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3134;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_pkcs7;

    if ( tmp_args_element_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "pkcs7" );
        exception_tb = NULL;

        exception_lineno = 3134;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3134;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_PKCS7_free );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 3134;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_a88924701bcd8a1d6541ab7a94a691c9->m_frame.f_lineno = 3134;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3134;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_pypkcs7;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkcs7, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 3134;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a88924701bcd8a1d6541ab7a94a691c9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a88924701bcd8a1d6541ab7a94a691c9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a88924701bcd8a1d6541ab7a94a691c9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a88924701bcd8a1d6541ab7a94a691c9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a88924701bcd8a1d6541ab7a94a691c9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a88924701bcd8a1d6541ab7a94a691c9,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_pypkcs7,
        var_pkcs7
    );


    // Release cached frame.
    if ( frame_a88924701bcd8a1d6541ab7a94a691c9 == cache_frame_a88924701bcd8a1d6541ab7a94a691c9 )
    {
        Py_DECREF( frame_a88924701bcd8a1d6541ab7a94a691c9 );
    }
    cache_frame_a88924701bcd8a1d6541ab7a94a691c9 = NULL;

    assertFrameObject( frame_a88924701bcd8a1d6541ab7a94a691c9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_pypkcs7;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_159_load_pkcs7_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)var_pypkcs7 );
    Py_DECREF( var_pypkcs7 );
    var_pypkcs7 = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_pkcs7 );
    var_pkcs7 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_pypkcs7 );
    var_pypkcs7 = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_pkcs7 );
    var_pkcs7 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_159_load_pkcs7_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$crypto$$$function_160_load_pkcs12( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_buffer = python_pars[ 0 ];
    PyObject *par_passphrase = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_pykey = NULL;
    PyObject *var_x509 = NULL;
    PyObject *var_friendlyname_buffer = NULL;
    PyObject *var_pkey = NULL;
    PyObject *var_i = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_cacerts = NULL;
    PyObject *var_pycert = NULL;
    PyObject *var_friendlyname_length = NULL;
    PyObject *var_p12 = NULL;
    PyObject *var_pycacert = NULL;
    PyObject *var_pkcs12 = NULL;
    PyObject *var_friendlyname = NULL;
    PyObject *var_pycacerts = NULL;
    PyObject *var_parse_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_element_name_22;
    PyObject *tmp_args_element_name_23;
    PyObject *tmp_args_element_name_24;
    PyObject *tmp_args_element_name_25;
    PyObject *tmp_args_element_name_26;
    PyObject *tmp_args_element_name_27;
    PyObject *tmp_args_element_name_28;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_name_5;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assattr_target_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_instance_10;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    int tmp_cmp_Eq_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_range_arg_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_6817feb5181abfef1d37cfd39fe30cb8 = NULL;

    struct Nuitka_FrameObject *frame_6817feb5181abfef1d37cfd39fe30cb8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6817feb5181abfef1d37cfd39fe30cb8, codeobj_6817feb5181abfef1d37cfd39fe30cb8, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6817feb5181abfef1d37cfd39fe30cb8 = cache_frame_6817feb5181abfef1d37cfd39fe30cb8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6817feb5181abfef1d37cfd39fe30cb8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6817feb5181abfef1d37cfd39fe30cb8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
        exception_tb = NULL;

        exception_lineno = 3161;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_plain_passphrase;
    tmp_args_element_name_2 = par_passphrase;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3161;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3161;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_passphrase;
        assert( old != NULL );
        par_passphrase = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_isinstance_inst_1 = par_buffer;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
        exception_tb = NULL;

        exception_lineno = 3163;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3163;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_buffer;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3164;
    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3164;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_buffer;
        assert( old != NULL );
        par_buffer = tmp_assign_source_2;
        Py_DECREF( old );
    }

    branch_no_1:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
        exception_tb = NULL;

        exception_lineno = 3166;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = par_buffer;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3166;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3166;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_3;

    tmp_cond_value_1 = par_passphrase;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3172;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3173;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_4 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3173;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_passphrase;
        assert( old != NULL );
        par_passphrase = tmp_assign_source_4;
        Py_DECREF( old );
    }

    branch_no_2:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3175;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_d2i_PKCS12_bio );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3175;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3175;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 3175;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3175;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3175;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_p12 == NULL );
    var_p12 = tmp_assign_source_5;

    tmp_compare_left_1 = var_p12;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3176;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3176;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 3176;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 3177;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3177;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3177;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3178;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_gc );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3178;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_p12;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3178;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_PKCS12_free );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 3178;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3178;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3178;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_p12;
        assert( old != NULL );
        var_p12 = tmp_assign_source_6;
        Py_DECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3180;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3180;
    tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_016ce3807ea72a262d921fa7d1804717_tuple, 0 ) );

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3180;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pkey == NULL );
    var_pkey = tmp_assign_source_7;

    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3181;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3181;
    tmp_assign_source_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339_tuple, 0 ) );

    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3181;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_cert == NULL );
    var_cert = tmp_assign_source_8;

    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3182;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3182;
    tmp_assign_source_9 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_4560cdf69c017b7cd264323295e708cb_tuple, 0 ) );

    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3182;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_cacerts == NULL );
    var_cacerts = tmp_assign_source_9;

    tmp_called_instance_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_5 == NULL ))
    {
        tmp_called_instance_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3184;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = var_p12;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_args_element_name_9 = par_passphrase;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_args_element_name_10 = var_pkey;

    CHECK_OBJECT( tmp_args_element_name_10 );
    tmp_args_element_name_11 = var_cert;

    CHECK_OBJECT( tmp_args_element_name_11 );
    tmp_args_element_name_12 = var_cacerts;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3184;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_assign_source_10 = CALL_METHOD_WITH_ARGS5( tmp_called_instance_5, const_str_plain_PKCS12_parse, call_args );
    }

    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3184;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_parse_result == NULL );
    var_parse_result = tmp_assign_source_10;

    tmp_cond_value_2 = var_parse_result;

    CHECK_OBJECT( tmp_cond_value_2 );
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3185;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 3186;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3186;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3186;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3188;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_gc );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3188;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = var_cacerts;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_args_element_name_13 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 3188;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_13 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3188;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_sk_X509_free );
    if ( tmp_args_element_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_13 );

        exception_lineno = 3188;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3188;
    {
        PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14 };
        tmp_assign_source_11 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_13 );
    Py_DECREF( tmp_args_element_name_14 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3188;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_cacerts;
        assert( old != NULL );
        var_cacerts = tmp_assign_source_11;
        Py_DECREF( old );
    }

    // Tried code:
    tmp_called_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_8 == NULL ))
    {
        tmp_called_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 3194;
        type_description_1 = "oooooooooooooooooo";
        goto try_except_handler_2;
    }

    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3194;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3194;
        type_description_1 = "oooooooooooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_6817feb5181abfef1d37cfd39fe30cb8 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_6817feb5181abfef1d37cfd39fe30cb8, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_6817feb5181abfef1d37cfd39fe30cb8, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_compare_right_2 == NULL ))
    {
        tmp_compare_right_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_compare_right_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 3195;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3195;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_no_5;
    }
    else
    {
        goto branch_yes_5;
    }
    branch_yes_5:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 3193;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame) frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_5:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_160_load_pkcs12 );
    return NULL;
    // End of try:
    try_end_1:;
    tmp_subscribed_name_2 = var_pkey;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_0;
    tmp_compare_left_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_compare_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3198;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_9 == NULL )
    {
        Py_DECREF( tmp_compare_left_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3198;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_NULL );
    if ( tmp_compare_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_3 );

        exception_lineno = 3198;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_3 );
        Py_DECREF( tmp_compare_right_3 );

        exception_lineno = 3198;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_3 );
    Py_DECREF( tmp_compare_right_3 );
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_assign_source_12 = Py_None;
    assert( var_pykey == NULL );
    Py_INCREF( tmp_assign_source_12 );
    var_pykey = tmp_assign_source_12;

    goto branch_end_6;
    branch_no_6:;
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 3201;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain___new__ );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3201;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_args_element_name_15 == NULL ))
    {
        tmp_args_element_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_args_element_name_15 == NULL )
    {
        Py_DECREF( tmp_called_name_9 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 3201;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3201;
    {
        PyObject *call_args[] = { tmp_args_element_name_15 };
        tmp_assign_source_13 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3201;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pykey == NULL );
    var_pykey = tmp_assign_source_13;

    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3202;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_gc );
    if ( tmp_called_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3202;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = var_pkey;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_0;
    tmp_args_element_name_16 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_10 );

        exception_lineno = 3202;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_12 == NULL )
    {
        Py_DECREF( tmp_called_name_10 );
        Py_DECREF( tmp_args_element_name_16 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3202;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_EVP_PKEY_free );
    if ( tmp_args_element_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_10 );
        Py_DECREF( tmp_args_element_name_16 );

        exception_lineno = 3202;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3202;
    {
        PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_10, call_args );
    }

    Py_DECREF( tmp_called_name_10 );
    Py_DECREF( tmp_args_element_name_16 );
    Py_DECREF( tmp_args_element_name_17 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3202;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_pykey;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 3202;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    branch_end_6:;
    tmp_subscribed_name_4 = var_cert;

    CHECK_OBJECT( tmp_subscribed_name_4 );
    tmp_subscript_name_4 = const_int_0;
    tmp_compare_left_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_compare_left_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3204;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_13 == NULL ))
    {
        tmp_source_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_13 == NULL )
    {
        Py_DECREF( tmp_compare_left_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3204;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_NULL );
    if ( tmp_compare_right_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_4 );

        exception_lineno = 3204;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_4, tmp_compare_right_4 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_4 );
        Py_DECREF( tmp_compare_right_4 );

        exception_lineno = 3204;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_4 );
    Py_DECREF( tmp_compare_right_4 );
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_assign_source_14 = Py_None;
    assert( var_pycert == NULL );
    Py_INCREF( tmp_assign_source_14 );
    var_pycert = tmp_assign_source_14;

    tmp_assign_source_15 = Py_None;
    assert( var_friendlyname == NULL );
    Py_INCREF( tmp_assign_source_15 );
    var_friendlyname = tmp_assign_source_15;

    goto branch_end_7;
    branch_no_7:;
    tmp_source_name_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_source_name_14 == NULL ))
    {
        tmp_source_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_source_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 3208;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain__from_raw_x509_ptr );
    if ( tmp_called_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3208;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_5 = var_cert;

    CHECK_OBJECT( tmp_subscribed_name_5 );
    tmp_subscript_name_5 = const_int_0;
    tmp_args_element_name_18 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_args_element_name_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_11 );

        exception_lineno = 3208;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3208;
    {
        PyObject *call_args[] = { tmp_args_element_name_18 };
        tmp_assign_source_16 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    Py_DECREF( tmp_called_name_11 );
    Py_DECREF( tmp_args_element_name_18 );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3208;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pycert == NULL );
    var_pycert = tmp_assign_source_16;

    tmp_called_instance_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_6 == NULL ))
    {
        tmp_called_instance_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3210;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3210;
    tmp_assign_source_17 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_8e9fba48e24a08144a915d52e31f6d23_tuple, 0 ) );

    if ( tmp_assign_source_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3210;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_friendlyname_length == NULL );
    var_friendlyname_length = tmp_assign_source_17;

    tmp_source_name_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_15 == NULL ))
    {
        tmp_source_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3211;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_X509_alias_get0 );
    if ( tmp_called_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3211;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_6 = var_cert;

    CHECK_OBJECT( tmp_subscribed_name_6 );
    tmp_subscript_name_6 = const_int_0;
    tmp_args_element_name_19 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_args_element_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_12 );

        exception_lineno = 3212;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_20 = var_friendlyname_length;

    CHECK_OBJECT( tmp_args_element_name_20 );
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3211;
    {
        PyObject *call_args[] = { tmp_args_element_name_19, tmp_args_element_name_20 };
        tmp_assign_source_18 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_12, call_args );
    }

    Py_DECREF( tmp_called_name_12 );
    Py_DECREF( tmp_args_element_name_19 );
    if ( tmp_assign_source_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3211;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_friendlyname_buffer == NULL );
    var_friendlyname_buffer = tmp_assign_source_18;

    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_source_name_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_16 == NULL ))
    {
        tmp_source_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3214;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_buffer );
    if ( tmp_called_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3214;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_21 = var_friendlyname_buffer;

    CHECK_OBJECT( tmp_args_element_name_21 );
    tmp_subscribed_name_7 = var_friendlyname_length;

    CHECK_OBJECT( tmp_subscribed_name_7 );
    tmp_subscript_name_7 = const_int_0;
    tmp_args_element_name_22 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    if ( tmp_args_element_name_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_13 );

        exception_lineno = 3215;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3214;
    {
        PyObject *call_args[] = { tmp_args_element_name_21, tmp_args_element_name_22 };
        tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_13, call_args );
    }

    Py_DECREF( tmp_called_name_13 );
    Py_DECREF( tmp_args_element_name_22 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3214;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_19 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_assign_source_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3214;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_friendlyname == NULL );
    var_friendlyname = tmp_assign_source_19;

    tmp_compare_left_5 = var_friendlyname_buffer;

    CHECK_OBJECT( tmp_compare_left_5 );
    tmp_source_name_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_17 == NULL ))
    {
        tmp_source_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 3217;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_5 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_NULL );
    if ( tmp_compare_right_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3217;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_4 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_5, tmp_compare_right_5 );
    if ( tmp_cmp_Eq_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_5 );

        exception_lineno = 3217;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_5 );
    if ( tmp_cmp_Eq_4 == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_assign_source_20 = Py_None;
    {
        PyObject *old = var_friendlyname;
        assert( old != NULL );
        var_friendlyname = tmp_assign_source_20;
        Py_INCREF( var_friendlyname );
        Py_DECREF( old );
    }

    branch_no_8:;
    branch_end_7:;
    tmp_assign_source_21 = PyList_New( 0 );
    assert( var_pycacerts == NULL );
    var_pycacerts = tmp_assign_source_21;

    tmp_called_instance_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_7 == NULL ))
    {
        tmp_called_instance_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3221;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_23 = var_cacerts;

    CHECK_OBJECT( tmp_args_element_name_23 );
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3221;
    {
        PyObject *call_args[] = { tmp_args_element_name_23 };
        tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_sk_X509_num, call_args );
    }

    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3221;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3221;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_22 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3221;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_22;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_23 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_23 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooooooooooooo";
        exception_lineno = 3221;
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_23;
        Py_XDECREF( old );
    }

    goto try_end_2;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_6 = exception_keeper_type_2;
    tmp_compare_right_6 = PyExc_StopIteration;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_6, tmp_compare_right_6 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 3221;
        type_description_1 = "oooooooooooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    Py_DECREF( exception_keeper_type_2 );
    Py_XDECREF( exception_keeper_value_2 );
    Py_XDECREF( exception_keeper_tb_2 );
    goto loop_end_1;
    goto branch_end_9;
    branch_no_9:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_3;
    branch_end_9:;
    // End of try:
    try_end_2:;
    tmp_assign_source_24 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_24 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_24;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_called_instance_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_8 == NULL ))
    {
        tmp_called_instance_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3222;
        type_description_1 = "oooooooooooooooooo";
        goto try_except_handler_3;
    }

    tmp_args_element_name_24 = var_cacerts;

    CHECK_OBJECT( tmp_args_element_name_24 );
    tmp_args_element_name_25 = var_i;

    CHECK_OBJECT( tmp_args_element_name_25 );
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3222;
    {
        PyObject *call_args[] = { tmp_args_element_name_24, tmp_args_element_name_25 };
        tmp_assign_source_25 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_8, const_str_plain_sk_X509_value, call_args );
    }

    if ( tmp_assign_source_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3222;
        type_description_1 = "oooooooooooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_x509;
        var_x509 = tmp_assign_source_25;
        Py_XDECREF( old );
    }

    tmp_called_instance_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_called_instance_9 == NULL ))
    {
        tmp_called_instance_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_called_instance_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 3223;
        type_description_1 = "oooooooooooooooooo";
        goto try_except_handler_3;
    }

    tmp_args_element_name_26 = var_x509;

    CHECK_OBJECT( tmp_args_element_name_26 );
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3223;
    {
        PyObject *call_args[] = { tmp_args_element_name_26 };
        tmp_assign_source_26 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_9, const_str_plain__from_raw_x509_ptr, call_args );
    }

    if ( tmp_assign_source_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3223;
        type_description_1 = "oooooooooooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_pycacert;
        var_pycacert = tmp_assign_source_26;
        Py_XDECREF( old );
    }

    tmp_called_instance_10 = var_pycacerts;

    CHECK_OBJECT( tmp_called_instance_10 );
    tmp_args_element_name_27 = var_pycacert;

    CHECK_OBJECT( tmp_args_element_name_27 );
    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3224;
    {
        PyObject *call_args[] = { tmp_args_element_name_27 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_10, const_str_plain_append, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3224;
        type_description_1 = "oooooooooooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3221;
        type_description_1 = "oooooooooooooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_cond_value_3 = var_pycacerts;

    CHECK_OBJECT( tmp_cond_value_3 );
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3225;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_no_10;
    }
    else
    {
        goto branch_yes_10;
    }
    branch_yes_10:;
    tmp_assign_source_27 = Py_None;
    {
        PyObject *old = var_pycacerts;
        assert( old != NULL );
        var_pycacerts = tmp_assign_source_27;
        Py_INCREF( var_pycacerts );
        Py_DECREF( old );
    }

    branch_no_10:;
    tmp_source_name_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS12 );

    if (unlikely( tmp_source_name_18 == NULL ))
    {
        tmp_source_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS12 );
    }

    if ( tmp_source_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKCS12" );
        exception_tb = NULL;

        exception_lineno = 3228;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain___new__ );
    if ( tmp_called_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3228;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_28 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS12 );

    if (unlikely( tmp_args_element_name_28 == NULL ))
    {
        tmp_args_element_name_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS12 );
    }

    if ( tmp_args_element_name_28 == NULL )
    {
        Py_DECREF( tmp_called_name_14 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKCS12" );
        exception_tb = NULL;

        exception_lineno = 3228;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame.f_lineno = 3228;
    {
        PyObject *call_args[] = { tmp_args_element_name_28 };
        tmp_assign_source_28 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, call_args );
    }

    Py_DECREF( tmp_called_name_14 );
    if ( tmp_assign_source_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3228;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pkcs12 == NULL );
    var_pkcs12 = tmp_assign_source_28;

    tmp_assattr_name_2 = var_pykey;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = var_pkcs12;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__pkey, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3229;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = var_pycert;

    CHECK_OBJECT( tmp_assattr_name_3 );
    tmp_assattr_target_3 = var_pkcs12;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__cert, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3230;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_4 = var_pycacerts;

    CHECK_OBJECT( tmp_assattr_name_4 );
    tmp_assattr_target_4 = var_pkcs12;

    CHECK_OBJECT( tmp_assattr_target_4 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__cacerts, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3231;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_5 = var_friendlyname;

    if ( tmp_assattr_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "friendlyname" );
        exception_tb = NULL;

        exception_lineno = 3232;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_5 = var_pkcs12;

    CHECK_OBJECT( tmp_assattr_target_5 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain__friendlyname, tmp_assattr_name_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3232;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_6817feb5181abfef1d37cfd39fe30cb8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_6817feb5181abfef1d37cfd39fe30cb8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6817feb5181abfef1d37cfd39fe30cb8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6817feb5181abfef1d37cfd39fe30cb8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6817feb5181abfef1d37cfd39fe30cb8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6817feb5181abfef1d37cfd39fe30cb8,
        type_description_1,
        par_buffer,
        par_passphrase,
        var_bio,
        var_pykey,
        var_x509,
        var_friendlyname_buffer,
        var_pkey,
        var_i,
        var_cert,
        var_cacerts,
        var_pycert,
        var_friendlyname_length,
        var_p12,
        var_pycacert,
        var_pkcs12,
        var_friendlyname,
        var_pycacerts,
        var_parse_result
    );


    // Release cached frame.
    if ( frame_6817feb5181abfef1d37cfd39fe30cb8 == cache_frame_6817feb5181abfef1d37cfd39fe30cb8 )
    {
        Py_DECREF( frame_6817feb5181abfef1d37cfd39fe30cb8 );
    }
    cache_frame_6817feb5181abfef1d37cfd39fe30cb8 = NULL;

    assertFrameObject( frame_6817feb5181abfef1d37cfd39fe30cb8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_pkcs12;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_160_load_pkcs12 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)var_pykey );
    Py_DECREF( var_pykey );
    var_pykey = NULL;

    Py_XDECREF( var_x509 );
    var_x509 = NULL;

    Py_XDECREF( var_friendlyname_buffer );
    var_friendlyname_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)var_cacerts );
    Py_DECREF( var_cacerts );
    var_cacerts = NULL;

    CHECK_OBJECT( (PyObject *)var_pycert );
    Py_DECREF( var_pycert );
    var_pycert = NULL;

    Py_XDECREF( var_friendlyname_length );
    var_friendlyname_length = NULL;

    CHECK_OBJECT( (PyObject *)var_p12 );
    Py_DECREF( var_p12 );
    var_p12 = NULL;

    Py_XDECREF( var_pycacert );
    var_pycacert = NULL;

    CHECK_OBJECT( (PyObject *)var_pkcs12 );
    Py_DECREF( var_pkcs12 );
    var_pkcs12 = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    Py_XDECREF( var_friendlyname );
    var_friendlyname = NULL;

    CHECK_OBJECT( (PyObject *)var_pycacerts );
    Py_DECREF( var_pycacerts );
    var_pycacerts = NULL;

    CHECK_OBJECT( (PyObject *)var_parse_result );
    Py_DECREF( var_parse_result );
    var_parse_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_pykey );
    var_pykey = NULL;

    Py_XDECREF( var_x509 );
    var_x509 = NULL;

    Py_XDECREF( var_friendlyname_buffer );
    var_friendlyname_buffer = NULL;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    Py_XDECREF( var_cacerts );
    var_cacerts = NULL;

    Py_XDECREF( var_pycert );
    var_pycert = NULL;

    Py_XDECREF( var_friendlyname_length );
    var_friendlyname_length = NULL;

    Py_XDECREF( var_p12 );
    var_p12 = NULL;

    Py_XDECREF( var_pycacert );
    var_pycacert = NULL;

    Py_XDECREF( var_pkcs12 );
    var_pkcs12 = NULL;

    Py_XDECREF( par_passphrase );
    par_passphrase = NULL;

    Py_XDECREF( var_friendlyname );
    var_friendlyname = NULL;

    Py_XDECREF( var_pycacerts );
    var_pycacerts = NULL;

    Py_XDECREF( var_parse_result );
    var_parse_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_160_load_pkcs12 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_100_load_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_100_load_certificate,
        const_str_plain_load_certificate,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_49f65499044958fd105e8a41711525ee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f979ae5e9b0a9a41a05276169a44e7e9,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_101_dump_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_101_dump_certificate,
        const_str_plain_dump_certificate,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6a7a8eee239b6a4648d8651514b607eb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_193e0ef9a8bffd6c41bf909f2da817bd,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_102_dump_publickey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_102_dump_publickey,
        const_str_plain_dump_publickey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_96feb5417aba60c65386efdfa05ffda6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0d8911e895179dcd467b4e9de2f411d4,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_103_dump_privatekey( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_103_dump_privatekey,
        const_str_plain_dump_privatekey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2f75eb83f141c45e8429039b2cce5fd5,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c71c443223c73b253b21961ef3bd7c9e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_104___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_104___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_781624e00a9735ef39d890417814f755,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_105_set_serial(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_105_set_serial,
        const_str_plain_set_serial,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_eaa8abaf1b913554e0e3552e860e2ed1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_8bcf6e6fbaf96377cbe58ba9960c9d58,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_106_get_serial(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_106_get_serial,
        const_str_plain_get_serial,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0612b9518d882fcbc0d3f58a38c9a868,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_007f81c06fa49e709fd9306cc6c26627,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_107__delete_reason(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_107__delete_reason,
        const_str_plain__delete_reason,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3786f0d21253e58936f662cecbfc0803,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_108_set_reason(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_108_set_reason,
        const_str_plain_set_reason,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b3244c50c8c54c5da547fc5b29816352,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a12e23c82fcdd4004653da2260294f18,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_109_get_reason(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_109_get_reason,
        const_str_plain_get_reason,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d092a227600410e01a6b811aac2b1868,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_435662c26b2c422edb954b82c85c55d9,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_10___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_10___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c420853ec5373143d72a06d844a52757,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_110_all_reasons(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_110_all_reasons,
        const_str_plain_all_reasons,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d51c13718977056415bef87cf9ca74e3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_4097a084fab55cf5c5baa1b785e7c82a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_111_set_rev_date(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_111_set_rev_date,
        const_str_plain_set_rev_date,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9bb39077dd2210e297f9b293e3ba3d43,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_11e1356f3459cf012eb88d7288e20e85,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_112_get_rev_date(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_112_get_rev_date,
        const_str_plain_get_rev_date,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ed069d1a9991feb4397571ea46f32f1d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1ca413f5b66374db6a573ac0926a99ae,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_113___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_113___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2043efb2389ea54ec41185bb817d4d92,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_114_to_cryptography(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_114_to_cryptography,
        const_str_plain_to_cryptography,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_753e3dd3d02b58575f16808234de0cc5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_2f591e55cc116ed5223c119e2f7da344,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_115_from_cryptography(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_115_from_cryptography,
        const_str_plain_from_cryptography,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_89c93e5d81ce22610ffc5a6402eaa2b2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f56881bccbbc40c6643f9603628e7a5c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_116_get_revoked(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_116_get_revoked,
        const_str_plain_get_revoked,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7abef46ac5fd5222e8eee23d9d0de8fa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0b9d4db9119537682a1f5302a9cbcc57,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_117_add_revoked(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_117_add_revoked,
        const_str_plain_add_revoked,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_22c8795b049654d8bc8a72f08c1a0691,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_880f67f2b28115a7ad1d1bfb533fc6bc,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_118_get_issuer(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_118_get_issuer,
        const_str_plain_get_issuer,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ebf7313f23a0eb07511542b17ec730a1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_48639cf22fbd4e6b3714265dae0dbed8,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_119_set_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_119_set_version,
        const_str_plain_set_version,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1611b903c9b5e6e33168f01f5ca2e18f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0b708bb28192f1a165c843c47343f35a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_11_to_cryptography_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_11_to_cryptography_key,
        const_str_plain_to_cryptography_key,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0b51c794f2deb346eb163bcfa124fc96,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_26a65c58106d086427e37cb87b0bc3b3,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_120__set_boundary_time(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_120__set_boundary_time,
        const_str_plain__set_boundary_time,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_06807d7bae8f316ff9a9e8ff657f7c28,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_121_set_lastUpdate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_121_set_lastUpdate,
        const_str_plain_set_lastUpdate,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b39bc7f4b92f008bf056168e2d35a0b3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_333948d9e51f0e161201a16305959930,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_122_set_nextUpdate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_122_set_nextUpdate,
        const_str_plain_set_nextUpdate,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_83c24878a9b5a5e8cf8af59795ee05c6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_b69ad7457b37f0df18af9a38324a8007,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_123_sign(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_123_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_99e4ea9ef8921a672a5c09e7667ef6af,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_cf86a9123926465ab14a7bd2861326f6,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_124_export( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_124_export,
        const_str_plain_export,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e2d69c1085f8607b608690a912064382,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_b6dd846b2ed8a994f97bac91e216f368,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_125_type_is_signed(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_125_type_is_signed,
        const_str_plain_type_is_signed,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_28c84ee70c601df7b191b6f7900ba260,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c384f9f99d5890cd2aae342c30dbaa14,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_126_type_is_enveloped(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_126_type_is_enveloped,
        const_str_plain_type_is_enveloped,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_827362a983b7474d6f375edfc3634b35,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_40ce736ad6e52bc3df10a00233b89318,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_127_type_is_signedAndEnveloped(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_127_type_is_signedAndEnveloped,
        const_str_plain_type_is_signedAndEnveloped,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d5256ae10053b2c8525f915629371344,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a078d66f5fc281c4117a5e5c24749809,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_128_type_is_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_128_type_is_data,
        const_str_plain_type_is_data,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7349adb7b143cb067732bf2b6a832926,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_90de967a5219b9210479f7eac5c285c8,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_129_get_type_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_129_get_type_name,
        const_str_plain_get_type_name,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_17894a2bd573cf70312dff7783ba8c00,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_782fa7272fdd3d3abdc1a0298e5e83fc,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_12_from_cryptography_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_12_from_cryptography_key,
        const_str_plain_from_cryptography_key,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3a363175d5408a6bc23af5d6f91497ed,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_ffd290e8bf49a587d94041b1fd6c3c55,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_130___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_130___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d792dc0a2b4ceb48a62671146c8bf0d7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_131_get_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_131_get_certificate,
        const_str_plain_get_certificate,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0c82a5452c5febb9099bd8db0c10394d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f68048107421fed17c8f1bc19be3ec03,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_132_set_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_132_set_certificate,
        const_str_plain_set_certificate,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_aa37b9cbdf49270d594d1c8bbf09fed2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_62c9c3f244d467c166be64cd38a755a7,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_133_get_privatekey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_133_get_privatekey,
        const_str_plain_get_privatekey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_297408a0aa65f790cf77d6f0ddab5fc4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a9bcf1af78e6d912e13685d8a606fe30,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_134_set_privatekey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_134_set_privatekey,
        const_str_plain_set_privatekey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_27ff3ab34ec54fd0321637ec5b9468ab,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5e37d069c5e76ee6d50c7e91b7181934,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_135_get_ca_certificates(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_135_get_ca_certificates,
        const_str_plain_get_ca_certificates,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9b12eba053e44d5fd15b6e0ac3462f9f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_978cd476d4acffdfb043e6a5e0ebae26,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_136_set_ca_certificates(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_136_set_ca_certificates,
        const_str_plain_set_ca_certificates,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ff2082c1effa87cca79f7de3b6f33a05,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_9781f115d6516693d922717b11376a73,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_137_set_friendlyname(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_137_set_friendlyname,
        const_str_plain_set_friendlyname,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_fba8564faf4c03ce4d5b0d189ce6194b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_9c28b2ef32679900c21c54152be8ce03,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_138_get_friendlyname(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_138_get_friendlyname,
        const_str_plain_get_friendlyname,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b1486947c5a61e6df127599c97e465e7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_4357c956c1f3628f437632877b5d8593,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_139_export( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_139_export,
        const_str_plain_export,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1a7304e9294486f283f111b9533e37ac,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_44f664275c70041c9ae4bef2565506f3,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_13_generate_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_13_generate_key,
        const_str_plain_generate_key,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_319356766fa623fbb53f8001dc596471,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_9a71d9e6319c409dff859e67083fc41c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_140___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_140___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_459d1e2f5259dad1fd69735ed07121a4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_141_sign(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_141_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8eb0152ada49813b33550455d2f476e6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_03f3989a7f0f1ec9623bd001f5a005a7,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_142_verify(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_142_verify,
        const_str_plain_verify,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_33a88964d744834d19cbcd47d9aefd1b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5699814601a04aa972bd2f18de396c39,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_143_b64_encode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_143_b64_encode,
        const_str_plain_b64_encode,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_119480fb0feb54a4f011bffa2f21182e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_af63c2663b0a5e83daac69d308dcb1d6,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_144_get_pubkey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_144_get_pubkey,
        const_str_plain_get_pubkey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e7ae04d16d91e8d239c7d8ea0b0f0b05,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_3b5fd85224219fd172d589ec8f98a12a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_145_set_pubkey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_145_set_pubkey,
        const_str_plain_set_pubkey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8288a95eb966387b5a4b6507bc1f1a0b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_686e4f9f1c51b7038afe792590c33346,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_146___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_146___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e284a8d70714fdb79809fb1913c8d00d,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_147_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_147_callback,
        const_str_plain_callback,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b937f289fb17e79995f422e1b9152e9d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_148_callback_args(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_148_callback_args,
        const_str_plain_callback_args,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_74cde753c21d561d79e5c3fb8ec14b96,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_149_raise_if_problem( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_149_raise_if_problem,
        const_str_plain_raise_if_problem,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_81d019b3ef51f73c296d9bd966429c42,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_14_check(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_14_check,
        const_str_plain_check,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_70275adf8e6632812c63bb55ba5541ea,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_8db7448b8246dd51f74c33bda58590bd,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_150__read_passphrase(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_150__read_passphrase,
        const_str_plain__read_passphrase,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_aa80a5d36a11ceafba5ad49aa16e30e0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_151_load_publickey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_151_load_publickey,
        const_str_plain_load_publickey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_95e8045ab91a3cf5ec43d09da1cff4dc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0a3eb1716e7caaaf09c8582b572bcb60,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_152_load_privatekey( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_152_load_privatekey,
        const_str_plain_load_privatekey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ee8c5e94f6b2bf50cc0c751599edbbf4,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f41f911aba33894e1da796354264d96a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_153_dump_certificate_request(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_153_dump_certificate_request,
        const_str_plain_dump_certificate_request,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0a9fc1297fc6ce588e759c7014f8b308,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_97388c7ddfea4f913fec5c846dd26ef1,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_154_load_certificate_request(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_154_load_certificate_request,
        const_str_plain_load_certificate_request,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_14c48645ee3ca3c857b7652479da20fc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1c1759444507dc6d4c0d7b4ce6b62611,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_155_sign(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_155_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ea1b89400f70df5f265adb95fc821fef,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_d6b3262f79e4b59cd83ab54699c92117,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_156_verify(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_156_verify,
        const_str_plain_verify,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_16d689f7baaa9ade885f0b9a9d240d0e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_9acbe023ce14d1d2ba528bd23b2423a0,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_157_dump_crl(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_157_dump_crl,
        const_str_plain_dump_crl,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7189c655d187dba7fe5d32c5a002d947,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_721230a42e287d5632d061ff8f0376d6,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_158_load_crl(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_158_load_crl,
        const_str_plain_load_crl,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2f3ff2ef3c95694bc7821e44dd686feb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_05b2bb16e6ee73fd972536e52cc4cabf,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_159_load_pkcs7_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_159_load_pkcs7_data,
        const_str_plain_load_pkcs7_data,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a88924701bcd8a1d6541ab7a94a691c9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1565887baecc678658a50e7d1f245653,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_15_type(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_15_type,
        const_str_plain_type,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_581db0cca4d33e8ad35e2569a0dead0b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c237653198d1acecae3452511968b22e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_160_load_pkcs12( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_160_load_pkcs12,
        const_str_plain_load_pkcs12,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6817feb5181abfef1d37cfd39fe30cb8,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_75a631b53fc267af68d162051a06411c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_16_bits(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_16_bits,
        const_str_plain_bits,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d646955fcdf80afde1b63bdd49140dae,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a658b60d9bffa55a9bdfb85ba96aec98,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_17___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_17___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3017da2311b90aa13ec5c98739847c3a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_4d14f6e4d6647c6573e3ca9449c2b51f,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_18__load_elliptic_curves(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_18__load_elliptic_curves,
        const_str_plain__load_elliptic_curves,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9da9fa45beb0c9f41a9608504e4060ef,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_74b73fd54833bfb6b761307c477c0a28,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_19__get_elliptic_curves(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_19__get_elliptic_curves,
        const_str_plain__get_elliptic_curves,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7096b6ad0685416ea20fafee5d682357,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_7de17ac920010129977e4280610f275c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_1__get_backend(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_1__get_backend,
        const_str_plain__get_backend,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_91827650124a919342a3904039e7cc23,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_d03be6fc9f3e6729b366e69e0856a450,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_20_from_nid(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_20_from_nid,
        const_str_plain_from_nid,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d9b4aca46fa45edc20186def74d2cc85,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0ba82c04a076f46925a74539c2a8ba40,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_21___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_21___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_063b1a0e18b7d09d3c7304577aae337e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f76c1a90d81cc9627b0b6df42991dbc9,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_22___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_22___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f3e20dc9e619a5c7b71876ef8e4ffdf2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_23__to_EC_KEY(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_23__to_EC_KEY,
        const_str_plain__to_EC_KEY,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9104ea89573b61be15ab468f377fb279,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c4a5d29f3ecd810d59e3d04a7a935f38,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_24_get_elliptic_curves(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_24_get_elliptic_curves,
        const_str_plain_get_elliptic_curves,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_107afbc3261214969697ae7bd17eb403,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_3121be4a855650e38916196ca238bf2b,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_25_get_elliptic_curve(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_25_get_elliptic_curve,
        const_str_plain_get_elliptic_curve,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_153767201ad1e1a2e0fa3001f507c4f6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f583009b639aad56f3c96c175e595626,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_26___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_26___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e74409a73207f7b2752994c2618d873f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_12c1bc175ad6309f9cfc24942b8c76ac,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_27___setattr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_27___setattr__,
        const_str_plain___setattr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5257480cf0e5c2a0e7b7480a7cb50162,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_28___getattr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_28___getattr__,
        const_str_plain___getattr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a82ccd2c0741621ed27296148a68c29b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c7bf9684574689f7d764ff6fbd5eab60,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_29__cmp,
        const_str_plain__cmp,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d868387e609dfd72b81d3fa1fa8ab351,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp$$$function_1_f( struct Nuitka_CellObject *closure_op )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_29__cmp$$$function_1_f,
        const_str_plain_f,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ecc5f2c4e5dc86a32ed116e99c89a5d1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        1
    );

result->m_closure[0] = closure_op;
Py_INCREF( result->m_closure[0] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_2__untested_error(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_2__untested_error,
        const_str_plain__untested_error,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a315eda621833a13d7eb0a139c70dafe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_de1d9872d12371b2ead20f3aa79dc834,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_30___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_30___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2a7bb83e6e75a054f19a73ff4f483805,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_463cb3c7dbe7753c6683d3195629dca3,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_31_hash(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_31_hash,
        const_str_plain_hash,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cde66f85dffd5588bcc9694a7fafb9fc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_e4c79524acf8a72de25c6c6491f370a8,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_32_der(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_32_der,
        const_str_plain_der,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8074998756d76facb0acefe4e2bce233,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_61d70cefdce1472400ab8a06d64ef78a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_33_get_components(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_33_get_components,
        const_str_plain_get_components,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ae02106742003eefd25af05a0213f462,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_7e62ce69c000886ecc0ae0b3e8ae9e79,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_34___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_34___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2dae63b82183f47dc1d1ccf37238a118,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_152d11f8848fac60442a26592ab3da87,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_35__nid(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_35__nid,
        const_str_plain__nid,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_be69f2a07a72c09df887316bd387c371,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_36__subjectAltNameString(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_36__subjectAltNameString,
        const_str_plain__subjectAltNameString,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b2eb147418d5fabeff8e35f9b5686e90,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_37___str__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_37___str__,
        const_str_plain___str__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6fee1e02bfdf5171d161d782964ddf8a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5bd123cbe57a454c8d9d37867b598cb2,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_38_get_critical(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_38_get_critical,
        const_str_plain_get_critical,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4c30ea601179f11262c4deefdcac8ea8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5f245d1740d80da82563e21c9c4f4fbf,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_39_get_short_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_39_get_short_name,
        const_str_plain_get_short_name,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cfbf41ceb63c16d529c709e5c8297fb7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_213346f5e36f3faf7ff7a566deec4adb,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_3__new_mem_buf,
        const_str_plain__new_mem_buf,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a5edad3959ffbe1dd9ddf61f4b759fb6,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1a7a898c4490dd89b305492a40bf2633,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free,
        const_str_plain_free,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_aad48952174175fb990f54e79c3441f0,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_40_get_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_40_get_data,
        const_str_plain_get_data,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_58da277305ed77bd76ae182c07ff471f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_719137938e890576c1050ba31a668078,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_41___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_41___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_35224eb056f22fe92af87e40d652fea6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_42_to_cryptography(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_42_to_cryptography,
        const_str_plain_to_cryptography,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_634dd2520f2d2675325c340573d2f303,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_66b2a3b8e35254752e96fbbddc255dfd,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_43_from_cryptography(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_43_from_cryptography,
        const_str_plain_from_cryptography,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0c7b9a5b3ed4ff89630439f7e0f3a7c3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_b16563a844474e8eed4710209909ab32,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_44_set_pubkey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_44_set_pubkey,
        const_str_plain_set_pubkey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e3fe386d49259b679544c27db4211b3f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_ab9563b0fc32f09cfde9a1636d8d2b80,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_45_get_pubkey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_45_get_pubkey,
        const_str_plain_get_pubkey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_817e625125db0bed6c9af343a2fa01ac,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_07697dd6fa4854473fa24b52569d5636,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_46_set_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_46_set_version,
        const_str_plain_set_version,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9f23f9ebe329837518bdc3f7e1a6e88c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_b2d5bbfa3f949ddcc231b89e71aa8d92,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_47_get_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_47_get_version,
        const_str_plain_get_version,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_84f20b87ad7f63be7d712f315dc27fea,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_ac089bdfaafc466d410fc6ffe7dfee50,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_48_get_subject(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_48_get_subject,
        const_str_plain_get_subject,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_00cd31b4c5e27fc1a7515a659d7cbc7a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_cac81eaf46e08badbc89f13fa3bbdf6b,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_49_add_extensions(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_49_add_extensions,
        const_str_plain_add_extensions,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5bfb296d5731d584cf8608b23453951b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_52cbe8d655a10e46907a30970ef9889a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_4__bio_to_string(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_4__bio_to_string,
        const_str_plain__bio_to_string,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f3aabc03ee2f84380109aeb9f42fe98a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_859c7c43c5cf3124cdd58374d6e7359e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_50_get_extensions(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_50_get_extensions,
        const_str_plain_get_extensions,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_fe1ab9327216940b89ff10309b7e559c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_2e4273bc9cbcc16bcfe5bca70ee1b585,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_50_get_extensions$$$function_1_lambda(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_50_get_extensions$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_40177b130baad3068ebe5a951155469e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_51_sign(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_51_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a3b1f8e833aa031bd6d706c06d21fefb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_cd7d7b6c262cf257f5bafa26f39b567e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_52_verify(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_52_verify,
        const_str_plain_verify,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_84aebb049548e459b85da103bbfd2471,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0d3c537bf958e2cc2494cf1be5c283dd,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_53___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_53___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1c0cae65699467a80d94f781d6c3d9b1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_54__from_raw_x509_ptr(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_54__from_raw_x509_ptr,
        const_str_plain__from_raw_x509_ptr,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_474b942d1079d7aa7b5b630fd0d8885f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_55_to_cryptography(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_55_to_cryptography,
        const_str_plain_to_cryptography,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6f232e0892e44270bff4d47905df44dc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f737de4a45174195dc1e46101235dc35,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_56_from_cryptography(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_56_from_cryptography,
        const_str_plain_from_cryptography,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e1bd12349b684047b31907a697c36274,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1f681e9f80c6df652cbc3a085be49171,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_57_set_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_57_set_version,
        const_str_plain_set_version,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d41d40838f88795a151b0b852e40ee1b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_603c60edaf58a8746faa757f20f3f938,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_58_get_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_58_get_version,
        const_str_plain_get_version,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_21af353ae645ab8ee28b6adbc1ad3978,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c47cfcedcc7803c0a6ef28b85213e16f,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_59_get_pubkey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_59_get_pubkey,
        const_str_plain_get_pubkey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f442bcbb68e2ecc7a7ffb9f1ee7dc59b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_11dbf726734533c622c12e725d15648e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_5__set_asn1_time(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_5__set_asn1_time,
        const_str_plain__set_asn1_time,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c196634e750512d513f350e0875f8a1f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_670c62a34c6767f6ecd5db6f969b2f34,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_60_set_pubkey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_60_set_pubkey,
        const_str_plain_set_pubkey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_335819dcf5f2ff177db72f200198965d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a7eaace656db47cf2975484b27c818e9,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_61_sign(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_61_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_62b37b398cca624e1da0cba42e8c2fbe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_685b3ded6e482839a3710e6a448d8669,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_62_get_signature_algorithm(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_62_get_signature_algorithm,
        const_str_plain_get_signature_algorithm,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_80b295e7b075bea47091b563200e78b8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_79b48b443a4edf88bd64a278e98529d3,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_63_digest(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_63_digest,
        const_str_plain_digest,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_39cfa03514a1d73dd0565fdcb05e6808,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5cb0319d0378026eb0ef49838e525520,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_64_subject_name_hash(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_64_subject_name_hash,
        const_str_plain_subject_name_hash,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8a05448908bde9009224b5554b838346,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_e69f89000e2dc720ec6a70b8f9cb0cac,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_65_set_serial_number(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_65_set_serial_number,
        const_str_plain_set_serial_number,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ece9e443ce0480c90f4788350c457a64,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_6b664ec0d0974a050be8b09b84bd0a5d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_66_get_serial_number(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_66_get_serial_number,
        const_str_plain_get_serial_number,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cd8026d8c03981ef7b359feb3aa91a02,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_7d6056c968d1eebfab898757e6f3054e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter,
        const_str_plain_gmtime_adj_notAfter,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b6e7e7435391bc9113c1cc9764c3e6e3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a643e6a1050d6f3782a0d190235d80a7,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore,
        const_str_plain_gmtime_adj_notBefore,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a797f2541923bcc6c680cbf8841d85e0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0807c1b9c5bc0ac3cc25375c4a9ebb2e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_69_has_expired(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_69_has_expired,
        const_str_plain_has_expired,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4dcbd11112592d2548a66b42db5772e6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_8ad6e418a1b04e7939cf7e738b8257d2,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_6__get_asn1_time(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_6__get_asn1_time,
        const_str_plain__get_asn1_time,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_91f0594f09524e3872738633f4f7e4d8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c0aedec8dc85440d3dace529a9d9050e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_70__get_boundary_time(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_70__get_boundary_time,
        const_str_plain__get_boundary_time,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d2e6aa63601547b6b03bc44158eb1f5e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_71_get_notBefore(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_71_get_notBefore,
        const_str_plain_get_notBefore,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_70910ab61c2a9a1468d98c3214045299,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_60cf4d81fa4ac0fb8a6d16cafc145b24,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_72__set_boundary_time(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_72__set_boundary_time,
        const_str_plain__set_boundary_time,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a856bd49c4603c5e0e8b903888741c02,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_73_set_notBefore(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_73_set_notBefore,
        const_str_plain_set_notBefore,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_60d95cc23d60386c3b98865d2e08e264,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f35548e1d45f67292233a83f1d0adcce,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_74_get_notAfter(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_74_get_notAfter,
        const_str_plain_get_notAfter,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1455e3e00773aae57fb3dc956853d9a5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_35e2a27cee76091329550405e1cb7dc4,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_75_set_notAfter(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_75_set_notAfter,
        const_str_plain_set_notAfter,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7616cad37f05a65bcb8c1a4729346ad9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_e335a7c8a0dd4d8ab6096b1597d79143,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_76__get_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_76__get_name,
        const_str_plain__get_name,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_31cede2371f8cc0be31721e82cc1d349,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_77__set_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_77__set_name,
        const_str_plain__set_name,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_57a4f44f27b7dd0a656889214e64bb91,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_78_get_issuer(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_78_get_issuer,
        const_str_plain_get_issuer,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8ba34bf3bdf107b089c685c0ea45312d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_40e46351c3b918f338d6e675fea0b1ca,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_79_set_issuer(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_79_set_issuer,
        const_str_plain_set_issuer,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d0171732bc26f9a167787680f68c98bf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_92b8d1a7fa93b4e7d2fab02e37bc15f8,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_7___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_7___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3fbfe9df01a81af8e37bd5a7f5ae6696,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_80_get_subject(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_80_get_subject,
        const_str_plain_get_subject,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4f8ed7f420c0ac066c4fb9a1c956cabc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_2f350f536232587387680a9435c758f6,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_81_set_subject(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_81_set_subject,
        const_str_plain_set_subject,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_be33a06b1200d059a460c969c87bf108,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_e2d5c2f473553b6759cc455da987e04a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_82_get_extension_count(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_82_get_extension_count,
        const_str_plain_get_extension_count,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_52692d97d9af6bf5d9cdd4e751d8736f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_3f7d687efa133ae490fe62a28c3c2584,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_83_add_extensions(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_83_add_extensions,
        const_str_plain_add_extensions,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9f2b9ad144beb7aa9e8cd5e09d9fa943,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_141cd36b231fb1bf7caa692f86984b7e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_84_get_extension(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_84_get_extension,
        const_str_plain_get_extension,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_05bd525e51ba5f81f7baedbcb28010d8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_d0137950921f709b6c00a3276a078e5f,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_85___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_85___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cf52b2979abc3841b63feac291ec11ae,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_86_add_cert(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_86_add_cert,
        const_str_plain_add_cert,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_fb7171180cafea0f8feff8daea432726,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_866d2e2176ccb47ef7515cbc6c993151,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_87_add_crl(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_87_add_crl,
        const_str_plain_add_crl,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7c89e32ae632b40579beca91c3fdd7c2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_998fe297d663eb0475d60a56d2b84182,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_88_set_flags(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_88_set_flags,
        const_str_plain_set_flags,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e56da31fff9a5ba5ac59532a15df82d5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1d1fec7c0642196df296efbe43db1801,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_89_set_time(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_89_set_time,
        const_str_plain_set_time,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b357cc9e906b9722fc07e8962b40d11d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1d608c98cc8048d3f7b439059ee29b66,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_8_add(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_8_add,
        const_str_plain_add,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d0b5dc3540b8ce76d706929407f28bf8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_90_load_locations( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_90_load_locations,
        const_str_plain_load_locations,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2709b5b328fe0d9822af3023feb7896a,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_ce96dba31c9fcf5052c236b4a8160f7f,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_91___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_91___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4e3b06b88584206930ad4ab3fea731d0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_92___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_92___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cc4235dd9f43b9c9542b53c88b8e6a03,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_93__build_certificate_stack(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_93__build_certificate_stack,
        const_str_plain__build_certificate_stack,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_83f6355a0f982176162b7419981e2765,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_93__build_certificate_stack$$$function_1_cleanup(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_93__build_certificate_stack$$$function_1_cleanup,
        const_str_plain_cleanup,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_dbceb89b1b1d3b1149b72b5d9f552b47,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_94__init(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_94__init,
        const_str_plain__init,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_939508a1e0496c5c137cc6f48b750d12,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_32726a73c20427f70712d109be7712b4,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_95__cleanup(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_95__cleanup,
        const_str_plain__cleanup,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6a070d2cef92fc76d5061d3f76c44171,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_61dbd227935e54cb40eecc7de8b8596b,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_96__exception_from_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_96__exception_from_context,
        const_str_plain__exception_from_context,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_22507613a2c65d750fef04b0041d1bcf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_8fda740163dc7d07c78736dc2ebb17b1,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_97_set_store(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_97_set_store,
        const_str_plain_set_store,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_deef68f99d6ac4c33ddafe5e7f7cd886,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_d85051204198165c5d51e35c1e5d5077,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_98_verify_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_98_verify_certificate,
        const_str_plain_verify_certificate,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6093350e55e88ba43a75d89738bbea61,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a2b9bb33a11d02b696dfc736bf45c56d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_99_get_verified_chain(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_99_get_verified_chain,
        const_str_plain_get_verified_chain,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b7cc71e6ff631f267fd48a1034a4d982,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        const_str_digest_458f07858808d53330e13a12d5e50e24,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_9_clear(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_9_clear,
        const_str_plain_clear,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f3c023895e4501d84ce768a27bdd335b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$crypto,
        Py_None,
        0
    );


    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_OpenSSL$crypto =
{
    PyModuleDef_HEAD_INIT,
    "OpenSSL.crypto",   /* m_name */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___package__;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;
#endif
#if PYTHON_VERSION >= 330
extern PyObject *const_str_plain___loader__;
extern PyObject *metapath_based_loader;
#endif
#if PYTHON_VERSION >= 330
extern PyObject *const_str_plain___spec__;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( OpenSSL$crypto )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_OpenSSL$crypto );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    puts("OpenSSL.crypto: Calling setupMetaPathBasedLoader().");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("OpenSSL.crypto: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("OpenSSL.crypto: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initOpenSSL$crypto" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_OpenSSL$crypto = Py_InitModule4(
        "OpenSSL.crypto",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else

    module_OpenSSL$crypto = PyModule_Create( &mdef_OpenSSL$crypto );
#endif

    moduledict_OpenSSL$crypto = MODULE_DICT( module_OpenSSL$crypto );

    // Update "__package__" value to what it ought to be.
    {
#if 0
#if PYTHON_VERSION < 300 || PYTHON_VERSION >= 330
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___name__ );

        UPDATE_STRING_DICT1(
            moduledict_OpenSSL$crypto,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#endif

#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___name__ );
        char const *module_name_cstr = PyString_AS_STRING( module_name );

        char const *last_dot = strrchr( module_name_cstr, '.' );

        if ( last_dot != NULL )
        {
            UPDATE_STRING_DICT1(
                moduledict_OpenSSL$crypto,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize( module_name_cstr, last_dot - module_name_cstr )
            );
        }
#elif PYTHON_VERSION < 330
        UPDATE_STRING_DICT1(
            moduledict_OpenSSL$crypto,
            (Nuitka_StringObject *)const_str_plain___package__,
            Py_None
        );
#else
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___name__ );
        Py_ssize_t dot_index = PyUnicode_Find( module_name, const_str_dot, 0, PyUnicode_GetLength( module_name ), -1 );

        if ( dot_index != -1 )
        {
            UPDATE_STRING_DICT1(
                moduledict_OpenSSL$crypto,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring( module_name, 0, dot_index )
            );
        }
#endif
#endif
    }

    CHECK_OBJECT( module_OpenSSL$crypto );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PySys_GetObject( (char *)"modules" ), const_str_digest_6d237a1253b74549ee18fb0e488e3cf9, module_OpenSSL$crypto );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if ( GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___builtins__, value );
    }

#if PYTHON_VERSION >= 330
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___loader__, metapath_based_loader );
#endif

#if PYTHON_VERSION >= 340
#if 0
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___spec__, Py_None );
#else
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT( bootstrap_module );
        PyObject *module_spec_class = PyObject_GetAttrString( bootstrap_module, "ModuleSpec" );
        Py_DECREF( bootstrap_module );

        PyObject *args[] = {
            GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___name__ ),
            metapath_based_loader
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );

        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___spec__, spec_value );

        Py_DECREF( module_spec_class );
    }
#endif
#endif


    // Temp variables if any
    PyObject *tmp_class_creation_10__class = NULL;
    PyObject *tmp_class_creation_10__class_dict = NULL;
    PyObject *tmp_class_creation_10__metaclass = NULL;
    PyObject *tmp_class_creation_11__bases = NULL;
    PyObject *tmp_class_creation_11__class = NULL;
    PyObject *tmp_class_creation_11__class_dict = NULL;
    PyObject *tmp_class_creation_11__metaclass = NULL;
    PyObject *tmp_class_creation_12__class = NULL;
    PyObject *tmp_class_creation_12__class_dict = NULL;
    PyObject *tmp_class_creation_12__metaclass = NULL;
    PyObject *tmp_class_creation_13__class = NULL;
    PyObject *tmp_class_creation_13__class_dict = NULL;
    PyObject *tmp_class_creation_13__metaclass = NULL;
    PyObject *tmp_class_creation_14__class = NULL;
    PyObject *tmp_class_creation_14__class_dict = NULL;
    PyObject *tmp_class_creation_14__metaclass = NULL;
    PyObject *tmp_class_creation_15__class = NULL;
    PyObject *tmp_class_creation_15__class_dict = NULL;
    PyObject *tmp_class_creation_15__metaclass = NULL;
    PyObject *tmp_class_creation_16__class = NULL;
    PyObject *tmp_class_creation_16__class_dict = NULL;
    PyObject *tmp_class_creation_16__metaclass = NULL;
    PyObject *tmp_class_creation_17__class = NULL;
    PyObject *tmp_class_creation_17__class_dict = NULL;
    PyObject *tmp_class_creation_17__metaclass = NULL;
    PyObject *tmp_class_creation_18__class = NULL;
    PyObject *tmp_class_creation_18__class_dict = NULL;
    PyObject *tmp_class_creation_18__metaclass = NULL;
    PyObject *tmp_class_creation_1__bases = NULL;
    PyObject *tmp_class_creation_1__class = NULL;
    PyObject *tmp_class_creation_1__class_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_2__class = NULL;
    PyObject *tmp_class_creation_2__class_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_3__class = NULL;
    PyObject *tmp_class_creation_3__class_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_4__class = NULL;
    PyObject *tmp_class_creation_4__class_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_5__class = NULL;
    PyObject *tmp_class_creation_5__class_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_6__class = NULL;
    PyObject *tmp_class_creation_6__class_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_7__class = NULL;
    PyObject *tmp_class_creation_7__class_dict = NULL;
    PyObject *tmp_class_creation_7__metaclass = NULL;
    PyObject *tmp_class_creation_8__class = NULL;
    PyObject *tmp_class_creation_8__class_dict = NULL;
    PyObject *tmp_class_creation_8__metaclass = NULL;
    PyObject *tmp_class_creation_9__class = NULL;
    PyObject *tmp_class_creation_9__class_dict = NULL;
    PyObject *tmp_class_creation_9__metaclass = NULL;
    PyObject *tmp_import_from_1__module = NULL;
    PyObject *tmp_import_from_2__module = NULL;
    PyObject *tmp_import_from_3__module = NULL;
    PyObject *tmp_import_from_4__module = NULL;
    PyObject *tmp_import_from_5__module = NULL;
    PyObject *tmp_select_metaclass_11__base = NULL;
    PyObject *tmp_select_metaclass_1__base = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;
    PyObject *exception_keeper_type_28;
    PyObject *exception_keeper_value_28;
    PyTracebackObject *exception_keeper_tb_28;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_28;
    PyObject *exception_keeper_type_29;
    PyObject *exception_keeper_value_29;
    PyTracebackObject *exception_keeper_tb_29;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_29;
    PyObject *exception_keeper_type_30;
    PyObject *exception_keeper_value_30;
    PyTracebackObject *exception_keeper_tb_30;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_30;
    PyObject *exception_keeper_type_31;
    PyObject *exception_keeper_value_31;
    PyTracebackObject *exception_keeper_tb_31;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_31;
    PyObject *exception_keeper_type_32;
    PyObject *exception_keeper_value_32;
    PyTracebackObject *exception_keeper_tb_32;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_32;
    PyObject *exception_keeper_type_33;
    PyObject *exception_keeper_value_33;
    PyTracebackObject *exception_keeper_tb_33;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_33;
    PyObject *exception_keeper_type_34;
    PyObject *exception_keeper_value_34;
    PyTracebackObject *exception_keeper_tb_34;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_34;
    PyObject *exception_keeper_type_35;
    PyObject *exception_keeper_value_35;
    PyTracebackObject *exception_keeper_tb_35;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_35;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_element_name_22;
    PyObject *tmp_args_element_name_23;
    PyObject *tmp_args_element_name_24;
    PyObject *tmp_args_element_name_25;
    PyObject *tmp_args_element_name_26;
    PyObject *tmp_args_element_name_27;
    PyObject *tmp_args_element_name_28;
    PyObject *tmp_args_element_name_29;
    PyObject *tmp_args_element_name_30;
    PyObject *tmp_args_element_name_31;
    PyObject *tmp_args_element_name_32;
    PyObject *tmp_args_element_name_33;
    PyObject *tmp_args_element_name_34;
    PyObject *tmp_args_element_name_35;
    PyObject *tmp_args_element_name_36;
    PyObject *tmp_args_element_name_37;
    PyObject *tmp_args_element_name_38;
    PyObject *tmp_args_element_name_39;
    PyObject *tmp_args_element_name_40;
    PyObject *tmp_args_element_name_41;
    PyObject *tmp_args_element_name_42;
    PyObject *tmp_args_element_name_43;
    PyObject *tmp_args_element_name_44;
    PyObject *tmp_args_element_name_45;
    PyObject *tmp_args_element_name_46;
    PyObject *tmp_args_element_name_47;
    PyObject *tmp_args_element_name_48;
    PyObject *tmp_args_element_name_49;
    PyObject *tmp_args_element_name_50;
    PyObject *tmp_args_element_name_51;
    PyObject *tmp_args_element_name_52;
    PyObject *tmp_args_element_name_53;
    PyObject *tmp_args_element_name_54;
    PyObject *tmp_args_element_name_55;
    PyObject *tmp_args_element_name_56;
    PyObject *tmp_args_element_name_57;
    PyObject *tmp_args_element_name_58;
    PyObject *tmp_args_element_name_59;
    PyObject *tmp_args_element_name_60;
    PyObject *tmp_args_element_name_61;
    PyObject *tmp_args_element_name_62;
    PyObject *tmp_args_element_name_63;
    PyObject *tmp_args_element_name_64;
    PyObject *tmp_args_element_name_65;
    PyObject *tmp_args_element_name_66;
    PyObject *tmp_args_element_name_67;
    PyObject *tmp_args_element_name_68;
    PyObject *tmp_args_element_name_69;
    PyObject *tmp_args_element_name_70;
    PyObject *tmp_args_element_name_71;
    PyObject *tmp_args_element_name_72;
    PyObject *tmp_args_element_name_73;
    PyObject *tmp_args_element_name_74;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_assign_source_30;
    PyObject *tmp_assign_source_31;
    PyObject *tmp_assign_source_32;
    PyObject *tmp_assign_source_33;
    PyObject *tmp_assign_source_34;
    PyObject *tmp_assign_source_35;
    PyObject *tmp_assign_source_36;
    PyObject *tmp_assign_source_37;
    PyObject *tmp_assign_source_38;
    PyObject *tmp_assign_source_39;
    PyObject *tmp_assign_source_40;
    PyObject *tmp_assign_source_41;
    PyObject *tmp_assign_source_42;
    PyObject *tmp_assign_source_43;
    PyObject *tmp_assign_source_44;
    PyObject *tmp_assign_source_45;
    PyObject *tmp_assign_source_46;
    PyObject *tmp_assign_source_47;
    PyObject *tmp_assign_source_48;
    PyObject *tmp_assign_source_49;
    PyObject *tmp_assign_source_50;
    PyObject *tmp_assign_source_51;
    PyObject *tmp_assign_source_52;
    PyObject *tmp_assign_source_53;
    PyObject *tmp_assign_source_54;
    PyObject *tmp_assign_source_55;
    PyObject *tmp_assign_source_56;
    PyObject *tmp_assign_source_57;
    PyObject *tmp_assign_source_58;
    PyObject *tmp_assign_source_59;
    PyObject *tmp_assign_source_60;
    PyObject *tmp_assign_source_61;
    PyObject *tmp_assign_source_62;
    PyObject *tmp_assign_source_63;
    PyObject *tmp_assign_source_64;
    PyObject *tmp_assign_source_65;
    PyObject *tmp_assign_source_66;
    PyObject *tmp_assign_source_67;
    PyObject *tmp_assign_source_68;
    PyObject *tmp_assign_source_69;
    PyObject *tmp_assign_source_70;
    PyObject *tmp_assign_source_71;
    PyObject *tmp_assign_source_72;
    PyObject *tmp_assign_source_73;
    PyObject *tmp_assign_source_74;
    PyObject *tmp_assign_source_75;
    PyObject *tmp_assign_source_76;
    PyObject *tmp_assign_source_77;
    PyObject *tmp_assign_source_78;
    PyObject *tmp_assign_source_79;
    PyObject *tmp_assign_source_80;
    PyObject *tmp_assign_source_81;
    PyObject *tmp_assign_source_82;
    PyObject *tmp_assign_source_83;
    PyObject *tmp_assign_source_84;
    PyObject *tmp_assign_source_85;
    PyObject *tmp_assign_source_86;
    PyObject *tmp_assign_source_87;
    PyObject *tmp_assign_source_88;
    PyObject *tmp_assign_source_89;
    PyObject *tmp_assign_source_90;
    PyObject *tmp_assign_source_91;
    PyObject *tmp_assign_source_92;
    PyObject *tmp_assign_source_93;
    PyObject *tmp_assign_source_94;
    PyObject *tmp_assign_source_95;
    PyObject *tmp_assign_source_96;
    PyObject *tmp_assign_source_97;
    PyObject *tmp_assign_source_98;
    PyObject *tmp_assign_source_99;
    PyObject *tmp_assign_source_100;
    PyObject *tmp_assign_source_101;
    PyObject *tmp_assign_source_102;
    PyObject *tmp_assign_source_103;
    PyObject *tmp_assign_source_104;
    PyObject *tmp_assign_source_105;
    PyObject *tmp_assign_source_106;
    PyObject *tmp_assign_source_107;
    PyObject *tmp_assign_source_108;
    PyObject *tmp_assign_source_109;
    PyObject *tmp_assign_source_110;
    PyObject *tmp_assign_source_111;
    PyObject *tmp_assign_source_112;
    PyObject *tmp_assign_source_113;
    PyObject *tmp_assign_source_114;
    PyObject *tmp_assign_source_115;
    PyObject *tmp_assign_source_116;
    PyObject *tmp_assign_source_117;
    PyObject *tmp_assign_source_118;
    PyObject *tmp_assign_source_119;
    PyObject *tmp_assign_source_120;
    PyObject *tmp_assign_source_121;
    PyObject *tmp_assign_source_122;
    PyObject *tmp_assign_source_123;
    PyObject *tmp_assign_source_124;
    PyObject *tmp_assign_source_125;
    PyObject *tmp_assign_source_126;
    PyObject *tmp_assign_source_127;
    PyObject *tmp_assign_source_128;
    PyObject *tmp_assign_source_129;
    PyObject *tmp_assign_source_130;
    PyObject *tmp_assign_source_131;
    PyObject *tmp_assign_source_132;
    PyObject *tmp_assign_source_133;
    PyObject *tmp_assign_source_134;
    PyObject *tmp_assign_source_135;
    PyObject *tmp_assign_source_136;
    PyObject *tmp_assign_source_137;
    PyObject *tmp_assign_source_138;
    PyObject *tmp_assign_source_139;
    PyObject *tmp_assign_source_140;
    PyObject *tmp_assign_source_141;
    PyObject *tmp_assign_source_142;
    PyObject *tmp_assign_source_143;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    PyObject *tmp_called_name_21;
    PyObject *tmp_called_name_22;
    PyObject *tmp_called_name_23;
    PyObject *tmp_called_name_24;
    PyObject *tmp_called_name_25;
    PyObject *tmp_called_name_26;
    PyObject *tmp_called_name_27;
    PyObject *tmp_called_name_28;
    PyObject *tmp_called_name_29;
    PyObject *tmp_called_name_30;
    PyObject *tmp_called_name_31;
    PyObject *tmp_classmethod_arg_1;
    PyObject *tmp_classmethod_arg_2;
    PyObject *tmp_classmethod_arg_3;
    PyObject *tmp_classmethod_arg_4;
    PyObject *tmp_classmethod_arg_5;
    PyObject *tmp_classmethod_arg_6;
    PyObject *tmp_classmethod_arg_7;
    PyObject *tmp_classmethod_arg_8;
    int tmp_cmp_In_1;
    int tmp_cmp_In_2;
    int tmp_cmp_In_3;
    int tmp_cmp_In_4;
    int tmp_cmp_In_5;
    int tmp_cmp_In_6;
    int tmp_cmp_In_7;
    int tmp_cmp_In_8;
    int tmp_cmp_In_9;
    int tmp_cmp_In_10;
    int tmp_cmp_In_11;
    int tmp_cmp_In_12;
    int tmp_cmp_In_13;
    int tmp_cmp_In_14;
    int tmp_cmp_In_15;
    int tmp_cmp_In_16;
    int tmp_cmp_In_17;
    int tmp_cmp_In_18;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_left_9;
    PyObject *tmp_compare_left_10;
    PyObject *tmp_compare_left_11;
    PyObject *tmp_compare_left_12;
    PyObject *tmp_compare_left_13;
    PyObject *tmp_compare_left_14;
    PyObject *tmp_compare_left_15;
    PyObject *tmp_compare_left_16;
    PyObject *tmp_compare_left_17;
    PyObject *tmp_compare_left_18;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_compare_right_9;
    PyObject *tmp_compare_right_10;
    PyObject *tmp_compare_right_11;
    PyObject *tmp_compare_right_12;
    PyObject *tmp_compare_right_13;
    PyObject *tmp_compare_right_14;
    PyObject *tmp_compare_right_15;
    PyObject *tmp_compare_right_16;
    PyObject *tmp_compare_right_17;
    PyObject *tmp_compare_right_18;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_defaults_1;
    PyObject *tmp_defaults_2;
    PyObject *tmp_defaults_3;
    PyObject *tmp_defaults_4;
    PyObject *tmp_defaults_5;
    PyObject *tmp_defaults_6;
    PyObject *tmp_defaults_7;
    PyObject *tmp_defaults_8;
    PyObject *tmp_defaults_9;
    PyObject *tmp_defaults_10;
    PyObject *tmp_defaults_11;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_name_1;
    PyObject *tmp_dict_name_2;
    PyObject *tmp_dict_name_3;
    PyObject *tmp_dict_name_4;
    PyObject *tmp_dict_name_5;
    PyObject *tmp_dict_name_6;
    PyObject *tmp_dict_name_7;
    PyObject *tmp_dict_name_8;
    PyObject *tmp_dict_name_9;
    PyObject *tmp_dict_name_10;
    PyObject *tmp_dict_name_11;
    PyObject *tmp_dict_name_12;
    PyObject *tmp_dict_name_13;
    PyObject *tmp_dict_name_14;
    PyObject *tmp_dict_name_15;
    PyObject *tmp_dict_name_16;
    PyObject *tmp_dict_name_17;
    PyObject *tmp_dict_name_18;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dictset_value;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_fromlist_name_2;
    PyObject *tmp_fromlist_name_3;
    PyObject *tmp_fromlist_name_4;
    PyObject *tmp_fromlist_name_5;
    PyObject *tmp_fromlist_name_6;
    PyObject *tmp_fromlist_name_7;
    PyObject *tmp_fromlist_name_8;
    PyObject *tmp_fromlist_name_9;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_globals_name_2;
    PyObject *tmp_globals_name_3;
    PyObject *tmp_globals_name_4;
    PyObject *tmp_globals_name_5;
    PyObject *tmp_globals_name_6;
    PyObject *tmp_globals_name_7;
    PyObject *tmp_globals_name_8;
    PyObject *tmp_globals_name_9;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_import_name_from_3;
    PyObject *tmp_import_name_from_4;
    PyObject *tmp_import_name_from_5;
    PyObject *tmp_import_name_from_6;
    PyObject *tmp_import_name_from_7;
    PyObject *tmp_import_name_from_8;
    PyObject *tmp_import_name_from_9;
    PyObject *tmp_import_name_from_10;
    PyObject *tmp_import_name_from_11;
    PyObject *tmp_import_name_from_12;
    PyObject *tmp_import_name_from_13;
    PyObject *tmp_import_name_from_14;
    PyObject *tmp_import_name_from_15;
    PyObject *tmp_import_name_from_16;
    PyObject *tmp_import_name_from_17;
    PyObject *tmp_import_name_from_18;
    PyObject *tmp_import_name_from_19;
    PyObject *tmp_import_name_from_20;
    PyObject *tmp_import_name_from_21;
    PyObject *tmp_import_name_from_22;
    PyObject *tmp_import_name_from_23;
    PyObject *tmp_import_name_from_24;
    PyObject *tmp_key_name_1;
    PyObject *tmp_key_name_2;
    PyObject *tmp_key_name_3;
    PyObject *tmp_key_name_4;
    PyObject *tmp_key_name_5;
    PyObject *tmp_key_name_6;
    PyObject *tmp_key_name_7;
    PyObject *tmp_key_name_8;
    PyObject *tmp_key_name_9;
    PyObject *tmp_key_name_10;
    PyObject *tmp_key_name_11;
    PyObject *tmp_key_name_12;
    PyObject *tmp_key_name_13;
    PyObject *tmp_key_name_14;
    PyObject *tmp_key_name_15;
    PyObject *tmp_key_name_16;
    PyObject *tmp_key_name_17;
    PyObject *tmp_key_name_18;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_locals_name_2;
    PyObject *tmp_locals_name_3;
    PyObject *tmp_locals_name_4;
    PyObject *tmp_locals_name_5;
    PyObject *tmp_locals_name_6;
    PyObject *tmp_locals_name_7;
    PyObject *tmp_locals_name_8;
    PyObject *tmp_locals_name_9;
    PyObject *tmp_name_name_1;
    PyObject *tmp_name_name_2;
    PyObject *tmp_name_name_3;
    PyObject *tmp_name_name_4;
    PyObject *tmp_name_name_5;
    PyObject *tmp_name_name_6;
    PyObject *tmp_name_name_7;
    PyObject *tmp_name_name_8;
    PyObject *tmp_name_name_9;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_outline_return_value_2;
    PyObject *tmp_outline_return_value_3;
    PyObject *tmp_outline_return_value_4;
    PyObject *tmp_outline_return_value_5;
    PyObject *tmp_outline_return_value_6;
    PyObject *tmp_outline_return_value_7;
    PyObject *tmp_outline_return_value_8;
    PyObject *tmp_outline_return_value_9;
    PyObject *tmp_outline_return_value_10;
    PyObject *tmp_outline_return_value_11;
    PyObject *tmp_outline_return_value_12;
    PyObject *tmp_outline_return_value_13;
    PyObject *tmp_outline_return_value_14;
    PyObject *tmp_outline_return_value_15;
    PyObject *tmp_outline_return_value_16;
    PyObject *tmp_outline_return_value_17;
    PyObject *tmp_outline_return_value_18;
    PyObject *tmp_outline_return_value_19;
    PyObject *tmp_outline_return_value_20;
    int tmp_res;
    PyObject *tmp_set_locals;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    PyObject *tmp_source_name_19;
    PyObject *tmp_source_name_20;
    PyObject *tmp_source_name_21;
    PyObject *tmp_source_name_22;
    PyObject *tmp_source_name_23;
    PyObject *tmp_source_name_24;
    PyObject *tmp_staticmethod_arg_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_tuple_element_4;
    PyObject *tmp_type_arg_1;
    PyObject *tmp_type_arg_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_49f77dedf80bc3efafd2f5a607bc3228_2 = NULL;

    struct Nuitka_FrameObject *frame_49f77dedf80bc3efafd2f5a607bc3228_2;

    static struct Nuitka_FrameObject *cache_frame_d39cbe985793ae46e571988cae52c815_3 = NULL;

    struct Nuitka_FrameObject *frame_d39cbe985793ae46e571988cae52c815_3;

    static struct Nuitka_FrameObject *cache_frame_bd5dfefd12bc6c3f36089482b1206592_4 = NULL;

    struct Nuitka_FrameObject *frame_bd5dfefd12bc6c3f36089482b1206592_4;

    static struct Nuitka_FrameObject *cache_frame_efbe69aec7044cb2a39b1ace99dec096_5 = NULL;

    struct Nuitka_FrameObject *frame_efbe69aec7044cb2a39b1ace99dec096_5;

    static struct Nuitka_FrameObject *cache_frame_d6e3285b23310238237c90ac0797e840_6 = NULL;

    struct Nuitka_FrameObject *frame_d6e3285b23310238237c90ac0797e840_6;

    static struct Nuitka_FrameObject *cache_frame_ef4113a8028bdb676c80e7a90f63ad7d_7 = NULL;

    struct Nuitka_FrameObject *frame_ef4113a8028bdb676c80e7a90f63ad7d_7;

    static struct Nuitka_FrameObject *cache_frame_6193021140077dcce0ad2cf734bebd36_8 = NULL;

    struct Nuitka_FrameObject *frame_6193021140077dcce0ad2cf734bebd36_8;

    static struct Nuitka_FrameObject *cache_frame_e7c675b53b12683555b138ae5949022f_9 = NULL;

    struct Nuitka_FrameObject *frame_e7c675b53b12683555b138ae5949022f_9;

    static struct Nuitka_FrameObject *cache_frame_e6218c4ff5c9cc85be7135f57a324c77_10 = NULL;

    struct Nuitka_FrameObject *frame_e6218c4ff5c9cc85be7135f57a324c77_10;

    static struct Nuitka_FrameObject *cache_frame_129fe76254a1387737fbb2b415f27966_11 = NULL;

    struct Nuitka_FrameObject *frame_129fe76254a1387737fbb2b415f27966_11;

    struct Nuitka_FrameObject *frame_46b4308dcfe4b8f3851708d0fb7512b6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_4 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_5 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_6 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_7 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_8 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_9 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_10 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_11 = NULL;
    tmp_outline_return_value_1 = NULL;
    tmp_outline_return_value_2 = NULL;
    tmp_outline_return_value_3 = NULL;
    tmp_outline_return_value_4 = NULL;
    tmp_outline_return_value_5 = NULL;
    tmp_outline_return_value_6 = NULL;
    tmp_outline_return_value_7 = NULL;
    tmp_outline_return_value_8 = NULL;
    tmp_outline_return_value_9 = NULL;
    tmp_outline_return_value_10 = NULL;
    tmp_outline_return_value_11 = NULL;
    tmp_outline_return_value_12 = NULL;
    tmp_outline_return_value_13 = NULL;
    tmp_outline_return_value_14 = NULL;
    tmp_outline_return_value_15 = NULL;
    tmp_outline_return_value_16 = NULL;
    tmp_outline_return_value_17 = NULL;
    tmp_outline_return_value_18 = NULL;
    tmp_outline_return_value_19 = NULL;
    tmp_outline_return_value_20 = NULL;
    PyObject *locals_X509StoreContextError_1732 = NULL;
    PyObject *locals_Revoked_2073 = NULL;
    PyObject *locals_X509StoreFlags_1556 = NULL;
    PyObject *locals_X509StoreContext_1746 = NULL;
    PyObject *locals_X509Name_520 = NULL;
    PyObject *locals_Error_80 = NULL;
    PyObject *locals_X509Store_1580 = NULL;
    PyObject *locals__X509NameInvalidator_210 = NULL;
    PyObject *locals_X509_1083 = NULL;
    PyObject *locals__PassphraseHelper_2782 = NULL;
    PyObject *locals__EllipticCurve_382 = NULL;
    PyObject *locals_X509Extension_720 = NULL;
    PyObject *locals_CRL_2246 = NULL;
    PyObject *locals_PKey_223 = NULL;
    PyObject *locals_PKCS12_2511 = NULL;
    PyObject *locals_NetscapeSPKI_2692 = NULL;
    PyObject *locals_X509Req_872 = NULL;
    PyObject *locals_PKCS7_2467 = NULL;

    // Module code.
    tmp_assign_source_1 = Py_None;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    tmp_assign_source_2 = module_filename_obj;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    // Frame without reuse.
    frame_46b4308dcfe4b8f3851708d0fb7512b6 = MAKE_MODULE_FRAME( codeobj_46b4308dcfe4b8f3851708d0fb7512b6, module_OpenSSL$crypto );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_46b4308dcfe4b8f3851708d0fb7512b6 );
    assert( Py_REFCNT( frame_46b4308dcfe4b8f3851708d0fb7512b6 ) == 2 );

    // Framed code:
    tmp_name_name_1 = const_str_plain_calendar;
    tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = Py_None;
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 1;
    tmp_assign_source_3 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_calendar, tmp_assign_source_3 );
    tmp_name_name_2 = const_str_plain_datetime;
    tmp_globals_name_2 = (PyObject *)moduledict_OpenSSL$crypto;
    tmp_locals_name_2 = Py_None;
    tmp_fromlist_name_2 = Py_None;
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 2;
    tmp_assign_source_4 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_datetime, tmp_assign_source_4 );
    tmp_name_name_3 = const_str_plain_base64;
    tmp_globals_name_3 = (PyObject *)moduledict_OpenSSL$crypto;
    tmp_locals_name_3 = Py_None;
    tmp_fromlist_name_3 = const_tuple_str_plain_b16encode_tuple;
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 4;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 4;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_5 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_b16encode );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 4;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_b16encode, tmp_assign_source_5 );
    tmp_name_name_4 = const_str_plain_functools;
    tmp_globals_name_4 = (PyObject *)moduledict_OpenSSL$crypto;
    tmp_locals_name_4 = Py_None;
    tmp_fromlist_name_4 = const_tuple_str_plain_partial_tuple;
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 5;
    tmp_import_name_from_2 = IMPORT_MODULE4( tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 5;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_6 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_partial );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 5;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_partial, tmp_assign_source_6 );
    tmp_name_name_5 = const_str_plain_operator;
    tmp_globals_name_5 = (PyObject *)moduledict_OpenSSL$crypto;
    tmp_locals_name_5 = Py_None;
    tmp_fromlist_name_5 = const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple;
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 6;
    tmp_assign_source_7 = IMPORT_MODULE4( tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 6;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_1__module == NULL );
    tmp_import_from_1__module = tmp_assign_source_7;

    // Tried code:
    tmp_import_name_from_3 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_3 );
    tmp_assign_source_8 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain___eq__ );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 6;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___eq__, tmp_assign_source_8 );
    tmp_import_name_from_4 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_4 );
    tmp_assign_source_9 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain___ne__ );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 6;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___ne__, tmp_assign_source_9 );
    tmp_import_name_from_5 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_5 );
    tmp_assign_source_10 = IMPORT_NAME( tmp_import_name_from_5, const_str_plain___lt__ );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 6;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___lt__, tmp_assign_source_10 );
    tmp_import_name_from_6 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_6 );
    tmp_assign_source_11 = IMPORT_NAME( tmp_import_name_from_6, const_str_plain___le__ );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 6;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___le__, tmp_assign_source_11 );
    tmp_import_name_from_7 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_7 );
    tmp_assign_source_12 = IMPORT_NAME( tmp_import_name_from_7, const_str_plain___gt__ );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 6;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___gt__, tmp_assign_source_12 );
    tmp_import_name_from_8 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_8 );
    tmp_assign_source_13 = IMPORT_NAME( tmp_import_name_from_8, const_str_plain___ge__ );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 6;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___ge__, tmp_assign_source_13 );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    tmp_name_name_6 = const_str_plain_six;
    tmp_globals_name_6 = (PyObject *)moduledict_OpenSSL$crypto;
    tmp_locals_name_6 = Py_None;
    tmp_fromlist_name_6 = const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY2_tuple;
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 8;
    tmp_assign_source_14 = IMPORT_MODULE4( tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6 );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 8;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_2__module == NULL );
    tmp_import_from_2__module = tmp_assign_source_14;

    // Tried code:
    tmp_import_name_from_9 = tmp_import_from_2__module;

    CHECK_OBJECT( tmp_import_name_from_9 );
    tmp_assign_source_15 = IMPORT_NAME( tmp_import_name_from_9, const_str_plain_integer_types );
    if ( tmp_assign_source_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 8;

        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__integer_types, tmp_assign_source_15 );
    tmp_import_name_from_10 = tmp_import_from_2__module;

    CHECK_OBJECT( tmp_import_name_from_10 );
    tmp_assign_source_16 = IMPORT_NAME( tmp_import_name_from_10, const_str_plain_text_type );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 8;

        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type, tmp_assign_source_16 );
    tmp_import_name_from_11 = tmp_import_from_2__module;

    CHECK_OBJECT( tmp_import_name_from_11 );
    tmp_assign_source_17 = IMPORT_NAME( tmp_import_name_from_11, const_str_plain_PY2 );
    if ( tmp_assign_source_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 8;

        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PY2, tmp_assign_source_17 );
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_2__module );
    Py_DECREF( tmp_import_from_2__module );
    tmp_import_from_2__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_2__module );
    Py_DECREF( tmp_import_from_2__module );
    tmp_import_from_2__module = NULL;

    tmp_name_name_7 = const_str_plain_cryptography;
    tmp_globals_name_7 = (PyObject *)moduledict_OpenSSL$crypto;
    tmp_locals_name_7 = Py_None;
    tmp_fromlist_name_7 = const_tuple_str_plain_utils_str_plain_x509_tuple;
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 14;
    tmp_assign_source_18 = IMPORT_MODULE4( tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7 );
    if ( tmp_assign_source_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 14;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_3__module == NULL );
    tmp_import_from_3__module = tmp_assign_source_18;

    // Tried code:
    tmp_import_name_from_12 = tmp_import_from_3__module;

    CHECK_OBJECT( tmp_import_name_from_12 );
    tmp_assign_source_19 = IMPORT_NAME( tmp_import_name_from_12, const_str_plain_utils );
    if ( tmp_assign_source_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 14;

        goto try_except_handler_3;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_utils, tmp_assign_source_19 );
    tmp_import_name_from_13 = tmp_import_from_3__module;

    CHECK_OBJECT( tmp_import_name_from_13 );
    tmp_assign_source_20 = IMPORT_NAME( tmp_import_name_from_13, const_str_plain_x509 );
    if ( tmp_assign_source_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 14;

        goto try_except_handler_3;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_x509, tmp_assign_source_20 );
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    tmp_name_name_8 = const_str_digest_426349c7e201b358f2086eb3f7fb6f47;
    tmp_globals_name_8 = (PyObject *)moduledict_OpenSSL$crypto;
    tmp_locals_name_8 = Py_None;
    tmp_fromlist_name_8 = const_tuple_str_plain_dsa_str_plain_rsa_tuple;
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 15;
    tmp_assign_source_21 = IMPORT_MODULE4( tmp_name_name_8, tmp_globals_name_8, tmp_locals_name_8, tmp_fromlist_name_8 );
    if ( tmp_assign_source_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 15;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_4__module == NULL );
    tmp_import_from_4__module = tmp_assign_source_21;

    // Tried code:
    tmp_import_name_from_14 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_14 );
    tmp_assign_source_22 = IMPORT_NAME( tmp_import_name_from_14, const_str_plain_dsa );
    if ( tmp_assign_source_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 15;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dsa, tmp_assign_source_22 );
    tmp_import_name_from_15 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_15 );
    tmp_assign_source_23 = IMPORT_NAME( tmp_import_name_from_15, const_str_plain_rsa );
    if ( tmp_assign_source_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 15;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_rsa, tmp_assign_source_23 );
    goto try_end_4;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_4__module );
    Py_DECREF( tmp_import_from_4__module );
    tmp_import_from_4__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_4__module );
    Py_DECREF( tmp_import_from_4__module );
    tmp_import_from_4__module = NULL;

    tmp_name_name_9 = const_str_digest_2c0accc407028fbaba46fefdee9c6c06;
    tmp_globals_name_9 = (PyObject *)moduledict_OpenSSL$crypto;
    tmp_locals_name_9 = Py_None;
    tmp_fromlist_name_9 = const_tuple_7e58e160edb2d3137d6df595cad17d36_tuple;
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 17;
    tmp_assign_source_24 = IMPORT_MODULE4( tmp_name_name_9, tmp_globals_name_9, tmp_locals_name_9, tmp_fromlist_name_9 );
    if ( tmp_assign_source_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_5__module == NULL );
    tmp_import_from_5__module = tmp_assign_source_24;

    // Tried code:
    tmp_import_name_from_16 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_16 );
    tmp_assign_source_25 = IMPORT_NAME( tmp_import_name_from_16, const_str_plain_ffi );
    if ( tmp_assign_source_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi, tmp_assign_source_25 );
    tmp_import_name_from_17 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_17 );
    tmp_assign_source_26 = IMPORT_NAME( tmp_import_name_from_17, const_str_plain_lib );
    if ( tmp_assign_source_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib, tmp_assign_source_26 );
    tmp_import_name_from_18 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_18 );
    tmp_assign_source_27 = IMPORT_NAME( tmp_import_name_from_18, const_str_plain_exception_from_error_queue );
    if ( tmp_assign_source_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue, tmp_assign_source_27 );
    tmp_import_name_from_19 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_19 );
    tmp_assign_source_28 = IMPORT_NAME( tmp_import_name_from_19, const_str_plain_byte_string );
    if ( tmp_assign_source_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string, tmp_assign_source_28 );
    tmp_import_name_from_20 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_20 );
    tmp_assign_source_29 = IMPORT_NAME( tmp_import_name_from_20, const_str_plain_native );
    if ( tmp_assign_source_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native, tmp_assign_source_29 );
    tmp_import_name_from_21 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_21 );
    tmp_assign_source_30 = IMPORT_NAME( tmp_import_name_from_21, const_str_plain_path_string );
    if ( tmp_assign_source_30 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__path_string, tmp_assign_source_30 );
    tmp_import_name_from_22 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_22 );
    tmp_assign_source_31 = IMPORT_NAME( tmp_import_name_from_22, const_str_plain_UNSPECIFIED );
    if ( tmp_assign_source_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED, tmp_assign_source_31 );
    tmp_import_name_from_23 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_23 );
    tmp_assign_source_32 = IMPORT_NAME( tmp_import_name_from_23, const_str_plain_text_to_bytes_and_warn );
    if ( tmp_assign_source_32 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn, tmp_assign_source_32 );
    tmp_import_name_from_24 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_24 );
    tmp_assign_source_33 = IMPORT_NAME( tmp_import_name_from_24, const_str_plain_make_assert );
    if ( tmp_assign_source_33 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__make_assert, tmp_assign_source_33 );
    goto try_end_5;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_5__module );
    Py_DECREF( tmp_import_from_5__module );
    tmp_import_from_5__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_5__module );
    Py_DECREF( tmp_import_from_5__module );
    tmp_import_from_5__module = NULL;

    tmp_assign_source_34 = LIST_COPY( const_list_b8e29824b436479d358fd3771a611e70_list );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___all__, tmp_assign_source_34 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 68;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_35 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_FILETYPE_PEM );
    if ( tmp_assign_source_35 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 68;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM, tmp_assign_source_35 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 69;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_36 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_FILETYPE_ASN1 );
    if ( tmp_assign_source_36 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 69;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1, tmp_assign_source_36 );
    tmp_assign_source_37 = const_int_pos_65535;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT, tmp_assign_source_37 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 74;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_38 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_EVP_PKEY_RSA );
    if ( tmp_assign_source_38 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 74;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_RSA, tmp_assign_source_38 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 75;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_39 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_EVP_PKEY_DSA );
    if ( tmp_assign_source_39 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 75;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_DSA, tmp_assign_source_39 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 76;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_40 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_EVP_PKEY_DH );
    if ( tmp_assign_source_40 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 76;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_DH, tmp_assign_source_40 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 77;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_41 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_EVP_PKEY_EC );
    if ( tmp_assign_source_41 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 77;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_EC, tmp_assign_source_41 );
    tmp_assign_source_42 = PyTuple_New( 1 );
    tmp_tuple_element_1 = PyExc_Exception;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_assign_source_42, 0, tmp_tuple_element_1 );
    assert( tmp_class_creation_1__bases == NULL );
    tmp_class_creation_1__bases = tmp_assign_source_42;

    tmp_set_locals = PyDict_New();
    locals_Error_80 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_Error_80, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_68e309761e6d5dc5f5c1e53801284f3a;
    tmp_res = PyDict_SetItem( locals_Error_80, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_1 = locals_Error_80;
    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_6;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_6:;
    Py_DECREF( locals_Error_80 );
    locals_Error_80 = NULL;
    goto outline_result_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_result_1:;
    tmp_assign_source_43 = tmp_outline_return_value_1;
    assert( tmp_class_creation_1__class_dict == NULL );
    tmp_class_creation_1__class_dict = tmp_assign_source_43;

    // Tried code:
    tmp_compare_left_1 = const_str_plain___metaclass__;
    tmp_compare_right_1 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_dict_name_1 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_dict_name_1 );
    tmp_key_name_1 = const_str_plain___metaclass__;
    tmp_assign_source_44 = DICT_GET_ITEM( tmp_dict_name_1, tmp_key_name_1 );
    if ( tmp_assign_source_44 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 80;

        goto try_except_handler_7;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_subscribed_name_1 = tmp_class_creation_1__bases;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_assign_source_45 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_assign_source_45 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 80;

        goto try_except_handler_7;
    }
    assert( tmp_select_metaclass_1__base == NULL );
    tmp_select_metaclass_1__base = tmp_assign_source_45;

    // Tried code:
    // Tried code:
    tmp_source_name_7 = tmp_select_metaclass_1__base;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_outline_return_value_2 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_7 );
    if ( tmp_outline_return_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 80;

        goto try_except_handler_9;
    }
    goto try_return_handler_8;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_9:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_6 );
    Py_XDECREF( exception_keeper_value_6 );
    Py_XDECREF( exception_keeper_tb_6 );
    tmp_type_arg_1 = tmp_select_metaclass_1__base;

    CHECK_OBJECT( tmp_type_arg_1 );
    tmp_outline_return_value_2 = BUILTIN_TYPE1( tmp_type_arg_1 );
    assert( tmp_outline_return_value_2 != NULL );
    goto try_return_handler_8;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_8:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_1__base );
    Py_DECREF( tmp_select_metaclass_1__base );
    tmp_select_metaclass_1__base = NULL;

    goto outline_result_2;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_1__base );
    Py_DECREF( tmp_select_metaclass_1__base );
    tmp_select_metaclass_1__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_result_2:;
    tmp_assign_source_44 = tmp_outline_return_value_2;
    condexpr_end_1:;
    assert( tmp_class_creation_1__metaclass == NULL );
    tmp_class_creation_1__metaclass = tmp_assign_source_44;

    tmp_called_name_1 = tmp_class_creation_1__metaclass;

    CHECK_OBJECT( tmp_called_name_1 );
    tmp_args_element_name_1 = const_str_plain_Error;
    tmp_args_element_name_2 = tmp_class_creation_1__bases;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 80;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_46 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_46 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 80;

        goto try_except_handler_7;
    }
    assert( tmp_class_creation_1__class == NULL );
    tmp_class_creation_1__class = tmp_assign_source_46;

    goto try_end_6;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases );
    Py_DECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    tmp_assign_source_47 = tmp_class_creation_1__class;

    CHECK_OBJECT( tmp_assign_source_47 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error, tmp_assign_source_47 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class );
    Py_DECREF( tmp_class_creation_1__class );
    tmp_class_creation_1__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases );
    Py_DECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__metaclass );
    Py_DECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_partial );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_partial );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "partial" );
        exception_tb = NULL;

        exception_lineno = 86;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue );

    if (unlikely( tmp_args_element_name_4 == NULL ))
    {
        tmp_args_element_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue );
    }

    if ( tmp_args_element_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_exception_from_error_queue" );
        exception_tb = NULL;

        exception_lineno = 86;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_args_element_name_5 == NULL ))
    {
        tmp_args_element_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_args_element_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 86;

        goto frame_exception_exit_1;
    }

    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 86;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_48 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_48 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 86;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error, tmp_assign_source_48 );
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__make_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_assert" );
        exception_tb = NULL;

        exception_lineno = 87;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_args_element_name_6 == NULL ))
    {
        tmp_args_element_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_args_element_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 87;

        goto frame_exception_exit_1;
    }

    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 87;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_assign_source_49 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    if ( tmp_assign_source_49 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 87;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert, tmp_assign_source_49 );
    tmp_assign_source_50 = MAKE_FUNCTION_OpenSSL$crypto$$$function_1__get_backend(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend, tmp_assign_source_50 );
    tmp_assign_source_51 = MAKE_FUNCTION_OpenSSL$crypto$$$function_2__untested_error(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__untested_error, tmp_assign_source_51 );
    tmp_defaults_1 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_1 );
    tmp_assign_source_52 = MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf( tmp_defaults_1 );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf, tmp_assign_source_52 );
    tmp_assign_source_53 = MAKE_FUNCTION_OpenSSL$crypto$$$function_4__bio_to_string(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string, tmp_assign_source_53 );
    tmp_assign_source_54 = MAKE_FUNCTION_OpenSSL$crypto$$$function_5__set_asn1_time(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__set_asn1_time, tmp_assign_source_54 );
    tmp_assign_source_55 = MAKE_FUNCTION_OpenSSL$crypto$$$function_6__get_asn1_time(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_asn1_time, tmp_assign_source_55 );
    tmp_set_locals = PyDict_New();
    locals__X509NameInvalidator_210 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals__X509NameInvalidator_210, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_7___init__(  );
    tmp_res = PyDict_SetItem( locals__X509NameInvalidator_210, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_8_add(  );
    tmp_res = PyDict_SetItem( locals__X509NameInvalidator_210, const_str_plain_add, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_9_clear(  );
    tmp_res = PyDict_SetItem( locals__X509NameInvalidator_210, const_str_plain_clear, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_3 = locals__X509NameInvalidator_210;
    Py_INCREF( tmp_outline_return_value_3 );
    goto try_return_handler_10;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_10:;
    Py_DECREF( locals__X509NameInvalidator_210 );
    locals__X509NameInvalidator_210 = NULL;
    goto outline_result_3;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_result_3:;
    tmp_assign_source_56 = tmp_outline_return_value_3;
    assert( tmp_class_creation_2__class_dict == NULL );
    tmp_class_creation_2__class_dict = tmp_assign_source_56;

    // Tried code:
    tmp_compare_left_2 = const_str_plain___metaclass__;
    tmp_compare_right_2 = tmp_class_creation_2__class_dict;

    CHECK_OBJECT( tmp_compare_right_2 );
    tmp_cmp_In_2 = PySequence_Contains( tmp_compare_right_2, tmp_compare_left_2 );
    assert( !(tmp_cmp_In_2 == -1) );
    if ( tmp_cmp_In_2 == 1 )
    {
        goto condexpr_true_2;
    }
    else
    {
        goto condexpr_false_2;
    }
    condexpr_true_2:;
    tmp_dict_name_2 = tmp_class_creation_2__class_dict;

    CHECK_OBJECT( tmp_dict_name_2 );
    tmp_key_name_2 = const_str_plain___metaclass__;
    tmp_assign_source_57 = DICT_GET_ITEM( tmp_dict_name_2, tmp_key_name_2 );
    if ( tmp_assign_source_57 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 210;

        goto try_except_handler_11;
    }
    goto condexpr_end_2;
    condexpr_false_2:;
    tmp_assign_source_57 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_57 );
    condexpr_end_2:;
    assert( tmp_class_creation_2__metaclass == NULL );
    tmp_class_creation_2__metaclass = tmp_assign_source_57;

    tmp_called_name_4 = tmp_class_creation_2__metaclass;

    CHECK_OBJECT( tmp_called_name_4 );
    tmp_args_element_name_7 = const_str_plain__X509NameInvalidator;
    tmp_args_element_name_8 = const_tuple_type_object_tuple;
    tmp_args_element_name_9 = tmp_class_creation_2__class_dict;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 210;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_assign_source_58 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    if ( tmp_assign_source_58 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 210;

        goto try_except_handler_11;
    }
    assert( tmp_class_creation_2__class == NULL );
    tmp_class_creation_2__class = tmp_assign_source_58;

    goto try_end_7;
    // Exception handler code:
    try_except_handler_11:;
    exception_keeper_type_8 = exception_type;
    exception_keeper_value_8 = exception_value;
    exception_keeper_tb_8 = exception_tb;
    exception_keeper_lineno_8 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_8;
    exception_value = exception_keeper_value_8;
    exception_tb = exception_keeper_tb_8;
    exception_lineno = exception_keeper_lineno_8;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    tmp_assign_source_59 = tmp_class_creation_2__class;

    CHECK_OBJECT( tmp_assign_source_59 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator, tmp_assign_source_59 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class );
    Py_DECREF( tmp_class_creation_2__class );
    tmp_class_creation_2__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__metaclass );
    Py_DECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_PKey_223 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_PKey_223, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_5997506aef8ffc5e12c453030416acc6;
    tmp_res = PyDict_SetItem( locals_PKey_223, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = Py_False;
    tmp_res = PyDict_SetItem( locals_PKey_223, const_str_plain__only_public, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = Py_True;
    tmp_res = PyDict_SetItem( locals_PKey_223, const_str_plain__initialized, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_10___init__(  );
    tmp_res = PyDict_SetItem( locals_PKey_223, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_11_to_cryptography_key(  );
    tmp_res = PyDict_SetItem( locals_PKey_223, const_str_plain_to_cryptography_key, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_49f77dedf80bc3efafd2f5a607bc3228_2, codeobj_49f77dedf80bc3efafd2f5a607bc3228, module_OpenSSL$crypto, 0 );
    frame_49f77dedf80bc3efafd2f5a607bc3228_2 = cache_frame_49f77dedf80bc3efafd2f5a607bc3228_2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_49f77dedf80bc3efafd2f5a607bc3228_2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_49f77dedf80bc3efafd2f5a607bc3228_2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_classmethod_arg_1 = MAKE_FUNCTION_OpenSSL$crypto$$$function_12_from_cryptography_key(  );
    tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_1 );
    Py_DECREF( tmp_classmethod_arg_1 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 253;

        goto frame_exception_exit_2;
    }
    tmp_res = PyDict_SetItem( locals_PKey_223, const_str_plain_from_cryptography_key, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 253;

        goto frame_exception_exit_2;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_49f77dedf80bc3efafd2f5a607bc3228_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_49f77dedf80bc3efafd2f5a607bc3228_2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_49f77dedf80bc3efafd2f5a607bc3228_2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_49f77dedf80bc3efafd2f5a607bc3228_2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_49f77dedf80bc3efafd2f5a607bc3228_2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_49f77dedf80bc3efafd2f5a607bc3228_2,
        type_description_2
    );


    // Release cached frame.
    if ( frame_49f77dedf80bc3efafd2f5a607bc3228_2 == cache_frame_49f77dedf80bc3efafd2f5a607bc3228_2 )
    {
        Py_DECREF( frame_49f77dedf80bc3efafd2f5a607bc3228_2 );
    }
    cache_frame_49f77dedf80bc3efafd2f5a607bc3228_2 = NULL;

    assertFrameObject( frame_49f77dedf80bc3efafd2f5a607bc3228_2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_1;

    frame_no_exception_1:;

    goto skip_nested_handling_1;
    nested_frame_exit_1:;

    goto try_except_handler_13;
    skip_nested_handling_1:;
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_13_generate_key(  );
    tmp_res = PyDict_SetItem( locals_PKey_223, const_str_plain_generate_key, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_14_check(  );
    tmp_res = PyDict_SetItem( locals_PKey_223, const_str_plain_check, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_15_type(  );
    tmp_res = PyDict_SetItem( locals_PKey_223, const_str_plain_type, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_16_bits(  );
    tmp_res = PyDict_SetItem( locals_PKey_223, const_str_plain_bits, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_4 = locals_PKey_223;
    Py_INCREF( tmp_outline_return_value_4 );
    goto try_return_handler_13;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_13:;
    Py_DECREF( locals_PKey_223 );
    locals_PKey_223 = NULL;
    goto outline_result_4;
    // Exception handler code:
    try_except_handler_13:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PKey_223 );
    locals_PKey_223 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto outline_exception_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_1:;
    exception_lineno = 223;
    goto try_except_handler_12;
    outline_result_4:;
    tmp_assign_source_60 = tmp_outline_return_value_4;
    assert( tmp_class_creation_3__class_dict == NULL );
    tmp_class_creation_3__class_dict = tmp_assign_source_60;

    tmp_compare_left_3 = const_str_plain___metaclass__;
    tmp_compare_right_3 = tmp_class_creation_3__class_dict;

    CHECK_OBJECT( tmp_compare_right_3 );
    tmp_cmp_In_3 = PySequence_Contains( tmp_compare_right_3, tmp_compare_left_3 );
    assert( !(tmp_cmp_In_3 == -1) );
    if ( tmp_cmp_In_3 == 1 )
    {
        goto condexpr_true_3;
    }
    else
    {
        goto condexpr_false_3;
    }
    condexpr_true_3:;
    tmp_dict_name_3 = tmp_class_creation_3__class_dict;

    CHECK_OBJECT( tmp_dict_name_3 );
    tmp_key_name_3 = const_str_plain___metaclass__;
    tmp_assign_source_61 = DICT_GET_ITEM( tmp_dict_name_3, tmp_key_name_3 );
    if ( tmp_assign_source_61 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 223;

        goto try_except_handler_12;
    }
    goto condexpr_end_3;
    condexpr_false_3:;
    tmp_assign_source_61 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_61 );
    condexpr_end_3:;
    assert( tmp_class_creation_3__metaclass == NULL );
    tmp_class_creation_3__metaclass = tmp_assign_source_61;

    tmp_called_name_5 = tmp_class_creation_3__metaclass;

    CHECK_OBJECT( tmp_called_name_5 );
    tmp_args_element_name_10 = const_str_plain_PKey;
    tmp_args_element_name_11 = const_tuple_type_object_tuple;
    tmp_args_element_name_12 = tmp_class_creation_3__class_dict;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 223;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_assign_source_62 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
    }

    if ( tmp_assign_source_62 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 223;

        goto try_except_handler_12;
    }
    assert( tmp_class_creation_3__class == NULL );
    tmp_class_creation_3__class = tmp_assign_source_62;

    goto try_end_8;
    // Exception handler code:
    try_except_handler_12:;
    exception_keeper_type_10 = exception_type;
    exception_keeper_value_10 = exception_value;
    exception_keeper_tb_10 = exception_tb;
    exception_keeper_lineno_10 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_10;
    exception_value = exception_keeper_value_10;
    exception_tb = exception_keeper_tb_10;
    exception_lineno = exception_keeper_lineno_10;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    tmp_assign_source_63 = tmp_class_creation_3__class;

    CHECK_OBJECT( tmp_assign_source_63 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey, tmp_assign_source_63 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class );
    Py_DECREF( tmp_class_creation_3__class );
    tmp_class_creation_3__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_dict );
    Py_DECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__metaclass );
    Py_DECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals__EllipticCurve_382 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals__EllipticCurve_382, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_4a193fbd1ccf06765e0cb44620b7d74a;
    tmp_res = PyDict_SetItem( locals__EllipticCurve_382, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = Py_None;
    tmp_res = PyDict_SetItem( locals__EllipticCurve_382, const_str_plain__curves, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d39cbe985793ae46e571988cae52c815_3, codeobj_d39cbe985793ae46e571988cae52c815, module_OpenSSL$crypto, 0 );
    frame_d39cbe985793ae46e571988cae52c815_3 = cache_frame_d39cbe985793ae46e571988cae52c815_3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d39cbe985793ae46e571988cae52c815_3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d39cbe985793ae46e571988cae52c815_3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_cond_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PY2 );

    if (unlikely( tmp_cond_value_1 == NULL ))
    {
        tmp_cond_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PY2 );
    }

    if ( tmp_cond_value_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_PY2" );
        exception_tb = NULL;

        exception_lineno = 394;

        goto frame_exception_exit_3;
    }

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 394;

        goto frame_exception_exit_3;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_17___ne__(  );
    tmp_res = PyDict_SetItem( locals__EllipticCurve_382, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    branch_no_1:;
    tmp_classmethod_arg_2 = MAKE_FUNCTION_OpenSSL$crypto$$$function_18__load_elliptic_curves(  );
    tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_2 );
    Py_DECREF( tmp_classmethod_arg_2 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 407;

        goto frame_exception_exit_3;
    }
    tmp_res = PyDict_SetItem( locals__EllipticCurve_382, const_str_plain__load_elliptic_curves, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 407;

        goto frame_exception_exit_3;
    }
    tmp_classmethod_arg_3 = MAKE_FUNCTION_OpenSSL$crypto$$$function_19__get_elliptic_curves(  );
    tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_3 );
    Py_DECREF( tmp_classmethod_arg_3 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 425;

        goto frame_exception_exit_3;
    }
    tmp_res = PyDict_SetItem( locals__EllipticCurve_382, const_str_plain__get_elliptic_curves, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 425;

        goto frame_exception_exit_3;
    }
    tmp_classmethod_arg_4 = MAKE_FUNCTION_OpenSSL$crypto$$$function_20_from_nid(  );
    tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_4 );
    Py_DECREF( tmp_classmethod_arg_4 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 439;

        goto frame_exception_exit_3;
    }
    tmp_res = PyDict_SetItem( locals__EllipticCurve_382, const_str_plain_from_nid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 439;

        goto frame_exception_exit_3;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d39cbe985793ae46e571988cae52c815_3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_exception_exit_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d39cbe985793ae46e571988cae52c815_3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d39cbe985793ae46e571988cae52c815_3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d39cbe985793ae46e571988cae52c815_3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d39cbe985793ae46e571988cae52c815_3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d39cbe985793ae46e571988cae52c815_3,
        type_description_2
    );


    // Release cached frame.
    if ( frame_d39cbe985793ae46e571988cae52c815_3 == cache_frame_d39cbe985793ae46e571988cae52c815_3 )
    {
        Py_DECREF( frame_d39cbe985793ae46e571988cae52c815_3 );
    }
    cache_frame_d39cbe985793ae46e571988cae52c815_3 = NULL;

    assertFrameObject( frame_d39cbe985793ae46e571988cae52c815_3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_2;

    frame_no_exception_2:;

    goto skip_nested_handling_2;
    nested_frame_exit_2:;

    goto try_except_handler_15;
    skip_nested_handling_2:;
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_21___init__(  );
    tmp_res = PyDict_SetItem( locals__EllipticCurve_382, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_22___repr__(  );
    tmp_res = PyDict_SetItem( locals__EllipticCurve_382, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_23__to_EC_KEY(  );
    tmp_res = PyDict_SetItem( locals__EllipticCurve_382, const_str_plain__to_EC_KEY, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_5 = locals__EllipticCurve_382;
    Py_INCREF( tmp_outline_return_value_5 );
    goto try_return_handler_15;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_15:;
    Py_DECREF( locals__EllipticCurve_382 );
    locals__EllipticCurve_382 = NULL;
    goto outline_result_5;
    // Exception handler code:
    try_except_handler_15:;
    exception_keeper_type_11 = exception_type;
    exception_keeper_value_11 = exception_value;
    exception_keeper_tb_11 = exception_tb;
    exception_keeper_lineno_11 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals__EllipticCurve_382 );
    locals__EllipticCurve_382 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_11;
    exception_value = exception_keeper_value_11;
    exception_tb = exception_keeper_tb_11;
    exception_lineno = exception_keeper_lineno_11;

    goto outline_exception_2;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_2:;
    exception_lineno = 382;
    goto try_except_handler_14;
    outline_result_5:;
    tmp_assign_source_64 = tmp_outline_return_value_5;
    assert( tmp_class_creation_4__class_dict == NULL );
    tmp_class_creation_4__class_dict = tmp_assign_source_64;

    tmp_compare_left_4 = const_str_plain___metaclass__;
    tmp_compare_right_4 = tmp_class_creation_4__class_dict;

    CHECK_OBJECT( tmp_compare_right_4 );
    tmp_cmp_In_4 = PySequence_Contains( tmp_compare_right_4, tmp_compare_left_4 );
    assert( !(tmp_cmp_In_4 == -1) );
    if ( tmp_cmp_In_4 == 1 )
    {
        goto condexpr_true_4;
    }
    else
    {
        goto condexpr_false_4;
    }
    condexpr_true_4:;
    tmp_dict_name_4 = tmp_class_creation_4__class_dict;

    CHECK_OBJECT( tmp_dict_name_4 );
    tmp_key_name_4 = const_str_plain___metaclass__;
    tmp_assign_source_65 = DICT_GET_ITEM( tmp_dict_name_4, tmp_key_name_4 );
    if ( tmp_assign_source_65 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 382;

        goto try_except_handler_14;
    }
    goto condexpr_end_4;
    condexpr_false_4:;
    tmp_assign_source_65 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_65 );
    condexpr_end_4:;
    assert( tmp_class_creation_4__metaclass == NULL );
    tmp_class_creation_4__metaclass = tmp_assign_source_65;

    tmp_called_name_6 = tmp_class_creation_4__metaclass;

    CHECK_OBJECT( tmp_called_name_6 );
    tmp_args_element_name_13 = const_str_plain__EllipticCurve;
    tmp_args_element_name_14 = const_tuple_type_object_tuple;
    tmp_args_element_name_15 = tmp_class_creation_4__class_dict;

    CHECK_OBJECT( tmp_args_element_name_15 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 382;
    {
        PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15 };
        tmp_assign_source_66 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, call_args );
    }

    if ( tmp_assign_source_66 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 382;

        goto try_except_handler_14;
    }
    assert( tmp_class_creation_4__class == NULL );
    tmp_class_creation_4__class = tmp_assign_source_66;

    goto try_end_9;
    // Exception handler code:
    try_except_handler_14:;
    exception_keeper_type_12 = exception_type;
    exception_keeper_value_12 = exception_value;
    exception_keeper_tb_12 = exception_tb;
    exception_keeper_lineno_12 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_12;
    exception_value = exception_keeper_value_12;
    exception_tb = exception_keeper_tb_12;
    exception_lineno = exception_keeper_lineno_12;

    goto frame_exception_exit_1;
    // End of try:
    try_end_9:;
    tmp_assign_source_67 = tmp_class_creation_4__class;

    CHECK_OBJECT( tmp_assign_source_67 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__EllipticCurve, tmp_assign_source_67 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class );
    Py_DECREF( tmp_class_creation_4__class );
    tmp_class_creation_4__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class_dict );
    Py_DECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__metaclass );
    Py_DECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    tmp_assign_source_68 = MAKE_FUNCTION_OpenSSL$crypto$$$function_24_get_elliptic_curves(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_get_elliptic_curves, tmp_assign_source_68 );
    tmp_assign_source_69 = MAKE_FUNCTION_OpenSSL$crypto$$$function_25_get_elliptic_curve(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_get_elliptic_curve, tmp_assign_source_69 );
    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_X509Name_520 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_5a3f7f69104a4ed1267a21c950d94463;
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_26___init__(  );
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_27___setattr__(  );
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain___setattr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_28___getattr__(  );
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain___getattr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp(  );
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain__cmp, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bd5dfefd12bc6c3f36089482b1206592_4, codeobj_bd5dfefd12bc6c3f36089482b1206592, module_OpenSSL$crypto, 0 );
    frame_bd5dfefd12bc6c3f36089482b1206592_4 = cache_frame_bd5dfefd12bc6c3f36089482b1206592_4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bd5dfefd12bc6c3f36089482b1206592_4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bd5dfefd12bc6c3f36089482b1206592_4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_7 = PyDict_GetItem( locals_X509Name_520, const_str_plain__cmp );

    if ( tmp_called_name_7 == NULL )
    {
        tmp_called_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__cmp );

        if (unlikely( tmp_called_name_7 == NULL ))
        {
            tmp_called_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__cmp );
        }

        if ( tmp_called_name_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_cmp" );
            exception_tb = NULL;

            exception_lineno = 643;

            goto frame_exception_exit_4;
        }

    }

    tmp_args_element_name_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___eq__ );

    if (unlikely( tmp_args_element_name_16 == NULL ))
    {
        tmp_args_element_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___eq__ );
    }

    if ( tmp_args_element_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "__eq__" );
        exception_tb = NULL;

        exception_lineno = 643;

        goto frame_exception_exit_4;
    }

    frame_bd5dfefd12bc6c3f36089482b1206592_4->m_frame.f_lineno = 643;
    {
        PyObject *call_args[] = { tmp_args_element_name_16 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 643;

        goto frame_exception_exit_4;
    }
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain___eq__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 643;

        goto frame_exception_exit_4;
    }
    tmp_called_name_8 = PyDict_GetItem( locals_X509Name_520, const_str_plain__cmp );

    if ( tmp_called_name_8 == NULL )
    {
        tmp_called_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__cmp );

        if (unlikely( tmp_called_name_8 == NULL ))
        {
            tmp_called_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__cmp );
        }

        if ( tmp_called_name_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_cmp" );
            exception_tb = NULL;

            exception_lineno = 644;

            goto frame_exception_exit_4;
        }

    }

    tmp_args_element_name_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___ne__ );

    if (unlikely( tmp_args_element_name_17 == NULL ))
    {
        tmp_args_element_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___ne__ );
    }

    if ( tmp_args_element_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "__ne__" );
        exception_tb = NULL;

        exception_lineno = 644;

        goto frame_exception_exit_4;
    }

    frame_bd5dfefd12bc6c3f36089482b1206592_4->m_frame.f_lineno = 644;
    {
        PyObject *call_args[] = { tmp_args_element_name_17 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
    }

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 644;

        goto frame_exception_exit_4;
    }
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain___ne__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 644;

        goto frame_exception_exit_4;
    }
    tmp_called_name_9 = PyDict_GetItem( locals_X509Name_520, const_str_plain__cmp );

    if ( tmp_called_name_9 == NULL )
    {
        tmp_called_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__cmp );

        if (unlikely( tmp_called_name_9 == NULL ))
        {
            tmp_called_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__cmp );
        }

        if ( tmp_called_name_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_cmp" );
            exception_tb = NULL;

            exception_lineno = 646;

            goto frame_exception_exit_4;
        }

    }

    tmp_args_element_name_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___lt__ );

    if (unlikely( tmp_args_element_name_18 == NULL ))
    {
        tmp_args_element_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___lt__ );
    }

    if ( tmp_args_element_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "__lt__" );
        exception_tb = NULL;

        exception_lineno = 646;

        goto frame_exception_exit_4;
    }

    frame_bd5dfefd12bc6c3f36089482b1206592_4->m_frame.f_lineno = 646;
    {
        PyObject *call_args[] = { tmp_args_element_name_18 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 646;

        goto frame_exception_exit_4;
    }
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain___lt__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 646;

        goto frame_exception_exit_4;
    }
    tmp_called_name_10 = PyDict_GetItem( locals_X509Name_520, const_str_plain__cmp );

    if ( tmp_called_name_10 == NULL )
    {
        tmp_called_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__cmp );

        if (unlikely( tmp_called_name_10 == NULL ))
        {
            tmp_called_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__cmp );
        }

        if ( tmp_called_name_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_cmp" );
            exception_tb = NULL;

            exception_lineno = 647;

            goto frame_exception_exit_4;
        }

    }

    tmp_args_element_name_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___le__ );

    if (unlikely( tmp_args_element_name_19 == NULL ))
    {
        tmp_args_element_name_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___le__ );
    }

    if ( tmp_args_element_name_19 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "__le__" );
        exception_tb = NULL;

        exception_lineno = 647;

        goto frame_exception_exit_4;
    }

    frame_bd5dfefd12bc6c3f36089482b1206592_4->m_frame.f_lineno = 647;
    {
        PyObject *call_args[] = { tmp_args_element_name_19 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
    }

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 647;

        goto frame_exception_exit_4;
    }
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain___le__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 647;

        goto frame_exception_exit_4;
    }
    tmp_called_name_11 = PyDict_GetItem( locals_X509Name_520, const_str_plain__cmp );

    if ( tmp_called_name_11 == NULL )
    {
        tmp_called_name_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__cmp );

        if (unlikely( tmp_called_name_11 == NULL ))
        {
            tmp_called_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__cmp );
        }

        if ( tmp_called_name_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_cmp" );
            exception_tb = NULL;

            exception_lineno = 649;

            goto frame_exception_exit_4;
        }

    }

    tmp_args_element_name_20 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___gt__ );

    if (unlikely( tmp_args_element_name_20 == NULL ))
    {
        tmp_args_element_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___gt__ );
    }

    if ( tmp_args_element_name_20 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "__gt__" );
        exception_tb = NULL;

        exception_lineno = 649;

        goto frame_exception_exit_4;
    }

    frame_bd5dfefd12bc6c3f36089482b1206592_4->m_frame.f_lineno = 649;
    {
        PyObject *call_args[] = { tmp_args_element_name_20 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 649;

        goto frame_exception_exit_4;
    }
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain___gt__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 649;

        goto frame_exception_exit_4;
    }
    tmp_called_name_12 = PyDict_GetItem( locals_X509Name_520, const_str_plain__cmp );

    if ( tmp_called_name_12 == NULL )
    {
        tmp_called_name_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__cmp );

        if (unlikely( tmp_called_name_12 == NULL ))
        {
            tmp_called_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__cmp );
        }

        if ( tmp_called_name_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_cmp" );
            exception_tb = NULL;

            exception_lineno = 650;

            goto frame_exception_exit_4;
        }

    }

    tmp_args_element_name_21 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___ge__ );

    if (unlikely( tmp_args_element_name_21 == NULL ))
    {
        tmp_args_element_name_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___ge__ );
    }

    if ( tmp_args_element_name_21 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "__ge__" );
        exception_tb = NULL;

        exception_lineno = 650;

        goto frame_exception_exit_4;
    }

    frame_bd5dfefd12bc6c3f36089482b1206592_4->m_frame.f_lineno = 650;
    {
        PyObject *call_args[] = { tmp_args_element_name_21 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_12, call_args );
    }

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 650;

        goto frame_exception_exit_4;
    }
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain___ge__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 650;

        goto frame_exception_exit_4;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bd5dfefd12bc6c3f36089482b1206592_4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_3;

    frame_exception_exit_4:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bd5dfefd12bc6c3f36089482b1206592_4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bd5dfefd12bc6c3f36089482b1206592_4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bd5dfefd12bc6c3f36089482b1206592_4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bd5dfefd12bc6c3f36089482b1206592_4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bd5dfefd12bc6c3f36089482b1206592_4,
        type_description_2
    );


    // Release cached frame.
    if ( frame_bd5dfefd12bc6c3f36089482b1206592_4 == cache_frame_bd5dfefd12bc6c3f36089482b1206592_4 )
    {
        Py_DECREF( frame_bd5dfefd12bc6c3f36089482b1206592_4 );
    }
    cache_frame_bd5dfefd12bc6c3f36089482b1206592_4 = NULL;

    assertFrameObject( frame_bd5dfefd12bc6c3f36089482b1206592_4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_3;

    frame_no_exception_3:;

    goto skip_nested_handling_3;
    nested_frame_exit_3:;

    goto try_except_handler_17;
    skip_nested_handling_3:;
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_30___repr__(  );
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_31_hash(  );
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain_hash, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_32_der(  );
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain_der, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_33_get_components(  );
    tmp_res = PyDict_SetItem( locals_X509Name_520, const_str_plain_get_components, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_6 = locals_X509Name_520;
    Py_INCREF( tmp_outline_return_value_6 );
    goto try_return_handler_17;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_17:;
    Py_DECREF( locals_X509Name_520 );
    locals_X509Name_520 = NULL;
    goto outline_result_6;
    // Exception handler code:
    try_except_handler_17:;
    exception_keeper_type_13 = exception_type;
    exception_keeper_value_13 = exception_value;
    exception_keeper_tb_13 = exception_tb;
    exception_keeper_lineno_13 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_X509Name_520 );
    locals_X509Name_520 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_13;
    exception_value = exception_keeper_value_13;
    exception_tb = exception_keeper_tb_13;
    exception_lineno = exception_keeper_lineno_13;

    goto outline_exception_3;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_3:;
    exception_lineno = 520;
    goto try_except_handler_16;
    outline_result_6:;
    tmp_assign_source_70 = tmp_outline_return_value_6;
    assert( tmp_class_creation_5__class_dict == NULL );
    tmp_class_creation_5__class_dict = tmp_assign_source_70;

    tmp_compare_left_5 = const_str_plain___metaclass__;
    tmp_compare_right_5 = tmp_class_creation_5__class_dict;

    CHECK_OBJECT( tmp_compare_right_5 );
    tmp_cmp_In_5 = PySequence_Contains( tmp_compare_right_5, tmp_compare_left_5 );
    assert( !(tmp_cmp_In_5 == -1) );
    if ( tmp_cmp_In_5 == 1 )
    {
        goto condexpr_true_5;
    }
    else
    {
        goto condexpr_false_5;
    }
    condexpr_true_5:;
    tmp_dict_name_5 = tmp_class_creation_5__class_dict;

    CHECK_OBJECT( tmp_dict_name_5 );
    tmp_key_name_5 = const_str_plain___metaclass__;
    tmp_assign_source_71 = DICT_GET_ITEM( tmp_dict_name_5, tmp_key_name_5 );
    if ( tmp_assign_source_71 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 520;

        goto try_except_handler_16;
    }
    goto condexpr_end_5;
    condexpr_false_5:;
    tmp_assign_source_71 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_71 );
    condexpr_end_5:;
    assert( tmp_class_creation_5__metaclass == NULL );
    tmp_class_creation_5__metaclass = tmp_assign_source_71;

    tmp_called_name_13 = tmp_class_creation_5__metaclass;

    CHECK_OBJECT( tmp_called_name_13 );
    tmp_args_element_name_22 = const_str_plain_X509Name;
    tmp_args_element_name_23 = const_tuple_type_object_tuple;
    tmp_args_element_name_24 = tmp_class_creation_5__class_dict;

    CHECK_OBJECT( tmp_args_element_name_24 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 520;
    {
        PyObject *call_args[] = { tmp_args_element_name_22, tmp_args_element_name_23, tmp_args_element_name_24 };
        tmp_assign_source_72 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_13, call_args );
    }

    if ( tmp_assign_source_72 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 520;

        goto try_except_handler_16;
    }
    assert( tmp_class_creation_5__class == NULL );
    tmp_class_creation_5__class = tmp_assign_source_72;

    goto try_end_10;
    // Exception handler code:
    try_except_handler_16:;
    exception_keeper_type_14 = exception_type;
    exception_keeper_value_14 = exception_value;
    exception_keeper_tb_14 = exception_tb;
    exception_keeper_lineno_14 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_14;
    exception_value = exception_keeper_value_14;
    exception_tb = exception_keeper_tb_14;
    exception_lineno = exception_keeper_lineno_14;

    goto frame_exception_exit_1;
    // End of try:
    try_end_10:;
    tmp_assign_source_73 = tmp_class_creation_5__class;

    CHECK_OBJECT( tmp_assign_source_73 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name, tmp_assign_source_73 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class );
    Py_DECREF( tmp_class_creation_5__class );
    tmp_class_creation_5__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class_dict );
    Py_DECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__metaclass );
    Py_DECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_X509Extension_720 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_X509Extension_720, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_b52a484c26b348bfec0a17217a58ad7e;
    tmp_res = PyDict_SetItem( locals_X509Extension_720, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_2 = const_tuple_none_none_tuple;
    Py_INCREF( tmp_defaults_2 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_34___init__( tmp_defaults_2 );
    tmp_res = PyDict_SetItem( locals_X509Extension_720, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_efbe69aec7044cb2a39b1ace99dec096_5, codeobj_efbe69aec7044cb2a39b1ace99dec096, module_OpenSSL$crypto, 0 );
    frame_efbe69aec7044cb2a39b1ace99dec096_5 = cache_frame_efbe69aec7044cb2a39b1ace99dec096_5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_efbe69aec7044cb2a39b1ace99dec096_5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_efbe69aec7044cb2a39b1ace99dec096_5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_14 = (PyObject *)&PyProperty_Type;
    tmp_args_element_name_25 = MAKE_FUNCTION_OpenSSL$crypto$$$function_35__nid(  );
    frame_efbe69aec7044cb2a39b1ace99dec096_5->m_frame.f_lineno = 786;
    {
        PyObject *call_args[] = { tmp_args_element_name_25 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, call_args );
    }

    Py_DECREF( tmp_args_element_name_25 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 786;

        goto frame_exception_exit_5;
    }
    tmp_res = PyDict_SetItem( locals_X509Extension_720, const_str_plain__nid, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 786;

        goto frame_exception_exit_5;
    }
    tmp_dictset_value = _PyDict_NewPresized( 3 );
    tmp_dict_value_1 = const_str_plain_email;
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {
        Py_DECREF( tmp_dictset_value );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 793;

        goto frame_exception_exit_5;
    }

    tmp_dict_key_1 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_GEN_EMAIL );
    if ( tmp_dict_key_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_dictset_value );

        exception_lineno = 793;

        goto frame_exception_exit_5;
    }
    tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_key_1 );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_dictset_value );

        exception_lineno = 792;

        goto frame_exception_exit_5;
    }
    tmp_dict_value_2 = const_str_plain_DNS;
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_9 == NULL )
    {
        Py_DECREF( tmp_dictset_value );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 794;

        goto frame_exception_exit_5;
    }

    tmp_dict_key_2 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_GEN_DNS );
    if ( tmp_dict_key_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_dictset_value );

        exception_lineno = 794;

        goto frame_exception_exit_5;
    }
    tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_key_2 );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_dictset_value );

        exception_lineno = 792;

        goto frame_exception_exit_5;
    }
    tmp_dict_value_3 = const_str_plain_URI;
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_10 == NULL )
    {
        Py_DECREF( tmp_dictset_value );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 795;

        goto frame_exception_exit_5;
    }

    tmp_dict_key_3 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_GEN_URI );
    if ( tmp_dict_key_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_dictset_value );

        exception_lineno = 795;

        goto frame_exception_exit_5;
    }
    tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_key_3 );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_dictset_value );

        exception_lineno = 792;

        goto frame_exception_exit_5;
    }
    tmp_res = PyDict_SetItem( locals_X509Extension_720, const_str_plain__prefixes, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 792;

        goto frame_exception_exit_5;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_efbe69aec7044cb2a39b1ace99dec096_5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_4;

    frame_exception_exit_5:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_efbe69aec7044cb2a39b1ace99dec096_5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_efbe69aec7044cb2a39b1ace99dec096_5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_efbe69aec7044cb2a39b1ace99dec096_5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_efbe69aec7044cb2a39b1ace99dec096_5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_efbe69aec7044cb2a39b1ace99dec096_5,
        type_description_2
    );


    // Release cached frame.
    if ( frame_efbe69aec7044cb2a39b1ace99dec096_5 == cache_frame_efbe69aec7044cb2a39b1ace99dec096_5 )
    {
        Py_DECREF( frame_efbe69aec7044cb2a39b1ace99dec096_5 );
    }
    cache_frame_efbe69aec7044cb2a39b1ace99dec096_5 = NULL;

    assertFrameObject( frame_efbe69aec7044cb2a39b1ace99dec096_5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_4;

    frame_no_exception_4:;

    goto skip_nested_handling_4;
    nested_frame_exit_4:;

    goto try_except_handler_19;
    skip_nested_handling_4:;
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_36__subjectAltNameString(  );
    tmp_res = PyDict_SetItem( locals_X509Extension_720, const_str_plain__subjectAltNameString, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_37___str__(  );
    tmp_res = PyDict_SetItem( locals_X509Extension_720, const_str_plain___str__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_38_get_critical(  );
    tmp_res = PyDict_SetItem( locals_X509Extension_720, const_str_plain_get_critical, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_39_get_short_name(  );
    tmp_res = PyDict_SetItem( locals_X509Extension_720, const_str_plain_get_short_name, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_40_get_data(  );
    tmp_res = PyDict_SetItem( locals_X509Extension_720, const_str_plain_get_data, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_7 = locals_X509Extension_720;
    Py_INCREF( tmp_outline_return_value_7 );
    goto try_return_handler_19;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_19:;
    Py_DECREF( locals_X509Extension_720 );
    locals_X509Extension_720 = NULL;
    goto outline_result_7;
    // Exception handler code:
    try_except_handler_19:;
    exception_keeper_type_15 = exception_type;
    exception_keeper_value_15 = exception_value;
    exception_keeper_tb_15 = exception_tb;
    exception_keeper_lineno_15 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_X509Extension_720 );
    locals_X509Extension_720 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_15;
    exception_value = exception_keeper_value_15;
    exception_tb = exception_keeper_tb_15;
    exception_lineno = exception_keeper_lineno_15;

    goto outline_exception_4;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_4:;
    exception_lineno = 720;
    goto try_except_handler_18;
    outline_result_7:;
    tmp_assign_source_74 = tmp_outline_return_value_7;
    assert( tmp_class_creation_6__class_dict == NULL );
    tmp_class_creation_6__class_dict = tmp_assign_source_74;

    tmp_compare_left_6 = const_str_plain___metaclass__;
    tmp_compare_right_6 = tmp_class_creation_6__class_dict;

    CHECK_OBJECT( tmp_compare_right_6 );
    tmp_cmp_In_6 = PySequence_Contains( tmp_compare_right_6, tmp_compare_left_6 );
    assert( !(tmp_cmp_In_6 == -1) );
    if ( tmp_cmp_In_6 == 1 )
    {
        goto condexpr_true_6;
    }
    else
    {
        goto condexpr_false_6;
    }
    condexpr_true_6:;
    tmp_dict_name_6 = tmp_class_creation_6__class_dict;

    CHECK_OBJECT( tmp_dict_name_6 );
    tmp_key_name_6 = const_str_plain___metaclass__;
    tmp_assign_source_75 = DICT_GET_ITEM( tmp_dict_name_6, tmp_key_name_6 );
    if ( tmp_assign_source_75 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 720;

        goto try_except_handler_18;
    }
    goto condexpr_end_6;
    condexpr_false_6:;
    tmp_assign_source_75 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_75 );
    condexpr_end_6:;
    assert( tmp_class_creation_6__metaclass == NULL );
    tmp_class_creation_6__metaclass = tmp_assign_source_75;

    tmp_called_name_15 = tmp_class_creation_6__metaclass;

    CHECK_OBJECT( tmp_called_name_15 );
    tmp_args_element_name_26 = const_str_plain_X509Extension;
    tmp_args_element_name_27 = const_tuple_type_object_tuple;
    tmp_args_element_name_28 = tmp_class_creation_6__class_dict;

    CHECK_OBJECT( tmp_args_element_name_28 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 720;
    {
        PyObject *call_args[] = { tmp_args_element_name_26, tmp_args_element_name_27, tmp_args_element_name_28 };
        tmp_assign_source_76 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_15, call_args );
    }

    if ( tmp_assign_source_76 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 720;

        goto try_except_handler_18;
    }
    assert( tmp_class_creation_6__class == NULL );
    tmp_class_creation_6__class = tmp_assign_source_76;

    goto try_end_11;
    // Exception handler code:
    try_except_handler_18:;
    exception_keeper_type_16 = exception_type;
    exception_keeper_value_16 = exception_value;
    exception_keeper_tb_16 = exception_tb;
    exception_keeper_lineno_16 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_16;
    exception_value = exception_keeper_value_16;
    exception_tb = exception_keeper_tb_16;
    exception_lineno = exception_keeper_lineno_16;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    tmp_assign_source_77 = tmp_class_creation_6__class;

    CHECK_OBJECT( tmp_assign_source_77 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension, tmp_assign_source_77 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class );
    Py_DECREF( tmp_class_creation_6__class );
    tmp_class_creation_6__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class_dict );
    Py_DECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__metaclass );
    Py_DECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_X509Req_872 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_9226325aac109a91f8326c1a26ede065;
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_41___init__(  );
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_42_to_cryptography(  );
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain_to_cryptography, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d6e3285b23310238237c90ac0797e840_6, codeobj_d6e3285b23310238237c90ac0797e840, module_OpenSSL$crypto, 0 );
    frame_d6e3285b23310238237c90ac0797e840_6 = cache_frame_d6e3285b23310238237c90ac0797e840_6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d6e3285b23310238237c90ac0797e840_6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d6e3285b23310238237c90ac0797e840_6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_classmethod_arg_5 = MAKE_FUNCTION_OpenSSL$crypto$$$function_43_from_cryptography(  );
    tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_5 );
    Py_DECREF( tmp_classmethod_arg_5 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 898;

        goto frame_exception_exit_6;
    }
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain_from_cryptography, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 898;

        goto frame_exception_exit_6;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d6e3285b23310238237c90ac0797e840_6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_5;

    frame_exception_exit_6:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d6e3285b23310238237c90ac0797e840_6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d6e3285b23310238237c90ac0797e840_6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d6e3285b23310238237c90ac0797e840_6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d6e3285b23310238237c90ac0797e840_6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d6e3285b23310238237c90ac0797e840_6,
        type_description_2
    );


    // Release cached frame.
    if ( frame_d6e3285b23310238237c90ac0797e840_6 == cache_frame_d6e3285b23310238237c90ac0797e840_6 )
    {
        Py_DECREF( frame_d6e3285b23310238237c90ac0797e840_6 );
    }
    cache_frame_d6e3285b23310238237c90ac0797e840_6 = NULL;

    assertFrameObject( frame_d6e3285b23310238237c90ac0797e840_6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_5;

    frame_no_exception_5:;

    goto skip_nested_handling_5;
    nested_frame_exit_5:;

    goto try_except_handler_21;
    skip_nested_handling_5:;
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_44_set_pubkey(  );
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain_set_pubkey, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_45_get_pubkey(  );
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain_get_pubkey, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_46_set_version(  );
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain_set_version, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_47_get_version(  );
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain_get_version, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_48_get_subject(  );
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain_get_subject, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_49_add_extensions(  );
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain_add_extensions, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_50_get_extensions(  );
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain_get_extensions, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_51_sign(  );
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain_sign, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_52_verify(  );
    tmp_res = PyDict_SetItem( locals_X509Req_872, const_str_plain_verify, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_8 = locals_X509Req_872;
    Py_INCREF( tmp_outline_return_value_8 );
    goto try_return_handler_21;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_21:;
    Py_DECREF( locals_X509Req_872 );
    locals_X509Req_872 = NULL;
    goto outline_result_8;
    // Exception handler code:
    try_except_handler_21:;
    exception_keeper_type_17 = exception_type;
    exception_keeper_value_17 = exception_value;
    exception_keeper_tb_17 = exception_tb;
    exception_keeper_lineno_17 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_X509Req_872 );
    locals_X509Req_872 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_17;
    exception_value = exception_keeper_value_17;
    exception_tb = exception_keeper_tb_17;
    exception_lineno = exception_keeper_lineno_17;

    goto outline_exception_5;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_5:;
    exception_lineno = 872;
    goto try_except_handler_20;
    outline_result_8:;
    tmp_assign_source_78 = tmp_outline_return_value_8;
    assert( tmp_class_creation_7__class_dict == NULL );
    tmp_class_creation_7__class_dict = tmp_assign_source_78;

    tmp_compare_left_7 = const_str_plain___metaclass__;
    tmp_compare_right_7 = tmp_class_creation_7__class_dict;

    CHECK_OBJECT( tmp_compare_right_7 );
    tmp_cmp_In_7 = PySequence_Contains( tmp_compare_right_7, tmp_compare_left_7 );
    assert( !(tmp_cmp_In_7 == -1) );
    if ( tmp_cmp_In_7 == 1 )
    {
        goto condexpr_true_7;
    }
    else
    {
        goto condexpr_false_7;
    }
    condexpr_true_7:;
    tmp_dict_name_7 = tmp_class_creation_7__class_dict;

    CHECK_OBJECT( tmp_dict_name_7 );
    tmp_key_name_7 = const_str_plain___metaclass__;
    tmp_assign_source_79 = DICT_GET_ITEM( tmp_dict_name_7, tmp_key_name_7 );
    if ( tmp_assign_source_79 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 872;

        goto try_except_handler_20;
    }
    goto condexpr_end_7;
    condexpr_false_7:;
    tmp_assign_source_79 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_79 );
    condexpr_end_7:;
    assert( tmp_class_creation_7__metaclass == NULL );
    tmp_class_creation_7__metaclass = tmp_assign_source_79;

    tmp_called_name_16 = tmp_class_creation_7__metaclass;

    CHECK_OBJECT( tmp_called_name_16 );
    tmp_args_element_name_29 = const_str_plain_X509Req;
    tmp_args_element_name_30 = const_tuple_type_object_tuple;
    tmp_args_element_name_31 = tmp_class_creation_7__class_dict;

    CHECK_OBJECT( tmp_args_element_name_31 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 872;
    {
        PyObject *call_args[] = { tmp_args_element_name_29, tmp_args_element_name_30, tmp_args_element_name_31 };
        tmp_assign_source_80 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_16, call_args );
    }

    if ( tmp_assign_source_80 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 872;

        goto try_except_handler_20;
    }
    assert( tmp_class_creation_7__class == NULL );
    tmp_class_creation_7__class = tmp_assign_source_80;

    goto try_end_12;
    // Exception handler code:
    try_except_handler_20:;
    exception_keeper_type_18 = exception_type;
    exception_keeper_value_18 = exception_value;
    exception_keeper_tb_18 = exception_tb;
    exception_keeper_lineno_18 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_18;
    exception_value = exception_keeper_value_18;
    exception_tb = exception_keeper_tb_18;
    exception_lineno = exception_keeper_lineno_18;

    goto frame_exception_exit_1;
    // End of try:
    try_end_12:;
    tmp_assign_source_81 = tmp_class_creation_7__class;

    CHECK_OBJECT( tmp_assign_source_81 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Req, tmp_assign_source_81 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class );
    Py_DECREF( tmp_class_creation_7__class );
    tmp_class_creation_7__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class_dict );
    Py_DECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__metaclass );
    Py_DECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_X509_1083 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_2cf9e4c7f607857df636a128997ff3fc;
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_53___init__(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ef4113a8028bdb676c80e7a90f63ad7d_7, codeobj_ef4113a8028bdb676c80e7a90f63ad7d, module_OpenSSL$crypto, 0 );
    frame_ef4113a8028bdb676c80e7a90f63ad7d_7 = cache_frame_ef4113a8028bdb676c80e7a90f63ad7d_7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ef4113a8028bdb676c80e7a90f63ad7d_7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ef4113a8028bdb676c80e7a90f63ad7d_7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_classmethod_arg_6 = MAKE_FUNCTION_OpenSSL$crypto$$$function_54__from_raw_x509_ptr(  );
    tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_6 );
    Py_DECREF( tmp_classmethod_arg_6 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1096;

        goto frame_exception_exit_7;
    }
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain__from_raw_x509_ptr, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1096;

        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_55_to_cryptography(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_to_cryptography, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_classmethod_arg_7 = MAKE_FUNCTION_OpenSSL$crypto$$$function_56_from_cryptography(  );
    tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_7 );
    Py_DECREF( tmp_classmethod_arg_7 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1117;

        goto frame_exception_exit_7;
    }
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_from_cryptography, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1117;

        goto frame_exception_exit_7;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ef4113a8028bdb676c80e7a90f63ad7d_7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_6;

    frame_exception_exit_7:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ef4113a8028bdb676c80e7a90f63ad7d_7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ef4113a8028bdb676c80e7a90f63ad7d_7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ef4113a8028bdb676c80e7a90f63ad7d_7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ef4113a8028bdb676c80e7a90f63ad7d_7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ef4113a8028bdb676c80e7a90f63ad7d_7,
        type_description_2
    );


    // Release cached frame.
    if ( frame_ef4113a8028bdb676c80e7a90f63ad7d_7 == cache_frame_ef4113a8028bdb676c80e7a90f63ad7d_7 )
    {
        Py_DECREF( frame_ef4113a8028bdb676c80e7a90f63ad7d_7 );
    }
    cache_frame_ef4113a8028bdb676c80e7a90f63ad7d_7 = NULL;

    assertFrameObject( frame_ef4113a8028bdb676c80e7a90f63ad7d_7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_6;

    frame_no_exception_6:;

    goto skip_nested_handling_6;
    nested_frame_exit_6:;

    goto try_except_handler_23;
    skip_nested_handling_6:;
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_57_set_version(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_set_version, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_58_get_version(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_get_version, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_59_get_pubkey(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_get_pubkey, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_60_set_pubkey(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_set_pubkey, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_61_sign(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_sign, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_62_get_signature_algorithm(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_get_signature_algorithm, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_63_digest(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_digest, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_64_subject_name_hash(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_subject_name_hash, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_65_set_serial_number(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_set_serial_number, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_66_get_serial_number(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_get_serial_number, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_gmtime_adj_notAfter, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_gmtime_adj_notBefore, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_69_has_expired(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_has_expired, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_70__get_boundary_time(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain__get_boundary_time, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_71_get_notBefore(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_get_notBefore, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_72__set_boundary_time(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain__set_boundary_time, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_73_set_notBefore(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_set_notBefore, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_74_get_notAfter(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_get_notAfter, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_75_set_notAfter(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_set_notAfter, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_76__get_name(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain__get_name, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_77__set_name(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain__set_name, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_78_get_issuer(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_get_issuer, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_79_set_issuer(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_set_issuer, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_80_get_subject(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_get_subject, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_81_set_subject(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_set_subject, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_82_get_extension_count(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_get_extension_count, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_83_add_extensions(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_add_extensions, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_84_get_extension(  );
    tmp_res = PyDict_SetItem( locals_X509_1083, const_str_plain_get_extension, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_9 = locals_X509_1083;
    Py_INCREF( tmp_outline_return_value_9 );
    goto try_return_handler_23;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_23:;
    Py_DECREF( locals_X509_1083 );
    locals_X509_1083 = NULL;
    goto outline_result_9;
    // Exception handler code:
    try_except_handler_23:;
    exception_keeper_type_19 = exception_type;
    exception_keeper_value_19 = exception_value;
    exception_keeper_tb_19 = exception_tb;
    exception_keeper_lineno_19 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_X509_1083 );
    locals_X509_1083 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_19;
    exception_value = exception_keeper_value_19;
    exception_tb = exception_keeper_tb_19;
    exception_lineno = exception_keeper_lineno_19;

    goto outline_exception_6;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_6:;
    exception_lineno = 1083;
    goto try_except_handler_22;
    outline_result_9:;
    tmp_assign_source_82 = tmp_outline_return_value_9;
    assert( tmp_class_creation_8__class_dict == NULL );
    tmp_class_creation_8__class_dict = tmp_assign_source_82;

    tmp_compare_left_8 = const_str_plain___metaclass__;
    tmp_compare_right_8 = tmp_class_creation_8__class_dict;

    CHECK_OBJECT( tmp_compare_right_8 );
    tmp_cmp_In_8 = PySequence_Contains( tmp_compare_right_8, tmp_compare_left_8 );
    assert( !(tmp_cmp_In_8 == -1) );
    if ( tmp_cmp_In_8 == 1 )
    {
        goto condexpr_true_8;
    }
    else
    {
        goto condexpr_false_8;
    }
    condexpr_true_8:;
    tmp_dict_name_8 = tmp_class_creation_8__class_dict;

    CHECK_OBJECT( tmp_dict_name_8 );
    tmp_key_name_8 = const_str_plain___metaclass__;
    tmp_assign_source_83 = DICT_GET_ITEM( tmp_dict_name_8, tmp_key_name_8 );
    if ( tmp_assign_source_83 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1083;

        goto try_except_handler_22;
    }
    goto condexpr_end_8;
    condexpr_false_8:;
    tmp_assign_source_83 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_83 );
    condexpr_end_8:;
    assert( tmp_class_creation_8__metaclass == NULL );
    tmp_class_creation_8__metaclass = tmp_assign_source_83;

    tmp_called_name_17 = tmp_class_creation_8__metaclass;

    CHECK_OBJECT( tmp_called_name_17 );
    tmp_args_element_name_32 = const_str_plain_X509;
    tmp_args_element_name_33 = const_tuple_type_object_tuple;
    tmp_args_element_name_34 = tmp_class_creation_8__class_dict;

    CHECK_OBJECT( tmp_args_element_name_34 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 1083;
    {
        PyObject *call_args[] = { tmp_args_element_name_32, tmp_args_element_name_33, tmp_args_element_name_34 };
        tmp_assign_source_84 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_17, call_args );
    }

    if ( tmp_assign_source_84 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1083;

        goto try_except_handler_22;
    }
    assert( tmp_class_creation_8__class == NULL );
    tmp_class_creation_8__class = tmp_assign_source_84;

    goto try_end_13;
    // Exception handler code:
    try_except_handler_22:;
    exception_keeper_type_20 = exception_type;
    exception_keeper_value_20 = exception_value;
    exception_keeper_tb_20 = exception_tb;
    exception_keeper_lineno_20 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_20;
    exception_value = exception_keeper_value_20;
    exception_tb = exception_keeper_tb_20;
    exception_lineno = exception_keeper_lineno_20;

    goto frame_exception_exit_1;
    // End of try:
    try_end_13:;
    tmp_assign_source_85 = tmp_class_creation_8__class;

    CHECK_OBJECT( tmp_assign_source_85 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509, tmp_assign_source_85 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class );
    Py_DECREF( tmp_class_creation_8__class );
    tmp_class_creation_8__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class_dict );
    Py_DECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__metaclass );
    Py_DECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_X509StoreFlags_1556 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_X509StoreFlags_1556, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_6ef28169edd3cfe530885f6f9d09c390;
    tmp_res = PyDict_SetItem( locals_X509StoreFlags_1556, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6193021140077dcce0ad2cf734bebd36_8, codeobj_6193021140077dcce0ad2cf734bebd36, module_OpenSSL$crypto, 0 );
    frame_6193021140077dcce0ad2cf734bebd36_8 = cache_frame_6193021140077dcce0ad2cf734bebd36_8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6193021140077dcce0ad2cf734bebd36_8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6193021140077dcce0ad2cf734bebd36_8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1567;

        goto frame_exception_exit_8;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_X509_V_FLAG_CRL_CHECK );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1567;

        goto frame_exception_exit_8;
    }
    tmp_res = PyDict_SetItem( locals_X509StoreFlags_1556, const_str_plain_CRL_CHECK, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1567;

        goto frame_exception_exit_8;
    }
    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1568;

        goto frame_exception_exit_8;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_X509_V_FLAG_CRL_CHECK_ALL );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1568;

        goto frame_exception_exit_8;
    }
    tmp_res = PyDict_SetItem( locals_X509StoreFlags_1556, const_str_plain_CRL_CHECK_ALL, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1568;

        goto frame_exception_exit_8;
    }
    tmp_source_name_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_13 == NULL ))
    {
        tmp_source_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_13 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1569;

        goto frame_exception_exit_8;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_X509_V_FLAG_IGNORE_CRITICAL );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1569;

        goto frame_exception_exit_8;
    }
    tmp_res = PyDict_SetItem( locals_X509StoreFlags_1556, const_str_plain_IGNORE_CRITICAL, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1569;

        goto frame_exception_exit_8;
    }
    tmp_source_name_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_14 == NULL ))
    {
        tmp_source_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1570;

        goto frame_exception_exit_8;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_X509_V_FLAG_X509_STRICT );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1570;

        goto frame_exception_exit_8;
    }
    tmp_res = PyDict_SetItem( locals_X509StoreFlags_1556, const_str_plain_X509_STRICT, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1570;

        goto frame_exception_exit_8;
    }
    tmp_source_name_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_15 == NULL ))
    {
        tmp_source_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1571;

        goto frame_exception_exit_8;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_X509_V_FLAG_ALLOW_PROXY_CERTS );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1571;

        goto frame_exception_exit_8;
    }
    tmp_res = PyDict_SetItem( locals_X509StoreFlags_1556, const_str_plain_ALLOW_PROXY_CERTS, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1571;

        goto frame_exception_exit_8;
    }
    tmp_source_name_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_16 == NULL ))
    {
        tmp_source_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1572;

        goto frame_exception_exit_8;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_X509_V_FLAG_POLICY_CHECK );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1572;

        goto frame_exception_exit_8;
    }
    tmp_res = PyDict_SetItem( locals_X509StoreFlags_1556, const_str_plain_POLICY_CHECK, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1572;

        goto frame_exception_exit_8;
    }
    tmp_source_name_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_17 == NULL ))
    {
        tmp_source_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1573;

        goto frame_exception_exit_8;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_X509_V_FLAG_EXPLICIT_POLICY );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1573;

        goto frame_exception_exit_8;
    }
    tmp_res = PyDict_SetItem( locals_X509StoreFlags_1556, const_str_plain_EXPLICIT_POLICY, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1573;

        goto frame_exception_exit_8;
    }
    tmp_source_name_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_18 == NULL ))
    {
        tmp_source_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1574;

        goto frame_exception_exit_8;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_X509_V_FLAG_INHIBIT_MAP );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1574;

        goto frame_exception_exit_8;
    }
    tmp_res = PyDict_SetItem( locals_X509StoreFlags_1556, const_str_plain_INHIBIT_MAP, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1574;

        goto frame_exception_exit_8;
    }
    tmp_source_name_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_19 == NULL ))
    {
        tmp_source_name_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_19 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1575;

        goto frame_exception_exit_8;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_X509_V_FLAG_NOTIFY_POLICY );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1575;

        goto frame_exception_exit_8;
    }
    tmp_res = PyDict_SetItem( locals_X509StoreFlags_1556, const_str_plain_NOTIFY_POLICY, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1575;

        goto frame_exception_exit_8;
    }
    tmp_source_name_20 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_20 == NULL ))
    {
        tmp_source_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_20 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1576;

        goto frame_exception_exit_8;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_X509_V_FLAG_CHECK_SS_SIGNATURE );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1576;

        goto frame_exception_exit_8;
    }
    tmp_res = PyDict_SetItem( locals_X509StoreFlags_1556, const_str_plain_CHECK_SS_SIGNATURE, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1576;

        goto frame_exception_exit_8;
    }
    tmp_source_name_21 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_21 == NULL ))
    {
        tmp_source_name_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_21 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1577;

        goto frame_exception_exit_8;
    }

    tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_21, const_str_plain_X509_V_FLAG_CB_ISSUER_CHECK );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1577;

        goto frame_exception_exit_8;
    }
    tmp_res = PyDict_SetItem( locals_X509StoreFlags_1556, const_str_plain_CB_ISSUER_CHECK, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1577;

        goto frame_exception_exit_8;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6193021140077dcce0ad2cf734bebd36_8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_7;

    frame_exception_exit_8:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6193021140077dcce0ad2cf734bebd36_8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6193021140077dcce0ad2cf734bebd36_8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6193021140077dcce0ad2cf734bebd36_8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6193021140077dcce0ad2cf734bebd36_8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6193021140077dcce0ad2cf734bebd36_8,
        type_description_2
    );


    // Release cached frame.
    if ( frame_6193021140077dcce0ad2cf734bebd36_8 == cache_frame_6193021140077dcce0ad2cf734bebd36_8 )
    {
        Py_DECREF( frame_6193021140077dcce0ad2cf734bebd36_8 );
    }
    cache_frame_6193021140077dcce0ad2cf734bebd36_8 = NULL;

    assertFrameObject( frame_6193021140077dcce0ad2cf734bebd36_8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_7;

    frame_no_exception_7:;

    goto skip_nested_handling_7;
    nested_frame_exit_7:;

    goto try_except_handler_25;
    skip_nested_handling_7:;
    tmp_outline_return_value_10 = locals_X509StoreFlags_1556;
    Py_INCREF( tmp_outline_return_value_10 );
    goto try_return_handler_25;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_25:;
    Py_DECREF( locals_X509StoreFlags_1556 );
    locals_X509StoreFlags_1556 = NULL;
    goto outline_result_10;
    // Exception handler code:
    try_except_handler_25:;
    exception_keeper_type_21 = exception_type;
    exception_keeper_value_21 = exception_value;
    exception_keeper_tb_21 = exception_tb;
    exception_keeper_lineno_21 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_X509StoreFlags_1556 );
    locals_X509StoreFlags_1556 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_21;
    exception_value = exception_keeper_value_21;
    exception_tb = exception_keeper_tb_21;
    exception_lineno = exception_keeper_lineno_21;

    goto outline_exception_7;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_7:;
    exception_lineno = 1556;
    goto try_except_handler_24;
    outline_result_10:;
    tmp_assign_source_86 = tmp_outline_return_value_10;
    assert( tmp_class_creation_9__class_dict == NULL );
    tmp_class_creation_9__class_dict = tmp_assign_source_86;

    tmp_compare_left_9 = const_str_plain___metaclass__;
    tmp_compare_right_9 = tmp_class_creation_9__class_dict;

    CHECK_OBJECT( tmp_compare_right_9 );
    tmp_cmp_In_9 = PySequence_Contains( tmp_compare_right_9, tmp_compare_left_9 );
    assert( !(tmp_cmp_In_9 == -1) );
    if ( tmp_cmp_In_9 == 1 )
    {
        goto condexpr_true_9;
    }
    else
    {
        goto condexpr_false_9;
    }
    condexpr_true_9:;
    tmp_dict_name_9 = tmp_class_creation_9__class_dict;

    CHECK_OBJECT( tmp_dict_name_9 );
    tmp_key_name_9 = const_str_plain___metaclass__;
    tmp_assign_source_87 = DICT_GET_ITEM( tmp_dict_name_9, tmp_key_name_9 );
    if ( tmp_assign_source_87 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1556;

        goto try_except_handler_24;
    }
    goto condexpr_end_9;
    condexpr_false_9:;
    tmp_assign_source_87 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_87 );
    condexpr_end_9:;
    assert( tmp_class_creation_9__metaclass == NULL );
    tmp_class_creation_9__metaclass = tmp_assign_source_87;

    tmp_called_name_18 = tmp_class_creation_9__metaclass;

    CHECK_OBJECT( tmp_called_name_18 );
    tmp_args_element_name_35 = const_str_plain_X509StoreFlags;
    tmp_args_element_name_36 = const_tuple_type_object_tuple;
    tmp_args_element_name_37 = tmp_class_creation_9__class_dict;

    CHECK_OBJECT( tmp_args_element_name_37 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 1556;
    {
        PyObject *call_args[] = { tmp_args_element_name_35, tmp_args_element_name_36, tmp_args_element_name_37 };
        tmp_assign_source_88 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_18, call_args );
    }

    if ( tmp_assign_source_88 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1556;

        goto try_except_handler_24;
    }
    assert( tmp_class_creation_9__class == NULL );
    tmp_class_creation_9__class = tmp_assign_source_88;

    goto try_end_14;
    // Exception handler code:
    try_except_handler_24:;
    exception_keeper_type_22 = exception_type;
    exception_keeper_value_22 = exception_value;
    exception_keeper_tb_22 = exception_tb;
    exception_keeper_lineno_22 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_22;
    exception_value = exception_keeper_value_22;
    exception_tb = exception_keeper_tb_22;
    exception_lineno = exception_keeper_lineno_22;

    goto frame_exception_exit_1;
    // End of try:
    try_end_14:;
    tmp_assign_source_89 = tmp_class_creation_9__class;

    CHECK_OBJECT( tmp_assign_source_89 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreFlags, tmp_assign_source_89 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class );
    Py_DECREF( tmp_class_creation_9__class );
    tmp_class_creation_9__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class_dict );
    Py_DECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__metaclass );
    Py_DECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    tmp_set_locals = PyDict_New();
    locals_X509Store_1580 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_X509Store_1580, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_6a19008e8f9a834793cf38dcba68883a;
    tmp_res = PyDict_SetItem( locals_X509Store_1580, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_85___init__(  );
    tmp_res = PyDict_SetItem( locals_X509Store_1580, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_86_add_cert(  );
    tmp_res = PyDict_SetItem( locals_X509Store_1580, const_str_plain_add_cert, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_87_add_crl(  );
    tmp_res = PyDict_SetItem( locals_X509Store_1580, const_str_plain_add_crl, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_88_set_flags(  );
    tmp_res = PyDict_SetItem( locals_X509Store_1580, const_str_plain_set_flags, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_89_set_time(  );
    tmp_res = PyDict_SetItem( locals_X509Store_1580, const_str_plain_set_time, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_3 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_3 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_90_load_locations( tmp_defaults_3 );
    tmp_res = PyDict_SetItem( locals_X509Store_1580, const_str_plain_load_locations, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_11 = locals_X509Store_1580;
    Py_INCREF( tmp_outline_return_value_11 );
    goto try_return_handler_26;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_26:;
    Py_DECREF( locals_X509Store_1580 );
    locals_X509Store_1580 = NULL;
    goto outline_result_11;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_result_11:;
    tmp_assign_source_90 = tmp_outline_return_value_11;
    assert( tmp_class_creation_10__class_dict == NULL );
    tmp_class_creation_10__class_dict = tmp_assign_source_90;

    // Tried code:
    tmp_compare_left_10 = const_str_plain___metaclass__;
    tmp_compare_right_10 = tmp_class_creation_10__class_dict;

    CHECK_OBJECT( tmp_compare_right_10 );
    tmp_cmp_In_10 = PySequence_Contains( tmp_compare_right_10, tmp_compare_left_10 );
    assert( !(tmp_cmp_In_10 == -1) );
    if ( tmp_cmp_In_10 == 1 )
    {
        goto condexpr_true_10;
    }
    else
    {
        goto condexpr_false_10;
    }
    condexpr_true_10:;
    tmp_dict_name_10 = tmp_class_creation_10__class_dict;

    CHECK_OBJECT( tmp_dict_name_10 );
    tmp_key_name_10 = const_str_plain___metaclass__;
    tmp_assign_source_91 = DICT_GET_ITEM( tmp_dict_name_10, tmp_key_name_10 );
    if ( tmp_assign_source_91 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1580;

        goto try_except_handler_27;
    }
    goto condexpr_end_10;
    condexpr_false_10:;
    tmp_assign_source_91 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_91 );
    condexpr_end_10:;
    assert( tmp_class_creation_10__metaclass == NULL );
    tmp_class_creation_10__metaclass = tmp_assign_source_91;

    tmp_called_name_19 = tmp_class_creation_10__metaclass;

    CHECK_OBJECT( tmp_called_name_19 );
    tmp_args_element_name_38 = const_str_plain_X509Store;
    tmp_args_element_name_39 = const_tuple_type_object_tuple;
    tmp_args_element_name_40 = tmp_class_creation_10__class_dict;

    CHECK_OBJECT( tmp_args_element_name_40 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 1580;
    {
        PyObject *call_args[] = { tmp_args_element_name_38, tmp_args_element_name_39, tmp_args_element_name_40 };
        tmp_assign_source_92 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_19, call_args );
    }

    if ( tmp_assign_source_92 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1580;

        goto try_except_handler_27;
    }
    assert( tmp_class_creation_10__class == NULL );
    tmp_class_creation_10__class = tmp_assign_source_92;

    goto try_end_15;
    // Exception handler code:
    try_except_handler_27:;
    exception_keeper_type_23 = exception_type;
    exception_keeper_value_23 = exception_value;
    exception_keeper_tb_23 = exception_tb;
    exception_keeper_lineno_23 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class_dict );
    Py_DECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_23;
    exception_value = exception_keeper_value_23;
    exception_tb = exception_keeper_tb_23;
    exception_lineno = exception_keeper_lineno_23;

    goto frame_exception_exit_1;
    // End of try:
    try_end_15:;
    tmp_assign_source_93 = tmp_class_creation_10__class;

    CHECK_OBJECT( tmp_assign_source_93 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Store, tmp_assign_source_93 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class );
    Py_DECREF( tmp_class_creation_10__class );
    tmp_class_creation_10__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class_dict );
    Py_DECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__metaclass );
    Py_DECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    tmp_assign_source_94 = PyTuple_New( 1 );
    tmp_tuple_element_2 = PyExc_Exception;
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_assign_source_94, 0, tmp_tuple_element_2 );
    assert( tmp_class_creation_11__bases == NULL );
    tmp_class_creation_11__bases = tmp_assign_source_94;

    tmp_set_locals = PyDict_New();
    locals_X509StoreContextError_1732 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_X509StoreContextError_1732, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_a9fcf3ea8b3ff05d45964d00ac386113;
    tmp_res = PyDict_SetItem( locals_X509StoreContextError_1732, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_91___init__(  );
    tmp_res = PyDict_SetItem( locals_X509StoreContextError_1732, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_12 = locals_X509StoreContextError_1732;
    Py_INCREF( tmp_outline_return_value_12 );
    goto try_return_handler_28;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_28:;
    Py_DECREF( locals_X509StoreContextError_1732 );
    locals_X509StoreContextError_1732 = NULL;
    goto outline_result_12;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_result_12:;
    tmp_assign_source_95 = tmp_outline_return_value_12;
    assert( tmp_class_creation_11__class_dict == NULL );
    tmp_class_creation_11__class_dict = tmp_assign_source_95;

    // Tried code:
    tmp_compare_left_11 = const_str_plain___metaclass__;
    tmp_compare_right_11 = tmp_class_creation_11__class_dict;

    CHECK_OBJECT( tmp_compare_right_11 );
    tmp_cmp_In_11 = PySequence_Contains( tmp_compare_right_11, tmp_compare_left_11 );
    assert( !(tmp_cmp_In_11 == -1) );
    if ( tmp_cmp_In_11 == 1 )
    {
        goto condexpr_true_11;
    }
    else
    {
        goto condexpr_false_11;
    }
    condexpr_true_11:;
    tmp_dict_name_11 = tmp_class_creation_11__class_dict;

    CHECK_OBJECT( tmp_dict_name_11 );
    tmp_key_name_11 = const_str_plain___metaclass__;
    tmp_assign_source_96 = DICT_GET_ITEM( tmp_dict_name_11, tmp_key_name_11 );
    if ( tmp_assign_source_96 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1732;

        goto try_except_handler_29;
    }
    goto condexpr_end_11;
    condexpr_false_11:;
    tmp_subscribed_name_2 = tmp_class_creation_11__bases;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_0;
    tmp_assign_source_97 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_assign_source_97 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1732;

        goto try_except_handler_29;
    }
    assert( tmp_select_metaclass_11__base == NULL );
    tmp_select_metaclass_11__base = tmp_assign_source_97;

    // Tried code:
    // Tried code:
    tmp_source_name_22 = tmp_select_metaclass_11__base;

    CHECK_OBJECT( tmp_source_name_22 );
    tmp_outline_return_value_13 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_22 );
    if ( tmp_outline_return_value_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1732;

        goto try_except_handler_31;
    }
    goto try_return_handler_30;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_31:;
    exception_keeper_type_24 = exception_type;
    exception_keeper_value_24 = exception_value;
    exception_keeper_tb_24 = exception_tb;
    exception_keeper_lineno_24 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_24 );
    Py_XDECREF( exception_keeper_value_24 );
    Py_XDECREF( exception_keeper_tb_24 );
    tmp_type_arg_2 = tmp_select_metaclass_11__base;

    CHECK_OBJECT( tmp_type_arg_2 );
    tmp_outline_return_value_13 = BUILTIN_TYPE1( tmp_type_arg_2 );
    assert( tmp_outline_return_value_13 != NULL );
    goto try_return_handler_30;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_30:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_11__base );
    Py_DECREF( tmp_select_metaclass_11__base );
    tmp_select_metaclass_11__base = NULL;

    goto outline_result_13;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_11__base );
    Py_DECREF( tmp_select_metaclass_11__base );
    tmp_select_metaclass_11__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_result_13:;
    tmp_assign_source_96 = tmp_outline_return_value_13;
    condexpr_end_11:;
    assert( tmp_class_creation_11__metaclass == NULL );
    tmp_class_creation_11__metaclass = tmp_assign_source_96;

    tmp_called_name_20 = tmp_class_creation_11__metaclass;

    CHECK_OBJECT( tmp_called_name_20 );
    tmp_args_element_name_41 = const_str_plain_X509StoreContextError;
    tmp_args_element_name_42 = tmp_class_creation_11__bases;

    CHECK_OBJECT( tmp_args_element_name_42 );
    tmp_args_element_name_43 = tmp_class_creation_11__class_dict;

    CHECK_OBJECT( tmp_args_element_name_43 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 1732;
    {
        PyObject *call_args[] = { tmp_args_element_name_41, tmp_args_element_name_42, tmp_args_element_name_43 };
        tmp_assign_source_98 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_20, call_args );
    }

    if ( tmp_assign_source_98 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1732;

        goto try_except_handler_29;
    }
    assert( tmp_class_creation_11__class == NULL );
    tmp_class_creation_11__class = tmp_assign_source_98;

    goto try_end_16;
    // Exception handler code:
    try_except_handler_29:;
    exception_keeper_type_25 = exception_type;
    exception_keeper_value_25 = exception_value;
    exception_keeper_tb_25 = exception_tb;
    exception_keeper_lineno_25 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__bases );
    Py_DECREF( tmp_class_creation_11__bases );
    tmp_class_creation_11__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class_dict );
    Py_DECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_25;
    exception_value = exception_keeper_value_25;
    exception_tb = exception_keeper_tb_25;
    exception_lineno = exception_keeper_lineno_25;

    goto frame_exception_exit_1;
    // End of try:
    try_end_16:;
    tmp_assign_source_99 = tmp_class_creation_11__class;

    CHECK_OBJECT( tmp_assign_source_99 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreContextError, tmp_assign_source_99 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class );
    Py_DECREF( tmp_class_creation_11__class );
    tmp_class_creation_11__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__bases );
    Py_DECREF( tmp_class_creation_11__bases );
    tmp_class_creation_11__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class_dict );
    Py_DECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__metaclass );
    Py_DECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_X509StoreContext_1746 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_X509StoreContext_1746, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_1dad1cec7e14813a999c9dcf96c8f89f;
    tmp_res = PyDict_SetItem( locals_X509StoreContext_1746, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_4 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_4 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_92___init__( tmp_defaults_4 );
    tmp_res = PyDict_SetItem( locals_X509StoreContext_1746, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e7c675b53b12683555b138ae5949022f_9, codeobj_e7c675b53b12683555b138ae5949022f, module_OpenSSL$crypto, 0 );
    frame_e7c675b53b12683555b138ae5949022f_9 = cache_frame_e7c675b53b12683555b138ae5949022f_9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e7c675b53b12683555b138ae5949022f_9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e7c675b53b12683555b138ae5949022f_9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_staticmethod_arg_1 = MAKE_FUNCTION_OpenSSL$crypto$$$function_93__build_certificate_stack(  );
    tmp_dictset_value = BUILTIN_STATICMETHOD( tmp_staticmethod_arg_1 );
    Py_DECREF( tmp_staticmethod_arg_1 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1779;

        goto frame_exception_exit_9;
    }
    tmp_res = PyDict_SetItem( locals_X509StoreContext_1746, const_str_plain__build_certificate_stack, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1779;

        goto frame_exception_exit_9;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e7c675b53b12683555b138ae5949022f_9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_8;

    frame_exception_exit_9:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e7c675b53b12683555b138ae5949022f_9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e7c675b53b12683555b138ae5949022f_9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e7c675b53b12683555b138ae5949022f_9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e7c675b53b12683555b138ae5949022f_9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e7c675b53b12683555b138ae5949022f_9,
        type_description_2
    );


    // Release cached frame.
    if ( frame_e7c675b53b12683555b138ae5949022f_9 == cache_frame_e7c675b53b12683555b138ae5949022f_9 )
    {
        Py_DECREF( frame_e7c675b53b12683555b138ae5949022f_9 );
    }
    cache_frame_e7c675b53b12683555b138ae5949022f_9 = NULL;

    assertFrameObject( frame_e7c675b53b12683555b138ae5949022f_9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_8;

    frame_no_exception_8:;

    goto skip_nested_handling_8;
    nested_frame_exit_8:;

    goto try_except_handler_33;
    skip_nested_handling_8:;
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_94__init(  );
    tmp_res = PyDict_SetItem( locals_X509StoreContext_1746, const_str_plain__init, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_95__cleanup(  );
    tmp_res = PyDict_SetItem( locals_X509StoreContext_1746, const_str_plain__cleanup, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_96__exception_from_context(  );
    tmp_res = PyDict_SetItem( locals_X509StoreContext_1746, const_str_plain__exception_from_context, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_97_set_store(  );
    tmp_res = PyDict_SetItem( locals_X509StoreContext_1746, const_str_plain_set_store, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_98_verify_certificate(  );
    tmp_res = PyDict_SetItem( locals_X509StoreContext_1746, const_str_plain_verify_certificate, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_99_get_verified_chain(  );
    tmp_res = PyDict_SetItem( locals_X509StoreContext_1746, const_str_plain_get_verified_chain, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_14 = locals_X509StoreContext_1746;
    Py_INCREF( tmp_outline_return_value_14 );
    goto try_return_handler_33;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_33:;
    Py_DECREF( locals_X509StoreContext_1746 );
    locals_X509StoreContext_1746 = NULL;
    goto outline_result_14;
    // Exception handler code:
    try_except_handler_33:;
    exception_keeper_type_26 = exception_type;
    exception_keeper_value_26 = exception_value;
    exception_keeper_tb_26 = exception_tb;
    exception_keeper_lineno_26 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_X509StoreContext_1746 );
    locals_X509StoreContext_1746 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_26;
    exception_value = exception_keeper_value_26;
    exception_tb = exception_keeper_tb_26;
    exception_lineno = exception_keeper_lineno_26;

    goto outline_exception_8;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_8:;
    exception_lineno = 1746;
    goto try_except_handler_32;
    outline_result_14:;
    tmp_assign_source_100 = tmp_outline_return_value_14;
    assert( tmp_class_creation_12__class_dict == NULL );
    tmp_class_creation_12__class_dict = tmp_assign_source_100;

    tmp_compare_left_12 = const_str_plain___metaclass__;
    tmp_compare_right_12 = tmp_class_creation_12__class_dict;

    CHECK_OBJECT( tmp_compare_right_12 );
    tmp_cmp_In_12 = PySequence_Contains( tmp_compare_right_12, tmp_compare_left_12 );
    assert( !(tmp_cmp_In_12 == -1) );
    if ( tmp_cmp_In_12 == 1 )
    {
        goto condexpr_true_12;
    }
    else
    {
        goto condexpr_false_12;
    }
    condexpr_true_12:;
    tmp_dict_name_12 = tmp_class_creation_12__class_dict;

    CHECK_OBJECT( tmp_dict_name_12 );
    tmp_key_name_12 = const_str_plain___metaclass__;
    tmp_assign_source_101 = DICT_GET_ITEM( tmp_dict_name_12, tmp_key_name_12 );
    if ( tmp_assign_source_101 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1746;

        goto try_except_handler_32;
    }
    goto condexpr_end_12;
    condexpr_false_12:;
    tmp_assign_source_101 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_101 );
    condexpr_end_12:;
    assert( tmp_class_creation_12__metaclass == NULL );
    tmp_class_creation_12__metaclass = tmp_assign_source_101;

    tmp_called_name_21 = tmp_class_creation_12__metaclass;

    CHECK_OBJECT( tmp_called_name_21 );
    tmp_args_element_name_44 = const_str_plain_X509StoreContext;
    tmp_args_element_name_45 = const_tuple_type_object_tuple;
    tmp_args_element_name_46 = tmp_class_creation_12__class_dict;

    CHECK_OBJECT( tmp_args_element_name_46 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 1746;
    {
        PyObject *call_args[] = { tmp_args_element_name_44, tmp_args_element_name_45, tmp_args_element_name_46 };
        tmp_assign_source_102 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_21, call_args );
    }

    if ( tmp_assign_source_102 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1746;

        goto try_except_handler_32;
    }
    assert( tmp_class_creation_12__class == NULL );
    tmp_class_creation_12__class = tmp_assign_source_102;

    goto try_end_17;
    // Exception handler code:
    try_except_handler_32:;
    exception_keeper_type_27 = exception_type;
    exception_keeper_value_27 = exception_value;
    exception_keeper_tb_27 = exception_tb;
    exception_keeper_lineno_27 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_27;
    exception_value = exception_keeper_value_27;
    exception_tb = exception_keeper_tb_27;
    exception_lineno = exception_keeper_lineno_27;

    goto frame_exception_exit_1;
    // End of try:
    try_end_17:;
    tmp_assign_source_103 = tmp_class_creation_12__class;

    CHECK_OBJECT( tmp_assign_source_103 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreContext, tmp_assign_source_103 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class );
    Py_DECREF( tmp_class_creation_12__class );
    tmp_class_creation_12__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class_dict );
    Py_DECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__metaclass );
    Py_DECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    tmp_assign_source_104 = MAKE_FUNCTION_OpenSSL$crypto$$$function_100_load_certificate(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_certificate, tmp_assign_source_104 );
    tmp_assign_source_105 = MAKE_FUNCTION_OpenSSL$crypto$$$function_101_dump_certificate(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_certificate, tmp_assign_source_105 );
    tmp_assign_source_106 = MAKE_FUNCTION_OpenSSL$crypto$$$function_102_dump_publickey(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_publickey, tmp_assign_source_106 );
    tmp_defaults_5 = const_tuple_none_none_tuple;
    Py_INCREF( tmp_defaults_5 );
    tmp_assign_source_107 = MAKE_FUNCTION_OpenSSL$crypto$$$function_103_dump_privatekey( tmp_defaults_5 );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_privatekey, tmp_assign_source_107 );
    tmp_set_locals = PyDict_New();
    locals_Revoked_2073 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_Revoked_2073, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_6b975dcb77568b31c2312e045b6c638c;
    tmp_res = PyDict_SetItem( locals_Revoked_2073, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = LIST_COPY( const_list_298f4a46a008df82aecc87d37443e76b_list );
    tmp_res = PyDict_SetItem( locals_Revoked_2073, const_str_plain__crl_reasons, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_104___init__(  );
    tmp_res = PyDict_SetItem( locals_Revoked_2073, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_105_set_serial(  );
    tmp_res = PyDict_SetItem( locals_Revoked_2073, const_str_plain_set_serial, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_106_get_serial(  );
    tmp_res = PyDict_SetItem( locals_Revoked_2073, const_str_plain_get_serial, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_107__delete_reason(  );
    tmp_res = PyDict_SetItem( locals_Revoked_2073, const_str_plain__delete_reason, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_108_set_reason(  );
    tmp_res = PyDict_SetItem( locals_Revoked_2073, const_str_plain_set_reason, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_109_get_reason(  );
    tmp_res = PyDict_SetItem( locals_Revoked_2073, const_str_plain_get_reason, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_110_all_reasons(  );
    tmp_res = PyDict_SetItem( locals_Revoked_2073, const_str_plain_all_reasons, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_111_set_rev_date(  );
    tmp_res = PyDict_SetItem( locals_Revoked_2073, const_str_plain_set_rev_date, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_112_get_rev_date(  );
    tmp_res = PyDict_SetItem( locals_Revoked_2073, const_str_plain_get_rev_date, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_15 = locals_Revoked_2073;
    Py_INCREF( tmp_outline_return_value_15 );
    goto try_return_handler_34;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_34:;
    Py_DECREF( locals_Revoked_2073 );
    locals_Revoked_2073 = NULL;
    goto outline_result_15;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_result_15:;
    tmp_assign_source_108 = tmp_outline_return_value_15;
    assert( tmp_class_creation_13__class_dict == NULL );
    tmp_class_creation_13__class_dict = tmp_assign_source_108;

    // Tried code:
    tmp_compare_left_13 = const_str_plain___metaclass__;
    tmp_compare_right_13 = tmp_class_creation_13__class_dict;

    CHECK_OBJECT( tmp_compare_right_13 );
    tmp_cmp_In_13 = PySequence_Contains( tmp_compare_right_13, tmp_compare_left_13 );
    assert( !(tmp_cmp_In_13 == -1) );
    if ( tmp_cmp_In_13 == 1 )
    {
        goto condexpr_true_13;
    }
    else
    {
        goto condexpr_false_13;
    }
    condexpr_true_13:;
    tmp_dict_name_13 = tmp_class_creation_13__class_dict;

    CHECK_OBJECT( tmp_dict_name_13 );
    tmp_key_name_13 = const_str_plain___metaclass__;
    tmp_assign_source_109 = DICT_GET_ITEM( tmp_dict_name_13, tmp_key_name_13 );
    if ( tmp_assign_source_109 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2073;

        goto try_except_handler_35;
    }
    goto condexpr_end_13;
    condexpr_false_13:;
    tmp_assign_source_109 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_109 );
    condexpr_end_13:;
    assert( tmp_class_creation_13__metaclass == NULL );
    tmp_class_creation_13__metaclass = tmp_assign_source_109;

    tmp_called_name_22 = tmp_class_creation_13__metaclass;

    CHECK_OBJECT( tmp_called_name_22 );
    tmp_args_element_name_47 = const_str_plain_Revoked;
    tmp_args_element_name_48 = const_tuple_type_object_tuple;
    tmp_args_element_name_49 = tmp_class_creation_13__class_dict;

    CHECK_OBJECT( tmp_args_element_name_49 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 2073;
    {
        PyObject *call_args[] = { tmp_args_element_name_47, tmp_args_element_name_48, tmp_args_element_name_49 };
        tmp_assign_source_110 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_22, call_args );
    }

    if ( tmp_assign_source_110 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2073;

        goto try_except_handler_35;
    }
    assert( tmp_class_creation_13__class == NULL );
    tmp_class_creation_13__class = tmp_assign_source_110;

    goto try_end_18;
    // Exception handler code:
    try_except_handler_35:;
    exception_keeper_type_28 = exception_type;
    exception_keeper_value_28 = exception_value;
    exception_keeper_tb_28 = exception_tb;
    exception_keeper_lineno_28 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class_dict );
    Py_DECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_28;
    exception_value = exception_keeper_value_28;
    exception_tb = exception_keeper_tb_28;
    exception_lineno = exception_keeper_lineno_28;

    goto frame_exception_exit_1;
    // End of try:
    try_end_18:;
    tmp_assign_source_111 = tmp_class_creation_13__class;

    CHECK_OBJECT( tmp_assign_source_111 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Revoked, tmp_assign_source_111 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class );
    Py_DECREF( tmp_class_creation_13__class );
    tmp_class_creation_13__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class_dict );
    Py_DECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__metaclass );
    Py_DECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_CRL_2246 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_6b6b180b644052fa34c3e81151f6ea0a;
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_113___init__(  );
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_114_to_cryptography(  );
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain_to_cryptography, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e6218c4ff5c9cc85be7135f57a324c77_10, codeobj_e6218c4ff5c9cc85be7135f57a324c77, module_OpenSSL$crypto, 0 );
    frame_e6218c4ff5c9cc85be7135f57a324c77_10 = cache_frame_e6218c4ff5c9cc85be7135f57a324c77_10;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e6218c4ff5c9cc85be7135f57a324c77_10 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e6218c4ff5c9cc85be7135f57a324c77_10 ) == 2 ); // Frame stack

    // Framed code:
    tmp_classmethod_arg_8 = MAKE_FUNCTION_OpenSSL$crypto$$$function_115_from_cryptography(  );
    tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_8 );
    Py_DECREF( tmp_classmethod_arg_8 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2270;

        goto frame_exception_exit_10;
    }
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain_from_cryptography, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2270;

        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_116_get_revoked(  );
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain_get_revoked, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_117_add_revoked(  );
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain_add_revoked, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_118_get_issuer(  );
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain_get_issuer, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_119_set_version(  );
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain_set_version, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_120__set_boundary_time(  );
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain__set_boundary_time, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_121_set_lastUpdate(  );
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain_set_lastUpdate, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_122_set_nextUpdate(  );
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain_set_nextUpdate, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_123_sign(  );
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain_sign, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_6 = PyTuple_New( 3 );
    tmp_tuple_element_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_tuple_element_3 == NULL ))
    {
        tmp_tuple_element_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_tuple_element_3 == NULL )
    {
        Py_DECREF( tmp_defaults_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 2413;

        goto frame_exception_exit_10;
    }

    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_defaults_6, 0, tmp_tuple_element_3 );
    tmp_tuple_element_3 = const_int_pos_100;
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_defaults_6, 1, tmp_tuple_element_3 );
    tmp_tuple_element_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );

    if (unlikely( tmp_tuple_element_3 == NULL ))
    {
        tmp_tuple_element_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );
    }

    if ( tmp_tuple_element_3 == NULL )
    {
        Py_DECREF( tmp_defaults_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_UNSPECIFIED" );
        exception_tb = NULL;

        exception_lineno = 2413;

        goto frame_exception_exit_10;
    }

    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_defaults_6, 2, tmp_tuple_element_3 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_124_export( tmp_defaults_6 );
    tmp_res = PyDict_SetItem( locals_CRL_2246, const_str_plain_export, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2412;

        goto frame_exception_exit_10;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e6218c4ff5c9cc85be7135f57a324c77_10 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_9;

    frame_exception_exit_10:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e6218c4ff5c9cc85be7135f57a324c77_10 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e6218c4ff5c9cc85be7135f57a324c77_10, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e6218c4ff5c9cc85be7135f57a324c77_10->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e6218c4ff5c9cc85be7135f57a324c77_10, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e6218c4ff5c9cc85be7135f57a324c77_10,
        type_description_2
    );


    // Release cached frame.
    if ( frame_e6218c4ff5c9cc85be7135f57a324c77_10 == cache_frame_e6218c4ff5c9cc85be7135f57a324c77_10 )
    {
        Py_DECREF( frame_e6218c4ff5c9cc85be7135f57a324c77_10 );
    }
    cache_frame_e6218c4ff5c9cc85be7135f57a324c77_10 = NULL;

    assertFrameObject( frame_e6218c4ff5c9cc85be7135f57a324c77_10 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_9;

    frame_no_exception_9:;

    goto skip_nested_handling_9;
    nested_frame_exit_9:;

    goto try_except_handler_37;
    skip_nested_handling_9:;
    tmp_outline_return_value_16 = locals_CRL_2246;
    Py_INCREF( tmp_outline_return_value_16 );
    goto try_return_handler_37;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_37:;
    Py_DECREF( locals_CRL_2246 );
    locals_CRL_2246 = NULL;
    goto outline_result_16;
    // Exception handler code:
    try_except_handler_37:;
    exception_keeper_type_29 = exception_type;
    exception_keeper_value_29 = exception_value;
    exception_keeper_tb_29 = exception_tb;
    exception_keeper_lineno_29 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_CRL_2246 );
    locals_CRL_2246 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_29;
    exception_value = exception_keeper_value_29;
    exception_tb = exception_keeper_tb_29;
    exception_lineno = exception_keeper_lineno_29;

    goto outline_exception_9;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_9:;
    exception_lineno = 2246;
    goto try_except_handler_36;
    outline_result_16:;
    tmp_assign_source_112 = tmp_outline_return_value_16;
    assert( tmp_class_creation_14__class_dict == NULL );
    tmp_class_creation_14__class_dict = tmp_assign_source_112;

    tmp_compare_left_14 = const_str_plain___metaclass__;
    tmp_compare_right_14 = tmp_class_creation_14__class_dict;

    CHECK_OBJECT( tmp_compare_right_14 );
    tmp_cmp_In_14 = PySequence_Contains( tmp_compare_right_14, tmp_compare_left_14 );
    assert( !(tmp_cmp_In_14 == -1) );
    if ( tmp_cmp_In_14 == 1 )
    {
        goto condexpr_true_14;
    }
    else
    {
        goto condexpr_false_14;
    }
    condexpr_true_14:;
    tmp_dict_name_14 = tmp_class_creation_14__class_dict;

    CHECK_OBJECT( tmp_dict_name_14 );
    tmp_key_name_14 = const_str_plain___metaclass__;
    tmp_assign_source_113 = DICT_GET_ITEM( tmp_dict_name_14, tmp_key_name_14 );
    if ( tmp_assign_source_113 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2246;

        goto try_except_handler_36;
    }
    goto condexpr_end_14;
    condexpr_false_14:;
    tmp_assign_source_113 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_113 );
    condexpr_end_14:;
    assert( tmp_class_creation_14__metaclass == NULL );
    tmp_class_creation_14__metaclass = tmp_assign_source_113;

    tmp_called_name_23 = tmp_class_creation_14__metaclass;

    CHECK_OBJECT( tmp_called_name_23 );
    tmp_args_element_name_50 = const_str_plain_CRL;
    tmp_args_element_name_51 = const_tuple_type_object_tuple;
    tmp_args_element_name_52 = tmp_class_creation_14__class_dict;

    CHECK_OBJECT( tmp_args_element_name_52 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 2246;
    {
        PyObject *call_args[] = { tmp_args_element_name_50, tmp_args_element_name_51, tmp_args_element_name_52 };
        tmp_assign_source_114 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_23, call_args );
    }

    if ( tmp_assign_source_114 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2246;

        goto try_except_handler_36;
    }
    assert( tmp_class_creation_14__class == NULL );
    tmp_class_creation_14__class = tmp_assign_source_114;

    goto try_end_19;
    // Exception handler code:
    try_except_handler_36:;
    exception_keeper_type_30 = exception_type;
    exception_keeper_value_30 = exception_value;
    exception_keeper_tb_30 = exception_tb;
    exception_keeper_lineno_30 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_30;
    exception_value = exception_keeper_value_30;
    exception_tb = exception_keeper_tb_30;
    exception_lineno = exception_keeper_lineno_30;

    goto frame_exception_exit_1;
    // End of try:
    try_end_19:;
    tmp_assign_source_115 = tmp_class_creation_14__class;

    CHECK_OBJECT( tmp_assign_source_115 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_CRL, tmp_assign_source_115 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class );
    Py_DECREF( tmp_class_creation_14__class );
    tmp_class_creation_14__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class_dict );
    Py_DECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__metaclass );
    Py_DECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    tmp_set_locals = PyDict_New();
    locals_PKCS7_2467 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_PKCS7_2467, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_125_type_is_signed(  );
    tmp_res = PyDict_SetItem( locals_PKCS7_2467, const_str_plain_type_is_signed, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_126_type_is_enveloped(  );
    tmp_res = PyDict_SetItem( locals_PKCS7_2467, const_str_plain_type_is_enveloped, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_127_type_is_signedAndEnveloped(  );
    tmp_res = PyDict_SetItem( locals_PKCS7_2467, const_str_plain_type_is_signedAndEnveloped, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_128_type_is_data(  );
    tmp_res = PyDict_SetItem( locals_PKCS7_2467, const_str_plain_type_is_data, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_129_get_type_name(  );
    tmp_res = PyDict_SetItem( locals_PKCS7_2467, const_str_plain_get_type_name, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_17 = locals_PKCS7_2467;
    Py_INCREF( tmp_outline_return_value_17 );
    goto try_return_handler_38;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_38:;
    Py_DECREF( locals_PKCS7_2467 );
    locals_PKCS7_2467 = NULL;
    goto outline_result_17;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_result_17:;
    tmp_assign_source_116 = tmp_outline_return_value_17;
    assert( tmp_class_creation_15__class_dict == NULL );
    tmp_class_creation_15__class_dict = tmp_assign_source_116;

    // Tried code:
    tmp_compare_left_15 = const_str_plain___metaclass__;
    tmp_compare_right_15 = tmp_class_creation_15__class_dict;

    CHECK_OBJECT( tmp_compare_right_15 );
    tmp_cmp_In_15 = PySequence_Contains( tmp_compare_right_15, tmp_compare_left_15 );
    assert( !(tmp_cmp_In_15 == -1) );
    if ( tmp_cmp_In_15 == 1 )
    {
        goto condexpr_true_15;
    }
    else
    {
        goto condexpr_false_15;
    }
    condexpr_true_15:;
    tmp_dict_name_15 = tmp_class_creation_15__class_dict;

    CHECK_OBJECT( tmp_dict_name_15 );
    tmp_key_name_15 = const_str_plain___metaclass__;
    tmp_assign_source_117 = DICT_GET_ITEM( tmp_dict_name_15, tmp_key_name_15 );
    if ( tmp_assign_source_117 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2467;

        goto try_except_handler_39;
    }
    goto condexpr_end_15;
    condexpr_false_15:;
    tmp_assign_source_117 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_117 );
    condexpr_end_15:;
    assert( tmp_class_creation_15__metaclass == NULL );
    tmp_class_creation_15__metaclass = tmp_assign_source_117;

    tmp_called_name_24 = tmp_class_creation_15__metaclass;

    CHECK_OBJECT( tmp_called_name_24 );
    tmp_args_element_name_53 = const_str_plain_PKCS7;
    tmp_args_element_name_54 = const_tuple_type_object_tuple;
    tmp_args_element_name_55 = tmp_class_creation_15__class_dict;

    CHECK_OBJECT( tmp_args_element_name_55 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 2467;
    {
        PyObject *call_args[] = { tmp_args_element_name_53, tmp_args_element_name_54, tmp_args_element_name_55 };
        tmp_assign_source_118 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_24, call_args );
    }

    if ( tmp_assign_source_118 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2467;

        goto try_except_handler_39;
    }
    assert( tmp_class_creation_15__class == NULL );
    tmp_class_creation_15__class = tmp_assign_source_118;

    goto try_end_20;
    // Exception handler code:
    try_except_handler_39:;
    exception_keeper_type_31 = exception_type;
    exception_keeper_value_31 = exception_value;
    exception_keeper_tb_31 = exception_tb;
    exception_keeper_lineno_31 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class_dict );
    Py_DECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_31;
    exception_value = exception_keeper_value_31;
    exception_tb = exception_keeper_tb_31;
    exception_lineno = exception_keeper_lineno_31;

    goto frame_exception_exit_1;
    // End of try:
    try_end_20:;
    tmp_assign_source_119 = tmp_class_creation_15__class;

    CHECK_OBJECT( tmp_assign_source_119 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS7, tmp_assign_source_119 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class );
    Py_DECREF( tmp_class_creation_15__class );
    tmp_class_creation_15__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class_dict );
    Py_DECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__metaclass );
    Py_DECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    tmp_set_locals = PyDict_New();
    locals_PKCS12_2511 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_PKCS12_2511, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_4b3673d04a6e4a628e29457d54d43c0d;
    tmp_res = PyDict_SetItem( locals_PKCS12_2511, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_130___init__(  );
    tmp_res = PyDict_SetItem( locals_PKCS12_2511, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_131_get_certificate(  );
    tmp_res = PyDict_SetItem( locals_PKCS12_2511, const_str_plain_get_certificate, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_132_set_certificate(  );
    tmp_res = PyDict_SetItem( locals_PKCS12_2511, const_str_plain_set_certificate, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_133_get_privatekey(  );
    tmp_res = PyDict_SetItem( locals_PKCS12_2511, const_str_plain_get_privatekey, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_134_set_privatekey(  );
    tmp_res = PyDict_SetItem( locals_PKCS12_2511, const_str_plain_set_privatekey, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_135_get_ca_certificates(  );
    tmp_res = PyDict_SetItem( locals_PKCS12_2511, const_str_plain_get_ca_certificates, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_136_set_ca_certificates(  );
    tmp_res = PyDict_SetItem( locals_PKCS12_2511, const_str_plain_set_ca_certificates, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_137_set_friendlyname(  );
    tmp_res = PyDict_SetItem( locals_PKCS12_2511, const_str_plain_set_friendlyname, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_138_get_friendlyname(  );
    tmp_res = PyDict_SetItem( locals_PKCS12_2511, const_str_plain_get_friendlyname, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_7 = const_tuple_none_int_pos_2048_int_pos_1_tuple;
    Py_INCREF( tmp_defaults_7 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_139_export( tmp_defaults_7 );
    tmp_res = PyDict_SetItem( locals_PKCS12_2511, const_str_plain_export, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_18 = locals_PKCS12_2511;
    Py_INCREF( tmp_outline_return_value_18 );
    goto try_return_handler_40;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_40:;
    Py_DECREF( locals_PKCS12_2511 );
    locals_PKCS12_2511 = NULL;
    goto outline_result_18;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_result_18:;
    tmp_assign_source_120 = tmp_outline_return_value_18;
    assert( tmp_class_creation_16__class_dict == NULL );
    tmp_class_creation_16__class_dict = tmp_assign_source_120;

    // Tried code:
    tmp_compare_left_16 = const_str_plain___metaclass__;
    tmp_compare_right_16 = tmp_class_creation_16__class_dict;

    CHECK_OBJECT( tmp_compare_right_16 );
    tmp_cmp_In_16 = PySequence_Contains( tmp_compare_right_16, tmp_compare_left_16 );
    assert( !(tmp_cmp_In_16 == -1) );
    if ( tmp_cmp_In_16 == 1 )
    {
        goto condexpr_true_16;
    }
    else
    {
        goto condexpr_false_16;
    }
    condexpr_true_16:;
    tmp_dict_name_16 = tmp_class_creation_16__class_dict;

    CHECK_OBJECT( tmp_dict_name_16 );
    tmp_key_name_16 = const_str_plain___metaclass__;
    tmp_assign_source_121 = DICT_GET_ITEM( tmp_dict_name_16, tmp_key_name_16 );
    if ( tmp_assign_source_121 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2511;

        goto try_except_handler_41;
    }
    goto condexpr_end_16;
    condexpr_false_16:;
    tmp_assign_source_121 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_121 );
    condexpr_end_16:;
    assert( tmp_class_creation_16__metaclass == NULL );
    tmp_class_creation_16__metaclass = tmp_assign_source_121;

    tmp_called_name_25 = tmp_class_creation_16__metaclass;

    CHECK_OBJECT( tmp_called_name_25 );
    tmp_args_element_name_56 = const_str_plain_PKCS12;
    tmp_args_element_name_57 = const_tuple_type_object_tuple;
    tmp_args_element_name_58 = tmp_class_creation_16__class_dict;

    CHECK_OBJECT( tmp_args_element_name_58 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 2511;
    {
        PyObject *call_args[] = { tmp_args_element_name_56, tmp_args_element_name_57, tmp_args_element_name_58 };
        tmp_assign_source_122 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_25, call_args );
    }

    if ( tmp_assign_source_122 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2511;

        goto try_except_handler_41;
    }
    assert( tmp_class_creation_16__class == NULL );
    tmp_class_creation_16__class = tmp_assign_source_122;

    goto try_end_21;
    // Exception handler code:
    try_except_handler_41:;
    exception_keeper_type_32 = exception_type;
    exception_keeper_value_32 = exception_value;
    exception_keeper_tb_32 = exception_tb;
    exception_keeper_lineno_32 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class_dict );
    Py_DECREF( tmp_class_creation_16__class_dict );
    tmp_class_creation_16__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_32;
    exception_value = exception_keeper_value_32;
    exception_tb = exception_keeper_tb_32;
    exception_lineno = exception_keeper_lineno_32;

    goto frame_exception_exit_1;
    // End of try:
    try_end_21:;
    tmp_assign_source_123 = tmp_class_creation_16__class;

    CHECK_OBJECT( tmp_assign_source_123 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS12, tmp_assign_source_123 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class );
    Py_DECREF( tmp_class_creation_16__class );
    tmp_class_creation_16__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class_dict );
    Py_DECREF( tmp_class_creation_16__class_dict );
    tmp_class_creation_16__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__metaclass );
    Py_DECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    tmp_set_locals = PyDict_New();
    locals_NetscapeSPKI_2692 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals_NetscapeSPKI_2692, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_713d8c2afef94db133cda1bff1cb496f;
    tmp_res = PyDict_SetItem( locals_NetscapeSPKI_2692, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_140___init__(  );
    tmp_res = PyDict_SetItem( locals_NetscapeSPKI_2692, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_141_sign(  );
    tmp_res = PyDict_SetItem( locals_NetscapeSPKI_2692, const_str_plain_sign, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_142_verify(  );
    tmp_res = PyDict_SetItem( locals_NetscapeSPKI_2692, const_str_plain_verify, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_143_b64_encode(  );
    tmp_res = PyDict_SetItem( locals_NetscapeSPKI_2692, const_str_plain_b64_encode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_144_get_pubkey(  );
    tmp_res = PyDict_SetItem( locals_NetscapeSPKI_2692, const_str_plain_get_pubkey, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_145_set_pubkey(  );
    tmp_res = PyDict_SetItem( locals_NetscapeSPKI_2692, const_str_plain_set_pubkey, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_19 = locals_NetscapeSPKI_2692;
    Py_INCREF( tmp_outline_return_value_19 );
    goto try_return_handler_42;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_42:;
    Py_DECREF( locals_NetscapeSPKI_2692 );
    locals_NetscapeSPKI_2692 = NULL;
    goto outline_result_19;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_result_19:;
    tmp_assign_source_124 = tmp_outline_return_value_19;
    assert( tmp_class_creation_17__class_dict == NULL );
    tmp_class_creation_17__class_dict = tmp_assign_source_124;

    // Tried code:
    tmp_compare_left_17 = const_str_plain___metaclass__;
    tmp_compare_right_17 = tmp_class_creation_17__class_dict;

    CHECK_OBJECT( tmp_compare_right_17 );
    tmp_cmp_In_17 = PySequence_Contains( tmp_compare_right_17, tmp_compare_left_17 );
    assert( !(tmp_cmp_In_17 == -1) );
    if ( tmp_cmp_In_17 == 1 )
    {
        goto condexpr_true_17;
    }
    else
    {
        goto condexpr_false_17;
    }
    condexpr_true_17:;
    tmp_dict_name_17 = tmp_class_creation_17__class_dict;

    CHECK_OBJECT( tmp_dict_name_17 );
    tmp_key_name_17 = const_str_plain___metaclass__;
    tmp_assign_source_125 = DICT_GET_ITEM( tmp_dict_name_17, tmp_key_name_17 );
    if ( tmp_assign_source_125 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2692;

        goto try_except_handler_43;
    }
    goto condexpr_end_17;
    condexpr_false_17:;
    tmp_assign_source_125 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_125 );
    condexpr_end_17:;
    assert( tmp_class_creation_17__metaclass == NULL );
    tmp_class_creation_17__metaclass = tmp_assign_source_125;

    tmp_called_name_26 = tmp_class_creation_17__metaclass;

    CHECK_OBJECT( tmp_called_name_26 );
    tmp_args_element_name_59 = const_str_plain_NetscapeSPKI;
    tmp_args_element_name_60 = const_tuple_type_object_tuple;
    tmp_args_element_name_61 = tmp_class_creation_17__class_dict;

    CHECK_OBJECT( tmp_args_element_name_61 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 2692;
    {
        PyObject *call_args[] = { tmp_args_element_name_59, tmp_args_element_name_60, tmp_args_element_name_61 };
        tmp_assign_source_126 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_26, call_args );
    }

    if ( tmp_assign_source_126 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2692;

        goto try_except_handler_43;
    }
    assert( tmp_class_creation_17__class == NULL );
    tmp_class_creation_17__class = tmp_assign_source_126;

    goto try_end_22;
    // Exception handler code:
    try_except_handler_43:;
    exception_keeper_type_33 = exception_type;
    exception_keeper_value_33 = exception_value;
    exception_keeper_tb_33 = exception_tb;
    exception_keeper_lineno_33 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__class_dict );
    Py_DECREF( tmp_class_creation_17__class_dict );
    tmp_class_creation_17__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_17__metaclass );
    tmp_class_creation_17__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_33;
    exception_value = exception_keeper_value_33;
    exception_tb = exception_keeper_tb_33;
    exception_lineno = exception_keeper_lineno_33;

    goto frame_exception_exit_1;
    // End of try:
    try_end_22:;
    tmp_assign_source_127 = tmp_class_creation_17__class;

    CHECK_OBJECT( tmp_assign_source_127 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_NetscapeSPKI, tmp_assign_source_127 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__class );
    Py_DECREF( tmp_class_creation_17__class );
    tmp_class_creation_17__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__class_dict );
    Py_DECREF( tmp_class_creation_17__class_dict );
    tmp_class_creation_17__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__metaclass );
    Py_DECREF( tmp_class_creation_17__metaclass );
    tmp_class_creation_17__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals__PassphraseHelper_2782 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_res = PyDict_SetItem( locals__PassphraseHelper_2782, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_8 = const_tuple_false_false_tuple;
    Py_INCREF( tmp_defaults_8 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_146___init__( tmp_defaults_8 );
    tmp_res = PyDict_SetItem( locals__PassphraseHelper_2782, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_129fe76254a1387737fbb2b415f27966_11, codeobj_129fe76254a1387737fbb2b415f27966, module_OpenSSL$crypto, 0 );
    frame_129fe76254a1387737fbb2b415f27966_11 = cache_frame_129fe76254a1387737fbb2b415f27966_11;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_129fe76254a1387737fbb2b415f27966_11 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_129fe76254a1387737fbb2b415f27966_11 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_27 = (PyObject *)&PyProperty_Type;
    tmp_args_element_name_62 = MAKE_FUNCTION_OpenSSL$crypto$$$function_147_callback(  );
    frame_129fe76254a1387737fbb2b415f27966_11->m_frame.f_lineno = 2793;
    {
        PyObject *call_args[] = { tmp_args_element_name_62 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_27, call_args );
    }

    Py_DECREF( tmp_args_element_name_62 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2793;

        goto frame_exception_exit_11;
    }
    tmp_res = PyDict_SetItem( locals__PassphraseHelper_2782, const_str_plain_callback, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2793;

        goto frame_exception_exit_11;
    }
    tmp_called_name_28 = (PyObject *)&PyProperty_Type;
    tmp_args_element_name_63 = MAKE_FUNCTION_OpenSSL$crypto$$$function_148_callback_args(  );
    frame_129fe76254a1387737fbb2b415f27966_11->m_frame.f_lineno = 2804;
    {
        PyObject *call_args[] = { tmp_args_element_name_63 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_28, call_args );
    }

    Py_DECREF( tmp_args_element_name_63 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2804;

        goto frame_exception_exit_11;
    }
    tmp_res = PyDict_SetItem( locals__PassphraseHelper_2782, const_str_plain_callback_args, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2804;

        goto frame_exception_exit_11;
    }
    tmp_defaults_9 = PyTuple_New( 1 );
    tmp_tuple_element_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_tuple_element_4 == NULL ))
    {
        tmp_tuple_element_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_tuple_element_4 == NULL )
    {
        Py_DECREF( tmp_defaults_9 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 2815;

        goto frame_exception_exit_11;
    }

    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_defaults_9, 0, tmp_tuple_element_4 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_149_raise_if_problem( tmp_defaults_9 );
    tmp_res = PyDict_SetItem( locals__PassphraseHelper_2782, const_str_plain_raise_if_problem, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2815;

        goto frame_exception_exit_11;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_129fe76254a1387737fbb2b415f27966_11 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_10;

    frame_exception_exit_11:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_129fe76254a1387737fbb2b415f27966_11 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_129fe76254a1387737fbb2b415f27966_11, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_129fe76254a1387737fbb2b415f27966_11->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_129fe76254a1387737fbb2b415f27966_11, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_129fe76254a1387737fbb2b415f27966_11,
        type_description_2
    );


    // Release cached frame.
    if ( frame_129fe76254a1387737fbb2b415f27966_11 == cache_frame_129fe76254a1387737fbb2b415f27966_11 )
    {
        Py_DECREF( frame_129fe76254a1387737fbb2b415f27966_11 );
    }
    cache_frame_129fe76254a1387737fbb2b415f27966_11 = NULL;

    assertFrameObject( frame_129fe76254a1387737fbb2b415f27966_11 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_10;

    frame_no_exception_10:;

    goto skip_nested_handling_10;
    nested_frame_exit_10:;

    goto try_except_handler_45;
    skip_nested_handling_10:;
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_150__read_passphrase(  );
    tmp_res = PyDict_SetItem( locals__PassphraseHelper_2782, const_str_plain__read_passphrase, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_20 = locals__PassphraseHelper_2782;
    Py_INCREF( tmp_outline_return_value_20 );
    goto try_return_handler_45;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_45:;
    Py_DECREF( locals__PassphraseHelper_2782 );
    locals__PassphraseHelper_2782 = NULL;
    goto outline_result_20;
    // Exception handler code:
    try_except_handler_45:;
    exception_keeper_type_34 = exception_type;
    exception_keeper_value_34 = exception_value;
    exception_keeper_tb_34 = exception_tb;
    exception_keeper_lineno_34 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals__PassphraseHelper_2782 );
    locals__PassphraseHelper_2782 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_34;
    exception_value = exception_keeper_value_34;
    exception_tb = exception_keeper_tb_34;
    exception_lineno = exception_keeper_lineno_34;

    goto outline_exception_10;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_10:;
    exception_lineno = 2782;
    goto try_except_handler_44;
    outline_result_20:;
    tmp_assign_source_128 = tmp_outline_return_value_20;
    assert( tmp_class_creation_18__class_dict == NULL );
    tmp_class_creation_18__class_dict = tmp_assign_source_128;

    tmp_compare_left_18 = const_str_plain___metaclass__;
    tmp_compare_right_18 = tmp_class_creation_18__class_dict;

    CHECK_OBJECT( tmp_compare_right_18 );
    tmp_cmp_In_18 = PySequence_Contains( tmp_compare_right_18, tmp_compare_left_18 );
    assert( !(tmp_cmp_In_18 == -1) );
    if ( tmp_cmp_In_18 == 1 )
    {
        goto condexpr_true_18;
    }
    else
    {
        goto condexpr_false_18;
    }
    condexpr_true_18:;
    tmp_dict_name_18 = tmp_class_creation_18__class_dict;

    CHECK_OBJECT( tmp_dict_name_18 );
    tmp_key_name_18 = const_str_plain___metaclass__;
    tmp_assign_source_129 = DICT_GET_ITEM( tmp_dict_name_18, tmp_key_name_18 );
    if ( tmp_assign_source_129 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2782;

        goto try_except_handler_44;
    }
    goto condexpr_end_18;
    condexpr_false_18:;
    tmp_assign_source_129 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_129 );
    condexpr_end_18:;
    assert( tmp_class_creation_18__metaclass == NULL );
    tmp_class_creation_18__metaclass = tmp_assign_source_129;

    tmp_called_name_29 = tmp_class_creation_18__metaclass;

    CHECK_OBJECT( tmp_called_name_29 );
    tmp_args_element_name_64 = const_str_plain__PassphraseHelper;
    tmp_args_element_name_65 = const_tuple_type_object_tuple;
    tmp_args_element_name_66 = tmp_class_creation_18__class_dict;

    CHECK_OBJECT( tmp_args_element_name_66 );
    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 2782;
    {
        PyObject *call_args[] = { tmp_args_element_name_64, tmp_args_element_name_65, tmp_args_element_name_66 };
        tmp_assign_source_130 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_29, call_args );
    }

    if ( tmp_assign_source_130 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2782;

        goto try_except_handler_44;
    }
    assert( tmp_class_creation_18__class == NULL );
    tmp_class_creation_18__class = tmp_assign_source_130;

    goto try_end_23;
    // Exception handler code:
    try_except_handler_44:;
    exception_keeper_type_35 = exception_type;
    exception_keeper_value_35 = exception_value;
    exception_keeper_tb_35 = exception_tb;
    exception_keeper_lineno_35 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_18__class_dict );
    tmp_class_creation_18__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_18__metaclass );
    tmp_class_creation_18__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_35;
    exception_value = exception_keeper_value_35;
    exception_tb = exception_keeper_tb_35;
    exception_lineno = exception_keeper_lineno_35;

    goto frame_exception_exit_1;
    // End of try:
    try_end_23:;
    tmp_assign_source_131 = tmp_class_creation_18__class;

    CHECK_OBJECT( tmp_assign_source_131 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PassphraseHelper, tmp_assign_source_131 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_18__class );
    Py_DECREF( tmp_class_creation_18__class );
    tmp_class_creation_18__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_18__class_dict );
    Py_DECREF( tmp_class_creation_18__class_dict );
    tmp_class_creation_18__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_18__metaclass );
    Py_DECREF( tmp_class_creation_18__metaclass );
    tmp_class_creation_18__metaclass = NULL;

    tmp_assign_source_132 = MAKE_FUNCTION_OpenSSL$crypto$$$function_151_load_publickey(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_publickey, tmp_assign_source_132 );
    tmp_defaults_10 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_10 );
    tmp_assign_source_133 = MAKE_FUNCTION_OpenSSL$crypto$$$function_152_load_privatekey( tmp_defaults_10 );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_privatekey, tmp_assign_source_133 );
    tmp_assign_source_134 = MAKE_FUNCTION_OpenSSL$crypto$$$function_153_dump_certificate_request(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_certificate_request, tmp_assign_source_134 );
    tmp_assign_source_135 = MAKE_FUNCTION_OpenSSL$crypto$$$function_154_load_certificate_request(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_certificate_request, tmp_assign_source_135 );
    tmp_assign_source_136 = MAKE_FUNCTION_OpenSSL$crypto$$$function_155_sign(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_sign, tmp_assign_source_136 );
    tmp_assign_source_137 = MAKE_FUNCTION_OpenSSL$crypto$$$function_156_verify(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_verify, tmp_assign_source_137 );
    tmp_assign_source_138 = MAKE_FUNCTION_OpenSSL$crypto$$$function_157_dump_crl(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_crl, tmp_assign_source_138 );
    tmp_assign_source_139 = MAKE_FUNCTION_OpenSSL$crypto$$$function_158_load_crl(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_crl, tmp_assign_source_139 );
    tmp_assign_source_140 = MAKE_FUNCTION_OpenSSL$crypto$$$function_159_load_pkcs7_data(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_pkcs7_data, tmp_assign_source_140 );
    tmp_source_name_23 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_23 == NULL ))
    {
        tmp_source_name_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_23 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 3138;

        goto frame_exception_exit_1;
    }

    tmp_called_name_30 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain_deprecated );
    if ( tmp_called_name_30 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3138;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_67 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_pkcs7_data );

    if (unlikely( tmp_args_element_name_67 == NULL ))
    {
        tmp_args_element_name_67 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_load_pkcs7_data );
    }

    if ( tmp_args_element_name_67 == NULL )
    {
        Py_DECREF( tmp_called_name_30 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "load_pkcs7_data" );
        exception_tb = NULL;

        exception_lineno = 3139;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_68 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_args_element_name_69 = const_str_digest_1548dadd592ed9bc13702fc15d573dfd;
    tmp_args_element_name_70 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

    if (unlikely( tmp_args_element_name_70 == NULL ))
    {
        tmp_args_element_name_70 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
    }

    if ( tmp_args_element_name_70 == NULL )
    {
        Py_DECREF( tmp_called_name_30 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
        exception_tb = NULL;

        exception_lineno = 3145;

        goto frame_exception_exit_1;
    }

    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 3138;
    {
        PyObject *call_args[] = { tmp_args_element_name_67, tmp_args_element_name_68, tmp_args_element_name_69, tmp_args_element_name_70 };
        tmp_assign_source_141 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_30, call_args );
    }

    Py_DECREF( tmp_called_name_30 );
    if ( tmp_assign_source_141 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3138;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_pkcs7_data, tmp_assign_source_141 );
    tmp_defaults_11 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_11 );
    tmp_assign_source_142 = MAKE_FUNCTION_OpenSSL$crypto$$$function_160_load_pkcs12( tmp_defaults_11 );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_pkcs12, tmp_assign_source_142 );
    tmp_source_name_24 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_utils );

    if (unlikely( tmp_source_name_24 == NULL ))
    {
        tmp_source_name_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_utils );
    }

    if ( tmp_source_name_24 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "utils" );
        exception_tb = NULL;

        exception_lineno = 3236;

        goto frame_exception_exit_1;
    }

    tmp_called_name_31 = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain_deprecated );
    if ( tmp_called_name_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3236;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_71 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_pkcs12 );

    if (unlikely( tmp_args_element_name_71 == NULL ))
    {
        tmp_args_element_name_71 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_load_pkcs12 );
    }

    if ( tmp_args_element_name_71 == NULL )
    {
        Py_DECREF( tmp_called_name_31 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "load_pkcs12" );
        exception_tb = NULL;

        exception_lineno = 3237;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_72 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_args_element_name_73 = const_str_digest_542816c377b6c750acf5d24f0edc02b0;
    tmp_args_element_name_74 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

    if (unlikely( tmp_args_element_name_74 == NULL ))
    {
        tmp_args_element_name_74 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
    }

    if ( tmp_args_element_name_74 == NULL )
    {
        Py_DECREF( tmp_called_name_31 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
        exception_tb = NULL;

        exception_lineno = 3243;

        goto frame_exception_exit_1;
    }

    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 3236;
    {
        PyObject *call_args[] = { tmp_args_element_name_71, tmp_args_element_name_72, tmp_args_element_name_73, tmp_args_element_name_74 };
        tmp_assign_source_143 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_31, call_args );
    }

    Py_DECREF( tmp_called_name_31 );
    if ( tmp_assign_source_143 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3236;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_pkcs12, tmp_assign_source_143 );
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3256;

        goto frame_exception_exit_1;
    }

    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 3256;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_OpenSSL_add_all_algorithms );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3256;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3260;

        goto frame_exception_exit_1;
    }

    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 3260;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_SSL_load_error_strings );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3260;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 3265;

        goto frame_exception_exit_1;
    }

    frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame.f_lineno = 3265;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_ASN1_STRING_set_default_mask_asc, &PyTuple_GET_ITEM( const_tuple_str_plain_utf8only_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3265;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION( frame_46b4308dcfe4b8f3851708d0fb7512b6 );
#endif
    popFrameStack();

    assertFrameObject( frame_46b4308dcfe4b8f3851708d0fb7512b6 );

    goto frame_no_exception_11;
    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_46b4308dcfe4b8f3851708d0fb7512b6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_46b4308dcfe4b8f3851708d0fb7512b6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_46b4308dcfe4b8f3851708d0fb7512b6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_46b4308dcfe4b8f3851708d0fb7512b6, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;
    frame_no_exception_11:;

    return MOD_RETURN_VALUE( module_OpenSSL$crypto );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
