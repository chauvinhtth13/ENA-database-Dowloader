/* Generated code for Python source for module 'OpenSSL.SSL'
 * created by Nuitka version 0.5.30
 *
 * This code is in part copyright 2018 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The _module_OpenSSL$SSL is a Python object pointer of module type. */

/* Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_OpenSSL$SSL;
PyDictObject *moduledict_OpenSSL$SSL;

/* The module constants used, if any. */
static PyObject *const_str_plain_tmpconn;
extern PyObject *const_int_neg_1;
static PyObject *const_tuple_str_plain_errorcode_tuple;
extern PyObject *const_str_plain_get;
extern PyObject *const_str_plain_set_result;
static PyObject *const_str_plain_get_context;
static PyObject *const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple;
static PyObject *const_str_plain_SSL_VERIFY_CLIENT_ONCE;
static PyObject *const_tuple_str_plain_self_str_plain_rc_tuple;
static PyObject *const_str_plain_SSL_CTX_use_PrivateKey;
static PyObject *const_str_plain_filetype;
static PyObject *const_str_plain_BIO_write;
static PyObject *const_str_plain_errorcode;
static PyObject *const_str_digest_60759f97a8e448eec2208bd0c353d705;
static PyObject *const_list_tuple_1892b43c5f7e8b28e9bf284d360fe6ef_tuple_list;
static PyObject *const_str_plain_ca_list;
static PyObject *const_str_plain_BIO_should_write;
static PyObject *const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple;
static PyObject *const_str_digest_92dae1d5c0e993b1b8bd25bfbbae5039;
static PyObject *const_str_plain_pyname;
extern PyObject *const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
extern PyObject *const_str_plain_use_privatekey_file;
static PyObject *const_str_plain_OP_COOKIE_EXCHANGE;
extern PyObject *const_str_plain_UNSPECIFIED;
static PyObject *const_str_plain_ca_names;
extern PyObject *const_str_plain_cdata;
static PyObject *const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE;
static PyObject *const_str_plain_OP_SINGLE_ECDH_USE;
static PyObject *const_str_plain_TLSv1_method;
extern PyObject *const_str_plain_data;
static PyObject *const_str_plain_SSL_set_tlsext_host_name;
extern PyObject *const_str_plain_pkey;
static PyObject *const_tuple_df35527807658c5906d3a25929231255_tuple;
extern PyObject *const_str_plain_get_certificate;
static PyObject *const_str_plain_depth;
static PyObject *const_str_plain_SSL_OP_NO_QUERY_MTU;
static PyObject *const_str_plain_in_;
static PyObject *const_str_plain_X509_STORE_CTX_get_ex_data;
extern PyObject *const_str_digest_c075052d723d6707083e869a0e3659bb;
extern PyObject *const_str_plain_SSL_set_alpn_protos;
static PyObject *const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple;
extern PyObject *const_str_plain_i;
static PyObject *const_str_plain_set_accept_state;
extern PyObject *const_str_plain__problems;
static PyObject *const_str_plain_error_number;
extern PyObject *const_str_plain_OP_NO_SSLv2;
extern PyObject *const_str_plain_Cryptography_HAS_ALPN;
static PyObject *const_str_plain_SSL_OP_NO_SSLv2;
static PyObject *const_str_plain_SSL_ST_CONNECT;
static PyObject *const_str_plain_want_read;
static PyObject *const_str_plain_add_client_ca;
extern PyObject *const_str_plain_environ;
static PyObject *const_str_plain_OP_NO_QUERY_MTU;
extern PyObject *const_str_plain_e;
static PyObject *const_str_plain__from_ssl;
static PyObject *const_str_digest_3319904791e7df62e14d88cc362facc1;
static PyObject *const_str_plain_set_ocsp_server_callback;
static PyObject *const_str_plain_SSL_CTX_get_timeout;
static PyObject *const_str_plain_SSL_version;
extern PyObject *const_str_plain__path_string;
extern PyObject *const_str_plain_write;
extern PyObject *const_str_plain_WantWriteError;
extern PyObject *const_str_plain___exit__;
extern PyObject *const_str_plain_X509Name;
extern PyObject *const_str_plain_DH_free;
static PyObject *const_str_plain__OCSPClientCallbackHelper;
extern PyObject *const_str_plain_itertools;
static PyObject *const_str_plain_VERIFY_CLIENT_ONCE;
static PyObject *const_str_digest_62d4d7edcf7c24573f6c449cbee3cf23;
static PyObject *const_str_plain_getwinerror;
static PyObject *const_str_plain__reverse_mapping;
extern PyObject *const_str_plain_addr;
static PyObject *const_str_digest_04211c3d50cdc4f69d9c36018d92c12f;
static PyObject *const_str_plain_set_client_ca_list;
extern PyObject *const_str_plain_connect_ex;
extern PyObject *const_str_plain_proto;
static PyObject *const_str_plain_set_session;
static PyObject *const_str_plain_OP_DONT_INSERT_EMPTY_FRAGMENTS;
static PyObject *const_str_digest_8e472bc9049677fa90a9da1a818ea22f;
static PyObject *const_str_plain_alert;
static PyObject *const_str_digest_b02795b9590127f96a3b627129a2fbd2;
static PyObject *const_str_plain_push_result;
static PyObject *const_str_plain_flag;
extern PyObject *const_str_plain_ok;
extern PyObject *const_str_plain_recv;
extern PyObject *const_tuple_str_digest_52773e1185116024389d12c91a4ccf3d_tuple;
extern PyObject *const_str_plain_ciphers;
extern PyObject *const_str_plain_os;
extern PyObject *const_str_plain__text_to_bytes_and_warn;
static PyObject *const_str_plain__socket;
extern PyObject *const_str_plain_Context;
static PyObject *const_tuple_40c019df00fadc68e051d5153056e038_tuple;
static PyObject *const_str_digest_053565796c68d049169d0efbeceaaf7d;
static PyObject *const_str_plain_SSL_CTX_set_tlsext_use_srtp;
extern PyObject *const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple;
static PyObject *const_str_digest_0bb5eb9f5b32c979fadc3e4b702de2f7;
static PyObject *const_str_plain_SSL_CTX_set_mode;
extern PyObject *const_str_plain_out;
extern PyObject *const_str_plain_dh;
static PyObject *const_str_digest_25ee1ab59a31b6b65728138ca859d41c;
extern PyObject *const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple;
extern PyObject *const_str_plain_send;
static PyObject *const_str_plain_SSL_get1_session;
extern PyObject *const_str_plain__from_raw_x509_ptr;
static PyObject *const_str_plain_SSL_CTX_set_verify;
static PyObject *const_str_plain_SSL_CTX_add_client_CA;
static PyObject *const_str_digest_cbc74855fdd069af46a5197a85921eab;
static PyObject *const_str_plain_SSL_CTX_use_certificate_chain_file;
static PyObject *const_str_plain_BIO_new_file;
static PyObject *const_str_plain_ocsp_data;
extern PyObject *const_str_plain_verify;
extern PyObject *const_str_plain_certfile;
static PyObject *const_str_digest_73851dbd1821d646fbb8ad48e937548f;
extern PyObject *const_str_digest_2aaae8e99c54112dad0b0da3957413a9;
static PyObject *const_str_digest_8cc305fc9d9a417a96ba57f2c87b94e9;
extern PyObject *const_tuple_str_plain_self_str_plain_state_tuple;
extern PyObject *const_str_plain___init__;
static PyObject *const_str_plain_SSLEAY_DIR;
static PyObject *const_str_digest_099382aff2f4e6520a621b385fae4992;
static PyObject *const_str_plain_use_privatekey;
extern PyObject *const_str_plain_ascii;
static PyObject *const_str_plain_nbytes;
extern PyObject *const_str_plain_items;
static PyObject *const_str_plain__alpn_select_callback_args;
static PyObject *const_str_plain_SSL_SESS_CACHE_OFF;
static PyObject *const_str_digest_92d0e5bbbb594d3595c30b16879df5a0;
static PyObject *const_str_plain_SSL_CB_HANDSHAKE_DONE;
static PyObject *const_str_plain_SESS_CACHE_OFF;
static PyObject *const_str_digest_240fed82a102b949d0d53c00df42e330;
static PyObject *const_str_plain_SSL_MODE_ENABLE_PARTIAL_WRITE;
static PyObject *const_str_digest_3957b1b23f06761ef1844caf450dffd3;
static PyObject *const_str_plain__VerifyHelper;
static PyObject *const_str_plain_SSL_CIPHER_get_version;
extern PyObject *const_str_plain_store;
static PyObject *const_str_plain_bio_shutdown;
static PyObject *const_str_digest_f45f13437cfffca595693525af90acd6;
extern PyObject *const_str_plain_more_args;
static PyObject *const_str_plain_TLSEXT_NAMETYPE_host_name;
extern PyObject *const_str_angle_genexpr;
static PyObject *const_str_plain_SSL_OP_MICROSOFT_SESS_ID_BUG;
static PyObject *const_str_plain_SSL_CB_EXIT;
static PyObject *const_str_plain_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;
static PyObject *const_str_plain_get_protocol_version;
static PyObject *const_str_digest_54ae0815d64a99c28491423112423094;
static PyObject *const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple;
static PyObject *const_str_plain__cert_stack_to_list;
extern PyObject *const_str_plain__raise_current_error;
extern PyObject *const_str_plain_SSLv3_method;
extern PyObject *const_str_plain_state;
static PyObject *const_str_plain__wrap_callback;
static PyObject *const_str_plain_X509_get_default_cert_dir_env;
static PyObject *const_str_digest_7ac3fb96e522dea60117802c4a4274df;
static PyObject *const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple;
static PyObject *const_str_plain_SSL_OP_NO_TLSv1_2;
extern PyObject *const_str_plain_SSL_OP_NO_TLSv1_3;
static PyObject *const_str_plain_SSL_OP_NO_TLSv1_1;
static PyObject *const_tuple_str_plain_ssl_str_plain_line_str_plain_callback_tuple;
static PyObject *const_str_plain_bio_read;
static PyObject *const_str_plain__requires_decorator;
extern PyObject *const_str_plain_res;
static PyObject *const_str_plain_name_stack;
static PyObject *const_str_digest_3d1ad7b2c9fa025afe944eacf471d909;
static PyObject *const_str_digest_fc4eb7967b0e83bc3a3b7fec0ef46cce;
extern PyObject *const_str_plain_read;
static PyObject *const_str_digest_77c1b668370aaac8571fd41e2e807543;
static PyObject *const_str_plain__asFileDescriptor;
static PyObject *const_str_plain_SESS_CACHE_NO_AUTO_CLEAR;
static PyObject *const_str_plain_add_extra_chain_cert;
extern PyObject *const_str_plain_set_options;
static PyObject *const_str_digest_09af89b9aab79bc5666da647371af25d;
extern PyObject *const_str_plain_Session;
static PyObject *const_str_digest_c16991ba946fb91cede508bddb6a3d8d;
static PyObject *const_str_plain_get_servername;
static PyObject *const_str_plain_instr;
extern PyObject *const_str_plain___metaclass__;
extern PyObject *const_str_plain_integer_types;
static PyObject *const_str_plain_TLS_CHACHA20_POLY1305_SHA256;
static PyObject *const_str_plain_SSL_CTX_use_certificate;
static PyObject *const_str_plain_SESS_CACHE_BOTH;
extern PyObject *const_str_plain_SSL_CTX_set_alpn_select_cb;
extern PyObject *const_tuple_str_plain_ascii_tuple;
static PyObject *const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple;
static PyObject *const_str_digest_f5da7ec1228a5c8d32fa9b786affa014;
static PyObject *const_str_digest_0d994cfb9823ffc5647bea3454d1e646;
static PyObject *const_str_digest_e7ed1590d11cbaaaf17420c6bdc13490;
static PyObject *const_str_digest_83abd167711a9d69f6fb1ba8bbb40fdb;
static PyObject *const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple;
extern PyObject *const_str_plain__pkey;
extern PyObject *const_str_plain_x509;
static PyObject *const_str_plain_SSL_ERROR_SYSCALL;
extern PyObject *const_str_plain_outlen;
static PyObject *const_str_plain_TLS_AES_256_GCM_SHA384;
static PyObject *const_str_plain_OP_EPHEMERAL_RSA;
static PyObject *const_str_plain_set_timeout;
extern PyObject *const_str_plain_set_passwd_cb;
static PyObject *const_str_plain_X509_get_default_cert_file;
static PyObject *const_str_plain_SSL_set_fd;
static PyObject *const_str_plain_protos;
static PyObject *const_str_digest_655ba65e888ba33199198c92a8e95d70;
static PyObject *const_str_plain_SSLv2_METHOD;
extern PyObject *const_str_plain_size;
static PyObject *const_str_plain__requires_alpn;
static PyObject *const_tuple_str_plain_self_str_plain_cipher_tuple;
extern PyObject *const_str_digest_c804b213c384a15865e18bf31cfff70e;
static PyObject *const_str_digest_d3a1e78595a066a43885e44a343877f5;
extern PyObject *const_str_plain_sys;
static PyObject *const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple;
static PyObject *const_str_digest_ef6e6485863cf611499d4e66d7c8cb32;
static PyObject *const_str_plain_set_session_cache_mode;
static PyObject *const_tuple_str_plain_self_str_plain_options_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple;
static PyObject *const_str_plain__alpn_select_callback;
static PyObject *const_str_plain_BIO_should_retry;
static PyObject *const_str_plain_Cryptography_HAS_KEYLOG;
static PyObject *const_str_plain_set_context;
extern PyObject *const_str_plain_Connection;
extern PyObject *const_str_digest_fa91b370bf4aa8601b20ad022c04c7f5;
static PyObject *const_str_digest_2c98e45dae0eb590d01836d5f4b5f54f;
extern PyObject *const_str_plain_mode;
static PyObject *const_str_digest_5f09856be161f8b617a90e11db2ed735;
extern PyObject *const_str_plain_wrapper;
static PyObject *const_str_plain_SSL_CB_ACCEPT_EXIT;
static PyObject *const_str_digest_c9c6fa40ef38c8d28b115afb17db4e50;
static PyObject *const_str_plain_SSL_OP_SSLEAY_080_CLIENT_DH_BUG;
static PyObject *const_str_plain_any_accepted;
static PyObject *const_str_plain_SSL_OP_NETSCAPE_CHALLENGE_BUG;
extern PyObject *const_str_plain__native;
static PyObject *const_str_digest_9575fec1eee4d60c15d3f7c228d8045c;
static PyObject *const_str_plain__ALPNSelectHelper;
extern PyObject *const_str_plain__ffi;
static PyObject *const_str_plain_bio_write;
static PyObject *const_str_plain_SSL_ERROR_WANT_READ;
static PyObject *const_str_plain_set_keylog_callback;
extern PyObject *const_str_plain_X509_up_ref;
static PyObject *const_str_plain_SSL_CTX_set_tlsext_status_cb;
extern PyObject *const_str_plain_set_cipher_list;
static PyObject *const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple;
static PyObject *const_str_plain_export_keying_material;
static PyObject *const_str_plain_SSL_get_tlsext_status_ocsp_resp;
static PyObject *const_str_plain_set_alpn_select_callback;
extern PyObject *const_str_plain___getattr__;
static PyObject *const_str_plain_get_verify_depth;
extern PyObject *const_str_plain_indexbytes;
extern PyObject *const_str_plain_X509_STORE_CTX_get_error;
static PyObject *const_str_plain_SSL_CTX_set_client_CA_list;
static PyObject *const_str_plain_SSL_set_bio;
extern PyObject *const_tuple_str_plain_self_str_plain_version_tuple;
static PyObject *const_str_digest_6e6304d3afc4a993b41c01e5af499f6b;
static PyObject *const_str_plain_sk_X509_NAME_value;
static PyObject *const_str_plain_OP_TLS_ROLLBACK_BUG;
static PyObject *const_str_digest_e5bdbccc007b5187d287f36f3c9f8130;
extern PyObject *const_tuple_str_plain_self_str_plain_curve_tuple;
static PyObject *const_str_plain_SSL_CTX_use_certificate_file;
static PyObject *const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple;
static PyObject *const_str_plain_SSL_MODE_RELEASE_BUFFERS;
extern PyObject *const_str_plain_from_buffer;
static PyObject *const_str_digest_b2b544e0252baa92681eeaf8ffa03130;
static PyObject *const_str_plain_ocsp_data_length;
extern PyObject *const_str_plain_args;
static PyObject *const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple;
extern PyObject *const_str_plain_platform;
static PyObject *const_str_plain_OP_NETSCAPE_CHALLENGE_BUG;
static PyObject *const_str_digest_62f84685dfb1efe6a65f54b5d84154ad;
static PyObject *const_str_digest_afa60644cf27716474a6bbd780185867;
static PyObject *const_str_plain__ocsp_data;
static PyObject *const_tuple_str_plain_count_str_plain_chain_tuple;
static PyObject *const_str_digest_d84d6f514b61e2d13913a11459387aca;
static PyObject *const_str_plain_outbytes;
extern PyObject *const_str_plain_OPENSSL_malloc;
extern PyObject *const_tuple_empty;
static PyObject *const_tuple_a992a212ff6e075874fbd47e83bc62d2_tuple;
static PyObject *const_str_plain_from_handle;
static PyObject *const_str_plain_protostr;
static PyObject *const_str_plain_SSL_CTX_get_verify_mode;
static PyObject *const_str_plain_SSL_get_servername;
extern PyObject *const_str_digest_e33a7f733650e687efe98e5491512b82;
static PyObject *const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple;
static PyObject *const_str_plain_SSL_VERIFY_PEER;
static PyObject *const_tuple_78e460fdd8266d432328f4bff5207c29_tuple;
static PyObject *const_str_digest_7540551bed0e4507c2b90cdbe0aa8fb3;
extern PyObject *const_str_plain_index;
static PyObject *const_str_plain__requires_keylog;
static PyObject *const_str_plain_rc;
static PyObject *const_tuple_1892b43c5f7e8b28e9bf284d360fe6ef_tuple;
static PyObject *const_str_digest_61df355efe52f096d5251268bee9ada3;
static PyObject *const_str_plain_SSL_CB_CONNECT_LOOP;
static PyObject *const_str_plain_SESS_CACHE_NO_INTERNAL_STORE;
extern PyObject *const_str_plain_sendall;
extern PyObject *const_str_plain_path_string;
extern PyObject *const_str_plain_makefile;
static PyObject *const_str_digest_df9e5608be804d3b3249be3c13b24db8;
extern PyObject *const_str_plain_method;
static PyObject *const_str_plain_SSL_OP_SINGLE_ECDH_USE;
static PyObject *const_str_plain_certificate_authority;
extern PyObject *const_tuple_int_neg_1_str_digest_fa91b370bf4aa8601b20ad022c04c7f5_tuple;
static PyObject *const_str_plain_set_session_id;
extern PyObject *const_str_plain_gc;
static PyObject *const_str_plain_OPENSSL_VERSION_NUMBER;
static PyObject *const_str_plain_SSL_ERROR_WANT_WRITE;
static PyObject *const_str_plain_SESS_CACHE_NO_INTERNAL_LOOKUP;
extern PyObject *const_str_plain_curve;
static PyObject *const_str_plain_profiles;
static PyObject *const_str_digest_fd8757ca246c476601094123086e9a80;
static PyObject *const_str_plain__methods;
static PyObject *const_str_plain_SSL_renegotiate_pending;
extern PyObject *const_str_plain_label;
static PyObject *const_tuple_str_plain_self_str_plain_depth_tuple;
static PyObject *const_str_digest_9e9a42d8484d15cb8253ecb92e0c7121;
static PyObject *const_str_plain_accept;
static PyObject *const_str_plain_SSLeay_version;
static PyObject *const_str_plain_SSL_renegotiate;
extern PyObject *const_str_plain__UNSPECIFIED;
extern PyObject *const_str_plain___file__;
extern PyObject *const_str_plain_X509_STORE_CTX_get_current_cert;
static PyObject *const_list_6fa8c3d8587ec1659fa28b2f58883e42_list;
static PyObject *const_tuple_7e6126bff16a8a76a713850dcb042242_tuple;
static PyObject *const_str_plain_SSL_OP_CIPHER_SERVER_PREFERENCE;
static PyObject *const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple;
static PyObject *const_str_plain_SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER;
static PyObject *const_str_plain_SSL_ERROR_NONE;
static PyObject *const_list_b44af29ad37821285e6b89a520342cf5_list;
extern PyObject *const_str_plain_text_to_bytes_and_warn;
static PyObject *const_str_plain_SSL_load_client_CA_file;
extern PyObject *const_str_plain_socket;
static PyObject *const_str_digest_d242bea258df0e7212519aa660c5f53d;
static PyObject *const_str_plain_get_app_data;
static PyObject *const_str_plain_SSL_pending;
static PyObject *const_str_digest_aa8d23211c54bc521e23e53a6e431cd2;
static PyObject *const_str_plain_SSL_CTX_get_verify_depth;
extern PyObject *const_str_plain_arg;
static PyObject *const_str_plain_get_cipher_bits;
static PyObject *const_str_plain_SSL_CTX_set_tlsext_status_arg;
static PyObject *const_str_digest_1494ae1301cb98a828389add570df55f;
static PyObject *const_tuple_a67b1154f8342873401b8122b6389ba8_tuple;
static PyObject *const_str_plain_SSL_get_session;
static PyObject *const_tuple_bf8c920f4f7b4caeaec53a43edb49d5c_tuple;
extern PyObject *const_str_plain_SSL_CTX_set_ecdh_auto;
extern PyObject *const_str_plain_callable;
extern PyObject *const_str_plain_errno;
extern PyObject *const_str_plain_userdata;
static PyObject *const_str_plain_ocsp_ptr;
extern PyObject *const_str_plain_X509_NAME_dup;
static PyObject *const_str_digest_4387d84e76f6b2a931cf315cb767f6ce;
extern PyObject *const_tuple_none_none_tuple;
static PyObject *const_str_plain_OP_CIPHER_SERVER_PREFERENCE;
static PyObject *const_str_plain_SENT_SHUTDOWN;
static PyObject *const_str_plain_X509_get_default_cert_dir;
static PyObject *const_str_plain_SSL_CTX_add_extra_chain_cert;
static PyObject *const_str_digest_776556dd9343f57c1cd72ff937153f0f;
extern PyObject *const_int_pos_2147483647;
static PyObject *const_str_plain_master_key;
extern PyObject *const_str_plain_make_assert;
static PyObject *const_str_plain_inlen;
extern PyObject *const_tuple_str_plain_self_str_plain_buf_tuple;
extern PyObject *const_str_plain___new__;
static PyObject *const_tuple_str_plain_self_str_plain_profiles_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple;
static PyObject *const_str_digest_d5ded94dafea47ce6f2b4fa579755177;
static PyObject *const_str_plain__CallbackExceptionHelper;
extern PyObject *const_str_plain_path;
static PyObject *const_str_plain_set_alpn_protos;
extern PyObject *const_str_plain_PEM_read_bio_DHparams;
extern PyObject *const_str_plain_VERIFY_PEER;
extern PyObject *const_str_plain_weakref;
static PyObject *const_str_plain_empty;
extern PyObject *const_str_plain__PassphraseHelper;
static PyObject *const_str_plain_sk_X509_NAME_push;
extern PyObject *const_str_plain_name;
static PyObject *const_str_plain_OP_ALL;
static PyObject *const_str_digest_aa803484dcfcfaec3d1d830a5ef1f026;
static PyObject *const_str_plain_SSLEAY_BUILT_ON;
static PyObject *const_str_plain_total_renegotiations;
extern PyObject *const_str_plain_SSL_get0_alpn_selected;
static PyObject *const_str_plain_TLSv1_1_method;
extern PyObject *const_str_plain_SSL_CTX_set_alpn_protos;
static PyObject *const_str_plain_from_iterable;
extern PyObject *const_str_plain_VERIFY_NONE;
extern PyObject *const_str_plain_decode;
extern PyObject *const_str_plain_set_tlsext_host_name;
static PyObject *const_str_plain_error_depth;
static PyObject *const_str_plain__from_buffer;
static PyObject *const_str_digest_ebaec5436a48442094f25464a6eec24c;
static PyObject *const_str_digest_b8ccf81a020f16490de1c8527ea9e4d6;
static PyObject *const_str_digest_d89a36d0b4664ac4178af2071f30652f;
static PyObject *const_str_plain_SSL_CB_CONNECT_EXIT;
static PyObject *const_str_digest_cf5a529c83a60eab9bc87caa3430bc5c;
static PyObject *const_str_digest_3462bf983701fbd7caf2f521f5975fff;
extern PyObject *const_str_plain_SSL_library_init;
static PyObject *const_str_plain_OP_PKCS1_CHECK_1;
static PyObject *const_str_plain_get_finished;
static PyObject *const_str_digest_794f687944b90121fa261238090835e1;
extern PyObject *const_str_plain_flags;
extern PyObject *const_str_chr_0;
extern PyObject *const_str_digest_2c0accc407028fbaba46fefdee9c6c06;
static PyObject *const_str_plain_identifier;
static PyObject *const_str_plain_OP_PKCS1_CHECK_2;
static PyObject *const_str_plain_get_cipher_name;
static PyObject *const_str_plain_OP_MICROSOFT_BIG_SSLV3_BUFFER;
static PyObject *const_str_digest_ebc06328e68f0dbdd2e23e3f1f581b13;
static PyObject *const_str_plain__fallback_default_verify_paths;
static PyObject *const_str_plain_X509_V_OK;
static PyObject *const_str_plain_SSL_total_renegotiations;
static PyObject *const_str_plain_SSL_peek;
static PyObject *const_str_plain_SSL_CTX_load_verify_locations;
static PyObject *const_tuple_str_plain_type_tuple;
extern PyObject *const_str_plain_Error;
static PyObject *const_str_plain_SSL_set_SSL_CTX;
static PyObject *const_str_plain_OP_NO_TLSv1;
extern PyObject *const_str_plain_pending;
extern PyObject *const_str_plain_context;
static PyObject *const_str_plain__handle_bio_errors;
static PyObject *const_str_plain_SSLv23_method;
static PyObject *const_str_digest_616719c4a0cde3344203a07484a7fb54;
static PyObject *const_tuple_str_plain_WeakValueDictionary_tuple;
static PyObject *const_str_plain_SSL_CTX_get_cert_store;
static PyObject *const_str_plain_SSL_ERROR_WANT_X509_LOOKUP;
static PyObject *const_str_plain__info_callback;
static PyObject *const_str_plain_new_handle;
extern PyObject *const_str_plain_BIO_free;
static PyObject *const_str_plain_SSLv2_method;
static PyObject *const_str_plain_outp;
static PyObject *const_str_plain_set_shutdown;
static PyObject *const_str_plain_SSL_CB_ALERT;
static PyObject *const_str_plain_use_certificate_file;
static PyObject *const_str_plain_SSL_OP_SINGLE_DH_USE;
static PyObject *const_str_plain_SSL_write;
static PyObject *const_str_plain_meth;
extern PyObject *const_str_plain_ffi;
static PyObject *const_tuple_d443d2554e6119150f8264e2746dcaf3_tuple;
static PyObject *const_str_digest_1491fa532da0499070a77d607dd12a0d;
extern PyObject *const_str_plain_cert_stack;
static PyObject *const_str_plain_get_alpn_proto_negotiated;
extern PyObject *const_tuple_str_plain_self_str_plain_cert_tuple;
static PyObject *const_str_plain_ca_name;
static PyObject *const_tuple_str_plain_self_str_plain_callback_tuple;
extern PyObject *const_str_plain_PKey;
extern PyObject *const_str_plain_truncate;
extern PyObject *const_str_plain_SysCallError;
static PyObject *const_tuple_35c846c03e9c30b5467b3336c5c65a45_tuple;
static PyObject *const_tuple_70adcf8f254ece362639433ee96fdafb_tuple;
extern PyObject *const_str_plain_set_connect_state;
extern PyObject *const_str_plain_pop;
static PyObject *const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple;
static PyObject *const_str_plain__no_zero_allocator;
extern PyObject *const_str_plain_fileno;
static PyObject *const_str_plain_SSL_CIPHER_get_name;
extern PyObject *const_str_plain_raise_if_problem;
static PyObject *const_str_digest_6e6e0d8d93df9702d9c8795dc2391090;
static PyObject *const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple;
static PyObject *const_str_digest_28855c350e66dba47d4f94de98c7d542;
static PyObject *const_str_plain_ocsp_len;
static PyObject *const_str_plain_SSL_set_connect_state;
extern PyObject *const_str_plain__lib;
static PyObject *const_str_digest_6f72f23667e4f49591ed4cf6d6205ca5;
static PyObject *const_str_plain_SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
static PyObject *const_str_plain__CERTIFICATE_PATH_LOCATIONS;
static PyObject *const_str_plain__app_data;
static PyObject *const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple;
extern PyObject *const_str_plain_partial;
static PyObject *const_str_plain_MSG_PEEK;
static PyObject *const_str_plain_get_cipher_version;
extern PyObject *const_tuple_type_object_tuple;
static PyObject *const_str_plain_SSL_CTX_set_keylog_callback;
extern PyObject *const_str_plain__exception_from_error_queue;
static PyObject *const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple;
static PyObject *const_str_digest_242762bc0b8f70110beb7fa23160c8c2;
static PyObject *const_str_plain_encoded_len;
static PyObject *const_str_digest_e04d236da419e1b15c5c13532be67a91;
extern PyObject *const_str_plain_function;
extern PyObject *const_str_plain_type;
static PyObject *const_str_digest_85e95361903fe71cece52bb01216866e;
static PyObject *const_str_plain_set_info_callback;
extern PyObject *const_str_plain_X509_free;
static PyObject *const_str_plain_sk_X509_NAME_free;
static PyObject *const_str_digest_48d61bd61390dfd5cd1a721d2881edd7;
extern PyObject *const_str_plain_get_protocol_version_name;
extern PyObject *const_str_plain_sk_X509_num;
static PyObject *const_str_plain__keylog_callback;
static PyObject *const_str_plain_SSL_CB_HANDSHAKE_START;
static PyObject *const_str_plain_SSLEAY_PLATFORM;
static PyObject *const_str_plain__get_finished_message;
static PyObject *const_str_plain_get_session;
static PyObject *const_str_plain_SSL_set_mode;
static PyObject *const_str_plain_dhfile;
static PyObject *const_str_plain_SSL_get_certificate;
extern PyObject *const_str_plain_return_code;
static PyObject *const_str_plain_SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG;
static PyObject *const_str_plain_SSL_CTX_set_options;
static PyObject *const_str_digest_a824ae6766bf79c53a58510064186c32;
static PyObject *const_str_digest_0b1af5d020260df564f1f58f9f88daaa;
static PyObject *const_str_plain_BIO_should_io_special;
static PyObject *const_str_plain_SSL_OP_EPHEMERAL_RSA;
static PyObject *const_str_plain_SSL_SESS_CACHE_CLIENT;
extern PyObject *const_str_plain_set_default_verify_paths;
static PyObject *const_str_digest_1c06dc4166e08805f38a8dca82ce4339;
static PyObject *const_tuple_str_plain_wraps_str_plain_partial_tuple;
extern PyObject *const_str_plain_self;
static PyObject *const_str_digest_ceaeeee7f342339744c9535ada3c62e3;
static PyObject *const_str_plain_SSL_set_tlsext_status_type;
static PyObject *const_str_plain__verify_helper;
extern PyObject *const_str_plain__make_assert;
static PyObject *const_str_digest_38eb25c1dd31f1c93831bc586a51d94a;
static PyObject *const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple;
static PyObject *const_str_plain_SSL_OP_TLS_BLOCK_PADDING_BUG;
static PyObject *const_str_plain_pysession;
static PyObject *const_str_digest_7cc8f764b42656b144d56bfbd9df2b48;
static PyObject *const_str_plain__make_requires;
static PyObject *const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e;
static PyObject *const_str_plain_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG;
extern PyObject *const_str_plain_cafile;
static PyObject *const_str_plain_BIO_should_read;
static PyObject *const_str_plain_cipher_list;
static PyObject *const_str_plain_set_verify_depth;
static PyObject *const_str_digest_bae02e8783abd2cb1ef184c4ddb0f45d;
static PyObject *const_str_plain_SSL_CTX_check_private_key;
static PyObject *const_str_digest_0f682ae315fc37e97d14dcc920e8b91d;
static PyObject *const_tuple_db9f88d750a1668ba43cf0b62b6c8a91_tuple;
extern PyObject *const_str_plain_chain;
static PyObject *const_str_digest_b65860d01f08f87c7391d19b5cfd9850;
static PyObject *const_str_digest_39e6e3efbf37d872dab9cfbddc398ebf;
static PyObject *const_str_plain_use_certificate;
extern PyObject *const_str_plain_store_ctx;
static PyObject *const_str_plain_SSL_CTX_get_session_cache_mode;
static PyObject *const_str_plain_dir_path;
static PyObject *const_str_digest_f5111f918158679228186076f422f85e;
extern PyObject *const_str_plain_set_verify;
static PyObject *const_str_digest_720dcf8e2be0afcf53b482e84751fd16;
static PyObject *const_list_394c4be2fcfa967175404c799b8030c7_list;
extern PyObject *const_str_plain_min;
static PyObject *const_str_plain_certobj;
static PyObject *const_str_plain_SSL_CTX_new;
static PyObject *const_str_plain__raise_ssl_error;
static PyObject *const_str_plain_SSL_get_peer_finished;
static PyObject *const_str_plain_SSL_MODE_AUTO_RETRY;
static PyObject *const_str_plain_SSL_get_peer_certificate;
extern PyObject *const_str_plain_capath;
static PyObject *const_tuple_str_plain_self_str_plain_cert_stack_tuple;
extern PyObject *const_tuple_str_plain_self_tuple;
static PyObject *const_str_plain_load_client_ca;
extern PyObject *const_str_plain_buf;
static PyObject *const_str_plain_SSL_get_server_random;
extern PyObject *const_str_plain_SSL_get0_verified_chain;
extern PyObject *const_str_plain_error;
static PyObject *const_str_plain_SSL_CB_ACCEPT_LOOP;
static PyObject *const_str_digest_39dd8800b3995a2e161e8739b1bebc01;
static PyObject *const_tuple_b5f59418c193d572a22cf854b821fa76_tuple;
extern PyObject *const_str_plain_NULL;
extern PyObject *const_str_plain_OP_NO_COMPRESSION;
static PyObject *const_str_digest_1c1aa9b3fa80807ae10c68cfa1a0b8e6;
static PyObject *const_str_plain_SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;
extern PyObject *const_tuple_none_none_none_tuple;
static PyObject *const_str_plain_client_random;
static PyObject *const_str_plain_renegotiate_pending;
static PyObject *const_str_plain_SSL_SENT_SHUTDOWN;
static PyObject *const_str_plain__tlsext_servername_callback;
static PyObject *const_str_digest_59969d93e4432efc7c61f6e9fd945ba6;
extern PyObject *const_int_pos_6;
static PyObject *const_str_digest_7eea2d7bc9b359d848e500f33cdf6253;
extern PyObject *const_int_pos_4;
static PyObject *const_str_digest_eb75de26d3d89a0b83fc536ac20042b0;
extern PyObject *const_int_pos_2;
static PyObject *const_str_plain_get_session_cache_mode;
extern PyObject *const_str_plain_RECEIVED_SHUTDOWN;
extern PyObject *const_int_pos_1;
static PyObject *const_str_digest_a971aca8bab65513da2005120ca529f5;
static PyObject *const_str_digest_ee77c76941f8fd58acff5cfda589cc1d;
static PyObject *const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_STORE;
static PyObject *const_str_plain_SSL_state_string_long;
static PyObject *const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple;
static PyObject *const_str_plain_NO_OVERLAPPING_PROTOCOLS;
static PyObject *const_str_plain_SSL_set_shutdown;
static PyObject *const_str_plain_SSL_get_client_CA_list;
static PyObject *const_str_plain_SSL_CTX_use_PrivateKey_file;
static PyObject *const_str_plain_SSL_VERIFY_NONE;
extern PyObject *const_str_plain_load_result;
static PyObject *const_str_plain_SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG;
static PyObject *const_str_plain_SSLEAY_CFLAGS;
extern PyObject *const_str_plain_cert;
static PyObject *const_str_plain_SSL_SESS_CACHE_NO_INTERNAL;
static PyObject *const_str_digest_8d1f7ec402c1b452808eeb662977982b;
extern PyObject *const_int_pos_5;
static PyObject *const_str_plain_SSL_CTX_set_tlsext_servername_callback;
static PyObject *const_str_plain_OP_NO_TLSv1_1;
extern PyObject *const_str_plain_shutdown;
static PyObject *const_str_plain_OP_NO_TLSv1_3;
static PyObject *const_str_plain_OP_NO_TLSv1_2;
extern PyObject *const_str_digest_c561652c58984ec0e9541542aa405594;
extern PyObject *const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple;
extern PyObject *const_int_pos_3;
static PyObject *const_str_plain_WeakValueDictionary;
static PyObject *const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6;
static PyObject *const_str_plain_SSL_CTX_set_tmp_dh;
static PyObject *const_str_digest_0438f8885bf87c226201350e81ca4f79;
static PyObject *const_str_digest_1bd7405e218c8a579c48801956097e27;
extern PyObject *const_tuple_str_plain_self_str_plain_timeout_tuple;
static PyObject *const_str_plain_SSL_read;
extern PyObject *const_str_plain_sk_X509_value;
static PyObject *const_str_plain_SSL_free;
static PyObject *const_str_plain_explode;
extern PyObject *const_str_plain_join;
static PyObject *const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple;
extern PyObject *const_str_plain__verify_callback;
extern PyObject *const_str_digest_499043b9b2da602637f07b1aa101ddfb;
static PyObject *const_str_digest_723fb164f3e133051d00542dd747fe2d;
extern PyObject *const_str_plain_version;
extern PyObject *const_str_plain_functools;
static PyObject *const_str_plain_set_app_data;
static PyObject *const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple;
static PyObject *const_str_plain_SSL_SESS_CACHE_SERVER;
extern PyObject *const_str_plain_connect;
static PyObject *const_str_plain_SSL_OP_NETSCAPE_CA_DN_BUG;
static PyObject *const_tuple_cf035770f08c8746b05138973d8b64b8_tuple;
extern PyObject *const_str_plain___enter__;
static PyObject *const_str_plain_fd;
static PyObject *const_tuple_str_plain_self_str_plain_addr_tuple;
extern PyObject *const_str_plain_add_result;
static PyObject *const_str_plain_SSL_want_write;
static PyObject *const_str_digest_2eac950a8b26412274fa98ea596054c5;
extern PyObject *const_str_plain_result;
extern PyObject *const_str_plain_BIO_new;
static PyObject *const_str_digest_1f723e76cd26cf3162ae94f693472dd5;
static PyObject *const_str_plain_method_func;
static PyObject *const_str_digest_d71143a9aaaa613b59e0c4c3015a7c4a;
static PyObject *const_str_plain_client;
static PyObject *const_dict_4a96d2f6310f0842d222254905a83466;
static PyObject *const_str_plain__into_ssl;
extern PyObject *const_str_plain__openssl_assert;
static PyObject *const_str_digest_c5585513b25f5127855be671a08a1332;
extern PyObject *const_str_plain_int2byte;
static PyObject *const_str_plain_SSL_SESS_CACHE_NO_AUTO_CLEAR;
static PyObject *const_str_plain_default_file;
extern PyObject *const_str_plain_buffer;
extern PyObject *const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple;
static PyObject *const_str_digest_5ecd8d00ee49c82aecc9b4312a6eab51;
static PyObject *const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple;
extern PyObject *const_str_plain_keyfile;
extern PyObject *const_str_plain_p;
extern PyObject *const_str_plain_r;
static PyObject *const_str_plain_load_tmp_dh;
static PyObject *const_str_digest_0bdfe95b50c341a06f9727afb1a762dc;
static PyObject *const_str_plain__context;
static PyObject *const_tuple_str_plain_self_str_plain_context_tuple;
static PyObject *const_str_plain_valid;
static PyObject *const_str_digest_7f19e81c824604e95ebb1f01b7f5d7a1;
static PyObject *const_str_digest_746ae0014bb266cffee8b7b1473626af;
static PyObject *const_str_plain_SSL_shutdown;
extern PyObject *const_str_plain_X509Store;
static PyObject *const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple;
static PyObject *const_str_plain_SSL_get_peer_cert_chain;
static PyObject *const_str_plain__session;
static PyObject *const_str_digest_ce6e46c47189c65d4c33b9ca8d5ba2ad;
static PyObject *const_str_plain__OCSPServerCallbackHelper;
static PyObject *const_str_plain_SSL_new;
static PyObject *const_str_plain_OP_SINGLE_DH_USE;
static PyObject *const_str_digest_ad463a4d3fa3baff68f13aea2d205572;
static PyObject *const_str_plain_SSL_ERROR_ZERO_RETURN;
extern PyObject *const_str_plain_X509_NAME_free;
extern PyObject *const_str_plain_win32;
static PyObject *const_str_plain__passphrase_userdata;
extern PyObject *const_str_plain_FILETYPE_PEM;
extern PyObject *const_str_plain_native;
extern PyObject *const_str_plain_helper;
static PyObject *const_str_plain_SSL_OP_NO_SSLv3;
static PyObject *const_str_plain_OP_MICROSOFT_SESS_ID_BUG;
static PyObject *const_str_plain_SSL_SESSION_free;
extern PyObject *const_str_plain_TLSv1_2_METHOD;
static PyObject *const_str_digest_6d088f969ab84bf3d60ab75faa431e51;
extern PyObject *const_str_plain___all__;
extern PyObject *const_int_0;
extern PyObject *const_str_plain_six;
static PyObject *const_str_plain_SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
static PyObject *const_str_plain_set_mode;
static PyObject *const_list_str_digest_746ae0014bb266cffee8b7b1473626af_list;
extern PyObject *const_str_plain_get_shutdown;
static PyObject *const_str_plain_pystore;
static PyObject *const_str_plain_set_tlsext_servername_callback;
static PyObject *const_str_plain_SSL_TLSEXT_ERR_ALERT_FATAL;
static PyObject *const_str_plain_SSL_OP_NO_TLSv1;
extern PyObject *const_str_plain_callback;
static PyObject *const_str_plain_SSL_OP_MSIE_SSLV2_RSA_PADDING;
extern PyObject *const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
static PyObject *const_str_plain_check_privatekey;
static PyObject *const_str_plain_SSL_get_shutdown;
static PyObject *const_str_plain_context_buf;
static PyObject *const_str_digest_052250489768b32f02c8505795c1c0c7;
static PyObject *const_str_digest_b55bbb0df6959d47693f7145ead6828a;
static PyObject *const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple;
extern PyObject *const_str_plain_append;
static PyObject *const_str_plain_dir_env_var;
static PyObject *const_str_digest_3b38b9684d0a691f727a5c25b49127cb;
static PyObject *const_str_plain_request_ocsp;
static PyObject *const_str_digest_3c214455d63d6846892932f043ae8dab;
extern PyObject *const_str_plain_load_verify_locations;
static PyObject *const_str_plain_OP_TLS_D5_BUG;
static PyObject *const_str_plain_SESS_CACHE_SERVER;
static PyObject *const_str_digest_df17ae6c88635e3960d7bf94f5e880a4;
extern PyObject *const_str_plain_copy;
static PyObject *const_str_plain_SSL_want_read;
static PyObject *const_str_plain_SSL_CTX_set_default_passwd_cb;
static PyObject *const_str_plain_SSL_CTX_set_info_callback;
static PyObject *const_str_plain_OP_TLS_BLOCK_PADDING_BUG;
static PyObject *const_str_plain_SSL_get_error;
static PyObject *const_str_plain_SSL_CB_WRITE;
static PyObject *const_str_plain_get_timeout;
static PyObject *const_str_digest_f68d1733f2e29d0ad83b903b8f287e14;
extern PyObject *const_str_plain_pycert;
extern PyObject *const_str_plain_func;
extern PyObject *const_tuple_str_plain_self_str_plain_data_tuple;
extern PyObject *const_str_plain_wraps;
extern PyObject *const_dict_empty;
static PyObject *const_tuple_e7183725d38a187a36c7befeae938036_tuple;
static PyObject *const_str_digest_685ba6a7380a18939915178358979194;
extern PyObject *const_str_plain_SSLv23_METHOD;
static PyObject *const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple;
static PyObject *const_str_plain_use_context;
static PyObject *const_str_digest_68d768407778bc3b4c8ffc953440b717;
extern PyObject *const_str_plain_count;
static PyObject *const_str_digest_971aa32305ac0845a4048d72c4cd63c5;
static PyObject *const_str_digest_fe9d923dffe7ca07e210d76d45bba668;
static PyObject *const_str_digest_71f502d97e845c89ec13eb6ef271f294;
static PyObject *const_str_plain_get_cipher_list;
static PyObject *const_str_digest_770cbd653c9b65a44061ec243e0b5fd3;
static PyObject *const_str_plain_bufsiz;
static PyObject *const_str_plain_SSL_TLSEXT_ERR_NOACK;
static PyObject *const_str_plain_left_to_send;
extern PyObject *const_str_plain_TLSv1_METHOD;
static PyObject *const_str_digest_75d74458faf9dee1d9b7a20a034cfad7;
extern PyObject *const_str_plain__name;
static PyObject *const_str_plain_file_env_var;
extern PyObject *const_str_plain_get_verified_chain;
extern PyObject *const_str_plain_length;
static PyObject *const_str_plain__check_env_vars_set;
static PyObject *const_str_digest_bd36e8cd21056831af843bc4658cec96;
extern PyObject *const_str_plain_do_handshake;
static PyObject *const_str_plain_SSL_CB_READ;
static PyObject *const_str_plain_SSL_OP_ALL;
static PyObject *const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple;
static PyObject *const_str_plain__ocsp_callback;
extern PyObject *const_str_plain_X509_dup;
extern PyObject *const_str_plain_new;
static PyObject *const_str_digest_1f9e090d5f76db9e818dd53fef9b8465;
static PyObject *const_str_digest_627e1a07a1a60af86ff9e544428f2f09;
static PyObject *const_str_plain_ERR_peek_error;
static PyObject *const_str_digest_0e87e25b0ab76d44ec1e50f187ee33bd;
static PyObject *const_str_digest_03a9c0f25246f86801453ac49af67056;
static PyObject *const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_LOOKUP;
static PyObject *const_str_plain_X509_get_default_cert_file_env;
extern PyObject *const_str_plain_SSLv3_METHOD;
extern PyObject *const_str_plain__ssl;
static PyObject *const_str_digest_a9a754c6f4c1dd488de35af4ae59537f;
static PyObject *const_str_plain_WantX509LookupError;
static PyObject *const_str_plain_SSLEAY_VERSION;
static PyObject *const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple;
static PyObject *const_str_plain_get_peer_finished;
static PyObject *const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple;
static PyObject *const_str_plain_want_write;
static PyObject *const_str_plain_SSL_OP_COOKIE_EXCHANGE;
static PyObject *const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple;
extern PyObject *const_str_plain_session;
static PyObject *const_str_digest_447836721d7454a13033957e012d7688;
static PyObject *const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple;
static PyObject *const_str_digest_91220ffd97efb14a503e0ecf9d7ff0d1;
extern PyObject *const_str_plain__store;
static PyObject *const_str_digest_94e7111e03f9422114930bb75dfc492c;
static PyObject *const_str_digest_8d7c284f25a4b19db8bcbef7a9895745;
static PyObject *const_str_plain_SSL_get_version;
static PyObject *const_str_plain_SESS_CACHE_CLIENT;
extern PyObject *const_str_plain_connection;
static PyObject *const_str_plain_get_client_ca_list;
static PyObject *const_str_plain_get_cert_store;
static PyObject *const_tuple_str_plain_self_str_plain_result_tuple;
static PyObject *const_str_plain_SSL_get_current_cipher;
static PyObject *const_tuple_str_plain_self_str_plain_buf_str_plain_data_str_plain_result_tuple;
extern PyObject *const_str_digest_b9c4baf879ebd882d40843df3a4dead7;
static PyObject *const_str_digest_b8ec26ebdab81fb3d5f36275b48d4beb;
extern PyObject *const_tuple_int_0_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple;
static PyObject *const_str_plain_SSL_get_ex_data_X509_STORE_CTX_idx;
extern PyObject *const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple;
extern PyObject *const_str_plain_WantReadError;
extern PyObject *const_str_plain_OP_NO_SSLv3;
static PyObject *const_str_plain__set_ocsp_callback;
static PyObject *const_str_plain_SSL_set_session;
extern PyObject *const_str_plain_get_peer_certificate;
static PyObject *const_str_plain_sk_X509_NAME_num;
static PyObject *const_str_digest_a8ac54b3ed8845d56dee411b1beed5c2;
static PyObject *const_str_plain__ocsp_helper;
static PyObject *const_str_plain_SSL_CTX_set_session_id_context;
static PyObject *const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple;
static PyObject *const_str_plain_certificate_authorities;
static PyObject *const_str_plain_file_path;
extern PyObject *const_str_plain_kwargs;
static PyObject *const_str_plain_SSL_CTX_free;
static PyObject *const_str_plain_context_len;
static PyObject *const_str_digest_215c056443df9aa1456b62fe40673d54;
static PyObject *const_tuple_fb64e812782e9f70f19909e310070a01_tuple;
static PyObject *const_str_plain_SSL_OP_TLS_D5_BUG;
static PyObject *const_str_plain_OP_SSLEAY_080_CLIENT_DH_BUG;
extern PyObject *const_str_digest_52773e1185116024389d12c91a4ccf3d;
extern PyObject *const_str_plain___module__;
extern PyObject *const_str_plain__to_EC_KEY;
extern PyObject *const_str_plain_cipher;
static PyObject *const_str_plain_SSL_get_finished;
static PyObject *const_str_plain_SSL_get_cipher_list;
static PyObject *const_str_plain_SSL_ST_MASK;
static PyObject *const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple;
static PyObject *const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple;
static PyObject *const_str_digest_159b478f00ae4e4ff337b75b4ff4b73e;
static PyObject *const_str_digest_7cf2d06a8643ddce5d0ceedd61c750e1;
static PyObject *const_str_plain_SSL_SESS_CACHE_BOTH;
static PyObject *const_str_plain_SSL_CIPHER_get_bits;
extern PyObject *const_str_plain_exception_from_error_queue;
static PyObject *const_str_plain_OP_SSLREF2_REUSE_CERT_TYPE_BUG;
static PyObject *const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple;
static PyObject *const_str_digest_428eff9fedd3b449496fa307af56b948;
extern PyObject *const_str_plain__x509;
extern PyObject *const_str_plain___name__;
static PyObject *const_str_plain_sk_X509_NAME_new_null;
static PyObject *const_str_plain_SSL_OP_TLS_ROLLBACK_BUG;
extern PyObject *const_str_plain_string;
extern PyObject *const_str_plain_TLSv1_1_METHOD;
static PyObject *const_str_plain_SESS_CACHE_NO_INTERNAL;
static PyObject *const_tuple_4b816eca93dfbff03f5cbbe11e88a73f_tuple;
static PyObject *const_str_digest_e51bcf1ff2d3a73499a1380c77d20ade;
extern PyObject *const_str_plain_ssl;
extern PyObject *const_str_plain_data_ptr;
static PyObject *const_str_plain_SSL_CB_READ_ALERT;
static PyObject *const_str_plain_set_tlsext_use_srtp;
extern PyObject *const_str_plain_no_zero_allocator;
static PyObject *const_str_plain_SSL_OP_NO_COMPRESSION;
static PyObject *const_str_plain_SSL_TLSEXT_ERR_OK;
extern PyObject *const_str_plain_lib;
static PyObject *const_str_plain_MODE_RELEASE_BUFFERS;
static PyObject *const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple;
static PyObject *const_str_plain__passphrase_helper;
static PyObject *const_str_plain_SSL_set_tlsext_status_ocsp_resp;
extern PyObject *const_str_plain_where;
extern PyObject *const_str_plain_recv_into;
static PyObject *const_str_digest_a068c39f2c9878239ba2a3b47e83e1e0;
static PyObject *const_str_plain_SSL_ST_ACCEPT;
static PyObject *const_str_plain__passphrase_callback;
extern PyObject *const_str_plain_success;
extern PyObject *const_str_plain_ZeroReturnError;
static PyObject *const_str_plain_SSL_export_keying_material;
static PyObject *const_str_plain_SSL_CTX_set_default_verify_paths;
static PyObject *const_str_plain_get_state_string;
static PyObject *const_str_plain_SSL_CTX_set_cipher_list;
extern PyObject *const_str_plain_conn;
static PyObject *const_str_plain_SSL_OP_NO_TICKET;
static PyObject *const_str_digest_0db98f8a8931566efc9f7dd135830a12;
extern PyObject *const_str_plain_get_verify_mode;
static PyObject *const_str_plain_SSL_OP_PKCS1_CHECK_1;
static PyObject *const_str_plain_SSL_OP_PKCS1_CHECK_2;
static PyObject *const_str_plain_TLS_AES_128_GCM_SHA256;
static PyObject *const_str_plain_isfile;
static PyObject *const_str_plain_get_peer_cert_chain;
extern PyObject *const_str_plain_options;
static PyObject *const_str_plain_OP_NETSCAPE_CA_DN_BUG;
static PyObject *const_str_plain_SSL_CTX_set_tmp_ecdh;
static PyObject *const_str_plain_olen;
static PyObject *const_str_plain_SSL_CTX_set_timeout;
static PyObject *const_str_plain_method_obj;
extern PyObject *const_str_plain_obj;
static PyObject *const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple;
static PyObject *const_str_digest_8cde8912e8f2207155a1addb0752791f;
static PyObject *const_str_plain__raise_passphrase_exception;
static PyObject *const_str_digest_a94ef27b6600318cb26f98532a46ec7d;
extern PyObject *const_str_plain_data_len;
extern PyObject *const_str_plain_line;
static PyObject *const_str_plain_SSL_CTX_set_verify_depth;
static PyObject *const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR;
extern PyObject *const_str_plain_VERIFY_FAIL_IF_NO_PEER_CERT;
static PyObject *const_str_plain_use_result;
extern PyObject *const_str_plain_BIO_s_mem;
static PyObject *const_str_plain_TLSv1_2_method;
static PyObject *const_str_digest_6a85cdfe995e144af7c992d7adff36a9;
extern PyObject *const_str_plain_bio;
static PyObject *const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple;
static PyObject *const_str_digest_b6ee2740f619fbeb4f2040d74693ca57;
extern PyObject *const_tuple_str_plain_self_str_plain_name_tuple;
static PyObject *const_str_digest_c8e9b5ff5b00d8190ecae28b8a410248;
static PyObject *const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple;
extern PyObject *const_str_plain_isdir;
static PyObject *const_str_digest_f6ccda911266ccc3bb4cd038d18beb52;
static PyObject *const_str_plain__alpn_select_helper;
static PyObject *const_tuple_str_plain_self_str_plain_mode_tuple;
static PyObject *const_str_digest_f7bf61568f9564a7aee5354f80d84343;
static PyObject *const_str_plain_SSL_get_client_random;
static PyObject *const_str_plain_SSL_RECEIVED_SHUTDOWN;
static PyObject *const_str_plain_input_str;
static PyObject *const_str_digest_3f54294273e4f6390044ae027b11e5ae;
static PyObject *const_str_plain_SSL_CB_LOOP;
static PyObject *const_str_plain_BIO_set_mem_eof_return;
static PyObject *const_str_plain_OP_NO_TICKET;
static PyObject *const_str_plain_set_tmp_ecdh;
static PyObject *const_str_digest_91c07271f44b73503e7c77deea91aef1;
static PyObject *const_str_plain_SSL_SESSION_get_master_key;
static PyObject *const_str_plain_OP_MSIE_SSLV2_RSA_PADDING;
static PyObject *const_str_digest_b965e7ab82e8e0c92ec2736091bc1c12;
static PyObject *const_tuple_str_plain_platform_tuple;
extern PyObject *const_str_plain_total_sent;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_digest_a3b259134db00dfd8458bf615870c7e2;
static PyObject *const_str_plain__CERTIFICATE_FILE_LOCATIONS;
static PyObject *const_str_plain_set_ocsp_client_callback;
extern PyObject *const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
static PyObject *const_str_digest_f4ac5993e0eb53c16d6349308d51d30e;
static PyObject *const_str_digest_1ba1651f4266e42e9b568d28fa131281;
extern PyObject *const_str_plain_use_certificate_chain_file;
static PyObject *const_str_digest_bcb5a3a78e430302038d88f5e5d88cc5;
static PyObject *const_str_plain__buffer;
static PyObject *const_str_plain_protolist;
static PyObject *const_str_digest_149b7c0937a6a666f182d0520ebdf631;
static PyObject *const_str_digest_eda9ad2d7932cfc1d1f52f27a3ed06a8;
static PyObject *const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple;
static PyObject *const_str_plain_renegotiate;
extern PyObject *const_str_empty;
static PyObject *const_str_digest_9071118ef0006cb5d28d9100761be8e9;
static PyObject *const_str_digest_060a092ce142509580b5fc6c56b149a1;
static PyObject *const_str_plain_SSL_do_handshake;
static PyObject *const_str_plain_SSL_CB_WRITE_ALERT;
extern PyObject *const_str_plain_timeout;
extern PyObject *const_str_plain_X509_STORE_CTX_get_error_depth;
static PyObject *const_str_plain_X509_STORE_CTX_set_error;
static PyObject *const_str_plain_SSL_CTX_set_session_cache_mode;
static PyObject *const_str_plain_SSL_set_accept_state;
static PyObject *const_str_plain_sock_shutdown;
static PyObject *const_str_plain_BIO_read;
extern PyObject *const_str_plain_X509;
static PyObject *const_str_digest_592776beca582822ed747da68adba670;
extern PyObject *const_tuple_none_tuple;
static PyObject *const_str_plain_server_random;
static PyObject *const_str_plain_TLSEXT_STATUSTYPE_ocsp;
static PyObject *const_str_plain_default_dir;
static PyObject *module_filename_obj;

static bool constants_created = false;

static void createModuleConstants( void )
{
    const_str_plain_tmpconn = UNSTREAM_STRING( &constant_bin[ 57 ], 7, 1 );
    const_tuple_str_plain_errorcode_tuple = PyTuple_New( 1 );
    const_str_plain_errorcode = UNSTREAM_STRING( &constant_bin[ 64 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_errorcode_tuple, 0, const_str_plain_errorcode ); Py_INCREF( const_str_plain_errorcode );
    const_str_plain_get_context = UNSTREAM_STRING( &constant_bin[ 73 ], 11, 1 );
    const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple, 1, const_str_plain_session ); Py_INCREF( const_str_plain_session );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_SSL_VERIFY_CLIENT_ONCE = UNSTREAM_STRING( &constant_bin[ 84 ], 22, 1 );
    const_tuple_str_plain_self_str_plain_rc_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_rc_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_rc = UNSTREAM_STRING( &constant_bin[ 68 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_rc_tuple, 1, const_str_plain_rc ); Py_INCREF( const_str_plain_rc );
    const_str_plain_SSL_CTX_use_PrivateKey = UNSTREAM_STRING( &constant_bin[ 106 ], 22, 1 );
    const_str_plain_filetype = UNSTREAM_STRING( &constant_bin[ 128 ], 8, 1 );
    const_str_plain_BIO_write = UNSTREAM_STRING( &constant_bin[ 136 ], 9, 1 );
    const_str_digest_60759f97a8e448eec2208bd0c353d705 = UNSTREAM_STRING( &constant_bin[ 145 ], 405, 0 );
    const_list_tuple_1892b43c5f7e8b28e9bf284d360fe6ef_tuple_list = PyList_New( 1 );
    const_tuple_1892b43c5f7e8b28e9bf284d360fe6ef_tuple = PyTuple_New( 3 );
    const_str_digest_54ae0815d64a99c28491423112423094 = UNSTREAM_STRING( &constant_bin[ 550 ], 12, 0 );
    PyTuple_SET_ITEM( const_tuple_1892b43c5f7e8b28e9bf284d360fe6ef_tuple, 0, const_str_digest_54ae0815d64a99c28491423112423094 ); Py_INCREF( const_str_digest_54ae0815d64a99c28491423112423094 );
    const_str_plain_SSL_CTX_set_cipher_list = UNSTREAM_STRING( &constant_bin[ 562 ], 23, 1 );
    PyTuple_SET_ITEM( const_tuple_1892b43c5f7e8b28e9bf284d360fe6ef_tuple, 1, const_str_plain_SSL_CTX_set_cipher_list ); Py_INCREF( const_str_plain_SSL_CTX_set_cipher_list );
    const_str_digest_7eea2d7bc9b359d848e500f33cdf6253 = UNSTREAM_STRING( &constant_bin[ 585 ], 15, 0 );
    PyTuple_SET_ITEM( const_tuple_1892b43c5f7e8b28e9bf284d360fe6ef_tuple, 2, const_str_digest_7eea2d7bc9b359d848e500f33cdf6253 ); Py_INCREF( const_str_digest_7eea2d7bc9b359d848e500f33cdf6253 );
    PyList_SET_ITEM( const_list_tuple_1892b43c5f7e8b28e9bf284d360fe6ef_tuple_list, 0, const_tuple_1892b43c5f7e8b28e9bf284d360fe6ef_tuple ); Py_INCREF( const_tuple_1892b43c5f7e8b28e9bf284d360fe6ef_tuple );
    const_str_plain_ca_list = UNSTREAM_STRING( &constant_bin[ 600 ], 7, 1 );
    const_str_plain_BIO_should_write = UNSTREAM_STRING( &constant_bin[ 607 ], 16, 1 );
    const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple, 0, const_str_plain_func ); Py_INCREF( const_str_plain_func );
    const_str_plain_explode = UNSTREAM_STRING( &constant_bin[ 623 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple, 1, const_str_plain_explode ); Py_INCREF( const_str_plain_explode );
    const_str_plain_flag = UNSTREAM_STRING( &constant_bin[ 630 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple, 2, const_str_plain_flag ); Py_INCREF( const_str_plain_flag );
    const_str_digest_92dae1d5c0e993b1b8bd25bfbbae5039 = UNSTREAM_STRING( &constant_bin[ 634 ], 472, 0 );
    const_str_plain_pyname = UNSTREAM_STRING( &constant_bin[ 1106 ], 6, 1 );
    const_str_plain_OP_COOKIE_EXCHANGE = UNSTREAM_STRING( &constant_bin[ 1112 ], 18, 1 );
    const_str_plain_ca_names = UNSTREAM_STRING( &constant_bin[ 1130 ], 8, 1 );
    const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE = UNSTREAM_STRING( &constant_bin[ 1138 ], 32, 1 );
    const_str_plain_OP_SINGLE_ECDH_USE = UNSTREAM_STRING( &constant_bin[ 1170 ], 18, 1 );
    const_str_plain_TLSv1_method = UNSTREAM_STRING( &constant_bin[ 1188 ], 12, 1 );
    const_str_plain_SSL_set_tlsext_host_name = UNSTREAM_STRING( &constant_bin[ 1200 ], 24, 1 );
    const_tuple_df35527807658c5906d3a25929231255_tuple = PyTuple_New( 16 );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 0, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 1, const_str_plain_out ); Py_INCREF( const_str_plain_out );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 2, const_str_plain_outlen ); Py_INCREF( const_str_plain_outlen );
    const_str_plain_in_ = UNSTREAM_STRING( &constant_bin[ 1224 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 3, const_str_plain_in_ ); Py_INCREF( const_str_plain_in_ );
    const_str_plain_inlen = UNSTREAM_STRING( &constant_bin[ 1227 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 4, const_str_plain_inlen ); Py_INCREF( const_str_plain_inlen );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 5, const_str_plain_arg ); Py_INCREF( const_str_plain_arg );
    const_str_plain_encoded_len = UNSTREAM_STRING( &constant_bin[ 1232 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 6, const_str_plain_encoded_len ); Py_INCREF( const_str_plain_encoded_len );
    const_str_plain_protolist = UNSTREAM_STRING( &constant_bin[ 1243 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 7, const_str_plain_protolist ); Py_INCREF( const_str_plain_protolist );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 8, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    const_str_plain_outbytes = UNSTREAM_STRING( &constant_bin[ 1252 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 9, const_str_plain_outbytes ); Py_INCREF( const_str_plain_outbytes );
    const_str_plain_instr = UNSTREAM_STRING( &constant_bin[ 1260 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 10, const_str_plain_instr ); Py_INCREF( const_str_plain_instr );
    const_str_plain_any_accepted = UNSTREAM_STRING( &constant_bin[ 1265 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 11, const_str_plain_any_accepted ); Py_INCREF( const_str_plain_any_accepted );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 12, const_str_plain_proto ); Py_INCREF( const_str_plain_proto );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 13, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 14, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_df35527807658c5906d3a25929231255_tuple, 15, const_str_plain_conn ); Py_INCREF( const_str_plain_conn );
    const_str_plain_depth = UNSTREAM_STRING( &constant_bin[ 1277 ], 5, 1 );
    const_str_plain_SSL_OP_NO_QUERY_MTU = UNSTREAM_STRING( &constant_bin[ 1282 ], 19, 1 );
    const_str_plain_X509_STORE_CTX_get_ex_data = UNSTREAM_STRING( &constant_bin[ 1301 ], 26, 1 );
    const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_certobj = UNSTREAM_STRING( &constant_bin[ 1327 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 1, const_str_plain_certobj ); Py_INCREF( const_str_plain_certobj );
    PyTuple_SET_ITEM( const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 2, const_str_plain_copy ); Py_INCREF( const_str_plain_copy );
    PyTuple_SET_ITEM( const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 3, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    const_str_plain_set_accept_state = UNSTREAM_STRING( &constant_bin[ 1334 ], 16, 1 );
    const_str_plain_error_number = UNSTREAM_STRING( &constant_bin[ 1350 ], 12, 1 );
    const_str_plain_SSL_OP_NO_SSLv2 = UNSTREAM_STRING( &constant_bin[ 1362 ], 15, 1 );
    const_str_plain_SSL_ST_CONNECT = UNSTREAM_STRING( &constant_bin[ 1377 ], 14, 1 );
    const_str_plain_want_read = UNSTREAM_STRING( &constant_bin[ 1391 ], 9, 1 );
    const_str_plain_add_client_ca = UNSTREAM_STRING( &constant_bin[ 1400 ], 13, 1 );
    const_str_plain_OP_NO_QUERY_MTU = UNSTREAM_STRING( &constant_bin[ 1286 ], 15, 1 );
    const_str_plain__from_ssl = UNSTREAM_STRING( &constant_bin[ 1413 ], 9, 1 );
    const_str_digest_3319904791e7df62e14d88cc362facc1 = UNSTREAM_STRING( &constant_bin[ 1422 ], 150, 0 );
    const_str_plain_set_ocsp_server_callback = UNSTREAM_STRING( &constant_bin[ 1572 ], 24, 1 );
    const_str_plain_SSL_CTX_get_timeout = UNSTREAM_STRING( &constant_bin[ 1596 ], 19, 1 );
    const_str_plain_SSL_version = UNSTREAM_STRING( &constant_bin[ 1615 ], 11, 1 );
    const_str_plain__OCSPClientCallbackHelper = UNSTREAM_STRING( &constant_bin[ 1626 ], 25, 1 );
    const_str_plain_VERIFY_CLIENT_ONCE = UNSTREAM_STRING( &constant_bin[ 88 ], 18, 1 );
    const_str_digest_62d4d7edcf7c24573f6c449cbee3cf23 = UNSTREAM_STRING( &constant_bin[ 1651 ], 534, 0 );
    const_str_plain_getwinerror = UNSTREAM_STRING( &constant_bin[ 2185 ], 11, 1 );
    const_str_plain__reverse_mapping = UNSTREAM_STRING( &constant_bin[ 2196 ], 16, 1 );
    const_str_digest_04211c3d50cdc4f69d9c36018d92c12f = UNSTREAM_STRING( &constant_bin[ 2212 ], 39, 0 );
    const_str_plain_set_client_ca_list = UNSTREAM_STRING( &constant_bin[ 2251 ], 18, 1 );
    const_str_plain_set_session = UNSTREAM_STRING( &constant_bin[ 2269 ], 11, 1 );
    const_str_plain_OP_DONT_INSERT_EMPTY_FRAGMENTS = UNSTREAM_STRING( &constant_bin[ 2280 ], 30, 1 );
    const_str_digest_8e472bc9049677fa90a9da1a818ea22f = UNSTREAM_STRING( &constant_bin[ 2310 ], 186, 0 );
    const_str_plain_alert = UNSTREAM_STRING( &constant_bin[ 2496 ], 5, 1 );
    const_str_digest_b02795b9590127f96a3b627129a2fbd2 = UNSTREAM_STRING( &constant_bin[ 2501 ], 29, 0 );
    const_str_plain_push_result = UNSTREAM_STRING( &constant_bin[ 2530 ], 11, 1 );
    const_str_plain__socket = UNSTREAM_STRING( &constant_bin[ 2541 ], 7, 1 );
    const_tuple_40c019df00fadc68e051d5153056e038_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 2, const_str_plain_pyname ); Py_INCREF( const_str_plain_pyname );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 3, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 4, const_str_plain_ca_names ); Py_INCREF( const_str_plain_ca_names );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 5, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 6, const_str_plain_copy ); Py_INCREF( const_str_plain_copy );
    const_str_digest_053565796c68d049169d0efbeceaaf7d = UNSTREAM_STRING( &constant_bin[ 2548 ], 23, 0 );
    const_str_plain_SSL_CTX_set_tlsext_use_srtp = UNSTREAM_STRING( &constant_bin[ 2571 ], 27, 1 );
    const_str_digest_0bb5eb9f5b32c979fadc3e4b702de2f7 = UNSTREAM_STRING( &constant_bin[ 2598 ], 148, 0 );
    const_str_plain_SSL_CTX_set_mode = UNSTREAM_STRING( &constant_bin[ 2746 ], 16, 1 );
    const_str_digest_25ee1ab59a31b6b65728138ca859d41c = UNSTREAM_STRING( &constant_bin[ 2762 ], 986, 0 );
    const_str_plain_SSL_get1_session = UNSTREAM_STRING( &constant_bin[ 3748 ], 16, 1 );
    const_str_plain_SSL_CTX_set_verify = UNSTREAM_STRING( &constant_bin[ 3694 ], 18, 1 );
    const_str_plain_SSL_CTX_add_client_CA = UNSTREAM_STRING( &constant_bin[ 3764 ], 21, 1 );
    const_str_digest_cbc74855fdd069af46a5197a85921eab = UNSTREAM_STRING( &constant_bin[ 3785 ], 328, 0 );
    const_str_plain_SSL_CTX_use_certificate_chain_file = UNSTREAM_STRING( &constant_bin[ 4113 ], 34, 1 );
    const_str_plain_BIO_new_file = UNSTREAM_STRING( &constant_bin[ 4147 ], 12, 1 );
    const_str_plain_ocsp_data = UNSTREAM_STRING( &constant_bin[ 4159 ], 9, 1 );
    const_str_digest_73851dbd1821d646fbb8ad48e937548f = UNSTREAM_STRING( &constant_bin[ 4168 ], 135, 0 );
    const_str_digest_8cc305fc9d9a417a96ba57f2c87b94e9 = UNSTREAM_STRING( &constant_bin[ 4303 ], 24, 0 );
    const_str_plain_SSLEAY_DIR = UNSTREAM_STRING( &constant_bin[ 4327 ], 10, 1 );
    const_str_digest_099382aff2f4e6520a621b385fae4992 = UNSTREAM_STRING( &constant_bin[ 4337 ], 220, 0 );
    const_str_plain_use_privatekey = UNSTREAM_STRING( &constant_bin[ 4557 ], 14, 1 );
    const_str_plain_nbytes = UNSTREAM_STRING( &constant_bin[ 4571 ], 6, 1 );
    const_str_plain__alpn_select_callback_args = UNSTREAM_STRING( &constant_bin[ 4577 ], 26, 1 );
    const_str_plain_SSL_SESS_CACHE_OFF = UNSTREAM_STRING( &constant_bin[ 4603 ], 18, 1 );
    const_str_digest_92d0e5bbbb594d3595c30b16879df5a0 = UNSTREAM_STRING( &constant_bin[ 4621 ], 128, 0 );
    const_str_plain_SSL_CB_HANDSHAKE_DONE = UNSTREAM_STRING( &constant_bin[ 4749 ], 21, 1 );
    const_str_plain_SESS_CACHE_OFF = UNSTREAM_STRING( &constant_bin[ 4607 ], 14, 1 );
    const_str_digest_240fed82a102b949d0d53c00df42e330 = UNSTREAM_STRING( &constant_bin[ 4770 ], 103, 0 );
    const_str_plain_SSL_MODE_ENABLE_PARTIAL_WRITE = UNSTREAM_STRING( &constant_bin[ 4873 ], 29, 1 );
    const_str_digest_3957b1b23f06761ef1844caf450dffd3 = UNSTREAM_STRING( &constant_bin[ 4902 ], 221, 0 );
    const_str_plain__VerifyHelper = UNSTREAM_STRING( &constant_bin[ 5123 ], 13, 1 );
    const_str_plain_SSL_CIPHER_get_version = UNSTREAM_STRING( &constant_bin[ 5136 ], 22, 1 );
    const_str_plain_bio_shutdown = UNSTREAM_STRING( &constant_bin[ 5158 ], 12, 1 );
    const_str_digest_f45f13437cfffca595693525af90acd6 = UNSTREAM_STRING( &constant_bin[ 5170 ], 156, 0 );
    const_str_plain_TLSEXT_NAMETYPE_host_name = UNSTREAM_STRING( &constant_bin[ 5326 ], 25, 1 );
    const_str_plain_SSL_OP_MICROSOFT_SESS_ID_BUG = UNSTREAM_STRING( &constant_bin[ 5351 ], 28, 1 );
    const_str_plain_SSL_CB_EXIT = UNSTREAM_STRING( &constant_bin[ 5379 ], 11, 1 );
    const_str_plain_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = UNSTREAM_STRING( &constant_bin[ 5390 ], 35, 1 );
    const_str_plain_get_protocol_version = UNSTREAM_STRING( &constant_bin[ 5425 ], 20, 1 );
    const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 0, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 1, const_str_plain_cdata ); Py_INCREF( const_str_plain_cdata );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 2, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    const_str_plain_ocsp_data_length = UNSTREAM_STRING( &constant_bin[ 5445 ], 16, 1 );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 3, const_str_plain_ocsp_data_length ); Py_INCREF( const_str_plain_ocsp_data_length );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 4, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 5, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 6, const_str_plain_ocsp_data ); Py_INCREF( const_str_plain_ocsp_data );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 7, const_str_plain_data_ptr ); Py_INCREF( const_str_plain_data_ptr );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 8, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 9, const_str_plain_conn ); Py_INCREF( const_str_plain_conn );
    const_str_plain__cert_stack_to_list = UNSTREAM_STRING( &constant_bin[ 5461 ], 19, 1 );
    const_str_plain__wrap_callback = UNSTREAM_STRING( &constant_bin[ 5480 ], 14, 1 );
    const_str_plain_X509_get_default_cert_dir_env = UNSTREAM_STRING( &constant_bin[ 5494 ], 29, 1 );
    const_str_digest_7ac3fb96e522dea60117802c4a4274df = UNSTREAM_STRING( &constant_bin[ 5523 ], 26, 0 );
    const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 1, const_str_plain_method ); Py_INCREF( const_str_plain_method );
    const_str_plain_method_obj = UNSTREAM_STRING( &constant_bin[ 5549 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 2, const_str_plain_method_obj ); Py_INCREF( const_str_plain_method_obj );
    PyTuple_SET_ITEM( const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 3, const_str_plain_res ); Py_INCREF( const_str_plain_res );
    PyTuple_SET_ITEM( const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 4, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    const_str_plain_method_func = UNSTREAM_STRING( &constant_bin[ 5559 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 5, const_str_plain_method_func ); Py_INCREF( const_str_plain_method_func );
    const_str_plain_SSL_OP_NO_TLSv1_2 = UNSTREAM_STRING( &constant_bin[ 5570 ], 17, 1 );
    const_str_plain_SSL_OP_NO_TLSv1_1 = UNSTREAM_STRING( &constant_bin[ 5587 ], 17, 1 );
    const_tuple_str_plain_ssl_str_plain_line_str_plain_callback_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ssl_str_plain_line_str_plain_callback_tuple, 0, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_str_plain_ssl_str_plain_line_str_plain_callback_tuple, 1, const_str_plain_line ); Py_INCREF( const_str_plain_line );
    PyTuple_SET_ITEM( const_tuple_str_plain_ssl_str_plain_line_str_plain_callback_tuple, 2, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    const_str_plain_bio_read = UNSTREAM_STRING( &constant_bin[ 5604 ], 8, 1 );
    const_str_plain__requires_decorator = UNSTREAM_STRING( &constant_bin[ 5612 ], 19, 1 );
    const_str_plain_name_stack = UNSTREAM_STRING( &constant_bin[ 5631 ], 10, 1 );
    const_str_digest_3d1ad7b2c9fa025afe944eacf471d909 = UNSTREAM_STRING( &constant_bin[ 5641 ], 137, 0 );
    const_str_digest_fc4eb7967b0e83bc3a3b7fec0ef46cce = UNSTREAM_STRING( &constant_bin[ 5778 ], 465, 0 );
    const_str_digest_77c1b668370aaac8571fd41e2e807543 = UNSTREAM_STRING( &constant_bin[ 6243 ], 763, 0 );
    const_str_plain__asFileDescriptor = UNSTREAM_STRING( &constant_bin[ 7006 ], 17, 1 );
    const_str_plain_SESS_CACHE_NO_AUTO_CLEAR = UNSTREAM_STRING( &constant_bin[ 7023 ], 24, 1 );
    const_str_plain_add_extra_chain_cert = UNSTREAM_STRING( &constant_bin[ 7047 ], 20, 1 );
    const_str_digest_09af89b9aab79bc5666da647371af25d = UNSTREAM_STRING( &constant_bin[ 7067 ], 272, 0 );
    const_str_digest_c16991ba946fb91cede508bddb6a3d8d = UNSTREAM_STRING( &constant_bin[ 7339 ], 668, 0 );
    const_str_plain_get_servername = UNSTREAM_STRING( &constant_bin[ 8007 ], 14, 1 );
    const_str_plain_TLS_CHACHA20_POLY1305_SHA256 = UNSTREAM_STRING( &constant_bin[ 8021 ], 28, 1 );
    const_str_plain_SSL_CTX_use_certificate = UNSTREAM_STRING( &constant_bin[ 4113 ], 23, 1 );
    const_str_plain_SESS_CACHE_BOTH = UNSTREAM_STRING( &constant_bin[ 8049 ], 15, 1 );
    const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple = PyTuple_New( 11 );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 0, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 1, const_str_plain_cdata ); Py_INCREF( const_str_plain_cdata );
    const_str_plain_ocsp_len = UNSTREAM_STRING( &constant_bin[ 8064 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 2, const_str_plain_ocsp_len ); Py_INCREF( const_str_plain_ocsp_len );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 3, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 4, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 5, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_valid = UNSTREAM_STRING( &constant_bin[ 6048 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 6, const_str_plain_valid ); Py_INCREF( const_str_plain_valid );
    const_str_plain_ocsp_ptr = UNSTREAM_STRING( &constant_bin[ 8072 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 7, const_str_plain_ocsp_ptr ); Py_INCREF( const_str_plain_ocsp_ptr );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 8, const_str_plain_ocsp_data ); Py_INCREF( const_str_plain_ocsp_data );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 9, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 10, const_str_plain_conn ); Py_INCREF( const_str_plain_conn );
    const_str_digest_f5da7ec1228a5c8d32fa9b786affa014 = UNSTREAM_STRING( &constant_bin[ 8080 ], 361, 0 );
    const_str_digest_0d994cfb9823ffc5647bea3454d1e646 = UNSTREAM_STRING( &constant_bin[ 8441 ], 119, 0 );
    const_str_digest_e7ed1590d11cbaaaf17420c6bdc13490 = UNSTREAM_STRING( &constant_bin[ 8560 ], 169, 0 );
    const_str_digest_83abd167711a9d69f6fb1ba8bbb40fdb = UNSTREAM_STRING( &constant_bin[ 8729 ], 1010, 0 );
    const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple, 1, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple, 2, const_str_plain_userdata ); Py_INCREF( const_str_plain_userdata );
    const_str_plain_SSL_ERROR_SYSCALL = UNSTREAM_STRING( &constant_bin[ 9739 ], 17, 1 );
    const_str_plain_TLS_AES_256_GCM_SHA384 = UNSTREAM_STRING( &constant_bin[ 9756 ], 22, 1 );
    const_str_plain_OP_EPHEMERAL_RSA = UNSTREAM_STRING( &constant_bin[ 9778 ], 16, 1 );
    const_str_plain_set_timeout = UNSTREAM_STRING( &constant_bin[ 2650 ], 11, 1 );
    const_str_plain_X509_get_default_cert_file = UNSTREAM_STRING( &constant_bin[ 9794 ], 26, 1 );
    const_str_plain_SSL_set_fd = UNSTREAM_STRING( &constant_bin[ 9820 ], 10, 1 );
    const_str_plain_protos = UNSTREAM_STRING( &constant_bin[ 9830 ], 6, 1 );
    const_str_digest_655ba65e888ba33199198c92a8e95d70 = UNSTREAM_STRING( &constant_bin[ 9836 ], 151, 0 );
    const_str_plain_SSLv2_METHOD = UNSTREAM_STRING( &constant_bin[ 9987 ], 12, 1 );
    const_str_plain__requires_alpn = UNSTREAM_STRING( &constant_bin[ 9999 ], 14, 1 );
    const_tuple_str_plain_self_str_plain_cipher_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_tuple, 1, const_str_plain_cipher ); Py_INCREF( const_str_plain_cipher );
    const_str_digest_d3a1e78595a066a43885e44a343877f5 = UNSTREAM_STRING( &constant_bin[ 10013 ], 14, 0 );
    const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple, 1, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_ef6e6485863cf611499d4e66d7c8cb32 = UNSTREAM_STRING( &constant_bin[ 10027 ], 196, 0 );
    const_str_plain_set_session_cache_mode = UNSTREAM_STRING( &constant_bin[ 10223 ], 22, 1 );
    const_tuple_str_plain_self_str_plain_options_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_options_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_options_tuple, 1, const_str_plain_options ); Py_INCREF( const_str_plain_options );
    const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple, 1, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple, 2, const_str_plain_connect_ex ); Py_INCREF( const_str_plain_connect_ex );
    const_str_plain__alpn_select_callback = UNSTREAM_STRING( &constant_bin[ 4577 ], 21, 1 );
    const_str_plain_BIO_should_retry = UNSTREAM_STRING( &constant_bin[ 10245 ], 16, 1 );
    const_str_plain_Cryptography_HAS_KEYLOG = UNSTREAM_STRING( &constant_bin[ 10261 ], 23, 1 );
    const_str_plain_set_context = UNSTREAM_STRING( &constant_bin[ 10284 ], 11, 1 );
    const_str_digest_2c98e45dae0eb590d01836d5f4b5f54f = UNSTREAM_STRING( &constant_bin[ 10295 ], 435, 0 );
    const_str_digest_5f09856be161f8b617a90e11db2ed735 = UNSTREAM_STRING( &constant_bin[ 10730 ], 105, 0 );
    const_str_plain_SSL_CB_ACCEPT_EXIT = UNSTREAM_STRING( &constant_bin[ 10835 ], 18, 1 );
    const_str_digest_c9c6fa40ef38c8d28b115afb17db4e50 = UNSTREAM_STRING( &constant_bin[ 10853 ], 343, 0 );
    const_str_plain_SSL_OP_SSLEAY_080_CLIENT_DH_BUG = UNSTREAM_STRING( &constant_bin[ 11196 ], 31, 1 );
    const_str_plain_SSL_OP_NETSCAPE_CHALLENGE_BUG = UNSTREAM_STRING( &constant_bin[ 11227 ], 29, 1 );
    const_str_digest_9575fec1eee4d60c15d3f7c228d8045c = UNSTREAM_STRING( &constant_bin[ 11256 ], 22, 0 );
    const_str_plain__ALPNSelectHelper = UNSTREAM_STRING( &constant_bin[ 11278 ], 17, 1 );
    const_str_plain_bio_write = UNSTREAM_STRING( &constant_bin[ 11295 ], 9, 1 );
    const_str_plain_SSL_ERROR_WANT_READ = UNSTREAM_STRING( &constant_bin[ 11304 ], 19, 1 );
    const_str_plain_set_keylog_callback = UNSTREAM_STRING( &constant_bin[ 11323 ], 19, 1 );
    const_str_plain_SSL_CTX_set_tlsext_status_cb = UNSTREAM_STRING( &constant_bin[ 11342 ], 28, 1 );
    const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_certificate_authority = UNSTREAM_STRING( &constant_bin[ 8314 ], 21, 1 );
    PyTuple_SET_ITEM( const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple, 1, const_str_plain_certificate_authority ); Py_INCREF( const_str_plain_certificate_authority );
    PyTuple_SET_ITEM( const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple, 2, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    const_str_plain_export_keying_material = UNSTREAM_STRING( &constant_bin[ 11370 ], 22, 1 );
    const_str_plain_SSL_get_tlsext_status_ocsp_resp = UNSTREAM_STRING( &constant_bin[ 11392 ], 31, 1 );
    const_str_plain_set_alpn_select_callback = UNSTREAM_STRING( &constant_bin[ 11423 ], 24, 1 );
    const_str_plain_get_verify_depth = UNSTREAM_STRING( &constant_bin[ 11447 ], 16, 1 );
    const_str_plain_SSL_CTX_set_client_CA_list = UNSTREAM_STRING( &constant_bin[ 11463 ], 26, 1 );
    const_str_plain_SSL_set_bio = UNSTREAM_STRING( &constant_bin[ 11489 ], 11, 1 );
    const_str_digest_6e6304d3afc4a993b41c01e5af499f6b = UNSTREAM_STRING( &constant_bin[ 11500 ], 154, 0 );
    const_str_plain_sk_X509_NAME_value = UNSTREAM_STRING( &constant_bin[ 11654 ], 18, 1 );
    const_str_plain_OP_TLS_ROLLBACK_BUG = UNSTREAM_STRING( &constant_bin[ 11672 ], 19, 1 );
    const_str_digest_e5bdbccc007b5187d287f36f3c9f8130 = UNSTREAM_STRING( &constant_bin[ 11691 ], 360, 0 );
    const_str_plain_SSL_CTX_use_certificate_file = UNSTREAM_STRING( &constant_bin[ 12051 ], 28, 1 );
    const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple, 0, const_str_plain_obj ); Py_INCREF( const_str_plain_obj );
    const_str_plain_fd = UNSTREAM_STRING( &constant_bin[ 9828 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple, 1, const_str_plain_fd ); Py_INCREF( const_str_plain_fd );
    const_str_plain_meth = UNSTREAM_STRING( &constant_bin[ 164 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple, 2, const_str_plain_meth ); Py_INCREF( const_str_plain_meth );
    const_str_plain_SSL_MODE_RELEASE_BUFFERS = UNSTREAM_STRING( &constant_bin[ 12079 ], 24, 1 );
    const_str_digest_b2b544e0252baa92681eeaf8ffa03130 = UNSTREAM_STRING( &constant_bin[ 12103 ], 173, 0 );
    const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple, 1, const_str_plain_cafile ); Py_INCREF( const_str_plain_cafile );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple, 2, const_str_plain_ca_list ); Py_INCREF( const_str_plain_ca_list );
    const_str_plain_OP_NETSCAPE_CHALLENGE_BUG = UNSTREAM_STRING( &constant_bin[ 11231 ], 25, 1 );
    const_str_digest_62f84685dfb1efe6a65f54b5d84154ad = UNSTREAM_STRING( &constant_bin[ 12276 ], 266, 0 );
    const_str_digest_afa60644cf27716474a6bbd780185867 = UNSTREAM_STRING( &constant_bin[ 12542 ], 49, 0 );
    const_str_plain__ocsp_data = UNSTREAM_STRING( &constant_bin[ 12591 ], 10, 1 );
    const_tuple_str_plain_count_str_plain_chain_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_count_str_plain_chain_tuple, 0, const_str_plain_count ); Py_INCREF( const_str_plain_count );
    PyTuple_SET_ITEM( const_tuple_str_plain_count_str_plain_chain_tuple, 1, const_str_plain_chain ); Py_INCREF( const_str_plain_chain );
    const_str_digest_d84d6f514b61e2d13913a11459387aca = UNSTREAM_STRING( &constant_bin[ 12601 ], 259, 0 );
    const_tuple_a992a212ff6e075874fbd47e83bc62d2_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_a992a212ff6e075874fbd47e83bc62d2_tuple, 0, const_str_plain_cert_stack ); Py_INCREF( const_str_plain_cert_stack );
    PyTuple_SET_ITEM( const_tuple_a992a212ff6e075874fbd47e83bc62d2_tuple, 1, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_a992a212ff6e075874fbd47e83bc62d2_tuple, 2, const_str_plain_pycert ); Py_INCREF( const_str_plain_pycert );
    PyTuple_SET_ITEM( const_tuple_a992a212ff6e075874fbd47e83bc62d2_tuple, 3, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_a992a212ff6e075874fbd47e83bc62d2_tuple, 4, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_a992a212ff6e075874fbd47e83bc62d2_tuple, 5, const_str_plain_res ); Py_INCREF( const_str_plain_res );
    const_str_plain_from_handle = UNSTREAM_STRING( &constant_bin[ 12860 ], 11, 1 );
    const_str_plain_protostr = UNSTREAM_STRING( &constant_bin[ 12871 ], 8, 1 );
    const_str_plain_SSL_CTX_get_verify_mode = UNSTREAM_STRING( &constant_bin[ 12879 ], 23, 1 );
    const_str_plain_SSL_get_servername = UNSTREAM_STRING( &constant_bin[ 12902 ], 18, 1 );
    const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 1, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    PyTuple_SET_ITEM( const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 2, const_str_plain_socket ); Py_INCREF( const_str_plain_socket );
    PyTuple_SET_ITEM( const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 3, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 4, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_str_plain_SSL_VERIFY_PEER = UNSTREAM_STRING( &constant_bin[ 12920 ], 15, 1 );
    const_tuple_78e460fdd8266d432328f4bff5207c29_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 0, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 1, const_str_plain_where ); Py_INCREF( const_str_plain_where );
    PyTuple_SET_ITEM( const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 2, const_str_plain_return_code ); Py_INCREF( const_str_plain_return_code );
    PyTuple_SET_ITEM( const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 3, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    const_str_digest_7540551bed0e4507c2b90cdbe0aa8fb3 = UNSTREAM_STRING( &constant_bin[ 12935 ], 49, 0 );
    const_str_plain__requires_keylog = UNSTREAM_STRING( &constant_bin[ 12984 ], 16, 1 );
    const_str_digest_61df355efe52f096d5251268bee9ada3 = UNSTREAM_STRING( &constant_bin[ 13000 ], 130, 0 );
    const_str_plain_SSL_CB_CONNECT_LOOP = UNSTREAM_STRING( &constant_bin[ 13130 ], 19, 1 );
    const_str_plain_SESS_CACHE_NO_INTERNAL_STORE = UNSTREAM_STRING( &constant_bin[ 13149 ], 28, 1 );
    const_str_digest_df9e5608be804d3b3249be3c13b24db8 = UNSTREAM_STRING( &constant_bin[ 13177 ], 34, 0 );
    const_str_plain_SSL_OP_SINGLE_ECDH_USE = UNSTREAM_STRING( &constant_bin[ 13211 ], 22, 1 );
    const_str_plain_set_session_id = UNSTREAM_STRING( &constant_bin[ 13233 ], 14, 1 );
    const_str_plain_OPENSSL_VERSION_NUMBER = UNSTREAM_STRING( &constant_bin[ 13247 ], 22, 1 );
    const_str_plain_SSL_ERROR_WANT_WRITE = UNSTREAM_STRING( &constant_bin[ 13269 ], 20, 1 );
    const_str_plain_SESS_CACHE_NO_INTERNAL_LOOKUP = UNSTREAM_STRING( &constant_bin[ 13289 ], 29, 1 );
    const_str_plain_profiles = UNSTREAM_STRING( &constant_bin[ 13318 ], 8, 1 );
    const_str_digest_fd8757ca246c476601094123086e9a80 = UNSTREAM_STRING( &constant_bin[ 13326 ], 1008, 0 );
    const_str_plain__methods = UNSTREAM_STRING( &constant_bin[ 14334 ], 8, 1 );
    const_str_plain_SSL_renegotiate_pending = UNSTREAM_STRING( &constant_bin[ 14342 ], 23, 1 );
    const_tuple_str_plain_self_str_plain_depth_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_depth_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_depth_tuple, 1, const_str_plain_depth ); Py_INCREF( const_str_plain_depth );
    const_str_digest_9e9a42d8484d15cb8253ecb92e0c7121 = UNSTREAM_STRING( &constant_bin[ 14365 ], 51, 0 );
    const_str_plain_accept = UNSTREAM_STRING( &constant_bin[ 1269 ], 6, 1 );
    const_str_plain_SSLeay_version = UNSTREAM_STRING( &constant_bin[ 14416 ], 14, 1 );
    const_str_plain_SSL_renegotiate = UNSTREAM_STRING( &constant_bin[ 14342 ], 15, 1 );
    const_list_6fa8c3d8587ec1659fa28b2f58883e42_list = PyList_New( 3 );
    PyList_SET_ITEM( const_list_6fa8c3d8587ec1659fa28b2f58883e42_list, 0, const_str_plain_TLS_AES_256_GCM_SHA384 ); Py_INCREF( const_str_plain_TLS_AES_256_GCM_SHA384 );
    PyList_SET_ITEM( const_list_6fa8c3d8587ec1659fa28b2f58883e42_list, 1, const_str_plain_TLS_CHACHA20_POLY1305_SHA256 ); Py_INCREF( const_str_plain_TLS_CHACHA20_POLY1305_SHA256 );
    const_str_plain_TLS_AES_128_GCM_SHA256 = UNSTREAM_STRING( &constant_bin[ 14430 ], 22, 1 );
    PyList_SET_ITEM( const_list_6fa8c3d8587ec1659fa28b2f58883e42_list, 2, const_str_plain_TLS_AES_128_GCM_SHA256 ); Py_INCREF( const_str_plain_TLS_AES_128_GCM_SHA256 );
    const_tuple_7e6126bff16a8a76a713850dcb042242_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 0, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 1, const_str_plain_alert ); Py_INCREF( const_str_plain_alert );
    PyTuple_SET_ITEM( const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 2, const_str_plain_arg ); Py_INCREF( const_str_plain_arg );
    PyTuple_SET_ITEM( const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 3, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    const_str_plain_SSL_OP_CIPHER_SERVER_PREFERENCE = UNSTREAM_STRING( &constant_bin[ 14452 ], 31, 1 );
    const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple, 1, const_str_plain_mode ); Py_INCREF( const_str_plain_mode );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple, 2, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    const_str_plain_SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER = UNSTREAM_STRING( &constant_bin[ 14483 ], 33, 1 );
    const_str_plain_SSL_ERROR_NONE = UNSTREAM_STRING( &constant_bin[ 14516 ], 14, 1 );
    const_list_b44af29ad37821285e6b89a520342cf5_list = PyList_New( 5 );
    PyList_SET_ITEM( const_list_b44af29ad37821285e6b89a520342cf5_list, 0, const_str_digest_df9e5608be804d3b3249be3c13b24db8 ); Py_INCREF( const_str_digest_df9e5608be804d3b3249be3c13b24db8 );
    const_str_digest_052250489768b32f02c8505795c1c0c7 = UNSTREAM_STRING( &constant_bin[ 14530 ], 32, 0 );
    PyList_SET_ITEM( const_list_b44af29ad37821285e6b89a520342cf5_list, 1, const_str_digest_052250489768b32f02c8505795c1c0c7 ); Py_INCREF( const_str_digest_052250489768b32f02c8505795c1c0c7 );
    const_str_digest_ee77c76941f8fd58acff5cfda589cc1d = UNSTREAM_STRING( &constant_bin[ 14562 ], 22, 0 );
    PyList_SET_ITEM( const_list_b44af29ad37821285e6b89a520342cf5_list, 2, const_str_digest_ee77c76941f8fd58acff5cfda589cc1d ); Py_INCREF( const_str_digest_ee77c76941f8fd58acff5cfda589cc1d );
    PyList_SET_ITEM( const_list_b44af29ad37821285e6b89a520342cf5_list, 3, const_str_digest_053565796c68d049169d0efbeceaaf7d ); Py_INCREF( const_str_digest_053565796c68d049169d0efbeceaaf7d );
    const_str_digest_a3b259134db00dfd8458bf615870c7e2 = UNSTREAM_STRING( &constant_bin[ 14584 ], 49, 0 );
    PyList_SET_ITEM( const_list_b44af29ad37821285e6b89a520342cf5_list, 4, const_str_digest_a3b259134db00dfd8458bf615870c7e2 ); Py_INCREF( const_str_digest_a3b259134db00dfd8458bf615870c7e2 );
    const_str_plain_SSL_load_client_CA_file = UNSTREAM_STRING( &constant_bin[ 14633 ], 23, 1 );
    const_str_digest_d242bea258df0e7212519aa660c5f53d = UNSTREAM_STRING( &constant_bin[ 14656 ], 24, 0 );
    const_str_plain_get_app_data = UNSTREAM_STRING( &constant_bin[ 14680 ], 12, 1 );
    const_str_plain_SSL_pending = UNSTREAM_STRING( &constant_bin[ 14692 ], 11, 1 );
    const_str_digest_aa8d23211c54bc521e23e53a6e431cd2 = UNSTREAM_STRING( &constant_bin[ 14703 ], 30, 0 );
    const_str_plain_SSL_CTX_get_verify_depth = UNSTREAM_STRING( &constant_bin[ 14733 ], 24, 1 );
    const_str_plain_get_cipher_bits = UNSTREAM_STRING( &constant_bin[ 14757 ], 15, 1 );
    const_str_plain_SSL_CTX_set_tlsext_status_arg = UNSTREAM_STRING( &constant_bin[ 14772 ], 29, 1 );
    const_str_digest_1494ae1301cb98a828389add570df55f = UNSTREAM_STRING( &constant_bin[ 14801 ], 94, 0 );
    const_tuple_a67b1154f8342873401b8122b6389ba8_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 2, const_str_plain_nbytes ); Py_INCREF( const_str_plain_nbytes );
    PyTuple_SET_ITEM( const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 3, const_str_plain_flags ); Py_INCREF( const_str_plain_flags );
    PyTuple_SET_ITEM( const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 4, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 5, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_SSL_get_session = UNSTREAM_STRING( &constant_bin[ 14895 ], 15, 1 );
    const_tuple_bf8c920f4f7b4caeaec53a43edb49d5c_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_bf8c920f4f7b4caeaec53a43edb49d5c_tuple, 0, const_str_plain_UNSPECIFIED ); Py_INCREF( const_str_plain_UNSPECIFIED );
    PyTuple_SET_ITEM( const_tuple_bf8c920f4f7b4caeaec53a43edb49d5c_tuple, 1, const_str_plain_exception_from_error_queue ); Py_INCREF( const_str_plain_exception_from_error_queue );
    PyTuple_SET_ITEM( const_tuple_bf8c920f4f7b4caeaec53a43edb49d5c_tuple, 2, const_str_plain_ffi ); Py_INCREF( const_str_plain_ffi );
    PyTuple_SET_ITEM( const_tuple_bf8c920f4f7b4caeaec53a43edb49d5c_tuple, 3, const_str_plain_from_buffer ); Py_INCREF( const_str_plain_from_buffer );
    PyTuple_SET_ITEM( const_tuple_bf8c920f4f7b4caeaec53a43edb49d5c_tuple, 4, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    PyTuple_SET_ITEM( const_tuple_bf8c920f4f7b4caeaec53a43edb49d5c_tuple, 5, const_str_plain_make_assert ); Py_INCREF( const_str_plain_make_assert );
    PyTuple_SET_ITEM( const_tuple_bf8c920f4f7b4caeaec53a43edb49d5c_tuple, 6, const_str_plain_native ); Py_INCREF( const_str_plain_native );
    PyTuple_SET_ITEM( const_tuple_bf8c920f4f7b4caeaec53a43edb49d5c_tuple, 7, const_str_plain_path_string ); Py_INCREF( const_str_plain_path_string );
    PyTuple_SET_ITEM( const_tuple_bf8c920f4f7b4caeaec53a43edb49d5c_tuple, 8, const_str_plain_text_to_bytes_and_warn ); Py_INCREF( const_str_plain_text_to_bytes_and_warn );
    PyTuple_SET_ITEM( const_tuple_bf8c920f4f7b4caeaec53a43edb49d5c_tuple, 9, const_str_plain_no_zero_allocator ); Py_INCREF( const_str_plain_no_zero_allocator );
    const_str_digest_4387d84e76f6b2a931cf315cb767f6ce = UNSTREAM_STRING( &constant_bin[ 14910 ], 51, 0 );
    const_str_plain_OP_CIPHER_SERVER_PREFERENCE = UNSTREAM_STRING( &constant_bin[ 14456 ], 27, 1 );
    const_str_plain_SENT_SHUTDOWN = UNSTREAM_STRING( &constant_bin[ 9923 ], 13, 1 );
    const_str_plain_X509_get_default_cert_dir = UNSTREAM_STRING( &constant_bin[ 5494 ], 25, 1 );
    const_str_plain_SSL_CTX_add_extra_chain_cert = UNSTREAM_STRING( &constant_bin[ 14961 ], 28, 1 );
    const_str_digest_776556dd9343f57c1cd72ff937153f0f = UNSTREAM_STRING( &constant_bin[ 14989 ], 268, 0 );
    const_str_plain_master_key = UNSTREAM_STRING( &constant_bin[ 15257 ], 10, 1 );
    const_tuple_str_plain_self_str_plain_profiles_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_profiles_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_profiles_tuple, 1, const_str_plain_profiles ); Py_INCREF( const_str_plain_profiles );
    const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_pystore = UNSTREAM_STRING( &constant_bin[ 15267 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple, 1, const_str_plain_pystore ); Py_INCREF( const_str_plain_pystore );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple, 2, const_str_plain_store ); Py_INCREF( const_str_plain_store );
    const_str_digest_d5ded94dafea47ce6f2b4fa579755177 = UNSTREAM_STRING( &constant_bin[ 15274 ], 34, 0 );
    const_str_plain__CallbackExceptionHelper = UNSTREAM_STRING( &constant_bin[ 15308 ], 24, 1 );
    const_str_plain_set_alpn_protos = UNSTREAM_STRING( &constant_bin[ 15332 ], 15, 1 );
    const_str_plain_empty = UNSTREAM_STRING( &constant_bin[ 995 ], 5, 1 );
    const_str_plain_sk_X509_NAME_push = UNSTREAM_STRING( &constant_bin[ 15347 ], 17, 1 );
    const_str_plain_OP_ALL = UNSTREAM_STRING( &constant_bin[ 15364 ], 6, 1 );
    const_str_digest_aa803484dcfcfaec3d1d830a5ef1f026 = UNSTREAM_STRING( &constant_bin[ 15370 ], 195, 0 );
    const_str_plain_SSLEAY_BUILT_ON = UNSTREAM_STRING( &constant_bin[ 15565 ], 15, 1 );
    const_str_plain_total_renegotiations = UNSTREAM_STRING( &constant_bin[ 15580 ], 20, 1 );
    const_str_plain_TLSv1_1_method = UNSTREAM_STRING( &constant_bin[ 15600 ], 14, 1 );
    const_str_plain_from_iterable = UNSTREAM_STRING( &constant_bin[ 15614 ], 13, 1 );
    const_str_plain_error_depth = UNSTREAM_STRING( &constant_bin[ 15627 ], 11, 1 );
    const_str_plain__from_buffer = UNSTREAM_STRING( &constant_bin[ 15638 ], 12, 1 );
    const_str_digest_ebaec5436a48442094f25464a6eec24c = UNSTREAM_STRING( &constant_bin[ 15650 ], 277, 0 );
    const_str_digest_b8ccf81a020f16490de1c8527ea9e4d6 = UNSTREAM_STRING( &constant_bin[ 15927 ], 302, 0 );
    const_str_digest_d89a36d0b4664ac4178af2071f30652f = UNSTREAM_STRING( &constant_bin[ 16229 ], 26, 0 );
    const_str_plain_SSL_CB_CONNECT_EXIT = UNSTREAM_STRING( &constant_bin[ 16255 ], 19, 1 );
    const_str_digest_cf5a529c83a60eab9bc87caa3430bc5c = UNSTREAM_STRING( &constant_bin[ 16274 ], 405, 0 );
    const_str_digest_3462bf983701fbd7caf2f521f5975fff = UNSTREAM_STRING( &constant_bin[ 16679 ], 25, 0 );
    const_str_plain_OP_PKCS1_CHECK_1 = UNSTREAM_STRING( &constant_bin[ 16704 ], 16, 1 );
    const_str_plain_get_finished = UNSTREAM_STRING( &constant_bin[ 16720 ], 12, 1 );
    const_str_digest_794f687944b90121fa261238090835e1 = UNSTREAM_STRING( &constant_bin[ 16732 ], 338, 0 );
    const_str_plain_identifier = UNSTREAM_STRING( &constant_bin[ 17070 ], 10, 1 );
    const_str_plain_OP_PKCS1_CHECK_2 = UNSTREAM_STRING( &constant_bin[ 17080 ], 16, 1 );
    const_str_plain_get_cipher_name = UNSTREAM_STRING( &constant_bin[ 17096 ], 15, 1 );
    const_str_plain_OP_MICROSOFT_BIG_SSLV3_BUFFER = UNSTREAM_STRING( &constant_bin[ 14487 ], 29, 1 );
    const_str_digest_ebc06328e68f0dbdd2e23e3f1f581b13 = UNSTREAM_STRING( &constant_bin[ 17111 ], 1008, 0 );
    const_str_plain__fallback_default_verify_paths = UNSTREAM_STRING( &constant_bin[ 18119 ], 30, 1 );
    const_str_plain_X509_V_OK = UNSTREAM_STRING( &constant_bin[ 18149 ], 9, 1 );
    const_str_plain_SSL_total_renegotiations = UNSTREAM_STRING( &constant_bin[ 18158 ], 24, 1 );
    const_str_plain_SSL_peek = UNSTREAM_STRING( &constant_bin[ 18182 ], 8, 1 );
    const_str_plain_SSL_CTX_load_verify_locations = UNSTREAM_STRING( &constant_bin[ 18190 ], 29, 1 );
    const_tuple_str_plain_type_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    const_str_plain_SSL_set_SSL_CTX = UNSTREAM_STRING( &constant_bin[ 18219 ], 15, 1 );
    const_str_plain_OP_NO_TLSv1 = UNSTREAM_STRING( &constant_bin[ 5574 ], 11, 1 );
    const_str_plain__handle_bio_errors = UNSTREAM_STRING( &constant_bin[ 18234 ], 18, 1 );
    const_str_plain_SSLv23_method = UNSTREAM_STRING( &constant_bin[ 18252 ], 13, 1 );
    const_str_digest_616719c4a0cde3344203a07484a7fb54 = UNSTREAM_STRING( &constant_bin[ 18265 ], 18, 0 );
    const_tuple_str_plain_WeakValueDictionary_tuple = PyTuple_New( 1 );
    const_str_plain_WeakValueDictionary = UNSTREAM_STRING( &constant_bin[ 18283 ], 19, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_WeakValueDictionary_tuple, 0, const_str_plain_WeakValueDictionary ); Py_INCREF( const_str_plain_WeakValueDictionary );
    const_str_plain_SSL_CTX_get_cert_store = UNSTREAM_STRING( &constant_bin[ 18302 ], 22, 1 );
    const_str_plain_SSL_ERROR_WANT_X509_LOOKUP = UNSTREAM_STRING( &constant_bin[ 18324 ], 26, 1 );
    const_str_plain__info_callback = UNSTREAM_STRING( &constant_bin[ 18350 ], 14, 1 );
    const_str_plain_new_handle = UNSTREAM_STRING( &constant_bin[ 18364 ], 10, 1 );
    const_str_plain_SSLv2_method = UNSTREAM_STRING( &constant_bin[ 18374 ], 12, 1 );
    const_str_plain_outp = UNSTREAM_STRING( &constant_bin[ 2147 ], 4, 1 );
    const_str_plain_set_shutdown = UNSTREAM_STRING( &constant_bin[ 18386 ], 12, 1 );
    const_str_plain_SSL_CB_ALERT = UNSTREAM_STRING( &constant_bin[ 18398 ], 12, 1 );
    const_str_plain_use_certificate_file = UNSTREAM_STRING( &constant_bin[ 12059 ], 20, 1 );
    const_str_plain_SSL_OP_SINGLE_DH_USE = UNSTREAM_STRING( &constant_bin[ 18410 ], 20, 1 );
    const_str_plain_SSL_write = UNSTREAM_STRING( &constant_bin[ 18430 ], 9, 1 );
    const_tuple_d443d2554e6119150f8264e2746dcaf3_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_d443d2554e6119150f8264e2746dcaf3_tuple, 0, const_str_plain_integer_types ); Py_INCREF( const_str_plain_integer_types );
    PyTuple_SET_ITEM( const_tuple_d443d2554e6119150f8264e2746dcaf3_tuple, 1, const_str_plain_int2byte ); Py_INCREF( const_str_plain_int2byte );
    PyTuple_SET_ITEM( const_tuple_d443d2554e6119150f8264e2746dcaf3_tuple, 2, const_str_plain_indexbytes ); Py_INCREF( const_str_plain_indexbytes );
    const_str_digest_1491fa532da0499070a77d607dd12a0d = UNSTREAM_STRING( &constant_bin[ 18439 ], 19, 0 );
    const_str_plain_get_alpn_proto_negotiated = UNSTREAM_STRING( &constant_bin[ 18458 ], 25, 1 );
    const_str_plain_ca_name = UNSTREAM_STRING( &constant_bin[ 1130 ], 7, 1 );
    const_tuple_str_plain_self_str_plain_callback_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_tuple, 1, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    const_tuple_35c846c03e9c30b5467b3336c5c65a45_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_35c846c03e9c30b5467b3336c5c65a45_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_35c846c03e9c30b5467b3336c5c65a45_tuple, 1, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_35c846c03e9c30b5467b3336c5c65a45_tuple, 2, const_str_plain_flags ); Py_INCREF( const_str_plain_flags );
    PyTuple_SET_ITEM( const_tuple_35c846c03e9c30b5467b3336c5c65a45_tuple, 3, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_35c846c03e9c30b5467b3336c5c65a45_tuple, 4, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    const_tuple_70adcf8f254ece362639433ee96fdafb_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 1, const_str_plain_certfile ); Py_INCREF( const_str_plain_certfile );
    PyTuple_SET_ITEM( const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 2, const_str_plain_filetype ); Py_INCREF( const_str_plain_filetype );
    const_str_plain_use_result = UNSTREAM_STRING( &constant_bin[ 18483 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 3, const_str_plain_use_result ); Py_INCREF( const_str_plain_use_result );
    const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 1, const_str_plain_data_len ); Py_INCREF( const_str_plain_data_len );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 2, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    const_str_plain__no_zero_allocator = UNSTREAM_STRING( &constant_bin[ 18493 ], 18, 1 );
    const_str_plain_SSL_CIPHER_get_name = UNSTREAM_STRING( &constant_bin[ 18511 ], 19, 1 );
    const_str_digest_6e6e0d8d93df9702d9c8795dc2391090 = UNSTREAM_STRING( &constant_bin[ 18530 ], 205, 0 );
    const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 1, const_str_plain_function ); Py_INCREF( const_str_plain_function );
    PyTuple_SET_ITEM( const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 2, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 3, const_str_plain_empty ); Py_INCREF( const_str_plain_empty );
    PyTuple_SET_ITEM( const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 4, const_str_plain_size ); Py_INCREF( const_str_plain_size );
    const_str_digest_28855c350e66dba47d4f94de98c7d542 = UNSTREAM_STRING( &constant_bin[ 18735 ], 94, 0 );
    const_str_plain_SSL_set_connect_state = UNSTREAM_STRING( &constant_bin[ 18829 ], 21, 1 );
    const_str_digest_6f72f23667e4f49591ed4cf6d6205ca5 = UNSTREAM_STRING( &constant_bin[ 18850 ], 613, 0 );
    const_str_plain_SSL_VERIFY_FAIL_IF_NO_PEER_CERT = UNSTREAM_STRING( &constant_bin[ 19463 ], 31, 1 );
    const_str_plain__CERTIFICATE_PATH_LOCATIONS = UNSTREAM_STRING( &constant_bin[ 19494 ], 27, 1 );
    const_str_plain__app_data = UNSTREAM_STRING( &constant_bin[ 8499 ], 9, 1 );
    const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 0, const_str_plain_FILETYPE_PEM ); Py_INCREF( const_str_plain_FILETYPE_PEM );
    PyTuple_SET_ITEM( const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 1, const_str_plain__PassphraseHelper ); Py_INCREF( const_str_plain__PassphraseHelper );
    PyTuple_SET_ITEM( const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 2, const_str_plain_PKey ); Py_INCREF( const_str_plain_PKey );
    PyTuple_SET_ITEM( const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 3, const_str_plain_X509Name ); Py_INCREF( const_str_plain_X509Name );
    PyTuple_SET_ITEM( const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 4, const_str_plain_X509 ); Py_INCREF( const_str_plain_X509 );
    PyTuple_SET_ITEM( const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 5, const_str_plain_X509Store ); Py_INCREF( const_str_plain_X509Store );
    const_str_plain_MSG_PEEK = UNSTREAM_STRING( &constant_bin[ 15813 ], 8, 1 );
    const_str_plain_get_cipher_version = UNSTREAM_STRING( &constant_bin[ 19521 ], 18, 1 );
    const_str_plain_SSL_CTX_set_keylog_callback = UNSTREAM_STRING( &constant_bin[ 19539 ], 27, 1 );
    const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 0, const_str_plain_size ); Py_INCREF( const_str_plain_size );
    PyTuple_SET_ITEM( const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 1, const_str_plain_verify ); Py_INCREF( const_str_plain_verify );
    PyTuple_SET_ITEM( const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 2, const_str_plain_userdata ); Py_INCREF( const_str_plain_userdata );
    PyTuple_SET_ITEM( const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 3, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 4, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    const_str_digest_242762bc0b8f70110beb7fa23160c8c2 = UNSTREAM_STRING( &constant_bin[ 19566 ], 35, 0 );
    const_str_digest_e04d236da419e1b15c5c13532be67a91 = UNSTREAM_STRING( &constant_bin[ 19601 ], 496, 0 );
    const_str_digest_85e95361903fe71cece52bb01216866e = UNSTREAM_STRING( &constant_bin[ 20097 ], 597, 0 );
    const_str_plain_set_info_callback = UNSTREAM_STRING( &constant_bin[ 20694 ], 17, 1 );
    const_str_plain_sk_X509_NAME_free = UNSTREAM_STRING( &constant_bin[ 20711 ], 17, 1 );
    const_str_digest_48d61bd61390dfd5cd1a721d2881edd7 = UNSTREAM_STRING( &constant_bin[ 20728 ], 259, 0 );
    const_str_plain__keylog_callback = UNSTREAM_STRING( &constant_bin[ 11326 ], 16, 1 );
    const_str_plain_SSL_CB_HANDSHAKE_START = UNSTREAM_STRING( &constant_bin[ 20987 ], 22, 1 );
    const_str_plain_SSLEAY_PLATFORM = UNSTREAM_STRING( &constant_bin[ 21009 ], 15, 1 );
    const_str_plain__get_finished_message = UNSTREAM_STRING( &constant_bin[ 21024 ], 21, 1 );
    const_str_plain_get_session = UNSTREAM_STRING( &constant_bin[ 14899 ], 11, 1 );
    const_str_plain_SSL_set_mode = UNSTREAM_STRING( &constant_bin[ 21045 ], 12, 1 );
    const_str_plain_dhfile = UNSTREAM_STRING( &constant_bin[ 2380 ], 6, 1 );
    const_str_plain_SSL_get_certificate = UNSTREAM_STRING( &constant_bin[ 21057 ], 19, 1 );
    const_str_plain_SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = UNSTREAM_STRING( &constant_bin[ 21076 ], 38, 1 );
    const_str_plain_SSL_CTX_set_options = UNSTREAM_STRING( &constant_bin[ 21114 ], 19, 1 );
    const_str_digest_a824ae6766bf79c53a58510064186c32 = UNSTREAM_STRING( &constant_bin[ 21133 ], 271, 0 );
    const_str_digest_0b1af5d020260df564f1f58f9f88daaa = UNSTREAM_STRING( &constant_bin[ 21404 ], 243, 0 );
    const_str_plain_BIO_should_io_special = UNSTREAM_STRING( &constant_bin[ 21647 ], 21, 1 );
    const_str_plain_SSL_OP_EPHEMERAL_RSA = UNSTREAM_STRING( &constant_bin[ 21668 ], 20, 1 );
    const_str_plain_SSL_SESS_CACHE_CLIENT = UNSTREAM_STRING( &constant_bin[ 21688 ], 21, 1 );
    const_str_digest_1c06dc4166e08805f38a8dca82ce4339 = UNSTREAM_STRING( &constant_bin[ 21709 ], 147, 0 );
    const_tuple_str_plain_wraps_str_plain_partial_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_wraps_str_plain_partial_tuple, 0, const_str_plain_wraps ); Py_INCREF( const_str_plain_wraps );
    PyTuple_SET_ITEM( const_tuple_str_plain_wraps_str_plain_partial_tuple, 1, const_str_plain_partial ); Py_INCREF( const_str_plain_partial );
    const_str_digest_ceaeeee7f342339744c9535ada3c62e3 = UNSTREAM_STRING( &constant_bin[ 21856 ], 223, 0 );
    const_str_plain_SSL_set_tlsext_status_type = UNSTREAM_STRING( &constant_bin[ 22079 ], 26, 1 );
    const_str_plain__verify_helper = UNSTREAM_STRING( &constant_bin[ 22105 ], 14, 1 );
    const_str_digest_38eb25c1dd31f1c93831bc586a51d94a = UNSTREAM_STRING( &constant_bin[ 22119 ], 386, 0 );
    const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple, 1, const_str_plain_cipher ); Py_INCREF( const_str_plain_cipher );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_plain_SSL_OP_TLS_BLOCK_PADDING_BUG = UNSTREAM_STRING( &constant_bin[ 22505 ], 28, 1 );
    const_str_plain_pysession = UNSTREAM_STRING( &constant_bin[ 22533 ], 9, 1 );
    const_str_digest_7cc8f764b42656b144d56bfbd9df2b48 = UNSTREAM_STRING( &constant_bin[ 22542 ], 909, 0 );
    const_str_plain__make_requires = UNSTREAM_STRING( &constant_bin[ 23451 ], 14, 1 );
    const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e = UNSTREAM_STRING( &constant_bin[ 23465 ], 33, 0 );
    const_str_plain_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = UNSTREAM_STRING( &constant_bin[ 21080 ], 34, 1 );
    const_str_plain_BIO_should_read = UNSTREAM_STRING( &constant_bin[ 23498 ], 15, 1 );
    const_str_plain_cipher_list = UNSTREAM_STRING( &constant_bin[ 574 ], 11, 1 );
    const_str_plain_set_verify_depth = UNSTREAM_STRING( &constant_bin[ 23513 ], 16, 1 );
    const_str_digest_bae02e8783abd2cb1ef184c4ddb0f45d = UNSTREAM_STRING( &constant_bin[ 23529 ], 143, 0 );
    const_str_plain_SSL_CTX_check_private_key = UNSTREAM_STRING( &constant_bin[ 23672 ], 25, 1 );
    const_str_digest_0f682ae315fc37e97d14dcc920e8b91d = UNSTREAM_STRING( &constant_bin[ 23697 ], 112, 0 );
    const_tuple_db9f88d750a1668ba43cf0b62b6c8a91_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_db9f88d750a1668ba43cf0b62b6c8a91_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_db9f88d750a1668ba43cf0b62b6c8a91_tuple, 1, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_db9f88d750a1668ba43cf0b62b6c8a91_tuple, 2, const_str_plain_flags ); Py_INCREF( const_str_plain_flags );
    const_str_plain_left_to_send = UNSTREAM_STRING( &constant_bin[ 23809 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_db9f88d750a1668ba43cf0b62b6c8a91_tuple, 3, const_str_plain_left_to_send ); Py_INCREF( const_str_plain_left_to_send );
    PyTuple_SET_ITEM( const_tuple_db9f88d750a1668ba43cf0b62b6c8a91_tuple, 4, const_str_plain_total_sent ); Py_INCREF( const_str_plain_total_sent );
    PyTuple_SET_ITEM( const_tuple_db9f88d750a1668ba43cf0b62b6c8a91_tuple, 5, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_db9f88d750a1668ba43cf0b62b6c8a91_tuple, 6, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_b65860d01f08f87c7391d19b5cfd9850 = UNSTREAM_STRING( &constant_bin[ 23821 ], 398, 0 );
    const_str_digest_39e6e3efbf37d872dab9cfbddc398ebf = UNSTREAM_STRING( &constant_bin[ 24219 ], 318, 0 );
    const_str_plain_use_certificate = UNSTREAM_STRING( &constant_bin[ 4121 ], 15, 1 );
    const_str_plain_SSL_CTX_get_session_cache_mode = UNSTREAM_STRING( &constant_bin[ 24537 ], 30, 1 );
    const_str_plain_dir_path = UNSTREAM_STRING( &constant_bin[ 24567 ], 8, 1 );
    const_str_digest_f5111f918158679228186076f422f85e = UNSTREAM_STRING( &constant_bin[ 24575 ], 46, 0 );
    const_str_digest_720dcf8e2be0afcf53b482e84751fd16 = UNSTREAM_STRING( &constant_bin[ 24621 ], 201, 0 );
    const_list_394c4be2fcfa967175404c799b8030c7_list = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 24822 ], 1817 );
    const_str_plain_SSL_CTX_new = UNSTREAM_STRING( &constant_bin[ 26639 ], 11, 1 );
    const_str_plain__raise_ssl_error = UNSTREAM_STRING( &constant_bin[ 26650 ], 16, 1 );
    const_str_plain_SSL_get_peer_finished = UNSTREAM_STRING( &constant_bin[ 22289 ], 21, 1 );
    const_str_plain_SSL_MODE_AUTO_RETRY = UNSTREAM_STRING( &constant_bin[ 26666 ], 19, 1 );
    const_str_plain_SSL_get_peer_certificate = UNSTREAM_STRING( &constant_bin[ 26685 ], 24, 1 );
    const_tuple_str_plain_self_str_plain_cert_stack_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cert_stack_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cert_stack_tuple, 1, const_str_plain_cert_stack ); Py_INCREF( const_str_plain_cert_stack );
    const_str_plain_load_client_ca = UNSTREAM_STRING( &constant_bin[ 26709 ], 14, 1 );
    const_str_plain_SSL_get_server_random = UNSTREAM_STRING( &constant_bin[ 26723 ], 21, 1 );
    const_str_plain_SSL_CB_ACCEPT_LOOP = UNSTREAM_STRING( &constant_bin[ 26331 ], 18, 1 );
    const_str_digest_39dd8800b3995a2e161e8739b1bebc01 = UNSTREAM_STRING( &constant_bin[ 26744 ], 337, 0 );
    const_tuple_b5f59418c193d572a22cf854b821fa76_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_b5f59418c193d572a22cf854b821fa76_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    PyTuple_SET_ITEM( const_tuple_b5f59418c193d572a22cf854b821fa76_tuple, 1, const_str_plain_identifier ); Py_INCREF( const_str_plain_identifier );
    PyTuple_SET_ITEM( const_tuple_b5f59418c193d572a22cf854b821fa76_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_digest_1c1aa9b3fa80807ae10c68cfa1a0b8e6 = UNSTREAM_STRING( &constant_bin[ 27081 ], 273, 0 );
    const_str_plain_SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = UNSTREAM_STRING( &constant_bin[ 27354 ], 39, 1 );
    const_str_plain_client_random = UNSTREAM_STRING( &constant_bin[ 27393 ], 13, 1 );
    const_str_plain_renegotiate_pending = UNSTREAM_STRING( &constant_bin[ 14346 ], 19, 1 );
    const_str_plain_SSL_SENT_SHUTDOWN = UNSTREAM_STRING( &constant_bin[ 27406 ], 17, 1 );
    const_str_plain__tlsext_servername_callback = UNSTREAM_STRING( &constant_bin[ 27423 ], 27, 1 );
    const_str_digest_59969d93e4432efc7c61f6e9fd945ba6 = UNSTREAM_STRING( &constant_bin[ 27450 ], 98, 0 );
    const_str_digest_eb75de26d3d89a0b83fc536ac20042b0 = UNSTREAM_STRING( &constant_bin[ 27548 ], 121, 0 );
    const_str_plain_get_session_cache_mode = UNSTREAM_STRING( &constant_bin[ 24545 ], 22, 1 );
    const_str_digest_a971aca8bab65513da2005120ca529f5 = UNSTREAM_STRING( &constant_bin[ 27669 ], 360, 0 );
    const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_STORE = UNSTREAM_STRING( &constant_bin[ 28029 ], 32, 1 );
    const_str_plain_SSL_state_string_long = UNSTREAM_STRING( &constant_bin[ 28061 ], 21, 1 );
    const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_default_dir = UNSTREAM_STRING( &constant_bin[ 28082 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 1, const_str_plain_default_dir ); Py_INCREF( const_str_plain_default_dir );
    PyTuple_SET_ITEM( const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 2, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_str_plain_dir_env_var = UNSTREAM_STRING( &constant_bin[ 28093 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 3, const_str_plain_dir_env_var ); Py_INCREF( const_str_plain_dir_env_var );
    const_str_plain_file_env_var = UNSTREAM_STRING( &constant_bin[ 28104 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 4, const_str_plain_file_env_var ); Py_INCREF( const_str_plain_file_env_var );
    const_str_plain_default_file = UNSTREAM_STRING( &constant_bin[ 28116 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 5, const_str_plain_default_file ); Py_INCREF( const_str_plain_default_file );
    const_str_plain_NO_OVERLAPPING_PROTOCOLS = UNSTREAM_STRING( &constant_bin[ 7851 ], 24, 1 );
    const_str_plain_SSL_set_shutdown = UNSTREAM_STRING( &constant_bin[ 28128 ], 16, 1 );
    const_str_plain_SSL_get_client_CA_list = UNSTREAM_STRING( &constant_bin[ 28144 ], 22, 1 );
    const_str_plain_SSL_CTX_use_PrivateKey_file = UNSTREAM_STRING( &constant_bin[ 28166 ], 27, 1 );
    const_str_plain_SSL_VERIFY_NONE = UNSTREAM_STRING( &constant_bin[ 28193 ], 15, 1 );
    const_str_plain_SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG = UNSTREAM_STRING( &constant_bin[ 28208 ], 34, 1 );
    const_str_plain_SSLEAY_CFLAGS = UNSTREAM_STRING( &constant_bin[ 24878 ], 13, 1 );
    const_str_plain_SSL_SESS_CACHE_NO_INTERNAL = UNSTREAM_STRING( &constant_bin[ 28029 ], 26, 1 );
    const_str_digest_8d1f7ec402c1b452808eeb662977982b = UNSTREAM_STRING( &constant_bin[ 28242 ], 224, 0 );
    const_str_plain_SSL_CTX_set_tlsext_servername_callback = UNSTREAM_STRING( &constant_bin[ 28466 ], 38, 1 );
    const_str_plain_OP_NO_TLSv1_1 = UNSTREAM_STRING( &constant_bin[ 5591 ], 13, 1 );
    const_str_plain_OP_NO_TLSv1_3 = UNSTREAM_STRING( &constant_bin[ 25182 ], 13, 1 );
    const_str_plain_OP_NO_TLSv1_2 = UNSTREAM_STRING( &constant_bin[ 5574 ], 13, 1 );
    const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6 = UNSTREAM_STRING( &constant_bin[ 28504 ], 28, 0 );
    const_str_plain_SSL_CTX_set_tmp_dh = UNSTREAM_STRING( &constant_bin[ 28532 ], 18, 1 );
    const_str_digest_0438f8885bf87c226201350e81ca4f79 = UNSTREAM_STRING( &constant_bin[ 28550 ], 129, 0 );
    const_str_digest_1bd7405e218c8a579c48801956097e27 = UNSTREAM_STRING( &constant_bin[ 28679 ], 94, 0 );
    const_str_plain_SSL_read = UNSTREAM_STRING( &constant_bin[ 28773 ], 8, 1 );
    const_str_plain_SSL_free = UNSTREAM_STRING( &constant_bin[ 28781 ], 8, 1 );
    const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple, 1, const_str_plain_certfile ); Py_INCREF( const_str_plain_certfile );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_723fb164f3e133051d00542dd747fe2d = UNSTREAM_STRING( &constant_bin[ 28789 ], 140, 0 );
    const_str_plain_set_app_data = UNSTREAM_STRING( &constant_bin[ 8496 ], 12, 1 );
    const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_file_path = UNSTREAM_STRING( &constant_bin[ 28929 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 1, const_str_plain_file_path ); Py_INCREF( const_str_plain_file_path );
    PyTuple_SET_ITEM( const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 2, const_str_plain_dir_path ); Py_INCREF( const_str_plain_dir_path );
    PyTuple_SET_ITEM( const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 3, const_str_plain_capath ); Py_INCREF( const_str_plain_capath );
    PyTuple_SET_ITEM( const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 4, const_str_plain_cafile ); Py_INCREF( const_str_plain_cafile );
    const_str_plain_SSL_SESS_CACHE_SERVER = UNSTREAM_STRING( &constant_bin[ 28938 ], 21, 1 );
    const_str_plain_SSL_OP_NETSCAPE_CA_DN_BUG = UNSTREAM_STRING( &constant_bin[ 28959 ], 25, 1 );
    const_tuple_cf035770f08c8746b05138973d8b64b8_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 1, const_str_plain_protos ); Py_INCREF( const_str_plain_protos );
    PyTuple_SET_ITEM( const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 2, const_str_plain_protostr ); Py_INCREF( const_str_plain_protostr );
    const_str_plain_input_str = UNSTREAM_STRING( &constant_bin[ 28984 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 3, const_str_plain_input_str ); Py_INCREF( const_str_plain_input_str );
    const_tuple_str_plain_self_str_plain_addr_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_addr_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_addr_tuple, 1, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    const_str_plain_SSL_want_write = UNSTREAM_STRING( &constant_bin[ 28993 ], 14, 1 );
    const_str_digest_2eac950a8b26412274fa98ea596054c5 = UNSTREAM_STRING( &constant_bin[ 29007 ], 425, 0 );
    const_str_digest_1f723e76cd26cf3162ae94f693472dd5 = UNSTREAM_STRING( &constant_bin[ 29432 ], 157, 0 );
    const_str_digest_d71143a9aaaa613b59e0c4c3015a7c4a = UNSTREAM_STRING( &constant_bin[ 29589 ], 104, 0 );
    const_str_plain_client = UNSTREAM_STRING( &constant_bin[ 688 ], 6, 1 );
    const_dict_4a96d2f6310f0842d222254905a83466 = _PyDict_NewPresized( 2 );
    PyDict_SetItem( const_dict_4a96d2f6310f0842d222254905a83466, const_str_plain_more_args, Py_True );
    PyDict_SetItem( const_dict_4a96d2f6310f0842d222254905a83466, const_str_plain_truncate, Py_True );
    assert( PyDict_Size( const_dict_4a96d2f6310f0842d222254905a83466 ) == 2 );
    const_str_plain__into_ssl = UNSTREAM_STRING( &constant_bin[ 29693 ], 9, 1 );
    const_str_digest_c5585513b25f5127855be671a08a1332 = UNSTREAM_STRING( &constant_bin[ 29702 ], 217, 0 );
    const_str_plain_SSL_SESS_CACHE_NO_AUTO_CLEAR = UNSTREAM_STRING( &constant_bin[ 29919 ], 28, 1 );
    const_str_digest_5ecd8d00ee49c82aecc9b4312a6eab51 = UNSTREAM_STRING( &constant_bin[ 29947 ], 213, 0 );
    const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 1, const_str_plain_client ); Py_INCREF( const_str_plain_client );
    PyTuple_SET_ITEM( const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 2, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    PyTuple_SET_ITEM( const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 3, const_str_plain_conn ); Py_INCREF( const_str_plain_conn );
    const_str_plain_load_tmp_dh = UNSTREAM_STRING( &constant_bin[ 30160 ], 11, 1 );
    const_str_digest_0bdfe95b50c341a06f9727afb1a762dc = UNSTREAM_STRING( &constant_bin[ 30171 ], 158, 0 );
    const_str_plain__context = UNSTREAM_STRING( &constant_bin[ 76 ], 8, 1 );
    const_tuple_str_plain_self_str_plain_context_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_context_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_context_tuple, 1, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    const_str_digest_7f19e81c824604e95ebb1f01b7f5d7a1 = UNSTREAM_STRING( &constant_bin[ 30329 ], 729, 0 );
    const_str_digest_746ae0014bb266cffee8b7b1473626af = UNSTREAM_STRING( &constant_bin[ 13177 ], 14, 0 );
    const_str_plain_SSL_shutdown = UNSTREAM_STRING( &constant_bin[ 31058 ], 12, 1 );
    const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 1, const_str_plain_keyfile ); Py_INCREF( const_str_plain_keyfile );
    PyTuple_SET_ITEM( const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 2, const_str_plain_filetype ); Py_INCREF( const_str_plain_filetype );
    PyTuple_SET_ITEM( const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 3, const_str_plain_use_result ); Py_INCREF( const_str_plain_use_result );
    const_str_plain_SSL_get_peer_cert_chain = UNSTREAM_STRING( &constant_bin[ 31070 ], 23, 1 );
    const_str_plain__session = UNSTREAM_STRING( &constant_bin[ 2272 ], 8, 1 );
    const_str_digest_ce6e46c47189c65d4c33b9ca8d5ba2ad = UNSTREAM_STRING( &constant_bin[ 31093 ], 129, 0 );
    const_str_plain__OCSPServerCallbackHelper = UNSTREAM_STRING( &constant_bin[ 31222 ], 25, 1 );
    const_str_plain_SSL_new = UNSTREAM_STRING( &constant_bin[ 31247 ], 7, 1 );
    const_str_plain_OP_SINGLE_DH_USE = UNSTREAM_STRING( &constant_bin[ 18414 ], 16, 1 );
    const_str_digest_ad463a4d3fa3baff68f13aea2d205572 = UNSTREAM_STRING( &constant_bin[ 31254 ], 129, 0 );
    const_str_plain_SSL_ERROR_ZERO_RETURN = UNSTREAM_STRING( &constant_bin[ 31383 ], 21, 1 );
    const_str_plain__passphrase_userdata = UNSTREAM_STRING( &constant_bin[ 31404 ], 20, 1 );
    const_str_plain_SSL_OP_NO_SSLv3 = UNSTREAM_STRING( &constant_bin[ 31424 ], 15, 1 );
    const_str_plain_OP_MICROSOFT_SESS_ID_BUG = UNSTREAM_STRING( &constant_bin[ 5355 ], 24, 1 );
    const_str_plain_SSL_SESSION_free = UNSTREAM_STRING( &constant_bin[ 31439 ], 16, 1 );
    const_str_digest_6d088f969ab84bf3d60ab75faa431e51 = UNSTREAM_STRING( &constant_bin[ 31455 ], 132, 0 );
    const_str_plain_SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = UNSTREAM_STRING( &constant_bin[ 31587 ], 34, 1 );
    const_str_plain_set_mode = UNSTREAM_STRING( &constant_bin[ 2754 ], 8, 1 );
    const_list_str_digest_746ae0014bb266cffee8b7b1473626af_list = PyList_New( 1 );
    PyList_SET_ITEM( const_list_str_digest_746ae0014bb266cffee8b7b1473626af_list, 0, const_str_digest_746ae0014bb266cffee8b7b1473626af ); Py_INCREF( const_str_digest_746ae0014bb266cffee8b7b1473626af );
    const_str_plain_set_tlsext_servername_callback = UNSTREAM_STRING( &constant_bin[ 28474 ], 30, 1 );
    const_str_plain_SSL_TLSEXT_ERR_ALERT_FATAL = UNSTREAM_STRING( &constant_bin[ 31621 ], 26, 1 );
    const_str_plain_SSL_OP_NO_TLSv1 = UNSTREAM_STRING( &constant_bin[ 5570 ], 15, 1 );
    const_str_plain_SSL_OP_MSIE_SSLV2_RSA_PADDING = UNSTREAM_STRING( &constant_bin[ 31647 ], 29, 1 );
    const_str_plain_check_privatekey = UNSTREAM_STRING( &constant_bin[ 31676 ], 16, 1 );
    const_str_plain_SSL_get_shutdown = UNSTREAM_STRING( &constant_bin[ 31692 ], 16, 1 );
    const_str_plain_context_buf = UNSTREAM_STRING( &constant_bin[ 31708 ], 11, 1 );
    const_str_digest_b55bbb0df6959d47693f7145ead6828a = UNSTREAM_STRING( &constant_bin[ 31719 ], 250, 0 );
    const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_bufsiz = UNSTREAM_STRING( &constant_bin[ 15707 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 1, const_str_plain_bufsiz ); Py_INCREF( const_str_plain_bufsiz );
    PyTuple_SET_ITEM( const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 2, const_str_plain_flags ); Py_INCREF( const_str_plain_flags );
    PyTuple_SET_ITEM( const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 3, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 4, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_3b38b9684d0a691f727a5c25b49127cb = UNSTREAM_STRING( &constant_bin[ 31969 ], 36, 0 );
    const_str_plain_request_ocsp = UNSTREAM_STRING( &constant_bin[ 32005 ], 12, 1 );
    const_str_digest_3c214455d63d6846892932f043ae8dab = UNSTREAM_STRING( &constant_bin[ 32017 ], 362, 0 );
    const_str_plain_OP_TLS_D5_BUG = UNSTREAM_STRING( &constant_bin[ 25520 ], 13, 1 );
    const_str_plain_SESS_CACHE_SERVER = UNSTREAM_STRING( &constant_bin[ 25986 ], 17, 1 );
    const_str_digest_df17ae6c88635e3960d7bf94f5e880a4 = UNSTREAM_STRING( &constant_bin[ 32379 ], 342, 0 );
    const_str_plain_SSL_want_read = UNSTREAM_STRING( &constant_bin[ 32721 ], 13, 1 );
    const_str_plain_SSL_CTX_set_default_passwd_cb = UNSTREAM_STRING( &constant_bin[ 32734 ], 29, 1 );
    const_str_plain_SSL_CTX_set_info_callback = UNSTREAM_STRING( &constant_bin[ 32763 ], 25, 1 );
    const_str_plain_OP_TLS_BLOCK_PADDING_BUG = UNSTREAM_STRING( &constant_bin[ 22509 ], 24, 1 );
    const_str_plain_SSL_get_error = UNSTREAM_STRING( &constant_bin[ 32788 ], 13, 1 );
    const_str_plain_SSL_CB_WRITE = UNSTREAM_STRING( &constant_bin[ 26252 ], 12, 1 );
    const_str_plain_get_timeout = UNSTREAM_STRING( &constant_bin[ 1604 ], 11, 1 );
    const_str_digest_f68d1733f2e29d0ad83b903b8f287e14 = UNSTREAM_STRING( &constant_bin[ 32801 ], 441, 0 );
    const_tuple_e7183725d38a187a36c7befeae938036_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_e7183725d38a187a36c7befeae938036_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_e7183725d38a187a36c7befeae938036_tuple, 1, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_e7183725d38a187a36c7befeae938036_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_e7183725d38a187a36c7befeae938036_tuple, 3, const_str_plain_errno ); Py_INCREF( const_str_plain_errno );
    PyTuple_SET_ITEM( const_tuple_e7183725d38a187a36c7befeae938036_tuple, 4, const_str_plain_error ); Py_INCREF( const_str_plain_error );
    const_str_digest_685ba6a7380a18939915178358979194 = UNSTREAM_STRING( &constant_bin[ 33242 ], 16, 0 );
    const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple, 0, const_str_digest_c561652c58984ec0e9541542aa405594 ); Py_INCREF( const_str_digest_c561652c58984ec0e9541542aa405594 );
    PyTuple_SET_ITEM( const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple, 1, const_int_0 ); Py_INCREF( const_int_0 );
    const_str_plain_use_context = UNSTREAM_STRING( &constant_bin[ 33258 ], 11, 1 );
    const_str_digest_68d768407778bc3b4c8ffc953440b717 = UNSTREAM_STRING( &constant_bin[ 33269 ], 293, 0 );
    const_str_digest_971aa32305ac0845a4048d72c4cd63c5 = UNSTREAM_STRING( &constant_bin[ 33562 ], 52, 0 );
    const_str_digest_fe9d923dffe7ca07e210d76d45bba668 = UNSTREAM_STRING( &constant_bin[ 33614 ], 170, 0 );
    const_str_digest_71f502d97e845c89ec13eb6ef271f294 = UNSTREAM_STRING( &constant_bin[ 33784 ], 23, 0 );
    const_str_plain_get_cipher_list = UNSTREAM_STRING( &constant_bin[ 33807 ], 15, 1 );
    const_str_digest_770cbd653c9b65a44061ec243e0b5fd3 = UNSTREAM_STRING( &constant_bin[ 33822 ], 97, 0 );
    const_str_plain_SSL_TLSEXT_ERR_NOACK = UNSTREAM_STRING( &constant_bin[ 13670 ], 20, 1 );
    const_str_digest_75d74458faf9dee1d9b7a20a034cfad7 = UNSTREAM_STRING( &constant_bin[ 33919 ], 31, 0 );
    const_str_plain__check_env_vars_set = UNSTREAM_STRING( &constant_bin[ 33950 ], 19, 1 );
    const_str_digest_bd36e8cd21056831af843bc4658cec96 = UNSTREAM_STRING( &constant_bin[ 33969 ], 209, 0 );
    const_str_plain_SSL_CB_READ = UNSTREAM_STRING( &constant_bin[ 26236 ], 11, 1 );
    const_str_plain_SSL_OP_ALL = UNSTREAM_STRING( &constant_bin[ 34178 ], 10, 1 );
    const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple, 1, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple, 2, const_str_plain_use_result ); Py_INCREF( const_str_plain_use_result );
    const_str_plain__ocsp_callback = UNSTREAM_STRING( &constant_bin[ 34188 ], 14, 1 );
    const_str_digest_1f9e090d5f76db9e818dd53fef9b8465 = UNSTREAM_STRING( &constant_bin[ 34202 ], 115, 0 );
    const_str_digest_627e1a07a1a60af86ff9e544428f2f09 = UNSTREAM_STRING( &constant_bin[ 34317 ], 34, 0 );
    const_str_plain_ERR_peek_error = UNSTREAM_STRING( &constant_bin[ 34351 ], 14, 1 );
    const_str_digest_0e87e25b0ab76d44ec1e50f187ee33bd = UNSTREAM_STRING( &constant_bin[ 34365 ], 293, 0 );
    const_str_digest_03a9c0f25246f86801453ac49af67056 = UNSTREAM_STRING( &constant_bin[ 34658 ], 453, 0 );
    const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_LOOKUP = UNSTREAM_STRING( &constant_bin[ 35111 ], 33, 1 );
    const_str_plain_X509_get_default_cert_file_env = UNSTREAM_STRING( &constant_bin[ 35144 ], 30, 1 );
    const_str_digest_a9a754c6f4c1dd488de35af4ae59537f = UNSTREAM_STRING( &constant_bin[ 35174 ], 81, 0 );
    const_str_plain_WantX509LookupError = UNSTREAM_STRING( &constant_bin[ 26525 ], 19, 1 );
    const_str_plain_SSLEAY_VERSION = UNSTREAM_STRING( &constant_bin[ 24859 ], 14, 1 );
    const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple, 0, const_str_plain_flag ); Py_INCREF( const_str_plain_flag );
    PyTuple_SET_ITEM( const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple, 1, const_str_plain_error ); Py_INCREF( const_str_plain_error );
    PyTuple_SET_ITEM( const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple, 2, const_str_plain__requires_decorator ); Py_INCREF( const_str_plain__requires_decorator );
    const_str_plain_get_peer_finished = UNSTREAM_STRING( &constant_bin[ 22188 ], 17, 1 );
    const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 1, const_str_plain_label ); Py_INCREF( const_str_plain_label );
    const_str_plain_olen = UNSTREAM_STRING( &constant_bin[ 3934 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 2, const_str_plain_olen ); Py_INCREF( const_str_plain_olen );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 3, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 4, const_str_plain_outp ); Py_INCREF( const_str_plain_outp );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 5, const_str_plain_use_context ); Py_INCREF( const_str_plain_use_context );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 6, const_str_plain_success ); Py_INCREF( const_str_plain_success );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 7, const_str_plain_context_buf ); Py_INCREF( const_str_plain_context_buf );
    const_str_plain_context_len = UNSTREAM_STRING( &constant_bin[ 35255 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 8, const_str_plain_context_len ); Py_INCREF( const_str_plain_context_len );
    const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 1, const_str_plain_helper ); Py_INCREF( const_str_plain_helper );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 2, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 3, const_str_plain_rc ); Py_INCREF( const_str_plain_rc );
    const_str_plain_want_write = UNSTREAM_STRING( &constant_bin[ 28997 ], 10, 1 );
    const_str_plain_SSL_OP_COOKIE_EXCHANGE = UNSTREAM_STRING( &constant_bin[ 35266 ], 22, 1 );
    const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 1, const_str_plain_outp ); Py_INCREF( const_str_plain_outp );
    PyTuple_SET_ITEM( const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 2, const_str_plain_session ); Py_INCREF( const_str_plain_session );
    PyTuple_SET_ITEM( const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 3, const_str_plain_length ); Py_INCREF( const_str_plain_length );
    const_str_digest_447836721d7454a13033957e012d7688 = UNSTREAM_STRING( &constant_bin[ 35288 ], 247, 0 );
    const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple, 2, const_str_plain_use_result ); Py_INCREF( const_str_plain_use_result );
    const_str_digest_91220ffd97efb14a503e0ecf9d7ff0d1 = UNSTREAM_STRING( &constant_bin[ 35535 ], 205, 0 );
    const_str_digest_94e7111e03f9422114930bb75dfc492c = UNSTREAM_STRING( &constant_bin[ 35740 ], 239, 0 );
    const_str_digest_8d7c284f25a4b19db8bcbef7a9895745 = UNSTREAM_STRING( &constant_bin[ 35979 ], 114, 0 );
    const_str_plain_SSL_get_version = UNSTREAM_STRING( &constant_bin[ 36093 ], 15, 1 );
    const_str_plain_SESS_CACHE_CLIENT = UNSTREAM_STRING( &constant_bin[ 21692 ], 17, 1 );
    const_str_plain_get_client_ca_list = UNSTREAM_STRING( &constant_bin[ 36108 ], 18, 1 );
    const_str_plain_get_cert_store = UNSTREAM_STRING( &constant_bin[ 18310 ], 14, 1 );
    const_tuple_str_plain_self_str_plain_result_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_result_tuple, 1, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_SSL_get_current_cipher = UNSTREAM_STRING( &constant_bin[ 36126 ], 22, 1 );
    const_tuple_str_plain_self_str_plain_buf_str_plain_data_str_plain_result_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_buf_str_plain_data_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_buf_str_plain_data_str_plain_result_tuple, 1, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_buf_str_plain_data_str_plain_result_tuple, 2, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_buf_str_plain_data_str_plain_result_tuple, 3, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_b8ec26ebdab81fb3d5f36275b48d4beb = UNSTREAM_STRING( &constant_bin[ 36148 ], 404, 0 );
    const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple, 1, const_str_plain_cipher_list ); Py_INCREF( const_str_plain_cipher_list );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple, 2, const_str_plain_tmpconn ); Py_INCREF( const_str_plain_tmpconn );
    const_str_plain_SSL_get_ex_data_X509_STORE_CTX_idx = UNSTREAM_STRING( &constant_bin[ 36552 ], 34, 1 );
    const_str_plain__set_ocsp_callback = UNSTREAM_STRING( &constant_bin[ 36586 ], 18, 1 );
    const_str_plain_SSL_set_session = UNSTREAM_STRING( &constant_bin[ 36604 ], 15, 1 );
    const_str_plain_sk_X509_NAME_num = UNSTREAM_STRING( &constant_bin[ 36619 ], 16, 1 );
    const_str_digest_a8ac54b3ed8845d56dee411b1beed5c2 = UNSTREAM_STRING( &constant_bin[ 36635 ], 20, 0 );
    const_str_plain__ocsp_helper = UNSTREAM_STRING( &constant_bin[ 36655 ], 12, 1 );
    const_str_plain_SSL_CTX_set_session_id_context = UNSTREAM_STRING( &constant_bin[ 36667 ], 30, 1 );
    const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple, 1, const_str_plain_dir_env_var ); Py_INCREF( const_str_plain_dir_env_var );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple, 2, const_str_plain_file_env_var ); Py_INCREF( const_str_plain_file_env_var );
    const_str_plain_certificate_authorities = UNSTREAM_STRING( &constant_bin[ 36697 ], 23, 1 );
    const_str_plain_SSL_CTX_free = UNSTREAM_STRING( &constant_bin[ 36720 ], 12, 1 );
    const_str_digest_215c056443df9aa1456b62fe40673d54 = UNSTREAM_STRING( &constant_bin[ 36732 ], 31, 0 );
    const_tuple_fb64e812782e9f70f19909e310070a01_tuple = PyTuple_New( 13 );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 0, const_str_plain_ok ); Py_INCREF( const_str_plain_ok );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 1, const_str_plain_store_ctx ); Py_INCREF( const_str_plain_store_ctx );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 2, const_str_plain_index ); Py_INCREF( const_str_plain_index );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 3, const_str_plain_error_number ); Py_INCREF( const_str_plain_error_number );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 4, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 5, const_str_plain_x509 ); Py_INCREF( const_str_plain_x509 );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 6, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 7, const_str_plain_connection ); Py_INCREF( const_str_plain_connection );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 8, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 9, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 10, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 11, const_str_plain_error_depth ); Py_INCREF( const_str_plain_error_depth );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 12, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    const_str_plain_SSL_OP_TLS_D5_BUG = UNSTREAM_STRING( &constant_bin[ 36763 ], 17, 1 );
    const_str_plain_OP_SSLEAY_080_CLIENT_DH_BUG = UNSTREAM_STRING( &constant_bin[ 11200 ], 27, 1 );
    const_str_plain_SSL_get_finished = UNSTREAM_STRING( &constant_bin[ 22248 ], 16, 1 );
    const_str_plain_SSL_get_cipher_list = UNSTREAM_STRING( &constant_bin[ 36780 ], 19, 1 );
    const_str_plain_SSL_ST_MASK = UNSTREAM_STRING( &constant_bin[ 26188 ], 11, 1 );
    const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 1, const_str_plain_certificate_authorities ); Py_INCREF( const_str_plain_certificate_authorities );
    PyTuple_SET_ITEM( const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 2, const_str_plain_copy ); Py_INCREF( const_str_plain_copy );
    PyTuple_SET_ITEM( const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 3, const_str_plain_name_stack ); Py_INCREF( const_str_plain_name_stack );
    PyTuple_SET_ITEM( const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 4, const_str_plain_ca_name ); Py_INCREF( const_str_plain_ca_name );
    PyTuple_SET_ITEM( const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 5, const_str_plain_push_result ); Py_INCREF( const_str_plain_push_result );
    const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 1, const_str_plain_bufsiz ); Py_INCREF( const_str_plain_bufsiz );
    PyTuple_SET_ITEM( const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 2, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 3, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_159b478f00ae4e4ff337b75b4ff4b73e = UNSTREAM_STRING( &constant_bin[ 36799 ], 174, 0 );
    const_str_digest_7cf2d06a8643ddce5d0ceedd61c750e1 = UNSTREAM_STRING( &constant_bin[ 36973 ], 27, 0 );
    const_str_plain_SSL_SESS_CACHE_BOTH = UNSTREAM_STRING( &constant_bin[ 37000 ], 19, 1 );
    const_str_plain_SSL_CIPHER_get_bits = UNSTREAM_STRING( &constant_bin[ 37019 ], 19, 1 );
    const_str_plain_OP_SSLREF2_REUSE_CERT_TYPE_BUG = UNSTREAM_STRING( &constant_bin[ 25389 ], 30, 1 );
    const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 1, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 2, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 3, const_str_plain_helper ); Py_INCREF( const_str_plain_helper );
    const_str_digest_428eff9fedd3b449496fa307af56b948 = UNSTREAM_STRING( &constant_bin[ 37038 ], 34, 0 );
    const_str_plain_sk_X509_NAME_new_null = UNSTREAM_STRING( &constant_bin[ 37072 ], 21, 1 );
    const_str_plain_SSL_OP_TLS_ROLLBACK_BUG = UNSTREAM_STRING( &constant_bin[ 37093 ], 23, 1 );
    const_str_plain_SESS_CACHE_NO_INTERNAL = UNSTREAM_STRING( &constant_bin[ 13149 ], 22, 1 );
    const_tuple_4b816eca93dfbff03f5cbbe11e88a73f_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_4b816eca93dfbff03f5cbbe11e88a73f_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_4b816eca93dfbff03f5cbbe11e88a73f_tuple, 1, const_str_plain_dhfile ); Py_INCREF( const_str_plain_dhfile );
    PyTuple_SET_ITEM( const_tuple_4b816eca93dfbff03f5cbbe11e88a73f_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_4b816eca93dfbff03f5cbbe11e88a73f_tuple, 3, const_str_plain_dh ); Py_INCREF( const_str_plain_dh );
    PyTuple_SET_ITEM( const_tuple_4b816eca93dfbff03f5cbbe11e88a73f_tuple, 4, const_str_plain_res ); Py_INCREF( const_str_plain_res );
    const_str_digest_e51bcf1ff2d3a73499a1380c77d20ade = UNSTREAM_STRING( &constant_bin[ 37116 ], 32, 0 );
    const_str_plain_SSL_CB_READ_ALERT = UNSTREAM_STRING( &constant_bin[ 26286 ], 17, 1 );
    const_str_plain_set_tlsext_use_srtp = UNSTREAM_STRING( &constant_bin[ 2579 ], 19, 1 );
    const_str_plain_SSL_OP_NO_COMPRESSION = UNSTREAM_STRING( &constant_bin[ 37148 ], 21, 1 );
    const_str_plain_SSL_TLSEXT_ERR_OK = UNSTREAM_STRING( &constant_bin[ 13621 ], 17, 1 );
    const_str_plain_MODE_RELEASE_BUFFERS = UNSTREAM_STRING( &constant_bin[ 12083 ], 20, 1 );
    const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple, 1, const_str_plain_session ); Py_INCREF( const_str_plain_session );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple, 2, const_str_plain_pysession ); Py_INCREF( const_str_plain_pysession );
    const_str_plain__passphrase_helper = UNSTREAM_STRING( &constant_bin[ 37169 ], 18, 1 );
    const_str_plain_SSL_set_tlsext_status_ocsp_resp = UNSTREAM_STRING( &constant_bin[ 37187 ], 31, 1 );
    const_str_digest_a068c39f2c9878239ba2a3b47e83e1e0 = UNSTREAM_STRING( &constant_bin[ 37218 ], 26, 0 );
    const_str_plain_SSL_ST_ACCEPT = UNSTREAM_STRING( &constant_bin[ 26170 ], 13, 1 );
    const_str_plain__passphrase_callback = UNSTREAM_STRING( &constant_bin[ 37244 ], 20, 1 );
    const_str_plain_SSL_export_keying_material = UNSTREAM_STRING( &constant_bin[ 37264 ], 26, 1 );
    const_str_plain_SSL_CTX_set_default_verify_paths = UNSTREAM_STRING( &constant_bin[ 37290 ], 32, 1 );
    const_str_plain_get_state_string = UNSTREAM_STRING( &constant_bin[ 37322 ], 16, 1 );
    const_str_plain_SSL_OP_NO_TICKET = UNSTREAM_STRING( &constant_bin[ 37338 ], 16, 1 );
    const_str_digest_0db98f8a8931566efc9f7dd135830a12 = UNSTREAM_STRING( &constant_bin[ 37354 ], 25, 0 );
    const_str_plain_SSL_OP_PKCS1_CHECK_1 = UNSTREAM_STRING( &constant_bin[ 37379 ], 20, 1 );
    const_str_plain_SSL_OP_PKCS1_CHECK_2 = UNSTREAM_STRING( &constant_bin[ 37399 ], 20, 1 );
    const_str_plain_isfile = UNSTREAM_STRING( &constant_bin[ 37419 ], 6, 1 );
    const_str_plain_get_peer_cert_chain = UNSTREAM_STRING( &constant_bin[ 31074 ], 19, 1 );
    const_str_plain_OP_NETSCAPE_CA_DN_BUG = UNSTREAM_STRING( &constant_bin[ 25700 ], 21, 1 );
    const_str_plain_SSL_CTX_set_tmp_ecdh = UNSTREAM_STRING( &constant_bin[ 37425 ], 20, 1 );
    const_str_plain_SSL_CTX_set_timeout = UNSTREAM_STRING( &constant_bin[ 26945 ], 19, 1 );
    const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 1, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 2, const_str_plain_ciphers ); Py_INCREF( const_str_plain_ciphers );
    PyTuple_SET_ITEM( const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 3, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_8cde8912e8f2207155a1addb0752791f = UNSTREAM_STRING( &constant_bin[ 37445 ], 44, 0 );
    const_str_plain__raise_passphrase_exception = UNSTREAM_STRING( &constant_bin[ 37489 ], 27, 1 );
    const_str_digest_a94ef27b6600318cb26f98532a46ec7d = UNSTREAM_STRING( &constant_bin[ 37516 ], 122, 0 );
    const_str_plain_SSL_CTX_set_verify_depth = UNSTREAM_STRING( &constant_bin[ 37638 ], 24, 1 );
    const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR = UNSTREAM_STRING( &constant_bin[ 37662 ], 31, 1 );
    const_str_plain_TLSv1_2_method = UNSTREAM_STRING( &constant_bin[ 37693 ], 14, 1 );
    const_str_digest_6a85cdfe995e144af7c992d7adff36a9 = UNSTREAM_STRING( &constant_bin[ 37707 ], 289, 0 );
    const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 1, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, const_str_plain_wrapper ); Py_INCREF( const_str_plain_wrapper );
    const_str_digest_b6ee2740f619fbeb4f2040d74693ca57 = UNSTREAM_STRING( &constant_bin[ 37996 ], 194, 0 );
    const_str_digest_c8e9b5ff5b00d8190ecae28b8a410248 = UNSTREAM_STRING( &constant_bin[ 38190 ], 25, 0 );
    const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple, 1, const_str_plain_cipher ); Py_INCREF( const_str_plain_cipher );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple, 2, const_str_plain_version ); Py_INCREF( const_str_plain_version );
    const_str_digest_f6ccda911266ccc3bb4cd038d18beb52 = UNSTREAM_STRING( &constant_bin[ 38215 ], 25, 0 );
    const_str_plain__alpn_select_helper = UNSTREAM_STRING( &constant_bin[ 38240 ], 19, 1 );
    const_tuple_str_plain_self_str_plain_mode_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_mode_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_mode_tuple, 1, const_str_plain_mode ); Py_INCREF( const_str_plain_mode );
    const_str_digest_f7bf61568f9564a7aee5354f80d84343 = UNSTREAM_STRING( &constant_bin[ 38259 ], 351, 0 );
    const_str_plain_SSL_get_client_random = UNSTREAM_STRING( &constant_bin[ 38610 ], 21, 1 );
    const_str_plain_SSL_RECEIVED_SHUTDOWN = UNSTREAM_STRING( &constant_bin[ 38631 ], 21, 1 );
    const_str_digest_3f54294273e4f6390044ae027b11e5ae = UNSTREAM_STRING( &constant_bin[ 38652 ], 150, 0 );
    const_str_plain_SSL_CB_LOOP = UNSTREAM_STRING( &constant_bin[ 26204 ], 11, 1 );
    const_str_plain_BIO_set_mem_eof_return = UNSTREAM_STRING( &constant_bin[ 38802 ], 22, 1 );
    const_str_plain_OP_NO_TICKET = UNSTREAM_STRING( &constant_bin[ 25830 ], 12, 1 );
    const_str_plain_set_tmp_ecdh = UNSTREAM_STRING( &constant_bin[ 37433 ], 12, 1 );
    const_str_digest_91c07271f44b73503e7c77deea91aef1 = UNSTREAM_STRING( &constant_bin[ 38824 ], 139, 0 );
    const_str_plain_SSL_SESSION_get_master_key = UNSTREAM_STRING( &constant_bin[ 38963 ], 26, 1 );
    const_str_plain_OP_MSIE_SSLV2_RSA_PADDING = UNSTREAM_STRING( &constant_bin[ 25458 ], 25, 1 );
    const_str_digest_b965e7ab82e8e0c92ec2736091bc1c12 = UNSTREAM_STRING( &constant_bin[ 38989 ], 30, 0 );
    const_tuple_str_plain_platform_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_platform_tuple, 0, const_str_plain_platform ); Py_INCREF( const_str_plain_platform );
    const_str_plain__CERTIFICATE_FILE_LOCATIONS = UNSTREAM_STRING( &constant_bin[ 39019 ], 27, 1 );
    const_str_plain_set_ocsp_client_callback = UNSTREAM_STRING( &constant_bin[ 8658 ], 24, 1 );
    const_str_digest_f4ac5993e0eb53c16d6349308d51d30e = UNSTREAM_STRING( &constant_bin[ 39046 ], 39, 0 );
    const_str_digest_1ba1651f4266e42e9b568d28fa131281 = UNSTREAM_STRING( &constant_bin[ 39085 ], 207, 0 );
    const_str_digest_bcb5a3a78e430302038d88f5e5d88cc5 = UNSTREAM_STRING( &constant_bin[ 39292 ], 163, 0 );
    const_str_plain__buffer = UNSTREAM_STRING( &constant_bin[ 15643 ], 7, 1 );
    const_str_digest_149b7c0937a6a666f182d0520ebdf631 = UNSTREAM_STRING( &constant_bin[ 39455 ], 242, 0 );
    const_str_digest_eda9ad2d7932cfc1d1f52f27a3ed06a8 = UNSTREAM_STRING( &constant_bin[ 39697 ], 115, 0 );
    const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple, 0, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple, 1, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple, 2, const_str_plain_error ); Py_INCREF( const_str_plain_error );
    const_str_plain_renegotiate = UNSTREAM_STRING( &constant_bin[ 14346 ], 11, 1 );
    const_str_digest_9071118ef0006cb5d28d9100761be8e9 = UNSTREAM_STRING( &constant_bin[ 39812 ], 337, 0 );
    const_str_digest_060a092ce142509580b5fc6c56b149a1 = UNSTREAM_STRING( &constant_bin[ 40149 ], 308, 0 );
    const_str_plain_SSL_do_handshake = UNSTREAM_STRING( &constant_bin[ 40457 ], 16, 1 );
    const_str_plain_SSL_CB_WRITE_ALERT = UNSTREAM_STRING( &constant_bin[ 26308 ], 18, 1 );
    const_str_plain_X509_STORE_CTX_set_error = UNSTREAM_STRING( &constant_bin[ 40473 ], 24, 1 );
    const_str_plain_SSL_CTX_set_session_cache_mode = UNSTREAM_STRING( &constant_bin[ 40497 ], 30, 1 );
    const_str_plain_SSL_set_accept_state = UNSTREAM_STRING( &constant_bin[ 40527 ], 20, 1 );
    const_str_plain_sock_shutdown = UNSTREAM_STRING( &constant_bin[ 40547 ], 13, 1 );
    const_str_plain_BIO_read = UNSTREAM_STRING( &constant_bin[ 40560 ], 8, 1 );
    const_str_digest_592776beca582822ed747da68adba670 = UNSTREAM_STRING( &constant_bin[ 40568 ], 395, 0 );
    const_str_plain_server_random = UNSTREAM_STRING( &constant_bin[ 26731 ], 13, 1 );
    const_str_plain_TLSEXT_STATUSTYPE_ocsp = UNSTREAM_STRING( &constant_bin[ 40963 ], 22, 1 );

    constants_created = true;
}

#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_OpenSSL$SSL( void )
{
    // The module may not have been used at all.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_666efd733c0235abde1396b39c7b9f90;
static PyCodeObject *codeobj_53710dee329bd9462d1d050c80a1709d;
static PyCodeObject *codeobj_44bd407237c2a443c2a210cba0d6c284;
static PyCodeObject *codeobj_88603af527c83dda944c7ddf4d45b354;
static PyCodeObject *codeobj_e4910e1ff9226b6796184f2658fa4bf8;
static PyCodeObject *codeobj_ebb4019f10ac1dbcdaadd42bfd017b9d;
static PyCodeObject *codeobj_e398f1d99b089b4d7b9c44b332686f32;
static PyCodeObject *codeobj_424e405bc16ae3d269c45c550285d49d;
static PyCodeObject *codeobj_4ca3f63ef305b6138693815b24777b10;
static PyCodeObject *codeobj_f8a3170870e2ea9cb12ee1d6ba8dcc7c;
static PyCodeObject *codeobj_9af82c9b2f08b52e9e1a6e31b73ec652;
static PyCodeObject *codeobj_ab00c4dfc87ce556418936a5e1f26e78;
static PyCodeObject *codeobj_dade4f6f27b248c7011ea5b59e49e882;
static PyCodeObject *codeobj_5973516a5de55b67ec5f148e8c29eb73;
static PyCodeObject *codeobj_5791a020e2944607f45102dc7fe5b8e6;
static PyCodeObject *codeobj_ee325f32577779b2b6a08490839df69e;
static PyCodeObject *codeobj_188b168a82dba9bb38a8643a6f371a55;
static PyCodeObject *codeobj_2f089a1360ec6540a7885d667632b8af;
static PyCodeObject *codeobj_0d5bd775cfaaf931ada177403f26906f;
static PyCodeObject *codeobj_d03524879f755099a288faa08445dd35;
static PyCodeObject *codeobj_1f497ea15bbb42e7e15142701e11983e;
static PyCodeObject *codeobj_cc10cda9431f221c058f51f43369d877;
static PyCodeObject *codeobj_bb672ed8d8171604b1f6c1b3ebba963b;
static PyCodeObject *codeobj_f71814b0a3096f278454f1408739a313;
static PyCodeObject *codeobj_08887bdadd93093833a6269bac10532c;
static PyCodeObject *codeobj_9d0f44146929f76ab672b2aef6185af0;
static PyCodeObject *codeobj_367ddb5676f8f9ebb625b6c3a765d683;
static PyCodeObject *codeobj_f70ca376b0b1f16d9dd97a3dbf1ac8bc;
static PyCodeObject *codeobj_09f851592d260b18b7439a190a4cf649;
static PyCodeObject *codeobj_c79a0c40ab56e09c1dbb541ab527a740;
static PyCodeObject *codeobj_76de6ab7acc79e46a01681558ca59a8f;
static PyCodeObject *codeobj_b2acd45430926a957bca22524535bd30;
static PyCodeObject *codeobj_46248d2a1416020447a2f1bda814331e;
static PyCodeObject *codeobj_629eb5b1494882eb95b61538deae4ae8;
static PyCodeObject *codeobj_361c887bcade8cec7b7f7a75e2bc0931;
static PyCodeObject *codeobj_0b065f9eac3a60d85f6dd231c0feb979;
static PyCodeObject *codeobj_8ad19aa17d83645d613ebc651e52854c;
static PyCodeObject *codeobj_f471e6be7d01aa5c66b978c44c21caac;
static PyCodeObject *codeobj_063bd03355e78d04c83a3ed99d0f9b6f;
static PyCodeObject *codeobj_2fffdc517f229be102aa4e0949e42f3d;
static PyCodeObject *codeobj_68cb302ba2f275b9a0b37a8bc2f49774;
static PyCodeObject *codeobj_ce76a9677c8d247ae477dbc6379dbbc2;
static PyCodeObject *codeobj_7ad94f13e041b88ab1ac27807baabbcd;
static PyCodeObject *codeobj_15459965e009ac4caaaa8d3428cb3e67;
static PyCodeObject *codeobj_86508d4dd364cb660af852a87adf893f;
static PyCodeObject *codeobj_601cda9f3a43b06b800b2285b0e8144e;
static PyCodeObject *codeobj_293d554e28a2e0dbefe61787be9b3f54;
static PyCodeObject *codeobj_df8436592d8dd8945dc232488aaff7d5;
static PyCodeObject *codeobj_d494fa4cd1e36945df2bf5baf361dabb;
static PyCodeObject *codeobj_8a41e5553d84f5d5e266ff41226b9c33;
static PyCodeObject *codeobj_f05618381c99bf98f904cc9e5458eb7c;
static PyCodeObject *codeobj_d70f4c3855ac84dfd6756f48541c0461;
static PyCodeObject *codeobj_f5481765c0dd14c9fd2dc2cbccca5828;
static PyCodeObject *codeobj_59e17a52f108ec0be7939e85e90ca5b0;
static PyCodeObject *codeobj_d62fea0d70dd931f7aac134f15bc6f9d;
static PyCodeObject *codeobj_38389ef2c7d34bba1ceac4f4e9271d9b;
static PyCodeObject *codeobj_6f6b8001279fb5a11951fb3d88c5d2e2;
static PyCodeObject *codeobj_40b81d4d05ddb4f44d648a36b01e1399;
static PyCodeObject *codeobj_6287cec24f2f783aa4294293d15dff9f;
static PyCodeObject *codeobj_e9f59a45745b46ca2698acf2ac56b799;
static PyCodeObject *codeobj_87f7d3bd0c797a24b2bca9399e1fbbb9;
static PyCodeObject *codeobj_acba1edf54ec8ed7cadead9caaa107de;
static PyCodeObject *codeobj_9c51e814ae59c208eeea05af7ec1d290;
static PyCodeObject *codeobj_e0473f6709515182770f72050d887758;
static PyCodeObject *codeobj_d240f1f9ab03c9ad1d2cb68a1ae386bd;
static PyCodeObject *codeobj_1c2bbbdc204d748085502a3e6b781c3d;
static PyCodeObject *codeobj_3007ec3d2f42a3dd1be07ca3ae9168a6;
static PyCodeObject *codeobj_20f3644f0565fa197ebe62d163efece0;
static PyCodeObject *codeobj_d9c6f022e88d1a70d6925713b6a4247b;
static PyCodeObject *codeobj_7f96db37ca0e6291733c630c66c75747;
static PyCodeObject *codeobj_c5a33d979afcfefdaf074fd78849d7f9;
static PyCodeObject *codeobj_f269207fdd9aa826c85b87cc35f9c7ef;
static PyCodeObject *codeobj_2174564c9980af7eed2d6441dc38c5e4;
static PyCodeObject *codeobj_1f33a93420eb4e87671bc14ef5fd1e7f;
static PyCodeObject *codeobj_9de539dd2c4fff7fa74b7cb5d14f8608;
static PyCodeObject *codeobj_ef80d1e646870f9f8e6a3599220d1f6c;
static PyCodeObject *codeobj_cefffc968213c61d10c7867e6cb8570d;
static PyCodeObject *codeobj_644e8a19fb20958d76ff8d32a6edd3e6;
static PyCodeObject *codeobj_959585d8d371bbde9fdf5141fa04539f;
static PyCodeObject *codeobj_09184f4a96c99cec7a5d574311293fc2;
static PyCodeObject *codeobj_787b8e6bfd81d6bd4f675c83610bc416;
static PyCodeObject *codeobj_b36eb1a77f0339db15b9fbd63165b3ab;
static PyCodeObject *codeobj_8fa949167a3f0e0a7575ae806dd11e0c;
static PyCodeObject *codeobj_8aa9ecd9db1af193441ce35c222c7d1a;
static PyCodeObject *codeobj_b67de0094492dbb326b6f334ee86c858;
static PyCodeObject *codeobj_56c0d108e11d4f9beec70956f75d378a;
static PyCodeObject *codeobj_bb8872b94b0002e97eef74e34fbffbe1;
static PyCodeObject *codeobj_e56f5f73584ddfdf176a449c1f1d406c;
static PyCodeObject *codeobj_8d1ca164c82af98e35dc9aa41d641480;
static PyCodeObject *codeobj_6e69ef82635c437b7d2bbe57e645669d;
static PyCodeObject *codeobj_645fa587f009c4b0f21236cdaad0381f;
static PyCodeObject *codeobj_b4423fe8f1ca9b3a46b290e554de7290;
static PyCodeObject *codeobj_3ea94e74b8591248d24548abaaf564ff;
static PyCodeObject *codeobj_eb66fada38d507b21a902b1d1c274f94;
static PyCodeObject *codeobj_dca08831ab266ef2e54f8c8c25db7b17;
static PyCodeObject *codeobj_c383504c16885b5865730f200cd9d1f8;
static PyCodeObject *codeobj_42a5b4bb6bb2aefba79bf25001da3d90;
static PyCodeObject *codeobj_55a7db7b2da21870b1f168c22ed4f7b4;
static PyCodeObject *codeobj_3b53e64ae4d15799dfacfe9ba165e79a;
static PyCodeObject *codeobj_0061a6af4bcd40a38fc7710d502b3b9f;
static PyCodeObject *codeobj_dd4d76a4e8e6e30fb69eee67febb6ab6;
static PyCodeObject *codeobj_f5c821c2b0df1d06e32083d799bd68d5;
static PyCodeObject *codeobj_acda319b97db4bd0371702c365a552ee;
static PyCodeObject *codeobj_cadc07cf67a4e323687eed3a5255dfa8;
static PyCodeObject *codeobj_49b91f95fc6102a2bc1d95d7f9f8434b;
static PyCodeObject *codeobj_94c0d4b8cf686c2e34361e7cd48a3052;
static PyCodeObject *codeobj_68f89f8855b7fe9638b09d04b6d22f83;
static PyCodeObject *codeobj_087da86096a9eb38f52586f217604859;
static PyCodeObject *codeobj_6fece6983817e1fc2ad98a3d7d149aca;
static PyCodeObject *codeobj_8cf45d680dfdb9a914214d7fecc3e983;
static PyCodeObject *codeobj_970d54497ed5d25db8bd7deb24b2b711;
static PyCodeObject *codeobj_9351f991ba8e7d4c0845d79aab6ff700;
static PyCodeObject *codeobj_8020a8b1dd8cc3669fc7bd37ad12a2b9;
static PyCodeObject *codeobj_b23113cd07b644554a3131a5d950cae1;
static PyCodeObject *codeobj_a3496fb28d148bcd6c9a9c8044088e8a;
static PyCodeObject *codeobj_a8c1083e5a0e9d5d314d2ea77db9921f;
static PyCodeObject *codeobj_f14fc0f5a6135692e4f8d5cbdafa1fc5;
static PyCodeObject *codeobj_4de9fae261022cc2df5d1800c2c051e5;
static PyCodeObject *codeobj_d14e5f7a612d4badaf324988c48b88af;
static PyCodeObject *codeobj_66106d74879c849f5649f3f764b1f958;
static PyCodeObject *codeobj_e08bdb6ef7d176edd569f0ebe97e06fe;
static PyCodeObject *codeobj_45214eee286f8b09ba13e2d070abb952;
static PyCodeObject *codeobj_0ad17b909e53698f39728a57b64a8076;
static PyCodeObject *codeobj_43b1c0b0ce1eda30c8482da409dfed18;
static PyCodeObject *codeobj_ea8cd308a788cb7a890b205884b79311;
static PyCodeObject *codeobj_027a1d4675ab6e708189c79b6a91a682;
static PyCodeObject *codeobj_33618a1a0baec9d4158ab8b5d67b55bb;
static PyCodeObject *codeobj_d01eafbb0e285abd4a6f7d94f9e77264;

static void createModuleCodeObjects(void)
{
    module_filename_obj = MAKE_RELATIVE_PATH( const_str_digest_d3a1e78595a066a43885e44a343877f5 );
    codeobj_666efd733c0235abde1396b39c7b9f90 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 620, const_tuple_b5f59418c193d572a22cf854b821fa76_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_53710dee329bd9462d1d050c80a1709d = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 1373, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_44bd407237c2a443c2a210cba0d6c284 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 2391, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_88603af527c83dda944c7ddf4d45b354 = MAKE_CODEOBJ( module_filename_obj, const_str_digest_a8ac54b3ed8845d56dee411b1beed5c2, 1, const_tuple_empty, 0, CO_NOFREE );
    codeobj_e4910e1ff9226b6796184f2658fa4bf8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_Connection, 1461, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_ebb4019f10ac1dbcdaadd42bfd017b9d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_Context, 602, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_e398f1d99b089b4d7b9c44b332686f32 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_SSLeay_version, 546, const_tuple_str_plain_type_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_424e405bc16ae3d269c45c550285d49d = MAKE_CODEOBJ( module_filename_obj, const_str_plain___getattr__, 1518, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4ca3f63ef305b6138693815b24777b10 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 280, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f8a3170870e2ea9cb12ee1d6ba8dcc7c = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 302, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9af82c9b2f08b52e9e1a6e31b73ec652 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 344, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ab00c4dfc87ce556418936a5e1f26e78 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 422, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dade4f6f27b248c7011ea5b59e49e882 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 489, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5973516a5de55b67ec5f148e8c29eb73 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 625, const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5791a020e2944607f45102dc7fe5b8e6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1464, const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ee325f32577779b2b6a08490839df69e = MAKE_CODEOBJ( module_filename_obj, const_str_plain__asFileDescriptor, 526, const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_188b168a82dba9bb38a8643a6f371a55 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__cert_stack_to_list, 2130, const_tuple_a992a212ff6e075874fbd47e83bc62d2_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2f089a1360ec6540a7885d667632b8af = MAKE_CODEOBJ( module_filename_obj, const_str_plain__check_env_vars_set, 783, const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0d5bd775cfaaf931ada177403f26906f = MAKE_CODEOBJ( module_filename_obj, const_str_plain__fallback_default_verify_paths, 794, const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d03524879f755099a288faa08445dd35 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_finished_message, 2246, const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1f497ea15bbb42e7e15142701e11983e = MAKE_CODEOBJ( module_filename_obj, const_str_plain__handle_bio_errors, 1744, const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cc10cda9431f221c058f51f43369d877 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__make_requires, 555, const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bb672ed8d8171604b1f6c1b3ebba963b = MAKE_CODEOBJ( module_filename_obj, const_str_plain__raise_passphrase_exception, 884, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f71814b0a3096f278454f1408739a313 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__raise_ssl_error, 1531, const_tuple_e7183725d38a187a36c7befeae938036_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_08887bdadd93093833a6269bac10532c = MAKE_CODEOBJ( module_filename_obj, const_str_plain__requires_decorator, 566, const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_9d0f44146929f76ab672b2aef6185af0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__set_ocsp_callback, 1402, const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_367ddb5676f8f9ebb625b6c3a765d683 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__wrap_callback, 697, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f70ca376b0b1f16d9dd97a3dbf1ac8bc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_accept, 1875, const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_09f851592d260b18b7439a190a4cf649 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_client_ca, 1170, const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c79a0c40ab56e09c1dbb541ab527a740 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_extra_chain_cert, 867, const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_76de6ab7acc79e46a01681558ca59a8f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_bio_read, 1762, const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b2acd45430926a957bca22524535bd30 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_bio_shutdown, 1890, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_46248d2a1416020447a2f1bda814331e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_bio_write, 1786, const_tuple_str_plain_self_str_plain_buf_str_plain_data_str_plain_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_629eb5b1494882eb95b61538deae4ae8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_check_privatekey, 928, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_361c887bcade8cec7b7f7a75e2bc0931 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_client_random, 2036, const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0b065f9eac3a60d85f6dd231c0feb979 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_connect, 1849, const_tuple_str_plain_self_str_plain_addr_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8ad19aa17d83645d613ebc651e52854c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_connect_ex, 1861, const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f471e6be7d01aa5c66b978c44c21caac = MAKE_CODEOBJ( module_filename_obj, const_str_plain_do_handshake, 1819, const_tuple_str_plain_self_str_plain_result_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_063bd03355e78d04c83a3ed99d0f9b6f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_explode, 569, const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS );
    codeobj_2fffdc517f229be102aa4e0949e42f3d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_export_keying_material, 2068, const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_68cb302ba2f275b9a0b37a8bc2f49774 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_alpn_proto_negotiated, 2399, const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ce76a9677c8d247ae477dbc6379dbbc2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_app_data, 1261, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7ad94f13e041b88ab1ac27807baabbcd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_app_data, 1974, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_15459965e009ac4caaaa8d3428cb3e67 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_cert_store, 1278, const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_86508d4dd364cb660af852a87adf893f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_certificate, 2107, const_tuple_str_plain_self_str_plain_cert_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_601cda9f3a43b06b800b2285b0e8144e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_cipher_bits, 2321, const_tuple_str_plain_self_str_plain_cipher_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_293d554e28a2e0dbefe61787be9b3f54 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_cipher_list, 1920, const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_df8436592d8dd8945dc232488aaff7d5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_cipher_name, 2304, const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d494fa4cd1e36945df2bf5baf361dabb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_cipher_version, 2337, const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8a41e5553d84f5d5e266ff41226b9c33 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_client_ca_list, 1934, const_tuple_40c019df00fadc68e051d5153056e038_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f05618381c99bf98f904cc9e5458eb7c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_context, 1568, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d70f4c3855ac84dfd6756f48541c0461 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_finished, 2280, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f5481765c0dd14c9fd2dc2cbccca5828 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_peer_cert_chain, 2146, const_tuple_str_plain_self_str_plain_cert_stack_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_59e17a52f108ec0be7939e85e90ca5b0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_peer_certificate, 2119, const_tuple_str_plain_self_str_plain_cert_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d62fea0d70dd931f7aac134f15bc6f9d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_peer_finished, 2292, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_38389ef2c7d34bba1ceac4f4e9271d9b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_protocol_version, 2366, const_tuple_str_plain_self_str_plain_version_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6f6b8001279fb5a11951fb3d88c5d2e2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_protocol_version_name, 2354, const_tuple_str_plain_self_str_plain_version_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_40b81d4d05ddb4f44d648a36b01e1399 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_servername, 1588, const_tuple_str_plain_self_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6287cec24f2f783aa4294293d15dff9f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_session, 2214, const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e9f59a45745b46ca2698acf2ac56b799 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_session_cache_mode, 987, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_87f7d3bd0c797a24b2bca9399e1fbbb9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_shutdown, 1991, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_acba1edf54ec8ed7cadead9caaa107de = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_state_string, 2012, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9c51e814ae59c208eeea05af7ec1d290 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_timeout, 1205, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e0473f6709515182770f72050d887758 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_verified_chain, 2159, const_tuple_str_plain_self_str_plain_cert_stack_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d240f1f9ab03c9ad1d2cb68a1ae386bd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_verify_depth, 1054, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1c2bbbdc204d748085502a3e6b781c3d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_verify_mode, 1045, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3007ec3d2f42a3dd1be07ca3ae9168a6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_client_ca, 938, const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_20f3644f0565fa197ebe62d163efece0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_tmp_dh, 1063, const_tuple_4b816eca93dfbff03f5cbbe11e88a73f_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d9c6f022e88d1a70d6925713b6a4247b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_verify_locations, 665, const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7f96db37ca0e6291733c630c66c75747 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_makefile, 1963, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_c5a33d979afcfefdaf074fd78849d7f9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_master_key, 2052, const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f269207fdd9aa826c85b87cc35f9c7ef = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pending, 1621, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2174564c9980af7eed2d6441dc38c5e4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_raise_if_problem, 283, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1f33a93420eb4e87671bc14ef5fd1e7f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_recv, 1688, const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9de539dd2c4fff7fa74b7cb5d14f8608 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_recv_into, 1707, const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ef80d1e646870f9f8e6a3599220d1f6c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_renegotiate, 1807, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cefffc968213c61d10c7867e6cb8570d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_renegotiate_pending, 1830, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_644e8a19fb20958d76ff8d32a6edd3e6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_request_ocsp, 2417, const_tuple_str_plain_self_str_plain_rc_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_959585d8d371bbde9fdf5141fa04539f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_send, 1630, const_tuple_35c846c03e9c30b5467b3336c5c65a45_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_09184f4a96c99cec7a5d574311293fc2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sendall, 1658, const_tuple_db9f88d750a1668ba43cf0b62b6c8a91_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_787b8e6bfd81d6bd4f675c83610bc416 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_server_random, 2021, const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b36eb1a77f0339db15b9fbd63165b3ab = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_accept_state, 2196, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8fa949167a3f0e0a7575ae806dd11e0c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_alpn_protos, 1359, const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8aa9ecd9db1af193441ce35c222c7d1a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_alpn_protos, 2377, const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b67de0094492dbb326b6f334ee86c858 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_alpn_select_callback, 1381, const_tuple_str_plain_self_str_plain_callback_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_56c0d108e11d4f9beec70956f75d378a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_app_data, 1269, const_tuple_str_plain_self_str_plain_data_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bb8872b94b0002e97eef74e34fbffbe1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_app_data, 1982, const_tuple_str_plain_self_str_plain_data_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e56f5f73584ddfdf176a449c1f1d406c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_cipher_list, 1096, const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8d1ca164c82af98e35dc9aa41d641480 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_client_ca_list, 1135, const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6e69ef82635c437b7d2bbe57e645669d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_connect_state, 2205, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_645fa587f009c4b0f21236cdaad0381f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_context, 1575, const_tuple_str_plain_self_str_plain_context_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b4423fe8f1ca9b3a46b290e554de7290 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_default_verify_paths, 735, const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3ea94e74b8591248d24548abaaf564ff = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_info_callback, 1214, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_eb66fada38d507b21a902b1d1c274f94 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_keylog_callback, 1236, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dca08831ab266ef2e54f8c8c25db7b17 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_mode, 1308, const_tuple_str_plain_self_str_plain_mode_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c383504c16885b5865730f200cd9d1f8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_ocsp_client_callback, 1440, const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_42a5b4bb6bb2aefba79bf25001da3d90 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_ocsp_server_callback, 1422, const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_55a7db7b2da21870b1f168c22ed4f7b4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_options, 1295, const_tuple_str_plain_self_str_plain_options_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3b53e64ae4d15799dfacfe9ba165e79a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_passwd_cb, 706, const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0061a6af4bcd40a38fc7710d502b3b9f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_session, 2231, const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dd4d76a4e8e6e30fb69eee67febb6ab6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_session_cache_mode, 970, const_tuple_str_plain_self_str_plain_mode_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f5c821c2b0df1d06e32083d799bd68d5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_session_id, 953, const_tuple_str_plain_self_str_plain_buf_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_acda319b97db4bd0371702c365a552ee = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_shutdown, 2000, const_tuple_str_plain_self_str_plain_state_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cadc07cf67a4e323687eed3a5255dfa8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_timeout, 1191, const_tuple_str_plain_self_str_plain_timeout_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_49b91f95fc6102a2bc1d95d7f9f8434b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_tlsext_host_name, 1605, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_94c0d4b8cf686c2e34361e7cd48a3052 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_tlsext_servername_callback, 1321, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_68f89f8855b7fe9638b09d04b6d22f83 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_tlsext_use_srtp, 1344, const_tuple_str_plain_self_str_plain_profiles_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_087da86096a9eb38f52586f217604859 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_tmp_ecdh, 1084, const_tuple_str_plain_self_str_plain_curve_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6fece6983817e1fc2ad98a3d7d149aca = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_verify, 997, const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8cf45d680dfdb9a914214d7fecc3e983 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_verify_depth, 1032, const_tuple_str_plain_self_str_plain_depth_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_970d54497ed5d25db8bd7deb24b2b711 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shutdown, 1903, const_tuple_str_plain_self_str_plain_result_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9351f991ba8e7d4c0845d79aab6ff700 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sock_shutdown, 2098, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_8020a8b1dd8cc3669fc7bd37ad12a2b9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_total_renegotiations, 1840, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b23113cd07b644554a3131a5d950cae1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_use_certificate, 853, const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a3496fb28d148bcd6c9a9c8044088e8a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_use_certificate_chain_file, 814, const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a8c1083e5a0e9d5d314d2ea77db9921f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_use_certificate_file, 831, const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f14fc0f5a6135692e4f8d5cbdafa1fc5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_use_privatekey, 914, const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4de9fae261022cc2df5d1800c2c051e5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_use_privatekey_file, 890, const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d14e5f7a612d4badaf324988c48b88af = MAKE_CODEOBJ( module_filename_obj, const_str_plain_want_read, 2178, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_66106d74879c849f5649f3f764b1f958 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_want_write, 2187, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e08bdb6ef7d176edd569f0ebe97e06fe = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 305, const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_45214eee286f8b09ba13e2d070abb952 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 347, const_tuple_df35527807658c5906d3a25929231255_tuple, 6, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_0ad17b909e53698f39728a57b64a8076 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 425, const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_43b1c0b0ce1eda30c8482da409dfed18 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 492, const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_ea8cd308a788cb7a890b205884b79311 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 698, const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_027a1d4675ab6e708189c79b6a91a682 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 1227, const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_33618a1a0baec9d4158ab8b5d67b55bb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 1251, const_tuple_str_plain_ssl_str_plain_line_str_plain_callback_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_d01eafbb0e285abd4a6f7d94f9e77264 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 1332, const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS );
}

// The module function declarations.
#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *OpenSSL$SSL$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void OpenSSL$SSL$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *OpenSSL$SSL$$$function_49_set_alpn_protos$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void OpenSSL$SSL$$$function_49_set_alpn_protos$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *OpenSSL$SSL$$$function_110_set_alpn_protos$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void OpenSSL$SSL$$$function_110_set_alpn_protos$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_1_complex_call_helper_star_list_star_dict( PyObject **python_pars );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_100_get_session(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_101_set_session(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_102__get_finished_message(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_103_get_finished(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_104_get_peer_finished(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_105_get_cipher_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_106_get_cipher_bits(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_107_get_cipher_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_108_get_protocol_version_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_109_get_protocol_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_10___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_110_set_alpn_protos(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_111_get_alpn_proto_negotiated(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_112_request_ocsp(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11_load_verify_locations( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_12__wrap_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_12__wrap_callback$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback, struct Nuitka_CellObject *closure_self );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_13_set_passwd_cb( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_14_set_default_verify_paths(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_15__check_env_vars_set(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_16__fallback_default_verify_paths(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_17_use_certificate_chain_file(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_18_use_certificate_file( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_19_use_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_1___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_20_add_extra_chain_cert(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_21__raise_passphrase_exception(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_22_use_privatekey_file( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_23_use_privatekey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_24_check_privatekey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_25_load_client_ca(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_26_set_session_id(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_27_set_session_cache_mode(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_28_get_session_cache_mode(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_29_set_verify( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_2_raise_if_problem(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_30_set_verify_depth(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_31_get_verify_mode(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_32_get_verify_depth(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_33_load_tmp_dh(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_34_set_tmp_ecdh(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_35_set_cipher_list(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_36_set_client_ca_list(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_37_add_client_ca(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_38_set_timeout(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_39_get_timeout(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback, struct Nuitka_CellObject *closure_self );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_40_set_info_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_40_set_info_callback$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_41_set_keylog_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_41_set_keylog_callback$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_42_get_app_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_43_set_app_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_44_get_cert_store(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_45_set_options(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_46_set_mode(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_47_set_tlsext_servername_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_47_set_tlsext_servername_callback$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_use_srtp(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_49_set_alpn_protos(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback, struct Nuitka_CellObject *closure_self );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_50_set_alpn_select_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_51__set_ocsp_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_52_set_ocsp_server_callback( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_53_set_ocsp_client_callback( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_54___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_55___getattr__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_56__raise_ssl_error(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_57_get_context(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_58_set_context(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_59_get_servername(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback, struct Nuitka_CellObject *closure_self );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_60_set_tlsext_host_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_61_pending(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_62_send( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_63_sendall( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_64_recv( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_65_recv_into( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_66__handle_bio_errors(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_67_bio_read(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_68_bio_write(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_69_renegotiate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback, struct Nuitka_CellObject *closure_self );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_70_do_handshake(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_71_renegotiate_pending(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_72_total_renegotiations(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_73_connect(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_74_connect_ex(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_75_accept(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_76_bio_shutdown(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_77_shutdown(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_78_get_cipher_list(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_79_get_client_ca_list(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_7__asFileDescriptor(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_80_makefile(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_81_get_app_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_82_set_app_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_83_get_shutdown(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_84_set_shutdown(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_85_get_state_string(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_86_server_random(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_87_client_random(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_88_master_key(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_89_export_keying_material( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_8_SSLeay_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_90_sock_shutdown(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_91_get_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_92_get_peer_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_93__cert_stack_to_list(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_94_get_peer_cert_chain(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_95_get_verified_chain(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_96_want_read(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_97_want_write(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_98_set_accept_state(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_99_set_connect_state(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_9__make_requires(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator( struct Nuitka_CellObject *closure_error, struct Nuitka_CellObject *closure_flag );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator$$$function_1_explode( struct Nuitka_CellObject *closure_error );


// The module function definitions.
static PyObject *impl_OpenSSL$SSL$$$function_1___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_4ca3f63ef305b6138693815b24777b10 = NULL;

    struct Nuitka_FrameObject *frame_4ca3f63ef305b6138693815b24777b10;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4ca3f63ef305b6138693815b24777b10, codeobj_4ca3f63ef305b6138693815b24777b10, module_OpenSSL$SSL, sizeof(void *) );
    frame_4ca3f63ef305b6138693815b24777b10 = cache_frame_4ca3f63ef305b6138693815b24777b10;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4ca3f63ef305b6138693815b24777b10 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4ca3f63ef305b6138693815b24777b10 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = PyList_New( 0 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__problems, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 281;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4ca3f63ef305b6138693815b24777b10 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4ca3f63ef305b6138693815b24777b10 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4ca3f63ef305b6138693815b24777b10, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4ca3f63ef305b6138693815b24777b10->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4ca3f63ef305b6138693815b24777b10, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4ca3f63ef305b6138693815b24777b10,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_4ca3f63ef305b6138693815b24777b10 == cache_frame_4ca3f63ef305b6138693815b24777b10 )
    {
        Py_DECREF( frame_4ca3f63ef305b6138693815b24777b10 );
    }
    cache_frame_4ca3f63ef305b6138693815b24777b10 = NULL;

    assertFrameObject( frame_4ca3f63ef305b6138693815b24777b10 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_1___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_1___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_2_raise_if_problem( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_2174564c9980af7eed2d6441dc38c5e4 = NULL;

    struct Nuitka_FrameObject *frame_2174564c9980af7eed2d6441dc38c5e4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2174564c9980af7eed2d6441dc38c5e4, codeobj_2174564c9980af7eed2d6441dc38c5e4, module_OpenSSL$SSL, sizeof(void *) );
    frame_2174564c9980af7eed2d6441dc38c5e4 = cache_frame_2174564c9980af7eed2d6441dc38c5e4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2174564c9980af7eed2d6441dc38c5e4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2174564c9980af7eed2d6441dc38c5e4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__problems );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 288;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 288;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    // Tried code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 290;
        type_description_1 = "o";
        goto try_except_handler_2;
    }

    frame_2174564c9980af7eed2d6441dc38c5e4->m_frame.f_lineno = 290;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 290;
        type_description_1 = "o";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_2174564c9980af7eed2d6441dc38c5e4 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_2174564c9980af7eed2d6441dc38c5e4, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_2174564c9980af7eed2d6441dc38c5e4, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 291;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 291;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 289;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_2174564c9980af7eed2d6441dc38c5e4->m_frame) frame_2174564c9980af7eed2d6441dc38c5e4->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "o";
    goto frame_exception_exit_1;
    branch_no_2:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_2_raise_if_problem );
    return NULL;
    // End of try:
    try_end_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__problems );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_2174564c9980af7eed2d6441dc38c5e4->m_frame.f_lineno = 293;
    tmp_raise_type_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_pop, &PyTuple_GET_ITEM( const_tuple_int_0_tuple, 0 ) );

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_raise_type_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_1;
    exception_lineno = 293;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "o";
    goto frame_exception_exit_1;
    branch_no_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_2174564c9980af7eed2d6441dc38c5e4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_2174564c9980af7eed2d6441dc38c5e4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2174564c9980af7eed2d6441dc38c5e4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2174564c9980af7eed2d6441dc38c5e4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2174564c9980af7eed2d6441dc38c5e4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2174564c9980af7eed2d6441dc38c5e4,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_2174564c9980af7eed2d6441dc38c5e4 == cache_frame_2174564c9980af7eed2d6441dc38c5e4 )
    {
        Py_DECREF( frame_2174564c9980af7eed2d6441dc38c5e4 );
    }
    cache_frame_2174564c9980af7eed2d6441dc38c5e4 = NULL;

    assertFrameObject( frame_2174564c9980af7eed2d6441dc38c5e4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_2_raise_if_problem );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_2_raise_if_problem );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_3___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    bool tmp_result;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c = NULL;

    struct Nuitka_FrameObject *frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c, codeobj_f8a3170870e2ea9cb12ee1d6ba8dcc7c, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c = cache_frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CallbackExceptionHelper" );
        exception_tb = NULL;

        exception_lineno = 303;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    if ( par_self == NULL )
    {
        tmp_args_element_name_1 = NULL;
    }
    else
    {
        tmp_args_element_name_1 = PyCell_GET( par_self );
    }

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c->m_frame.f_lineno = 303;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 303;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
        exception_tb = NULL;

        exception_lineno = 305;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    if ( par_callback == NULL )
    {
        tmp_args_element_name_2 = NULL;
    }
    else
    {
        tmp_args_element_name_2 = PyCell_GET( par_callback );
    }

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c->m_frame.f_lineno = 305;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 305;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper( par_callback, par_self );
    frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c->m_frame.f_lineno = 305;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 305;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    assert( var_wrapper == NULL );
    var_wrapper = tmp_assign_source_1;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 331;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_str_digest_aa8d23211c54bc521e23e53a6e431cd2;
    tmp_args_element_name_5 = var_wrapper;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c->m_frame.f_lineno = 331;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_callback, call_args );
    }

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 331;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    if ( par_self == NULL )
    {
        tmp_assattr_target_1 = NULL;
    }
    else
    {
        tmp_assattr_target_1 = PyCell_GET( par_self );
    }

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 331;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c == cache_frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c )
    {
        Py_DECREF( frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c );
    }
    cache_frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c = NULL;

    assertFrameObject( frame_f8a3170870e2ea9cb12ee1d6ba8dcc7c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_3___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_3___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ok = python_pars[ 0 ];
    PyObject *par_store_ctx = python_pars[ 1 ];
    PyObject *var_index = NULL;
    PyObject *var_error_number = NULL;
    PyObject *var_x509 = NULL;
    PyObject *var_connection = NULL;
    PyObject *var_ssl = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_result = NULL;
    PyObject *var_error_depth = NULL;
    PyObject *var_e = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_e08bdb6ef7d176edd569f0ebe97e06fe = NULL;

    struct Nuitka_FrameObject *frame_e08bdb6ef7d176edd569f0ebe97e06fe;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e08bdb6ef7d176edd569f0ebe97e06fe, codeobj_e08bdb6ef7d176edd569f0ebe97e06fe, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e08bdb6ef7d176edd569f0ebe97e06fe = cache_frame_e08bdb6ef7d176edd569f0ebe97e06fe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e08bdb6ef7d176edd569f0ebe97e06fe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e08bdb6ef7d176edd569f0ebe97e06fe ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 307;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_store_ctx;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_e08bdb6ef7d176edd569f0ebe97e06fe->m_frame.f_lineno = 307;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_STORE_CTX_get_current_cert, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 307;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }
    assert( var_x509 == NULL );
    var_x509 = tmp_assign_source_1;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 308;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_x509;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_e08bdb6ef7d176edd569f0ebe97e06fe->m_frame.f_lineno = 308;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_X509_up_ref, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 308;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 309;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_x509;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_e08bdb6ef7d176edd569f0ebe97e06fe->m_frame.f_lineno = 309;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain__from_raw_x509_ptr, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 309;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }
    assert( var_cert == NULL );
    var_cert = tmp_assign_source_2;

    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 310;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = par_store_ctx;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_e08bdb6ef7d176edd569f0ebe97e06fe->m_frame.f_lineno = 310;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_X509_STORE_CTX_get_error, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 310;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }
    assert( var_error_number == NULL );
    var_error_number = tmp_assign_source_3;

    tmp_called_instance_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_5 == NULL ))
    {
        tmp_called_instance_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 311;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = par_store_ctx;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_e08bdb6ef7d176edd569f0ebe97e06fe->m_frame.f_lineno = 311;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_X509_STORE_CTX_get_error_depth, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 311;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }
    assert( var_error_depth == NULL );
    var_error_depth = tmp_assign_source_4;

    tmp_called_instance_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_6 == NULL ))
    {
        tmp_called_instance_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 313;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }

    frame_e08bdb6ef7d176edd569f0ebe97e06fe->m_frame.f_lineno = 313;
    tmp_assign_source_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_SSL_get_ex_data_X509_STORE_CTX_idx );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 313;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }
    assert( var_index == NULL );
    var_index = tmp_assign_source_5;

    tmp_called_instance_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_7 == NULL ))
    {
        tmp_called_instance_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 314;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = par_store_ctx;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = var_index;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_e08bdb6ef7d176edd569f0ebe97e06fe->m_frame.f_lineno = 314;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_7, const_str_plain_X509_STORE_CTX_get_ex_data, call_args );
    }

    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 314;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }
    assert( var_ssl == NULL );
    var_ssl = tmp_assign_source_6;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
        exception_tb = NULL;

        exception_lineno = 315;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 315;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = var_ssl;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_assign_source_7 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 315;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
    }
    assert( var_connection == NULL );
    var_connection = tmp_assign_source_7;

    // Tried code:
    // Tried code:
    if ( self->m_closure[0] == NULL )
    {
        tmp_called_name_1 = NULL;
    }
    else
    {
        tmp_called_name_1 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
        exception_tb = NULL;

        exception_lineno = 318;
        type_description_1 = "oooococoooooo";
        goto try_except_handler_3;
    }

    tmp_args_element_name_8 = var_connection;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_args_element_name_9 = var_cert;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_args_element_name_10 = var_error_number;

    CHECK_OBJECT( tmp_args_element_name_10 );
    tmp_args_element_name_11 = var_error_depth;

    CHECK_OBJECT( tmp_args_element_name_11 );
    tmp_args_element_name_12 = par_ok;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_e08bdb6ef7d176edd569f0ebe97e06fe->m_frame.f_lineno = 318;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS5( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 318;
        type_description_1 = "oooococoooooo";
        goto try_except_handler_3;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_8;

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_e08bdb6ef7d176edd569f0ebe97e06fe );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_e08bdb6ef7d176edd569f0ebe97e06fe, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_e08bdb6ef7d176edd569f0ebe97e06fe, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = PyExc_Exception;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 321;
        type_description_1 = "oooococoooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_9 = PyThreadState_GET()->exc_value;
    assert( var_e == NULL );
    Py_INCREF( tmp_assign_source_9 );
    var_e = tmp_assign_source_9;

    if ( self->m_closure[1] == NULL )
    {
        tmp_source_name_2 = NULL;
    }
    else
    {
        tmp_source_name_2 = PyCell_GET( self->m_closure[1] );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
        exception_tb = NULL;

        exception_lineno = 322;
        type_description_1 = "oooococoooooo";
        goto try_except_handler_2;
    }

    tmp_called_instance_8 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__problems );
    if ( tmp_called_instance_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 322;
        type_description_1 = "oooococoooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_13 = var_e;

    CHECK_OBJECT( tmp_args_element_name_13 );
    frame_e08bdb6ef7d176edd569f0ebe97e06fe->m_frame.f_lineno = 322;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_8, const_str_plain_append, call_args );
    }

    Py_DECREF( tmp_called_instance_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 322;
        type_description_1 = "oooococoooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 317;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_e08bdb6ef7d176edd569f0ebe97e06fe->m_frame) frame_e08bdb6ef7d176edd569f0ebe97e06fe->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooococoooooo";
    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_cond_value_1 = var_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 325;
        type_description_1 = "oooococoooooo";
        goto try_except_handler_2;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 326;
        type_description_1 = "oooococoooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_STORE_CTX_set_error );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 326;
        type_description_1 = "oooococoooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_14 = par_store_ctx;

    CHECK_OBJECT( tmp_args_element_name_14 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 326;
        type_description_1 = "oooococoooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_V_OK );
    if ( tmp_args_element_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 326;
        type_description_1 = "oooococoooooo";
        goto try_except_handler_2;
    }
    frame_e08bdb6ef7d176edd569f0ebe97e06fe->m_frame.f_lineno = 326;
    {
        PyObject *call_args[] = { tmp_args_element_name_14, tmp_args_element_name_15 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_15 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 326;
        type_description_1 = "oooococoooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_return_value = const_int_pos_1;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_2;
    branch_no_2:;
    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_end_2:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_e08bdb6ef7d176edd569f0ebe97e06fe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_e08bdb6ef7d176edd569f0ebe97e06fe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_e08bdb6ef7d176edd569f0ebe97e06fe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e08bdb6ef7d176edd569f0ebe97e06fe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e08bdb6ef7d176edd569f0ebe97e06fe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e08bdb6ef7d176edd569f0ebe97e06fe, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e08bdb6ef7d176edd569f0ebe97e06fe,
        type_description_1,
        par_ok,
        par_store_ctx,
        var_index,
        var_error_number,
        self->m_closure[0],
        var_x509,
        self->m_closure[1],
        var_connection,
        var_ssl,
        var_cert,
        var_result,
        var_error_depth,
        var_e
    );


    // Release cached frame.
    if ( frame_e08bdb6ef7d176edd569f0ebe97e06fe == cache_frame_e08bdb6ef7d176edd569f0ebe97e06fe )
    {
        Py_DECREF( frame_e08bdb6ef7d176edd569f0ebe97e06fe );
    }
    cache_frame_e08bdb6ef7d176edd569f0ebe97e06fe = NULL;

    assertFrameObject( frame_e08bdb6ef7d176edd569f0ebe97e06fe );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_index );
    Py_DECREF( var_index );
    var_index = NULL;

    CHECK_OBJECT( (PyObject *)var_error_number );
    Py_DECREF( var_error_number );
    var_error_number = NULL;

    CHECK_OBJECT( (PyObject *)par_ok );
    Py_DECREF( par_ok );
    par_ok = NULL;

    CHECK_OBJECT( (PyObject *)var_x509 );
    Py_DECREF( var_x509 );
    var_x509 = NULL;

    CHECK_OBJECT( (PyObject *)var_connection );
    Py_DECREF( var_connection );
    var_connection = NULL;

    CHECK_OBJECT( (PyObject *)var_ssl );
    Py_DECREF( var_ssl );
    var_ssl = NULL;

    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)var_error_depth );
    Py_DECREF( var_error_depth );
    var_error_depth = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    CHECK_OBJECT( (PyObject *)par_store_ctx );
    Py_DECREF( par_store_ctx );
    par_store_ctx = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_index );
    var_index = NULL;

    Py_XDECREF( var_error_number );
    var_error_number = NULL;

    CHECK_OBJECT( (PyObject *)par_ok );
    Py_DECREF( par_ok );
    par_ok = NULL;

    Py_XDECREF( var_x509 );
    var_x509 = NULL;

    Py_XDECREF( var_connection );
    var_connection = NULL;

    Py_XDECREF( var_ssl );
    var_ssl = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_error_depth );
    var_error_depth = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    CHECK_OBJECT( (PyObject *)par_store_ctx );
    Py_DECREF( par_store_ctx );
    par_store_ctx = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_4___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    bool tmp_result;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_9af82c9b2f08b52e9e1a6e31b73ec652 = NULL;

    struct Nuitka_FrameObject *frame_9af82c9b2f08b52e9e1a6e31b73ec652;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9af82c9b2f08b52e9e1a6e31b73ec652, codeobj_9af82c9b2f08b52e9e1a6e31b73ec652, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9af82c9b2f08b52e9e1a6e31b73ec652 = cache_frame_9af82c9b2f08b52e9e1a6e31b73ec652;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9af82c9b2f08b52e9e1a6e31b73ec652 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9af82c9b2f08b52e9e1a6e31b73ec652 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CallbackExceptionHelper" );
        exception_tb = NULL;

        exception_lineno = 345;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    if ( par_self == NULL )
    {
        tmp_args_element_name_1 = NULL;
    }
    else
    {
        tmp_args_element_name_1 = PyCell_GET( par_self );
    }

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_9af82c9b2f08b52e9e1a6e31b73ec652->m_frame.f_lineno = 345;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 345;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
        exception_tb = NULL;

        exception_lineno = 347;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    if ( par_callback == NULL )
    {
        tmp_args_element_name_2 = NULL;
    }
    else
    {
        tmp_args_element_name_2 = PyCell_GET( par_callback );
    }

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_9af82c9b2f08b52e9e1a6e31b73ec652->m_frame.f_lineno = 347;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 347;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper( par_callback, par_self );
    frame_9af82c9b2f08b52e9e1a6e31b73ec652->m_frame.f_lineno = 347;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 347;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    assert( var_wrapper == NULL );
    var_wrapper = tmp_assign_source_1;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 391;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_str_digest_1bd7405e218c8a579c48801956097e27;
    tmp_args_element_name_5 = var_wrapper;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_9af82c9b2f08b52e9e1a6e31b73ec652->m_frame.f_lineno = 391;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_callback, call_args );
    }

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 391;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    if ( par_self == NULL )
    {
        tmp_assattr_target_1 = NULL;
    }
    else
    {
        tmp_assattr_target_1 = PyCell_GET( par_self );
    }

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 391;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9af82c9b2f08b52e9e1a6e31b73ec652 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9af82c9b2f08b52e9e1a6e31b73ec652 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9af82c9b2f08b52e9e1a6e31b73ec652, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9af82c9b2f08b52e9e1a6e31b73ec652->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9af82c9b2f08b52e9e1a6e31b73ec652, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9af82c9b2f08b52e9e1a6e31b73ec652,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_9af82c9b2f08b52e9e1a6e31b73ec652 == cache_frame_9af82c9b2f08b52e9e1a6e31b73ec652 )
    {
        Py_DECREF( frame_9af82c9b2f08b52e9e1a6e31b73ec652 );
    }
    cache_frame_9af82c9b2f08b52e9e1a6e31b73ec652 = NULL;

    assertFrameObject( frame_9af82c9b2f08b52e9e1a6e31b73ec652 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_4___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_4___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[ 0 ];
    PyObject *par_out = python_pars[ 1 ];
    PyObject *par_outlen = python_pars[ 2 ];
    PyObject *par_in_ = python_pars[ 3 ];
    PyObject *par_inlen = python_pars[ 4 ];
    PyObject *par_arg = python_pars[ 5 ];
    PyObject *var_encoded_len = NULL;
    PyObject *var_protolist = NULL;
    PyObject *var_e = NULL;
    PyObject *var_outbytes = NULL;
    PyObject *var_instr = NULL;
    PyObject *var_any_accepted = NULL;
    PyObject *var_proto = NULL;
    PyObject *var_conn = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    int tmp_exc_match_exception_match_1;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_lower_1;
    PyObject *tmp_slice_lower_2;
    PyObject *tmp_slice_source_1;
    PyObject *tmp_slice_source_2;
    PyObject *tmp_slice_source_3;
    PyObject *tmp_slice_upper_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_45214eee286f8b09ba13e2d070abb952 = NULL;

    struct Nuitka_FrameObject *frame_45214eee286f8b09ba13e2d070abb952;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_45214eee286f8b09ba13e2d070abb952, codeobj_45214eee286f8b09ba13e2d070abb952, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_45214eee286f8b09ba13e2d070abb952 = cache_frame_45214eee286f8b09ba13e2d070abb952;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_45214eee286f8b09ba13e2d070abb952 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_45214eee286f8b09ba13e2d070abb952 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
        exception_tb = NULL;

        exception_lineno = 350;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 350;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    tmp_subscript_name_1 = par_ssl;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 350;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    assert( var_conn == NULL );
    var_conn = tmp_assign_source_1;

    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 355;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }

    tmp_args_element_name_1 = par_in_;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = par_inlen;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_45214eee286f8b09ba13e2d070abb952->m_frame.f_lineno = 355;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
    }

    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 355;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    tmp_assign_source_2 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 355;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    assert( var_instr == NULL );
    var_instr = tmp_assign_source_2;

    tmp_assign_source_3 = PyList_New( 0 );
    assert( var_protolist == NULL );
    var_protolist = tmp_assign_source_3;

    loop_start_1:;
    tmp_cond_value_1 = var_instr;

    if ( tmp_cond_value_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "instr" );
        exception_tb = NULL;

        exception_lineno = 357;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 357;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    goto loop_end_1;
    branch_no_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_indexbytes );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_indexbytes );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "indexbytes" );
        exception_tb = NULL;

        exception_lineno = 358;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }

    tmp_args_element_name_3 = var_instr;

    if ( tmp_args_element_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "instr" );
        exception_tb = NULL;

        exception_lineno = 358;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }

    tmp_args_element_name_4 = const_int_0;
    frame_45214eee286f8b09ba13e2d070abb952->m_frame.f_lineno = 358;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 358;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_encoded_len;
        var_encoded_len = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_slice_source_2 = var_instr;

    if ( tmp_slice_source_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "instr" );
        exception_tb = NULL;

        exception_lineno = 359;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }

    tmp_slice_lower_1 = const_int_pos_1;
    tmp_left_name_1 = var_encoded_len;

    CHECK_OBJECT( tmp_left_name_1 );
    tmp_right_name_1 = const_int_pos_1;
    tmp_slice_upper_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_slice_upper_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 359;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    tmp_assign_source_5 = LOOKUP_SLICE( tmp_slice_source_2, tmp_slice_lower_1, tmp_slice_upper_1 );
    Py_DECREF( tmp_slice_upper_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 359;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_proto;
        var_proto = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = var_protolist;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_5 = var_proto;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_45214eee286f8b09ba13e2d070abb952->m_frame.f_lineno = 360;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_append, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 360;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_slice_source_3 = var_instr;

    if ( tmp_slice_source_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "instr" );
        exception_tb = NULL;

        exception_lineno = 361;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }

    tmp_left_name_2 = var_encoded_len;

    CHECK_OBJECT( tmp_left_name_2 );
    tmp_right_name_2 = const_int_pos_1;
    tmp_slice_lower_2 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_2 );
    if ( tmp_slice_lower_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 361;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    tmp_assign_source_6 = LOOKUP_SLICE( tmp_slice_source_3, tmp_slice_lower_2, Py_None );
    Py_DECREF( tmp_slice_lower_2 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 361;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_instr;
        var_instr = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 357;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    if ( self->m_closure[0] == NULL )
    {
        tmp_called_name_2 = NULL;
    }
    else
    {
        tmp_called_name_2 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
        exception_tb = NULL;

        exception_lineno = 364;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }

    tmp_args_element_name_6 = var_conn;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = var_protolist;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_45214eee286f8b09ba13e2d070abb952->m_frame.f_lineno = 364;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 364;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    assert( var_outbytes == NULL );
    var_outbytes = tmp_assign_source_7;

    tmp_assign_source_8 = Py_True;
    assert( var_any_accepted == NULL );
    Py_INCREF( tmp_assign_source_8 );
    var_any_accepted = tmp_assign_source_8;

    tmp_compare_left_1 = var_outbytes;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_NO_OVERLAPPING_PROTOCOLS );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NO_OVERLAPPING_PROTOCOLS );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "NO_OVERLAPPING_PROTOCOLS" );
        exception_tb = NULL;

        exception_lineno = 366;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }

    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_9 = const_str_empty;
    {
        PyObject *old = var_outbytes;
        assert( old != NULL );
        var_outbytes = tmp_assign_source_9;
        Py_INCREF( var_outbytes );
        Py_DECREF( old );
    }

    tmp_assign_source_10 = Py_False;
    {
        PyObject *old = var_any_accepted;
        assert( old != NULL );
        var_any_accepted = tmp_assign_source_10;
        Py_INCREF( var_any_accepted );
        Py_DECREF( old );
    }

    goto branch_end_2;
    branch_no_2:;
    tmp_isinstance_inst_1 = var_outbytes;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 369;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_1 = const_str_digest_28855c350e66dba47d4f94de98c7d542;
    frame_45214eee286f8b09ba13e2d070abb952->m_frame.f_lineno = 370;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 370;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooooooooooocco";
    goto try_except_handler_2;
    branch_no_3:;
    branch_end_2:;
    tmp_assattr_name_1 = PyList_New( 2 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_assattr_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 379;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_new );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 379;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    tmp_args_element_name_8 = const_str_digest_2aaae8e99c54112dad0b0da3957413a9;
    tmp_len_arg_1 = var_outbytes;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_args_element_name_9 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 379;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    frame_45214eee286f8b09ba13e2d070abb952->m_frame.f_lineno = 379;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 379;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    PyList_SET_ITEM( tmp_assattr_name_1, 0, tmp_list_element_1 );
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_3 == NULL )
    {
        Py_DECREF( tmp_assattr_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 380;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }

    tmp_args_element_name_10 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
    tmp_args_element_name_11 = var_outbytes;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_45214eee286f8b09ba13e2d070abb952->m_frame.f_lineno = 380;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_list_element_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_new, call_args );
    }

    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 380;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    PyList_SET_ITEM( tmp_assattr_name_1, 1, tmp_list_element_1 );
    tmp_assattr_target_1 = var_conn;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__alpn_select_callback_args, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 378;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_source_name_3 = var_conn;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_subscribed_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__alpn_select_callback_args );
    if ( tmp_subscribed_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 382;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    tmp_subscript_name_2 = const_int_0;
    tmp_subscribed_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscribed_name_3 );
    if ( tmp_subscribed_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 382;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    tmp_subscript_name_3 = const_int_0;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_3 );
    Py_DECREF( tmp_subscribed_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 382;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    tmp_ass_subscribed_1 = par_outlen;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 382;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    tmp_source_name_4 = var_conn;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_subscribed_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__alpn_select_callback_args );
    if ( tmp_subscribed_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 383;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    tmp_subscript_name_4 = const_int_pos_1;
    tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    Py_DECREF( tmp_subscribed_name_4 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 383;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    tmp_ass_subscribed_2 = par_out;

    CHECK_OBJECT( tmp_ass_subscribed_2 );
    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 383;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    tmp_cond_value_2 = var_any_accepted;

    CHECK_OBJECT( tmp_cond_value_2 );
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 384;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 385;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_SSL_TLSEXT_ERR_NOACK );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 385;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    goto frame_return_exit_1;
    branch_no_4:;
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 386;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_SSL_TLSEXT_ERR_OK );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 386;
        type_description_1 = "ooooooooooooocco";
        goto try_except_handler_2;
    }
    goto frame_return_exit_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_45214eee286f8b09ba13e2d070abb952 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_45214eee286f8b09ba13e2d070abb952, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_45214eee286f8b09ba13e2d070abb952, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyExc_Exception;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 387;
        type_description_1 = "ooooooooooooocco";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_assign_source_11 = PyThreadState_GET()->exc_value;
    assert( var_e == NULL );
    Py_INCREF( tmp_assign_source_11 );
    var_e = tmp_assign_source_11;

    if ( self->m_closure[1] == NULL )
    {
        tmp_source_name_7 = NULL;
    }
    else
    {
        tmp_source_name_7 = PyCell_GET( self->m_closure[1] );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
        exception_tb = NULL;

        exception_lineno = 388;
        type_description_1 = "ooooooooooooocco";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__problems );
    if ( tmp_called_instance_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 388;
        type_description_1 = "ooooooooooooocco";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_12 = var_e;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_45214eee286f8b09ba13e2d070abb952->m_frame.f_lineno = 388;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, call_args );
    }

    Py_DECREF( tmp_called_instance_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 388;
        type_description_1 = "ooooooooooooocco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 389;
        type_description_1 = "ooooooooooooocco";
        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_SSL_TLSEXT_ERR_ALERT_FATAL );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 389;
        type_description_1 = "ooooooooooooocco";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_5;
    branch_no_5:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 349;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_45214eee286f8b09ba13e2d070abb952->m_frame) frame_45214eee286f8b09ba13e2d070abb952->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "ooooooooooooocco";
    goto frame_exception_exit_1;
    branch_end_5:;
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_45214eee286f8b09ba13e2d070abb952 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_45214eee286f8b09ba13e2d070abb952 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_45214eee286f8b09ba13e2d070abb952 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_45214eee286f8b09ba13e2d070abb952, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_45214eee286f8b09ba13e2d070abb952->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_45214eee286f8b09ba13e2d070abb952, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_45214eee286f8b09ba13e2d070abb952,
        type_description_1,
        par_ssl,
        par_out,
        par_outlen,
        par_in_,
        par_inlen,
        par_arg,
        var_encoded_len,
        var_protolist,
        var_e,
        var_outbytes,
        var_instr,
        var_any_accepted,
        var_proto,
        self->m_closure[0],
        self->m_closure[1],
        var_conn
    );


    // Release cached frame.
    if ( frame_45214eee286f8b09ba13e2d070abb952 == cache_frame_45214eee286f8b09ba13e2d070abb952 )
    {
        Py_DECREF( frame_45214eee286f8b09ba13e2d070abb952 );
    }
    cache_frame_45214eee286f8b09ba13e2d070abb952 = NULL;

    assertFrameObject( frame_45214eee286f8b09ba13e2d070abb952 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_encoded_len );
    var_encoded_len = NULL;

    Py_XDECREF( var_protolist );
    var_protolist = NULL;

    CHECK_OBJECT( (PyObject *)par_in_ );
    Py_DECREF( par_in_ );
    par_in_ = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_outbytes );
    var_outbytes = NULL;

    Py_XDECREF( var_instr );
    var_instr = NULL;

    Py_XDECREF( var_any_accepted );
    var_any_accepted = NULL;

    Py_XDECREF( var_proto );
    var_proto = NULL;

    CHECK_OBJECT( (PyObject *)par_outlen );
    Py_DECREF( par_outlen );
    par_outlen = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_out );
    Py_DECREF( par_out );
    par_out = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    CHECK_OBJECT( (PyObject *)par_inlen );
    Py_DECREF( par_inlen );
    par_inlen = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_encoded_len );
    var_encoded_len = NULL;

    Py_XDECREF( var_protolist );
    var_protolist = NULL;

    CHECK_OBJECT( (PyObject *)par_in_ );
    Py_DECREF( par_in_ );
    par_in_ = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_outbytes );
    var_outbytes = NULL;

    Py_XDECREF( var_instr );
    var_instr = NULL;

    Py_XDECREF( var_any_accepted );
    var_any_accepted = NULL;

    Py_XDECREF( var_proto );
    var_proto = NULL;

    CHECK_OBJECT( (PyObject *)par_outlen );
    Py_DECREF( par_outlen );
    par_outlen = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_out );
    Py_DECREF( par_out );
    par_out = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    CHECK_OBJECT( (PyObject *)par_inlen );
    Py_DECREF( par_inlen );
    par_inlen = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_5___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    bool tmp_result;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_ab00c4dfc87ce556418936a5e1f26e78 = NULL;

    struct Nuitka_FrameObject *frame_ab00c4dfc87ce556418936a5e1f26e78;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ab00c4dfc87ce556418936a5e1f26e78, codeobj_ab00c4dfc87ce556418936a5e1f26e78, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ab00c4dfc87ce556418936a5e1f26e78 = cache_frame_ab00c4dfc87ce556418936a5e1f26e78;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ab00c4dfc87ce556418936a5e1f26e78 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ab00c4dfc87ce556418936a5e1f26e78 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CallbackExceptionHelper" );
        exception_tb = NULL;

        exception_lineno = 423;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    if ( par_self == NULL )
    {
        tmp_args_element_name_1 = NULL;
    }
    else
    {
        tmp_args_element_name_1 = PyCell_GET( par_self );
    }

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_ab00c4dfc87ce556418936a5e1f26e78->m_frame.f_lineno = 423;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 423;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
        exception_tb = NULL;

        exception_lineno = 425;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    if ( par_callback == NULL )
    {
        tmp_args_element_name_2 = NULL;
    }
    else
    {
        tmp_args_element_name_2 = PyCell_GET( par_callback );
    }

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_ab00c4dfc87ce556418936a5e1f26e78->m_frame.f_lineno = 425;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 425;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper( par_callback, par_self );
    frame_ab00c4dfc87ce556418936a5e1f26e78->m_frame.f_lineno = 425;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 425;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    assert( var_wrapper == NULL );
    var_wrapper = tmp_assign_source_1;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 464;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_str_digest_9575fec1eee4d60c15d3f7c228d8045c;
    tmp_args_element_name_5 = var_wrapper;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_ab00c4dfc87ce556418936a5e1f26e78->m_frame.f_lineno = 464;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_callback, call_args );
    }

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 464;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    if ( par_self == NULL )
    {
        tmp_assattr_target_1 = NULL;
    }
    else
    {
        tmp_assattr_target_1 = PyCell_GET( par_self );
    }

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 464;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab00c4dfc87ce556418936a5e1f26e78 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab00c4dfc87ce556418936a5e1f26e78 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ab00c4dfc87ce556418936a5e1f26e78, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ab00c4dfc87ce556418936a5e1f26e78->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ab00c4dfc87ce556418936a5e1f26e78, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ab00c4dfc87ce556418936a5e1f26e78,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_ab00c4dfc87ce556418936a5e1f26e78 == cache_frame_ab00c4dfc87ce556418936a5e1f26e78 )
    {
        Py_DECREF( frame_ab00c4dfc87ce556418936a5e1f26e78 );
    }
    cache_frame_ab00c4dfc87ce556418936a5e1f26e78 = NULL;

    assertFrameObject( frame_ab00c4dfc87ce556418936a5e1f26e78 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_5___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_5___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[ 0 ];
    PyObject *par_cdata = python_pars[ 1 ];
    PyObject *var_e = NULL;
    PyObject *var_ocsp_data_length = NULL;
    PyObject *var_ocsp_data = NULL;
    PyObject *var_data_ptr = NULL;
    PyObject *var_data = NULL;
    PyObject *var_conn = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_name_1;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_sliceass_index_upper_1;
    PyObject *tmp_sliceass_target_1;
    PyObject *tmp_sliceass_value_1;
    Py_ssize_t tmp_sliceassslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_0ad17b909e53698f39728a57b64a8076 = NULL;

    struct Nuitka_FrameObject *frame_0ad17b909e53698f39728a57b64a8076;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0ad17b909e53698f39728a57b64a8076, codeobj_0ad17b909e53698f39728a57b64a8076, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0ad17b909e53698f39728a57b64a8076 = cache_frame_0ad17b909e53698f39728a57b64a8076;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0ad17b909e53698f39728a57b64a8076 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0ad17b909e53698f39728a57b64a8076 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
        exception_tb = NULL;

        exception_lineno = 428;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 428;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }
    tmp_subscript_name_1 = par_ssl;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 428;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }
    assert( var_conn == NULL );
    var_conn = tmp_assign_source_1;

    tmp_compare_left_1 = par_cdata;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 431;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 431;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 431;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 432;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_1 = par_cdata;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_0ad17b909e53698f39728a57b64a8076->m_frame.f_lineno = 432;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_from_handle, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 432;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }
    assert( var_data == NULL );
    var_data = tmp_assign_source_2;

    goto branch_end_1;
    branch_no_1:;
    tmp_assign_source_3 = Py_None;
    assert( var_data == NULL );
    Py_INCREF( tmp_assign_source_3 );
    var_data = tmp_assign_source_3;

    branch_end_1:;
    if ( self->m_closure[0] == NULL )
    {
        tmp_called_name_1 = NULL;
    }
    else
    {
        tmp_called_name_1 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
        exception_tb = NULL;

        exception_lineno = 437;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_2 = var_conn;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = var_data;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_0ad17b909e53698f39728a57b64a8076->m_frame.f_lineno = 437;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 437;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }
    assert( var_ocsp_data == NULL );
    var_ocsp_data = tmp_assign_source_4;

    tmp_isinstance_inst_1 = var_ocsp_data;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 439;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_1 = const_str_digest_f4ac5993e0eb53c16d6349308d51d30e;
    frame_0ad17b909e53698f39728a57b64a8076->m_frame.f_lineno = 440;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 440;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooccoooo";
    goto try_except_handler_2;
    branch_no_2:;
    tmp_cond_value_1 = var_ocsp_data;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 446;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_return_value = const_int_pos_3;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_3:;
    tmp_len_arg_1 = var_ocsp_data;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_assign_source_5 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 451;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }
    assert( var_ocsp_data_length == NULL );
    var_ocsp_data_length = tmp_assign_source_5;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 452;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_4 = var_ocsp_data_length;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_0ad17b909e53698f39728a57b64a8076->m_frame.f_lineno = 452;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_OPENSSL_malloc, call_args );
    }

    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 452;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }
    assert( var_data_ptr == NULL );
    var_data_ptr = tmp_assign_source_6;

    tmp_sliceass_value_1 = var_ocsp_data;

    CHECK_OBJECT( tmp_sliceass_value_1 );
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 453;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_5 = var_data_ptr;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = var_ocsp_data_length;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_0ad17b909e53698f39728a57b64a8076->m_frame.f_lineno = 453;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_sliceass_target_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_buffer, call_args );
    }

    if ( tmp_sliceass_target_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 453;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }
    tmp_sliceassslicedel_index_lower_1 = 0;
    tmp_sliceass_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_result = SET_INDEX_SLICE( tmp_sliceass_target_1, tmp_sliceassslicedel_index_lower_1, tmp_sliceass_index_upper_1, tmp_sliceass_value_1 );
    Py_DECREF( tmp_sliceass_target_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 453;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 455;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_7 = par_ssl;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = var_data_ptr;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_args_element_name_9 = var_ocsp_data_length;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_0ad17b909e53698f39728a57b64a8076->m_frame.f_lineno = 455;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_4, const_str_plain_SSL_set_tlsext_status_ocsp_resp, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 455;
        type_description_1 = "ooooccoooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_0ad17b909e53698f39728a57b64a8076 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_0ad17b909e53698f39728a57b64a8076, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_0ad17b909e53698f39728a57b64a8076, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyExc_Exception;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 460;
        type_description_1 = "ooooccoooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_assign_source_7 = PyThreadState_GET()->exc_value;
    assert( var_e == NULL );
    Py_INCREF( tmp_assign_source_7 );
    var_e = tmp_assign_source_7;

    if ( self->m_closure[1] == NULL )
    {
        tmp_source_name_3 = NULL;
    }
    else
    {
        tmp_source_name_3 = PyCell_GET( self->m_closure[1] );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
        exception_tb = NULL;

        exception_lineno = 461;
        type_description_1 = "ooooccoooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__problems );
    if ( tmp_called_instance_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 461;
        type_description_1 = "ooooccoooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = var_e;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_0ad17b909e53698f39728a57b64a8076->m_frame.f_lineno = 461;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_append, call_args );
    }

    Py_DECREF( tmp_called_instance_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 461;
        type_description_1 = "ooooccoooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_return_value = const_int_pos_2;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_4;
    branch_no_4:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 427;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_0ad17b909e53698f39728a57b64a8076->m_frame) frame_0ad17b909e53698f39728a57b64a8076->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "ooooccoooo";
    goto frame_exception_exit_1;
    branch_end_4:;
    // End of try:
    try_end_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_0ad17b909e53698f39728a57b64a8076 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_0ad17b909e53698f39728a57b64a8076 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_0ad17b909e53698f39728a57b64a8076 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0ad17b909e53698f39728a57b64a8076, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0ad17b909e53698f39728a57b64a8076->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0ad17b909e53698f39728a57b64a8076, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0ad17b909e53698f39728a57b64a8076,
        type_description_1,
        par_ssl,
        par_cdata,
        var_e,
        var_ocsp_data_length,
        self->m_closure[0],
        self->m_closure[1],
        var_ocsp_data,
        var_data_ptr,
        var_data,
        var_conn
    );


    // Release cached frame.
    if ( frame_0ad17b909e53698f39728a57b64a8076 == cache_frame_0ad17b909e53698f39728a57b64a8076 )
    {
        Py_DECREF( frame_0ad17b909e53698f39728a57b64a8076 );
    }
    cache_frame_0ad17b909e53698f39728a57b64a8076 = NULL;

    assertFrameObject( frame_0ad17b909e53698f39728a57b64a8076 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_ocsp_data_length );
    var_ocsp_data_length = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_cdata );
    Py_DECREF( par_cdata );
    par_cdata = NULL;

    Py_XDECREF( var_ocsp_data );
    var_ocsp_data = NULL;

    Py_XDECREF( var_data_ptr );
    var_data_ptr = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_ocsp_data_length );
    var_ocsp_data_length = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_cdata );
    Py_DECREF( par_cdata );
    par_cdata = NULL;

    Py_XDECREF( var_ocsp_data );
    var_ocsp_data = NULL;

    Py_XDECREF( var_data_ptr );
    var_data_ptr = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_6___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    bool tmp_result;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_dade4f6f27b248c7011ea5b59e49e882 = NULL;

    struct Nuitka_FrameObject *frame_dade4f6f27b248c7011ea5b59e49e882;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dade4f6f27b248c7011ea5b59e49e882, codeobj_dade4f6f27b248c7011ea5b59e49e882, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_dade4f6f27b248c7011ea5b59e49e882 = cache_frame_dade4f6f27b248c7011ea5b59e49e882;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dade4f6f27b248c7011ea5b59e49e882 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dade4f6f27b248c7011ea5b59e49e882 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CallbackExceptionHelper" );
        exception_tb = NULL;

        exception_lineno = 490;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    if ( par_self == NULL )
    {
        tmp_args_element_name_1 = NULL;
    }
    else
    {
        tmp_args_element_name_1 = PyCell_GET( par_self );
    }

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_dade4f6f27b248c7011ea5b59e49e882->m_frame.f_lineno = 490;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 490;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
        exception_tb = NULL;

        exception_lineno = 492;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    if ( par_callback == NULL )
    {
        tmp_args_element_name_2 = NULL;
    }
    else
    {
        tmp_args_element_name_2 = PyCell_GET( par_callback );
    }

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_dade4f6f27b248c7011ea5b59e49e882->m_frame.f_lineno = 492;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 492;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper( par_callback, par_self );
    frame_dade4f6f27b248c7011ea5b59e49e882->m_frame.f_lineno = 492;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 492;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    assert( var_wrapper == NULL );
    var_wrapper = tmp_assign_source_1;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 523;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_str_digest_9575fec1eee4d60c15d3f7c228d8045c;
    tmp_args_element_name_5 = var_wrapper;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_dade4f6f27b248c7011ea5b59e49e882->m_frame.f_lineno = 523;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_callback, call_args );
    }

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 523;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    if ( par_self == NULL )
    {
        tmp_assattr_target_1 = NULL;
    }
    else
    {
        tmp_assattr_target_1 = PyCell_GET( par_self );
    }

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 523;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dade4f6f27b248c7011ea5b59e49e882 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dade4f6f27b248c7011ea5b59e49e882 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dade4f6f27b248c7011ea5b59e49e882, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dade4f6f27b248c7011ea5b59e49e882->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dade4f6f27b248c7011ea5b59e49e882, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dade4f6f27b248c7011ea5b59e49e882,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_dade4f6f27b248c7011ea5b59e49e882 == cache_frame_dade4f6f27b248c7011ea5b59e49e882 )
    {
        Py_DECREF( frame_dade4f6f27b248c7011ea5b59e49e882 );
    }
    cache_frame_dade4f6f27b248c7011ea5b59e49e882 = NULL;

    assertFrameObject( frame_dade4f6f27b248c7011ea5b59e49e882 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_6___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_6___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[ 0 ];
    PyObject *par_cdata = python_pars[ 1 ];
    PyObject *var_ocsp_len = NULL;
    PyObject *var_e = NULL;
    PyObject *var_valid = NULL;
    PyObject *var_ocsp_ptr = NULL;
    PyObject *var_ocsp_data = NULL;
    PyObject *var_data = NULL;
    PyObject *var_conn = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_bool_arg_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Lt_1;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_int_arg_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_43b1c0b0ce1eda30c8482da409dfed18 = NULL;

    struct Nuitka_FrameObject *frame_43b1c0b0ce1eda30c8482da409dfed18;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_43b1c0b0ce1eda30c8482da409dfed18, codeobj_43b1c0b0ce1eda30c8482da409dfed18, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_43b1c0b0ce1eda30c8482da409dfed18 = cache_frame_43b1c0b0ce1eda30c8482da409dfed18;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_43b1c0b0ce1eda30c8482da409dfed18 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_43b1c0b0ce1eda30c8482da409dfed18 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
        exception_tb = NULL;

        exception_lineno = 495;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 495;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    tmp_subscript_name_1 = par_ssl;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 495;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    assert( var_conn == NULL );
    var_conn = tmp_assign_source_1;

    tmp_compare_left_1 = par_cdata;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 498;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 498;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 498;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 499;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_1 = par_cdata;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_43b1c0b0ce1eda30c8482da409dfed18->m_frame.f_lineno = 499;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_from_handle, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 499;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    assert( var_data == NULL );
    var_data = tmp_assign_source_2;

    goto branch_end_1;
    branch_no_1:;
    tmp_assign_source_3 = Py_None;
    assert( var_data == NULL );
    Py_INCREF( tmp_assign_source_3 );
    var_data = tmp_assign_source_3;

    branch_end_1:;
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 504;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }

    frame_43b1c0b0ce1eda30c8482da409dfed18->m_frame.f_lineno = 504;
    tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_52773e1185116024389d12c91a4ccf3d_tuple, 0 ) );

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 504;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    assert( var_ocsp_ptr == NULL );
    var_ocsp_ptr = tmp_assign_source_4;

    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 505;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_2 = par_ssl;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = var_ocsp_ptr;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_43b1c0b0ce1eda30c8482da409dfed18->m_frame.f_lineno = 505;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_SSL_get_tlsext_status_ocsp_resp, call_args );
    }

    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 505;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    assert( var_ocsp_len == NULL );
    var_ocsp_len = tmp_assign_source_5;

    tmp_compare_left_2 = var_ocsp_len;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = const_int_0;
    tmp_cmp_Lt_1 = RICH_COMPARE_BOOL_LT( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Lt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 506;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    if ( tmp_cmp_Lt_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_6 = const_str_empty;
    assert( var_ocsp_data == NULL );
    Py_INCREF( tmp_assign_source_6 );
    var_ocsp_data = tmp_assign_source_6;

    goto branch_end_2;
    branch_no_2:;
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 511;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_buffer );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    tmp_subscribed_name_2 = var_ocsp_ptr;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_0;
    tmp_args_element_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 511;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_5 = var_ocsp_len;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_43b1c0b0ce1eda30c8482da409dfed18->m_frame.f_lineno = 511;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    tmp_assign_source_7 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    assert( var_ocsp_data == NULL );
    var_ocsp_data = tmp_assign_source_7;

    branch_end_2:;
    if ( self->m_closure[0] == NULL )
    {
        tmp_called_name_2 = NULL;
    }
    else
    {
        tmp_called_name_2 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
        exception_tb = NULL;

        exception_lineno = 513;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_6 = var_conn;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = var_ocsp_data;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = var_data;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_43b1c0b0ce1eda30c8482da409dfed18->m_frame.f_lineno = 513;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 513;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    assert( var_valid == NULL );
    var_valid = tmp_assign_source_8;

    tmp_bool_arg_1 = var_valid;

    CHECK_OBJECT( tmp_bool_arg_1 );
    tmp_int_arg_1 = TO_BOOL( tmp_bool_arg_1 );
    if ( tmp_int_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 516;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    tmp_return_value = PyNumber_Int( tmp_int_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 516;
        type_description_1 = "ooooccooooo";
        goto try_except_handler_2;
    }
    goto frame_return_exit_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_43b1c0b0ce1eda30c8482da409dfed18 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_43b1c0b0ce1eda30c8482da409dfed18, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_43b1c0b0ce1eda30c8482da409dfed18, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_3 = PyThreadState_GET()->exc_type;
    tmp_compare_right_3 = PyExc_Exception;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 518;
        type_description_1 = "ooooccooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_assign_source_9 = PyThreadState_GET()->exc_value;
    assert( var_e == NULL );
    Py_INCREF( tmp_assign_source_9 );
    var_e = tmp_assign_source_9;

    if ( self->m_closure[1] == NULL )
    {
        tmp_source_name_4 = NULL;
    }
    else
    {
        tmp_source_name_4 = PyCell_GET( self->m_closure[1] );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
        exception_tb = NULL;

        exception_lineno = 519;
        type_description_1 = "ooooccooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__problems );
    if ( tmp_called_instance_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 519;
        type_description_1 = "ooooccooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_e;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_43b1c0b0ce1eda30c8482da409dfed18->m_frame.f_lineno = 519;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, call_args );
    }

    Py_DECREF( tmp_called_instance_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 519;
        type_description_1 = "ooooccooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_return_value = const_int_neg_1;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_3;
    branch_no_3:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 494;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_43b1c0b0ce1eda30c8482da409dfed18->m_frame) frame_43b1c0b0ce1eda30c8482da409dfed18->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "ooooccooooo";
    goto frame_exception_exit_1;
    branch_end_3:;
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_43b1c0b0ce1eda30c8482da409dfed18 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_43b1c0b0ce1eda30c8482da409dfed18 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_43b1c0b0ce1eda30c8482da409dfed18 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_43b1c0b0ce1eda30c8482da409dfed18, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_43b1c0b0ce1eda30c8482da409dfed18->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_43b1c0b0ce1eda30c8482da409dfed18, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_43b1c0b0ce1eda30c8482da409dfed18,
        type_description_1,
        par_ssl,
        par_cdata,
        var_ocsp_len,
        var_e,
        self->m_closure[0],
        self->m_closure[1],
        var_valid,
        var_ocsp_ptr,
        var_ocsp_data,
        var_data,
        var_conn
    );


    // Release cached frame.
    if ( frame_43b1c0b0ce1eda30c8482da409dfed18 == cache_frame_43b1c0b0ce1eda30c8482da409dfed18 )
    {
        Py_DECREF( frame_43b1c0b0ce1eda30c8482da409dfed18 );
    }
    cache_frame_43b1c0b0ce1eda30c8482da409dfed18 = NULL;

    assertFrameObject( frame_43b1c0b0ce1eda30c8482da409dfed18 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_ocsp_len );
    var_ocsp_len = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    Py_XDECREF( var_valid );
    var_valid = NULL;

    Py_XDECREF( var_ocsp_ptr );
    var_ocsp_ptr = NULL;

    CHECK_OBJECT( (PyObject *)par_cdata );
    Py_DECREF( par_cdata );
    par_cdata = NULL;

    Py_XDECREF( var_ocsp_data );
    var_ocsp_data = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_ocsp_len );
    var_ocsp_len = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    Py_XDECREF( var_valid );
    var_valid = NULL;

    Py_XDECREF( var_ocsp_ptr );
    var_ocsp_ptr = NULL;

    CHECK_OBJECT( (PyObject *)par_cdata );
    Py_DECREF( par_cdata );
    par_cdata = NULL;

    Py_XDECREF( var_ocsp_data );
    var_ocsp_data = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_7__asFileDescriptor( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_obj = python_pars[ 0 ];
    PyObject *var_fd = NULL;
    PyObject *var_meth = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Lt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_getattr_attr_1;
    PyObject *tmp_getattr_default_1;
    PyObject *tmp_getattr_target_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_cls_3;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_isinstance_inst_3;
    bool tmp_isnot_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_ee325f32577779b2b6a08490839df69e = NULL;

    struct Nuitka_FrameObject *frame_ee325f32577779b2b6a08490839df69e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = Py_None;
    assert( var_fd == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var_fd = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ee325f32577779b2b6a08490839df69e, codeobj_ee325f32577779b2b6a08490839df69e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ee325f32577779b2b6a08490839df69e = cache_frame_ee325f32577779b2b6a08490839df69e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ee325f32577779b2b6a08490839df69e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ee325f32577779b2b6a08490839df69e ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_obj;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 528;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 528;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_getattr_target_1 = par_obj;

    CHECK_OBJECT( tmp_getattr_target_1 );
    tmp_getattr_attr_1 = const_str_plain_fileno;
    tmp_getattr_default_1 = Py_None;
    tmp_assign_source_2 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 529;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_meth == NULL );
    var_meth = tmp_assign_source_2;

    tmp_compare_left_1 = var_meth;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_name_1 = var_meth;

    CHECK_OBJECT( tmp_called_name_1 );
    frame_ee325f32577779b2b6a08490839df69e->m_frame.f_lineno = 531;
    tmp_assign_source_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 531;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_obj;
        assert( old != NULL );
        par_obj = tmp_assign_source_3;
        Py_DECREF( old );
    }

    branch_no_2:;
    branch_no_1:;
    tmp_isinstance_inst_2 = par_obj;

    if ( tmp_isinstance_inst_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "obj" );
        exception_tb = NULL;

        exception_lineno = 533;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_2 == NULL ))
    {
        tmp_isinstance_cls_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 533;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 533;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_assign_source_4 = par_obj;

    if ( tmp_assign_source_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "obj" );
        exception_tb = NULL;

        exception_lineno = 534;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    {
        PyObject *old = var_fd;
        assert( old != NULL );
        var_fd = tmp_assign_source_4;
        Py_INCREF( var_fd );
        Py_DECREF( old );
    }

    branch_no_3:;
    tmp_isinstance_inst_3 = var_fd;

    CHECK_OBJECT( tmp_isinstance_inst_3 );
    tmp_isinstance_cls_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_3 == NULL ))
    {
        tmp_isinstance_cls_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 536;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 536;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    tmp_make_exception_arg_1 = const_str_digest_9e9a42d8484d15cb8253ecb92e0c7121;
    frame_ee325f32577779b2b6a08490839df69e->m_frame.f_lineno = 537;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 537;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    goto branch_end_4;
    branch_no_4:;
    tmp_compare_left_2 = var_fd;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = const_int_0;
    tmp_cmp_Lt_1 = RICH_COMPARE_BOOL_LT( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Lt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 538;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Lt_1 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_left_name_1 = const_str_digest_afa60644cf27716474a6bbd780185867;
    tmp_right_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = var_fd;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_make_exception_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 540;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_ee325f32577779b2b6a08490839df69e->m_frame.f_lineno = 539;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_2 );
    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 539;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_5:;
    branch_end_4:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ee325f32577779b2b6a08490839df69e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ee325f32577779b2b6a08490839df69e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ee325f32577779b2b6a08490839df69e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ee325f32577779b2b6a08490839df69e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ee325f32577779b2b6a08490839df69e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ee325f32577779b2b6a08490839df69e,
        type_description_1,
        par_obj,
        var_fd,
        var_meth
    );


    // Release cached frame.
    if ( frame_ee325f32577779b2b6a08490839df69e == cache_frame_ee325f32577779b2b6a08490839df69e )
    {
        Py_DECREF( frame_ee325f32577779b2b6a08490839df69e );
    }
    cache_frame_ee325f32577779b2b6a08490839df69e = NULL;

    assertFrameObject( frame_ee325f32577779b2b6a08490839df69e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_fd;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_7__asFileDescriptor );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_fd );
    Py_DECREF( var_fd );
    var_fd = NULL;

    Py_XDECREF( var_meth );
    var_meth = NULL;

    Py_XDECREF( par_obj );
    par_obj = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_fd );
    var_fd = NULL;

    Py_XDECREF( var_meth );
    var_meth = NULL;

    Py_XDECREF( par_obj );
    par_obj = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_7__asFileDescriptor );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_8_SSLeay_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_e398f1d99b089b4d7b9c44b332686f32 = NULL;

    struct Nuitka_FrameObject *frame_e398f1d99b089b4d7b9c44b332686f32;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e398f1d99b089b4d7b9c44b332686f32, codeobj_e398f1d99b089b4d7b9c44b332686f32, module_OpenSSL$SSL, sizeof(void *) );
    frame_e398f1d99b089b4d7b9c44b332686f32 = cache_frame_e398f1d99b089b4d7b9c44b332686f32;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e398f1d99b089b4d7b9c44b332686f32 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e398f1d99b089b4d7b9c44b332686f32 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 552;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_string );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 552;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 552;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_type;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_e398f1d99b089b4d7b9c44b332686f32->m_frame.f_lineno = 552;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_SSLeay_version, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 552;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_e398f1d99b089b4d7b9c44b332686f32->m_frame.f_lineno = 552;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 552;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e398f1d99b089b4d7b9c44b332686f32 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e398f1d99b089b4d7b9c44b332686f32 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e398f1d99b089b4d7b9c44b332686f32 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e398f1d99b089b4d7b9c44b332686f32, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e398f1d99b089b4d7b9c44b332686f32->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e398f1d99b089b4d7b9c44b332686f32, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e398f1d99b089b4d7b9c44b332686f32,
        type_description_1,
        par_type
    );


    // Release cached frame.
    if ( frame_e398f1d99b089b4d7b9c44b332686f32 == cache_frame_e398f1d99b089b4d7b9c44b332686f32 )
    {
        Py_DECREF( frame_e398f1d99b089b4d7b9c44b332686f32 );
    }
    cache_frame_e398f1d99b089b4d7b9c44b332686f32 = NULL;

    assertFrameObject( frame_e398f1d99b089b4d7b9c44b332686f32 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_8_SSLeay_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_8_SSLeay_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_9__make_requires( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_flag = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_error = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var__requires_decorator = NULL;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = MAKE_FUNCTION_OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator( par_error, par_flag );
    assert( var__requires_decorator == NULL );
    var__requires_decorator = tmp_assign_source_1;

    // Tried code:
    tmp_return_value = var__requires_decorator;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_9__make_requires );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_flag );
    Py_DECREF( par_flag );
    par_flag = NULL;

    CHECK_OBJECT( (PyObject *)var__requires_decorator );
    Py_DECREF( var__requires_decorator );
    var__requires_decorator = NULL;

    CHECK_OBJECT( (PyObject *)par_error );
    Py_DECREF( par_error );
    par_error = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_9__make_requires );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_func = python_pars[ 0 ];
    PyObject *var_explode = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_08887bdadd93093833a6269bac10532c = NULL;

    struct Nuitka_FrameObject *frame_08887bdadd93093833a6269bac10532c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_08887bdadd93093833a6269bac10532c, codeobj_08887bdadd93093833a6269bac10532c, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_08887bdadd93093833a6269bac10532c = cache_frame_08887bdadd93093833a6269bac10532c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_08887bdadd93093833a6269bac10532c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_08887bdadd93093833a6269bac10532c ) == 2 ); // Frame stack

    // Framed code:
    if ( self->m_closure[1] == NULL )
    {
        tmp_cond_value_1 = NULL;
    }
    else
    {
        tmp_cond_value_1 = PyCell_GET( self->m_closure[1] );
    }

    if ( tmp_cond_value_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "flag" );
        exception_tb = NULL;

        exception_lineno = 567;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 567;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
        exception_tb = NULL;

        exception_lineno = 569;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_func;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_08887bdadd93093833a6269bac10532c->m_frame.f_lineno = 569;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 569;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = MAKE_FUNCTION_OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator$$$function_1_explode( self->m_closure[0] );
    frame_08887bdadd93093833a6269bac10532c->m_frame.f_lineno = 569;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 569;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }
    assert( var_explode == NULL );
    var_explode = tmp_assign_source_1;

    tmp_return_value = var_explode;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_return_value = par_func;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08887bdadd93093833a6269bac10532c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_08887bdadd93093833a6269bac10532c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08887bdadd93093833a6269bac10532c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_08887bdadd93093833a6269bac10532c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_08887bdadd93093833a6269bac10532c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_08887bdadd93093833a6269bac10532c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_08887bdadd93093833a6269bac10532c,
        type_description_1,
        par_func,
        var_explode,
        self->m_closure[1]
    );


    // Release cached frame.
    if ( frame_08887bdadd93093833a6269bac10532c == cache_frame_08887bdadd93093833a6269bac10532c )
    {
        Py_DECREF( frame_08887bdadd93093833a6269bac10532c );
    }
    cache_frame_08887bdadd93093833a6269bac10532c = NULL;

    assertFrameObject( frame_08887bdadd93093833a6269bac10532c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_explode );
    var_explode = NULL;

    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator$$$function_1_explode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_args = python_pars[ 0 ];
    PyObject *par_kwargs = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    static struct Nuitka_FrameObject *cache_frame_063bd03355e78d04c83a3ed99d0f9b6f = NULL;

    struct Nuitka_FrameObject *frame_063bd03355e78d04c83a3ed99d0f9b6f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_063bd03355e78d04c83a3ed99d0f9b6f, codeobj_063bd03355e78d04c83a3ed99d0f9b6f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_063bd03355e78d04c83a3ed99d0f9b6f = cache_frame_063bd03355e78d04c83a3ed99d0f9b6f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_063bd03355e78d04c83a3ed99d0f9b6f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_063bd03355e78d04c83a3ed99d0f9b6f ) == 2 ); // Frame stack

    // Framed code:
    if ( self->m_closure[0] == NULL )
    {
        tmp_make_exception_arg_1 = NULL;
    }
    else
    {
        tmp_make_exception_arg_1 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_make_exception_arg_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "error" );
        exception_tb = NULL;

        exception_lineno = 571;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }

    frame_063bd03355e78d04c83a3ed99d0f9b6f->m_frame.f_lineno = 571;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 571;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooc";
    goto frame_exception_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_063bd03355e78d04c83a3ed99d0f9b6f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_063bd03355e78d04c83a3ed99d0f9b6f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_063bd03355e78d04c83a3ed99d0f9b6f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_063bd03355e78d04c83a3ed99d0f9b6f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_063bd03355e78d04c83a3ed99d0f9b6f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_063bd03355e78d04c83a3ed99d0f9b6f,
        type_description_1,
        par_args,
        par_kwargs,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_063bd03355e78d04c83a3ed99d0f9b6f == cache_frame_063bd03355e78d04c83a3ed99d0f9b6f )
    {
        Py_DECREF( frame_063bd03355e78d04c83a3ed99d0f9b6f );
    }
    cache_frame_063bd03355e78d04c83a3ed99d0f9b6f = NULL;

    assertFrameObject( frame_063bd03355e78d04c83a3ed99d0f9b6f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator$$$function_1_explode );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator$$$function_1_explode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct OpenSSL$SSL$$$genexpr_1_genexpr_locals {
    PyObject *var_identifier
    PyObject *var_name
    PyObject *tmp_iter_value_0
    PyObject *tmp_tuple_unpack_1__element_1
    PyObject *tmp_tuple_unpack_1__element_2
    PyObject *tmp_tuple_unpack_1__source_iter
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    int exception_keeper_lineno_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_getattr_attr_1;
    PyObject *tmp_getattr_attr_2;
    PyObject *tmp_getattr_default_1;
    PyObject *tmp_getattr_target_1;
    PyObject *tmp_getattr_target_2;
    bool tmp_isnot_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *OpenSSL$SSL$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void OpenSSL$SSL$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_identifier = NULL;
    PyObject *var_name = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_getattr_attr_1;
    PyObject *tmp_getattr_attr_2;
    PyObject *tmp_getattr_default_1;
    PyObject *tmp_getattr_target_1;
    PyObject *tmp_getattr_target_2;
    bool tmp_isnot_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_666efd733c0235abde1396b39c7b9f90, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "Noo";
        exception_lineno = 620;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 620;
        type_description_1 = "Noo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    // Tried code:
    tmp_iter_arg_1 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 620;
        type_description_1 = "Noo";
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__source_iter;
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    // Tried code:
    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_1 );
    tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "Noo";
        exception_lineno = 620;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_1;
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_2 );
    tmp_assign_source_4 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_4 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "Noo";
        exception_lineno = 620;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_2;
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_1 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "Noo";
                exception_lineno = 620;
                goto try_except_handler_5;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        type_description_1 = "Noo";
        exception_lineno = 620;
        goto try_except_handler_5;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_4;
    // End of try:
    try_end_2:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_2;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    tmp_assign_source_5 = tmp_tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_assign_source_5 );
    {
        PyObject *old = var_identifier;
        var_identifier = tmp_assign_source_5;
        Py_INCREF( var_identifier );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    tmp_assign_source_6 = tmp_tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_assign_source_6 );
    {
        PyObject *old = var_name;
        var_name = tmp_assign_source_6;
        Py_INCREF( var_name );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    tmp_getattr_target_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_getattr_target_1 == NULL ))
    {
        tmp_getattr_target_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_getattr_target_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 622;
        type_description_1 = "Noo";
        goto try_except_handler_2;
    }

    tmp_getattr_attr_1 = var_name;

    CHECK_OBJECT( tmp_getattr_attr_1 );
    tmp_getattr_default_1 = Py_None;
    tmp_compare_left_2 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1 );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 622;
        type_description_1 = "Noo";
        goto try_except_handler_2;
    }
    tmp_compare_right_2 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_2 != tmp_compare_right_2 );
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_expression_name_1 = PyTuple_New( 2 );
    tmp_tuple_element_1 = var_identifier;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_expression_name_1, 0, tmp_tuple_element_1 );
    tmp_getattr_target_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_getattr_target_2 == NULL ))
    {
        tmp_getattr_target_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_getattr_target_2 == NULL )
    {
        Py_DECREF( tmp_expression_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 620;
        type_description_1 = "Noo";
        goto try_except_handler_2;
    }

    tmp_getattr_attr_2 = var_name;

    CHECK_OBJECT( tmp_getattr_attr_2 );
    tmp_tuple_element_1 = BUILTIN_GETATTR( tmp_getattr_target_2, tmp_getattr_attr_2, NULL );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_1 );

        exception_lineno = 620;
        type_description_1 = "Noo";
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_expression_name_1, 1, tmp_tuple_element_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 620;
        type_description_1 = "Noo";
        goto try_except_handler_2;
    }
    branch_no_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 620;
        type_description_1 = "Noo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_identifier,
            var_name
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_5;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_identifier );
    var_identifier = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:
    try_end_5:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_identifier );
    var_identifier = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_OpenSSL$SSL$$$function_10___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_method = python_pars[ 1 ];
    PyObject *var_method_obj = NULL;
    PyObject *var_res = NULL;
    PyObject *var_context = NULL;
    PyObject *var_method_func = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_name_5;
    PyObject *tmp_assattr_name_6;
    PyObject *tmp_assattr_name_7;
    PyObject *tmp_assattr_name_8;
    PyObject *tmp_assattr_name_9;
    PyObject *tmp_assattr_name_10;
    PyObject *tmp_assattr_name_11;
    PyObject *tmp_assattr_name_12;
    PyObject *tmp_assattr_name_13;
    PyObject *tmp_assattr_name_14;
    PyObject *tmp_assattr_name_15;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assattr_target_5;
    PyObject *tmp_assattr_target_6;
    PyObject *tmp_assattr_target_7;
    PyObject *tmp_assattr_target_8;
    PyObject *tmp_assattr_target_9;
    PyObject *tmp_assattr_target_10;
    PyObject *tmp_assattr_target_11;
    PyObject *tmp_assattr_target_12;
    PyObject *tmp_assattr_target_13;
    PyObject *tmp_assattr_target_14;
    PyObject *tmp_assattr_target_15;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_5973516a5de55b67ec5f148e8c29eb73 = NULL;

    struct Nuitka_FrameObject *frame_5973516a5de55b67ec5f148e8c29eb73;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5973516a5de55b67ec5f148e8c29eb73, codeobj_5973516a5de55b67ec5f148e8c29eb73, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5973516a5de55b67ec5f148e8c29eb73 = cache_frame_5973516a5de55b67ec5f148e8c29eb73;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5973516a5de55b67ec5f148e8c29eb73 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5973516a5de55b67ec5f148e8c29eb73 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_method;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 626;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 626;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_c8e9b5ff5b00d8190ecae28b8a410248;
    frame_5973516a5de55b67ec5f148e8c29eb73->m_frame.f_lineno = 627;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 627;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    // Tried code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__methods );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 630;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_subscript_name_1 = par_method;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 630;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    assert( var_method_func == NULL );
    var_method_func = tmp_assign_source_1;

    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_5973516a5de55b67ec5f148e8c29eb73 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_5973516a5de55b67ec5f148e8c29eb73, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_5973516a5de55b67ec5f148e8c29eb73, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = PyExc_KeyError;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 631;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_685ba6a7380a18939915178358979194;
    frame_5973516a5de55b67ec5f148e8c29eb73->m_frame.f_lineno = 632;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 632;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooo";
    goto frame_exception_exit_1;
    goto branch_end_2;
    branch_no_2:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 629;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_5973516a5de55b67ec5f148e8c29eb73->m_frame) frame_5973516a5de55b67ec5f148e8c29eb73->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooooo";
    goto frame_exception_exit_1;
    branch_end_2:;
    // End of try:
    try_end_1:;
    tmp_called_name_1 = var_method_func;

    CHECK_OBJECT( tmp_called_name_1 );
    frame_5973516a5de55b67ec5f148e8c29eb73->m_frame.f_lineno = 634;
    tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 634;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_method_obj == NULL );
    var_method_obj = tmp_assign_source_2;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 635;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_method_obj;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 635;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 635;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 635;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_5973516a5de55b67ec5f148e8c29eb73->m_frame.f_lineno = 635;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 635;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 637;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_method_obj;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_5973516a5de55b67ec5f148e8c29eb73->m_frame.f_lineno = 637;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_SSL_CTX_new, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 637;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_context == NULL );
    var_context = tmp_assign_source_3;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 638;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_2 = var_context;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 638;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 638;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = RICH_COMPARE_NE( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 638;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_5973516a5de55b67ec5f148e8c29eb73->m_frame.f_lineno = 638;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 638;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 639;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_gc );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 639;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = var_context;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 639;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_SSL_CTX_free );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 639;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_5973516a5de55b67ec5f148e8c29eb73->m_frame.f_lineno = 639;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 639;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_context;
        assert( old != NULL );
        var_context = tmp_assign_source_4;
        Py_DECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 644;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = var_context;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = const_int_pos_1;
    frame_5973516a5de55b67ec5f148e8c29eb73->m_frame.f_lineno = 644;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_SSL_CTX_set_ecdh_auto, call_args );
    }

    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 644;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_res == NULL );
    var_res = tmp_assign_source_5;

    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 645;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_3 = var_res;

    CHECK_OBJECT( tmp_compexpr_left_3 );
    tmp_compexpr_right_3 = const_int_pos_1;
    tmp_args_element_name_8 = RICH_COMPARE_EQ( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 645;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_5973516a5de55b67ec5f148e8c29eb73->m_frame.f_lineno = 645;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 645;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_1 = var_context;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__context, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 647;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = Py_None;
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__passphrase_helper, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 648;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = Py_None;
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__passphrase_callback, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 649;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_4 = Py_None;
    tmp_assattr_target_4 = par_self;

    CHECK_OBJECT( tmp_assattr_target_4 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__passphrase_userdata, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 650;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_5 = Py_None;
    tmp_assattr_target_5 = par_self;

    CHECK_OBJECT( tmp_assattr_target_5 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain__verify_helper, tmp_assattr_name_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 651;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_6 = Py_None;
    tmp_assattr_target_6 = par_self;

    CHECK_OBJECT( tmp_assattr_target_6 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain__verify_callback, tmp_assattr_name_6 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 652;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_7 = Py_None;
    tmp_assattr_target_7 = par_self;

    CHECK_OBJECT( tmp_assattr_target_7 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain__info_callback, tmp_assattr_name_7 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 653;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_8 = Py_None;
    tmp_assattr_target_8 = par_self;

    CHECK_OBJECT( tmp_assattr_target_8 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain__keylog_callback, tmp_assattr_name_8 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 654;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_9 = Py_None;
    tmp_assattr_target_9 = par_self;

    CHECK_OBJECT( tmp_assattr_target_9 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain__tlsext_servername_callback, tmp_assattr_name_9 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 655;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_10 = Py_None;
    tmp_assattr_target_10 = par_self;

    CHECK_OBJECT( tmp_assattr_target_10 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain__app_data, tmp_assattr_name_10 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 656;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_11 = Py_None;
    tmp_assattr_target_11 = par_self;

    CHECK_OBJECT( tmp_assattr_target_11 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_11, const_str_plain__alpn_select_helper, tmp_assattr_name_11 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 657;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_12 = Py_None;
    tmp_assattr_target_12 = par_self;

    CHECK_OBJECT( tmp_assattr_target_12 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_12, const_str_plain__alpn_select_callback, tmp_assattr_name_12 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 658;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_13 = Py_None;
    tmp_assattr_target_13 = par_self;

    CHECK_OBJECT( tmp_assattr_target_13 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_13, const_str_plain__ocsp_helper, tmp_assattr_name_13 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 659;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_14 = Py_None;
    tmp_assattr_target_14 = par_self;

    CHECK_OBJECT( tmp_assattr_target_14 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_14, const_str_plain__ocsp_callback, tmp_assattr_name_14 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 660;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_15 = Py_None;
    tmp_assattr_target_15 = par_self;

    CHECK_OBJECT( tmp_assattr_target_15 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_15, const_str_plain__ocsp_data, tmp_assattr_name_15 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 661;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_set_mode );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 663;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 663;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_SSL_MODE_ENABLE_PARTIAL_WRITE );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 663;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_5973516a5de55b67ec5f148e8c29eb73->m_frame.f_lineno = 663;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 663;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 1
    RESTORE_FRAME_EXCEPTION( frame_5973516a5de55b67ec5f148e8c29eb73 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_5973516a5de55b67ec5f148e8c29eb73 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5973516a5de55b67ec5f148e8c29eb73, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5973516a5de55b67ec5f148e8c29eb73->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5973516a5de55b67ec5f148e8c29eb73, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5973516a5de55b67ec5f148e8c29eb73,
        type_description_1,
        par_self,
        par_method,
        var_method_obj,
        var_res,
        var_context,
        var_method_func
    );


    // Release cached frame.
    if ( frame_5973516a5de55b67ec5f148e8c29eb73 == cache_frame_5973516a5de55b67ec5f148e8c29eb73 )
    {
        Py_DECREF( frame_5973516a5de55b67ec5f148e8c29eb73 );
    }
    cache_frame_5973516a5de55b67ec5f148e8c29eb73 = NULL;

    assertFrameObject( frame_5973516a5de55b67ec5f148e8c29eb73 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_10___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_method_obj );
    Py_DECREF( var_method_obj );
    var_method_obj = NULL;

    CHECK_OBJECT( (PyObject *)var_res );
    Py_DECREF( var_res );
    var_res = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_context );
    Py_DECREF( var_context );
    var_context = NULL;

    CHECK_OBJECT( (PyObject *)par_method );
    Py_DECREF( par_method );
    par_method = NULL;

    CHECK_OBJECT( (PyObject *)var_method_func );
    Py_DECREF( var_method_func );
    var_method_func = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_method_obj );
    var_method_obj = NULL;

    Py_XDECREF( var_res );
    var_res = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_context );
    var_context = NULL;

    CHECK_OBJECT( (PyObject *)par_method );
    Py_DECREF( par_method );
    par_method = NULL;

    Py_XDECREF( var_method_func );
    var_method_func = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_10___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_11_load_verify_locations( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cafile = python_pars[ 1 ];
    PyObject *par_capath = python_pars[ 2 ];
    PyObject *var_load_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    bool tmp_is_1;
    bool tmp_is_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_d9c6f022e88d1a70d6925713b6a4247b = NULL;

    struct Nuitka_FrameObject *frame_d9c6f022e88d1a70d6925713b6a4247b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d9c6f022e88d1a70d6925713b6a4247b, codeobj_d9c6f022e88d1a70d6925713b6a4247b, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d9c6f022e88d1a70d6925713b6a4247b = cache_frame_d9c6f022e88d1a70d6925713b6a4247b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d9c6f022e88d1a70d6925713b6a4247b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d9c6f022e88d1a70d6925713b6a4247b ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_cafile;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 682;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 682;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_cafile;
        assert( old != NULL );
        par_cafile = tmp_assign_source_1;
        Py_DECREF( old );
    }

    goto branch_end_1;
    branch_no_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
        exception_tb = NULL;

        exception_lineno = 684;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_cafile;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_d9c6f022e88d1a70d6925713b6a4247b->m_frame.f_lineno = 684;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 684;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_cafile;
        assert( old != NULL );
        par_cafile = tmp_assign_source_2;
        Py_DECREF( old );
    }

    branch_end_1:;
    tmp_compare_left_2 = par_capath;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = Py_None;
    tmp_is_2 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    if ( tmp_is_2 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 687;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 687;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_capath;
        assert( old != NULL );
        par_capath = tmp_assign_source_3;
        Py_DECREF( old );
    }

    goto branch_end_2;
    branch_no_2:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
        exception_tb = NULL;

        exception_lineno = 689;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_capath;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_d9c6f022e88d1a70d6925713b6a4247b->m_frame.f_lineno = 689;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 689;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_capath;
        assert( old != NULL );
        par_capath = tmp_assign_source_4;
        Py_DECREF( old );
    }

    branch_end_2:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 691;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_load_verify_locations );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 691;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 692;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_cafile;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_args_element_name_5 = par_capath;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_d9c6f022e88d1a70d6925713b6a4247b->m_frame.f_lineno = 691;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 691;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_load_result == NULL );
    var_load_result = tmp_assign_source_5;

    tmp_cond_value_1 = var_load_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 694;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 695;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_d9c6f022e88d1a70d6925713b6a4247b->m_frame.f_lineno = 695;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 695;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9c6f022e88d1a70d6925713b6a4247b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9c6f022e88d1a70d6925713b6a4247b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d9c6f022e88d1a70d6925713b6a4247b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d9c6f022e88d1a70d6925713b6a4247b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d9c6f022e88d1a70d6925713b6a4247b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d9c6f022e88d1a70d6925713b6a4247b,
        type_description_1,
        par_self,
        par_cafile,
        par_capath,
        var_load_result
    );


    // Release cached frame.
    if ( frame_d9c6f022e88d1a70d6925713b6a4247b == cache_frame_d9c6f022e88d1a70d6925713b6a4247b )
    {
        Py_DECREF( frame_d9c6f022e88d1a70d6925713b6a4247b );
    }
    cache_frame_d9c6f022e88d1a70d6925713b6a4247b = NULL;

    assertFrameObject( frame_d9c6f022e88d1a70d6925713b6a4247b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_11_load_verify_locations );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_capath );
    Py_DECREF( par_capath );
    par_capath = NULL;

    CHECK_OBJECT( (PyObject *)par_cafile );
    Py_DECREF( par_cafile );
    par_cafile = NULL;

    CHECK_OBJECT( (PyObject *)var_load_result );
    Py_DECREF( var_load_result );
    var_load_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_capath );
    par_capath = NULL;

    Py_XDECREF( par_cafile );
    par_cafile = NULL;

    Py_XDECREF( var_load_result );
    var_load_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_11_load_verify_locations );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_12__wrap_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_367ddb5676f8f9ebb625b6c3a765d683 = NULL;

    struct Nuitka_FrameObject *frame_367ddb5676f8f9ebb625b6c3a765d683;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_367ddb5676f8f9ebb625b6c3a765d683, codeobj_367ddb5676f8f9ebb625b6c3a765d683, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_367ddb5676f8f9ebb625b6c3a765d683 = cache_frame_367ddb5676f8f9ebb625b6c3a765d683;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_367ddb5676f8f9ebb625b6c3a765d683 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_367ddb5676f8f9ebb625b6c3a765d683 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
        exception_tb = NULL;

        exception_lineno = 698;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    if ( par_callback == NULL )
    {
        tmp_args_element_name_1 = NULL;
    }
    else
    {
        tmp_args_element_name_1 = PyCell_GET( par_callback );
    }

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_367ddb5676f8f9ebb625b6c3a765d683->m_frame.f_lineno = 698;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 698;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = MAKE_FUNCTION_OpenSSL$SSL$$$function_12__wrap_callback$$$function_1_wrapper( par_callback, par_self );
    frame_367ddb5676f8f9ebb625b6c3a765d683->m_frame.f_lineno = 698;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 698;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    assert( var_wrapper == NULL );
    var_wrapper = tmp_assign_source_1;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__PassphraseHelper );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PassphraseHelper );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_PassphraseHelper" );
        exception_tb = NULL;

        exception_lineno = 702;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 2 );
    tmp_tuple_element_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_tuple_element_1 == NULL ))
    {
        tmp_tuple_element_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_tuple_element_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 703;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_wrapper;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_kw_name_1 = PyDict_Copy( const_dict_4a96d2f6310f0842d222254905a83466 );
    frame_367ddb5676f8f9ebb625b6c3a765d683->m_frame.f_lineno = 702;
    tmp_return_value = CALL_FUNCTION( tmp_called_name_3, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 702;
        type_description_1 = "cco";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_367ddb5676f8f9ebb625b6c3a765d683 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_367ddb5676f8f9ebb625b6c3a765d683 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_367ddb5676f8f9ebb625b6c3a765d683 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_367ddb5676f8f9ebb625b6c3a765d683, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_367ddb5676f8f9ebb625b6c3a765d683->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_367ddb5676f8f9ebb625b6c3a765d683, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_367ddb5676f8f9ebb625b6c3a765d683,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_367ddb5676f8f9ebb625b6c3a765d683 == cache_frame_367ddb5676f8f9ebb625b6c3a765d683 )
    {
        Py_DECREF( frame_367ddb5676f8f9ebb625b6c3a765d683 );
    }
    cache_frame_367ddb5676f8f9ebb625b6c3a765d683 = NULL;

    assertFrameObject( frame_367ddb5676f8f9ebb625b6c3a765d683 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_12__wrap_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_12__wrap_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_12__wrap_callback$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_size = python_pars[ 0 ];
    PyObject *par_verify = python_pars[ 1 ];
    PyObject *par_userdata = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_ea8cd308a788cb7a890b205884b79311 = NULL;

    struct Nuitka_FrameObject *frame_ea8cd308a788cb7a890b205884b79311;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ea8cd308a788cb7a890b205884b79311, codeobj_ea8cd308a788cb7a890b205884b79311, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ea8cd308a788cb7a890b205884b79311 = cache_frame_ea8cd308a788cb7a890b205884b79311;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ea8cd308a788cb7a890b205884b79311 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ea8cd308a788cb7a890b205884b79311 ) == 2 ); // Frame stack

    // Framed code:
    if ( self->m_closure[0] == NULL )
    {
        tmp_called_name_1 = NULL;
    }
    else
    {
        tmp_called_name_1 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
        exception_tb = NULL;

        exception_lineno = 700;
        type_description_1 = "ooocc";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_size;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = par_verify;

    CHECK_OBJECT( tmp_args_element_name_2 );
    if ( self->m_closure[1] == NULL )
    {
        tmp_source_name_1 = NULL;
    }
    else
    {
        tmp_source_name_1 = PyCell_GET( self->m_closure[1] );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
        exception_tb = NULL;

        exception_lineno = 700;
        type_description_1 = "ooocc";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__passphrase_userdata );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 700;
        type_description_1 = "ooocc";
        goto frame_exception_exit_1;
    }
    frame_ea8cd308a788cb7a890b205884b79311->m_frame.f_lineno = 700;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 700;
        type_description_1 = "ooocc";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ea8cd308a788cb7a890b205884b79311 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ea8cd308a788cb7a890b205884b79311 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ea8cd308a788cb7a890b205884b79311 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ea8cd308a788cb7a890b205884b79311, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ea8cd308a788cb7a890b205884b79311->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ea8cd308a788cb7a890b205884b79311, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ea8cd308a788cb7a890b205884b79311,
        type_description_1,
        par_size,
        par_verify,
        par_userdata,
        self->m_closure[1],
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_ea8cd308a788cb7a890b205884b79311 == cache_frame_ea8cd308a788cb7a890b205884b79311 )
    {
        Py_DECREF( frame_ea8cd308a788cb7a890b205884b79311 );
    }
    cache_frame_ea8cd308a788cb7a890b205884b79311 = NULL;

    assertFrameObject( frame_ea8cd308a788cb7a890b205884b79311 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_12__wrap_callback$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_verify );
    Py_DECREF( par_verify );
    par_verify = NULL;

    CHECK_OBJECT( (PyObject *)par_userdata );
    Py_DECREF( par_userdata );
    par_userdata = NULL;

    CHECK_OBJECT( (PyObject *)par_size );
    Py_DECREF( par_size );
    par_size = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_verify );
    Py_DECREF( par_verify );
    par_verify = NULL;

    CHECK_OBJECT( (PyObject *)par_userdata );
    Py_DECREF( par_userdata );
    par_userdata = NULL;

    CHECK_OBJECT( (PyObject *)par_size );
    Py_DECREF( par_size );
    par_size = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_12__wrap_callback$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_13_set_passwd_cb( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_callback = python_pars[ 1 ];
    PyObject *par_userdata = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_3b53e64ae4d15799dfacfe9ba165e79a = NULL;

    struct Nuitka_FrameObject *frame_3b53e64ae4d15799dfacfe9ba165e79a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3b53e64ae4d15799dfacfe9ba165e79a, codeobj_3b53e64ae4d15799dfacfe9ba165e79a, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3b53e64ae4d15799dfacfe9ba165e79a = cache_frame_3b53e64ae4d15799dfacfe9ba165e79a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3b53e64ae4d15799dfacfe9ba165e79a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3b53e64ae4d15799dfacfe9ba165e79a ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_callable );
    assert( tmp_called_name_1 != NULL );
    tmp_args_element_name_1 = par_callback;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_3b53e64ae4d15799dfacfe9ba165e79a->m_frame.f_lineno = 725;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 725;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 725;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_3462bf983701fbd7caf2f521f5975fff;
    frame_3b53e64ae4d15799dfacfe9ba165e79a->m_frame.f_lineno = 726;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 726;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_2 = par_callback;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_3b53e64ae4d15799dfacfe9ba165e79a->m_frame.f_lineno = 728;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__wrap_callback, call_args );
    }

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 728;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__passphrase_helper, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 728;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__passphrase_helper );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 729;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_callback );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 729;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__passphrase_callback, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 729;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 730;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_set_default_passwd_cb );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 730;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 731;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__passphrase_callback );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 731;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_3b53e64ae4d15799dfacfe9ba165e79a->m_frame.f_lineno = 730;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 730;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_3 = par_userdata;

    CHECK_OBJECT( tmp_assattr_name_3 );
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__passphrase_userdata, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 733;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3b53e64ae4d15799dfacfe9ba165e79a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3b53e64ae4d15799dfacfe9ba165e79a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3b53e64ae4d15799dfacfe9ba165e79a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3b53e64ae4d15799dfacfe9ba165e79a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3b53e64ae4d15799dfacfe9ba165e79a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3b53e64ae4d15799dfacfe9ba165e79a,
        type_description_1,
        par_self,
        par_callback,
        par_userdata
    );


    // Release cached frame.
    if ( frame_3b53e64ae4d15799dfacfe9ba165e79a == cache_frame_3b53e64ae4d15799dfacfe9ba165e79a )
    {
        Py_DECREF( frame_3b53e64ae4d15799dfacfe9ba165e79a );
    }
    cache_frame_3b53e64ae4d15799dfacfe9ba165e79a = NULL;

    assertFrameObject( frame_3b53e64ae4d15799dfacfe9ba165e79a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_13_set_passwd_cb );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_userdata );
    Py_DECREF( par_userdata );
    par_userdata = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_userdata );
    Py_DECREF( par_userdata );
    par_userdata = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_13_set_passwd_cb );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_14_set_default_verify_paths( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_default_dir = NULL;
    PyObject *var_set_result = NULL;
    PyObject *var_dir_env_var = NULL;
    PyObject *var_file_env_var = NULL;
    PyObject *var_default_file = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_b4423fe8f1ca9b3a46b290e554de7290 = NULL;

    struct Nuitka_FrameObject *frame_b4423fe8f1ca9b3a46b290e554de7290;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b4423fe8f1ca9b3a46b290e554de7290, codeobj_b4423fe8f1ca9b3a46b290e554de7290, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b4423fe8f1ca9b3a46b290e554de7290 = cache_frame_b4423fe8f1ca9b3a46b290e554de7290;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b4423fe8f1ca9b3a46b290e554de7290 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b4423fe8f1ca9b3a46b290e554de7290 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 755;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_default_verify_paths );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 755;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 755;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 755;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 755;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_set_result == NULL );
    var_set_result = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 756;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_set_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_2 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 756;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 756;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 756;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 762;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_string );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 762;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 762;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 762;
    tmp_args_element_name_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_X509_get_default_cert_dir_env );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 762;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 762;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_called_instance_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 762;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 762;
    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 762;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_dir_env_var == NULL );
    var_dir_env_var = tmp_assign_source_2;

    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 765;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_string );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 765;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 766;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 766;
    tmp_args_element_name_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_X509_get_default_cert_file_env );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 766;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 765;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_called_instance_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 765;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 765;
    tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 765;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_file_env_var == NULL );
    var_file_env_var = tmp_assign_source_3;

    tmp_called_instance_5 = par_self;

    CHECK_OBJECT( tmp_called_instance_5 );
    tmp_args_element_name_5 = var_dir_env_var;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = var_file_env_var;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 768;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_cond_value_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_5, const_str_plain__check_env_vars_set, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 768;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 768;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 769;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_string );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 769;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_6 == NULL ))
    {
        tmp_called_instance_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_6 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 769;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 769;
    tmp_args_element_name_7 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_X509_get_default_cert_dir );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 769;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 769;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 769;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_default_dir == NULL );
    var_default_dir = tmp_assign_source_4;

    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 770;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_string );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 770;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_7 == NULL ))
    {
        tmp_called_instance_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_7 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 770;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 770;
    tmp_args_element_name_8 = CALL_METHOD_NO_ARGS( tmp_called_instance_7, const_str_plain_X509_get_default_cert_file );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 770;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 770;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 770;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_default_file == NULL );
    var_default_file = tmp_assign_source_5;

    tmp_compexpr_left_2 = var_default_dir;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR );

    if (unlikely( tmp_compexpr_right_2 == NULL ))
    {
        tmp_compexpr_right_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR );
    }

    if ( tmp_compexpr_right_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CRYPTOGRAPHY_MANYLINUX1_CA_DIR" );
        exception_tb = NULL;

        exception_lineno = 775;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 775;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 776;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_compexpr_left_3 = var_default_file;

    CHECK_OBJECT( tmp_compexpr_left_3 );
    tmp_compexpr_right_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE );

    if (unlikely( tmp_compexpr_right_3 == NULL ))
    {
        tmp_compexpr_right_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE );
    }

    if ( tmp_compexpr_right_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CRYPTOGRAPHY_MANYLINUX1_CA_FILE" );
        exception_tb = NULL;

        exception_lineno = 776;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_and_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 776;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_2 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_2 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 776;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__fallback_default_verify_paths );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 779;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_FILE_LOCATIONS );

    if (unlikely( tmp_args_element_name_9 == NULL ))
    {
        tmp_args_element_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_FILE_LOCATIONS );
    }

    if ( tmp_args_element_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CERTIFICATE_FILE_LOCATIONS" );
        exception_tb = NULL;

        exception_lineno = 780;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_PATH_LOCATIONS );

    if (unlikely( tmp_args_element_name_10 == NULL ))
    {
        tmp_args_element_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_PATH_LOCATIONS );
    }

    if ( tmp_args_element_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CERTIFICATE_PATH_LOCATIONS" );
        exception_tb = NULL;

        exception_lineno = 780;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame.f_lineno = 779;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 779;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b4423fe8f1ca9b3a46b290e554de7290 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b4423fe8f1ca9b3a46b290e554de7290 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b4423fe8f1ca9b3a46b290e554de7290, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b4423fe8f1ca9b3a46b290e554de7290->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b4423fe8f1ca9b3a46b290e554de7290, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b4423fe8f1ca9b3a46b290e554de7290,
        type_description_1,
        par_self,
        var_default_dir,
        var_set_result,
        var_dir_env_var,
        var_file_env_var,
        var_default_file
    );


    // Release cached frame.
    if ( frame_b4423fe8f1ca9b3a46b290e554de7290 == cache_frame_b4423fe8f1ca9b3a46b290e554de7290 )
    {
        Py_DECREF( frame_b4423fe8f1ca9b3a46b290e554de7290 );
    }
    cache_frame_b4423fe8f1ca9b3a46b290e554de7290 = NULL;

    assertFrameObject( frame_b4423fe8f1ca9b3a46b290e554de7290 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_14_set_default_verify_paths );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_default_dir );
    var_default_dir = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    CHECK_OBJECT( (PyObject *)var_dir_env_var );
    Py_DECREF( var_dir_env_var );
    var_dir_env_var = NULL;

    CHECK_OBJECT( (PyObject *)var_file_env_var );
    Py_DECREF( var_file_env_var );
    var_file_env_var = NULL;

    Py_XDECREF( var_default_file );
    var_default_file = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_default_dir );
    var_default_dir = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    Py_XDECREF( var_dir_env_var );
    var_dir_env_var = NULL;

    Py_XDECREF( var_file_env_var );
    var_file_env_var = NULL;

    Py_XDECREF( var_default_file );
    var_default_file = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_14_set_default_verify_paths );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_15__check_env_vars_set( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_dir_env_var = python_pars[ 1 ];
    PyObject *par_file_env_var = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_2f089a1360ec6540a7885d667632b8af = NULL;

    struct Nuitka_FrameObject *frame_2f089a1360ec6540a7885d667632b8af;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2f089a1360ec6540a7885d667632b8af, codeobj_2f089a1360ec6540a7885d667632b8af, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_2f089a1360ec6540a7885d667632b8af = cache_frame_2f089a1360ec6540a7885d667632b8af;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2f089a1360ec6540a7885d667632b8af );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2f089a1360ec6540a7885d667632b8af ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "os" );
        exception_tb = NULL;

        exception_lineno = 790;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_environ );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 790;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_file_env_var;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_2f089a1360ec6540a7885d667632b8af->m_frame.f_lineno = 790;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_compexpr_left_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_get, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 790;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = Py_None;
    tmp_or_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 != tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    assert( !(tmp_or_left_truth_1 == -1) );
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "os" );
        exception_tb = NULL;

        exception_lineno = 791;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_environ );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 791;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_dir_env_var;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_2f089a1360ec6540a7885d667632b8af->m_frame.f_lineno = 791;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_compexpr_left_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_get, call_args );
    }

    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 791;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_2 = Py_None;
    tmp_or_right_value_1 = BOOL_FROM( tmp_compexpr_left_2 != tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    tmp_return_value = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_return_value = tmp_or_left_value_1;
    or_end_1:;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f089a1360ec6540a7885d667632b8af );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f089a1360ec6540a7885d667632b8af );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f089a1360ec6540a7885d667632b8af );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2f089a1360ec6540a7885d667632b8af, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2f089a1360ec6540a7885d667632b8af->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2f089a1360ec6540a7885d667632b8af, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f089a1360ec6540a7885d667632b8af,
        type_description_1,
        par_self,
        par_dir_env_var,
        par_file_env_var
    );


    // Release cached frame.
    if ( frame_2f089a1360ec6540a7885d667632b8af == cache_frame_2f089a1360ec6540a7885d667632b8af )
    {
        Py_DECREF( frame_2f089a1360ec6540a7885d667632b8af );
    }
    cache_frame_2f089a1360ec6540a7885d667632b8af = NULL;

    assertFrameObject( frame_2f089a1360ec6540a7885d667632b8af );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_15__check_env_vars_set );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dir_env_var );
    Py_DECREF( par_dir_env_var );
    par_dir_env_var = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_file_env_var );
    Py_DECREF( par_file_env_var );
    par_file_env_var = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_dir_env_var );
    Py_DECREF( par_dir_env_var );
    par_dir_env_var = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_file_env_var );
    Py_DECREF( par_file_env_var );
    par_file_env_var = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_15__check_env_vars_set );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_16__fallback_default_verify_paths( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_file_path = python_pars[ 1 ];
    PyObject *par_dir_path = python_pars[ 2 ];
    PyObject *var_capath = NULL;
    PyObject *var_cafile = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    PyObject *tmp_value_name_2;
    static struct Nuitka_FrameObject *cache_frame_0d5bd775cfaaf931ada177403f26906f = NULL;

    struct Nuitka_FrameObject *frame_0d5bd775cfaaf931ada177403f26906f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0d5bd775cfaaf931ada177403f26906f, codeobj_0d5bd775cfaaf931ada177403f26906f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0d5bd775cfaaf931ada177403f26906f = cache_frame_0d5bd775cfaaf931ada177403f26906f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0d5bd775cfaaf931ada177403f26906f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0d5bd775cfaaf931ada177403f26906f ) == 2 ); // Frame stack

    // Framed code:
    tmp_iter_arg_1 = par_file_path;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 804;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooo";
        exception_lineno = 804;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 804;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_cafile;
        var_cafile = tmp_assign_source_3;
        Py_INCREF( var_cafile );
        Py_XDECREF( old );
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "os" );
        exception_tb = NULL;

        exception_lineno = 805;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }

    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_path );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 805;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_1 = var_cafile;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_0d5bd775cfaaf931ada177403f26906f->m_frame.f_lineno = 805;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_isfile, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 805;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 805;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_2 = var_cafile;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_0d5bd775cfaaf931ada177403f26906f->m_frame.f_lineno = 806;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_load_verify_locations, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 806;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto loop_end_1;
    branch_no_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 804;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_iter_arg_2 = par_dir_path;

    CHECK_OBJECT( tmp_iter_arg_2 );
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 809;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_2__for_iterator == NULL );
    tmp_for_loop_2__for_iterator = tmp_assign_source_4;

    // Tried code:
    loop_start_2:;
    // Tried code:
    tmp_value_name_2 = tmp_for_loop_2__for_iterator;

    CHECK_OBJECT( tmp_value_name_2 );
    tmp_assign_source_5 = ITERATOR_NEXT( tmp_value_name_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooo";
        exception_lineno = 809;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_for_loop_2__iter_value;
        tmp_for_loop_2__iter_value = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    goto try_end_3;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_2 = exception_keeper_type_3;
    tmp_compare_right_2 = PyExc_StopIteration;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_3 );
        Py_XDECREF( exception_keeper_value_3 );
        Py_XDECREF( exception_keeper_tb_3 );

        exception_lineno = 809;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    Py_DECREF( exception_keeper_type_3 );
    Py_XDECREF( exception_keeper_value_3 );
    Py_XDECREF( exception_keeper_tb_3 );
    goto loop_end_2;
    goto branch_end_3;
    branch_no_3:;
    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_4;
    branch_end_3:;
    // End of try:
    try_end_3:;
    tmp_assign_source_6 = tmp_for_loop_2__iter_value;

    CHECK_OBJECT( tmp_assign_source_6 );
    {
        PyObject *old = var_capath;
        var_capath = tmp_assign_source_6;
        Py_INCREF( var_capath );
        Py_XDECREF( old );
    }

    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "os" );
        exception_tb = NULL;

        exception_lineno = 810;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }

    tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_path );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 810;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    tmp_args_element_name_3 = var_capath;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_0d5bd775cfaaf931ada177403f26906f->m_frame.f_lineno = 810;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_cond_value_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_isdir, call_args );
    }

    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 810;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 810;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    tmp_args_element_name_4 = Py_None;
    tmp_args_element_name_5 = var_capath;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_0d5bd775cfaaf931ada177403f26906f->m_frame.f_lineno = 811;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_4, const_str_plain_load_verify_locations, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 811;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    goto loop_end_2;
    branch_no_4:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 809;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d5bd775cfaaf931ada177403f26906f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d5bd775cfaaf931ada177403f26906f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0d5bd775cfaaf931ada177403f26906f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0d5bd775cfaaf931ada177403f26906f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0d5bd775cfaaf931ada177403f26906f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0d5bd775cfaaf931ada177403f26906f,
        type_description_1,
        par_self,
        par_file_path,
        par_dir_path,
        var_capath,
        var_cafile
    );


    // Release cached frame.
    if ( frame_0d5bd775cfaaf931ada177403f26906f == cache_frame_0d5bd775cfaaf931ada177403f26906f )
    {
        Py_DECREF( frame_0d5bd775cfaaf931ada177403f26906f );
    }
    cache_frame_0d5bd775cfaaf931ada177403f26906f = NULL;

    assertFrameObject( frame_0d5bd775cfaaf931ada177403f26906f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_16__fallback_default_verify_paths );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_capath );
    var_capath = NULL;

    Py_XDECREF( var_cafile );
    var_cafile = NULL;

    CHECK_OBJECT( (PyObject *)par_file_path );
    Py_DECREF( par_file_path );
    par_file_path = NULL;

    CHECK_OBJECT( (PyObject *)par_dir_path );
    Py_DECREF( par_dir_path );
    par_dir_path = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_capath );
    var_capath = NULL;

    Py_XDECREF( var_cafile );
    var_cafile = NULL;

    CHECK_OBJECT( (PyObject *)par_file_path );
    Py_DECREF( par_file_path );
    par_file_path = NULL;

    CHECK_OBJECT( (PyObject *)par_dir_path );
    Py_DECREF( par_dir_path );
    par_dir_path = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_16__fallback_default_verify_paths );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_17_use_certificate_chain_file( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_certfile = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_a3496fb28d148bcd6c9a9c8044088e8a = NULL;

    struct Nuitka_FrameObject *frame_a3496fb28d148bcd6c9a9c8044088e8a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a3496fb28d148bcd6c9a9c8044088e8a, codeobj_a3496fb28d148bcd6c9a9c8044088e8a, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a3496fb28d148bcd6c9a9c8044088e8a = cache_frame_a3496fb28d148bcd6c9a9c8044088e8a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a3496fb28d148bcd6c9a9c8044088e8a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a3496fb28d148bcd6c9a9c8044088e8a ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
        exception_tb = NULL;

        exception_lineno = 823;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_certfile;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_a3496fb28d148bcd6c9a9c8044088e8a->m_frame.f_lineno = 823;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_certfile;
        assert( old != NULL );
        par_certfile = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 825;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_use_certificate_chain_file );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 825;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 826;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_certfile;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_a3496fb28d148bcd6c9a9c8044088e8a->m_frame.f_lineno = 825;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 825;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_2;

    tmp_cond_value_1 = var_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 828;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 829;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_a3496fb28d148bcd6c9a9c8044088e8a->m_frame.f_lineno = 829;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 829;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a3496fb28d148bcd6c9a9c8044088e8a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a3496fb28d148bcd6c9a9c8044088e8a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a3496fb28d148bcd6c9a9c8044088e8a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a3496fb28d148bcd6c9a9c8044088e8a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a3496fb28d148bcd6c9a9c8044088e8a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a3496fb28d148bcd6c9a9c8044088e8a,
        type_description_1,
        par_self,
        par_certfile,
        var_result
    );


    // Release cached frame.
    if ( frame_a3496fb28d148bcd6c9a9c8044088e8a == cache_frame_a3496fb28d148bcd6c9a9c8044088e8a )
    {
        Py_DECREF( frame_a3496fb28d148bcd6c9a9c8044088e8a );
    }
    cache_frame_a3496fb28d148bcd6c9a9c8044088e8a = NULL;

    assertFrameObject( frame_a3496fb28d148bcd6c9a9c8044088e8a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_17_use_certificate_chain_file );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certfile );
    Py_DECREF( par_certfile );
    par_certfile = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certfile );
    Py_DECREF( par_certfile );
    par_certfile = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_17_use_certificate_chain_file );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_18_use_certificate_file( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_certfile = python_pars[ 1 ];
    PyObject *par_filetype = python_pars[ 2 ];
    PyObject *var_use_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_a8c1083e5a0e9d5d314d2ea77db9921f = NULL;

    struct Nuitka_FrameObject *frame_a8c1083e5a0e9d5d314d2ea77db9921f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a8c1083e5a0e9d5d314d2ea77db9921f, codeobj_a8c1083e5a0e9d5d314d2ea77db9921f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a8c1083e5a0e9d5d314d2ea77db9921f = cache_frame_a8c1083e5a0e9d5d314d2ea77db9921f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a8c1083e5a0e9d5d314d2ea77db9921f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a8c1083e5a0e9d5d314d2ea77db9921f ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
        exception_tb = NULL;

        exception_lineno = 843;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_certfile;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_a8c1083e5a0e9d5d314d2ea77db9921f->m_frame.f_lineno = 843;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 843;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_certfile;
        assert( old != NULL );
        par_certfile = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_isinstance_inst_1 = par_filetype;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 844;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 844;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_7cf2d06a8643ddce5d0ceedd61c750e1;
    frame_a8c1083e5a0e9d5d314d2ea77db9921f->m_frame.f_lineno = 845;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 845;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 847;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_use_certificate_file );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 847;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 848;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_certfile;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = par_filetype;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_a8c1083e5a0e9d5d314d2ea77db9921f->m_frame.f_lineno = 847;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 847;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_use_result == NULL );
    var_use_result = tmp_assign_source_2;

    tmp_cond_value_1 = var_use_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 850;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 851;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_a8c1083e5a0e9d5d314d2ea77db9921f->m_frame.f_lineno = 851;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 851;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a8c1083e5a0e9d5d314d2ea77db9921f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a8c1083e5a0e9d5d314d2ea77db9921f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a8c1083e5a0e9d5d314d2ea77db9921f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a8c1083e5a0e9d5d314d2ea77db9921f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a8c1083e5a0e9d5d314d2ea77db9921f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a8c1083e5a0e9d5d314d2ea77db9921f,
        type_description_1,
        par_self,
        par_certfile,
        par_filetype,
        var_use_result
    );


    // Release cached frame.
    if ( frame_a8c1083e5a0e9d5d314d2ea77db9921f == cache_frame_a8c1083e5a0e9d5d314d2ea77db9921f )
    {
        Py_DECREF( frame_a8c1083e5a0e9d5d314d2ea77db9921f );
    }
    cache_frame_a8c1083e5a0e9d5d314d2ea77db9921f = NULL;

    assertFrameObject( frame_a8c1083e5a0e9d5d314d2ea77db9921f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_18_use_certificate_file );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certfile );
    Py_DECREF( par_certfile );
    par_certfile = NULL;

    CHECK_OBJECT( (PyObject *)par_filetype );
    Py_DECREF( par_filetype );
    par_filetype = NULL;

    CHECK_OBJECT( (PyObject *)var_use_result );
    Py_DECREF( var_use_result );
    var_use_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certfile );
    Py_DECREF( par_certfile );
    par_certfile = NULL;

    CHECK_OBJECT( (PyObject *)par_filetype );
    Py_DECREF( par_filetype );
    par_filetype = NULL;

    Py_XDECREF( var_use_result );
    var_use_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_18_use_certificate_file );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_19_use_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cert = python_pars[ 1 ];
    PyObject *var_use_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_b23113cd07b644554a3131a5d950cae1 = NULL;

    struct Nuitka_FrameObject *frame_b23113cd07b644554a3131a5d950cae1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b23113cd07b644554a3131a5d950cae1, codeobj_b23113cd07b644554a3131a5d950cae1, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b23113cd07b644554a3131a5d950cae1 = cache_frame_b23113cd07b644554a3131a5d950cae1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b23113cd07b644554a3131a5d950cae1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b23113cd07b644554a3131a5d950cae1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_cert;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 860;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 860;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_c804b213c384a15865e18bf31cfff70e;
    frame_b23113cd07b644554a3131a5d950cae1->m_frame.f_lineno = 861;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 861;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 863;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_use_certificate );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 863;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 863;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_cert;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__x509 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 863;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_b23113cd07b644554a3131a5d950cae1->m_frame.f_lineno = 863;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 863;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_use_result == NULL );
    var_use_result = tmp_assign_source_1;

    tmp_cond_value_1 = var_use_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 864;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 865;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_b23113cd07b644554a3131a5d950cae1->m_frame.f_lineno = 865;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 865;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b23113cd07b644554a3131a5d950cae1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b23113cd07b644554a3131a5d950cae1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b23113cd07b644554a3131a5d950cae1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b23113cd07b644554a3131a5d950cae1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b23113cd07b644554a3131a5d950cae1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b23113cd07b644554a3131a5d950cae1,
        type_description_1,
        par_self,
        par_cert,
        var_use_result
    );


    // Release cached frame.
    if ( frame_b23113cd07b644554a3131a5d950cae1 == cache_frame_b23113cd07b644554a3131a5d950cae1 )
    {
        Py_DECREF( frame_b23113cd07b644554a3131a5d950cae1 );
    }
    cache_frame_b23113cd07b644554a3131a5d950cae1 = NULL;

    assertFrameObject( frame_b23113cd07b644554a3131a5d950cae1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_19_use_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    CHECK_OBJECT( (PyObject *)var_use_result );
    Py_DECREF( var_use_result );
    var_use_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    Py_XDECREF( var_use_result );
    var_use_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_19_use_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_20_add_extra_chain_cert( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_certobj = python_pars[ 1 ];
    PyObject *var_copy = NULL;
    PyObject *var_add_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_c79a0c40ab56e09c1dbb541ab527a740 = NULL;

    struct Nuitka_FrameObject *frame_c79a0c40ab56e09c1dbb541ab527a740;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c79a0c40ab56e09c1dbb541ab527a740, codeobj_c79a0c40ab56e09c1dbb541ab527a740, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c79a0c40ab56e09c1dbb541ab527a740 = cache_frame_c79a0c40ab56e09c1dbb541ab527a740;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c79a0c40ab56e09c1dbb541ab527a740 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c79a0c40ab56e09c1dbb541ab527a740 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_certobj;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 874;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 874;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_e51bcf1ff2d3a73499a1380c77d20ade;
    frame_c79a0c40ab56e09c1dbb541ab527a740->m_frame.f_lineno = 875;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 875;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 877;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_dup );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 877;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_certobj;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 877;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_c79a0c40ab56e09c1dbb541ab527a740->m_frame.f_lineno = 877;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 877;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_copy == NULL );
    var_copy = tmp_assign_source_1;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 878;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_add_extra_chain_cert );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 878;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 878;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_copy;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_c79a0c40ab56e09c1dbb541ab527a740->m_frame.f_lineno = 878;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 878;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_add_result == NULL );
    var_add_result = tmp_assign_source_2;

    tmp_cond_value_1 = var_add_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 879;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 881;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = var_copy;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_c79a0c40ab56e09c1dbb541ab527a740->m_frame.f_lineno = 881;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_free, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 881;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 882;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_c79a0c40ab56e09c1dbb541ab527a740->m_frame.f_lineno = 882;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 882;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c79a0c40ab56e09c1dbb541ab527a740 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c79a0c40ab56e09c1dbb541ab527a740 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c79a0c40ab56e09c1dbb541ab527a740, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c79a0c40ab56e09c1dbb541ab527a740->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c79a0c40ab56e09c1dbb541ab527a740, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c79a0c40ab56e09c1dbb541ab527a740,
        type_description_1,
        par_self,
        par_certobj,
        var_copy,
        var_add_result
    );


    // Release cached frame.
    if ( frame_c79a0c40ab56e09c1dbb541ab527a740 == cache_frame_c79a0c40ab56e09c1dbb541ab527a740 )
    {
        Py_DECREF( frame_c79a0c40ab56e09c1dbb541ab527a740 );
    }
    cache_frame_c79a0c40ab56e09c1dbb541ab527a740 = NULL;

    assertFrameObject( frame_c79a0c40ab56e09c1dbb541ab527a740 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_20_add_extra_chain_cert );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_copy );
    Py_DECREF( var_copy );
    var_copy = NULL;

    CHECK_OBJECT( (PyObject *)par_certobj );
    Py_DECREF( par_certobj );
    par_certobj = NULL;

    CHECK_OBJECT( (PyObject *)var_add_result );
    Py_DECREF( var_add_result );
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_copy );
    var_copy = NULL;

    CHECK_OBJECT( (PyObject *)par_certobj );
    Py_DECREF( par_certobj );
    par_certobj = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_20_add_extra_chain_cert );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_21__raise_passphrase_exception( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_isnot_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_bb672ed8d8171604b1f6c1b3ebba963b = NULL;

    struct Nuitka_FrameObject *frame_bb672ed8d8171604b1f6c1b3ebba963b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bb672ed8d8171604b1f6c1b3ebba963b, codeobj_bb672ed8d8171604b1f6c1b3ebba963b, module_OpenSSL$SSL, sizeof(void *) );
    frame_bb672ed8d8171604b1f6c1b3ebba963b = cache_frame_bb672ed8d8171604b1f6c1b3ebba963b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bb672ed8d8171604b1f6c1b3ebba963b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bb672ed8d8171604b1f6c1b3ebba963b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__passphrase_helper );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 885;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__passphrase_helper );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 886;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_raise_if_problem );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 886;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_args_element_name_1 == NULL ))
    {
        tmp_args_element_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 886;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_bb672ed8d8171604b1f6c1b3ebba963b->m_frame.f_lineno = 886;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 886;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 888;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_bb672ed8d8171604b1f6c1b3ebba963b->m_frame.f_lineno = 888;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 888;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bb672ed8d8171604b1f6c1b3ebba963b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bb672ed8d8171604b1f6c1b3ebba963b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bb672ed8d8171604b1f6c1b3ebba963b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bb672ed8d8171604b1f6c1b3ebba963b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bb672ed8d8171604b1f6c1b3ebba963b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bb672ed8d8171604b1f6c1b3ebba963b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_bb672ed8d8171604b1f6c1b3ebba963b == cache_frame_bb672ed8d8171604b1f6c1b3ebba963b )
    {
        Py_DECREF( frame_bb672ed8d8171604b1f6c1b3ebba963b );
    }
    cache_frame_bb672ed8d8171604b1f6c1b3ebba963b = NULL;

    assertFrameObject( frame_bb672ed8d8171604b1f6c1b3ebba963b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_21__raise_passphrase_exception );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_21__raise_passphrase_exception );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_22_use_privatekey_file( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_keyfile = python_pars[ 1 ];
    PyObject *par_filetype = python_pars[ 2 ];
    PyObject *var_use_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_4de9fae261022cc2df5d1800c2c051e5 = NULL;

    struct Nuitka_FrameObject *frame_4de9fae261022cc2df5d1800c2c051e5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4de9fae261022cc2df5d1800c2c051e5, codeobj_4de9fae261022cc2df5d1800c2c051e5, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_4de9fae261022cc2df5d1800c2c051e5 = cache_frame_4de9fae261022cc2df5d1800c2c051e5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4de9fae261022cc2df5d1800c2c051e5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4de9fae261022cc2df5d1800c2c051e5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
        exception_tb = NULL;

        exception_lineno = 901;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_keyfile;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_4de9fae261022cc2df5d1800c2c051e5->m_frame.f_lineno = 901;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 901;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_keyfile;
        assert( old != NULL );
        par_keyfile = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_compare_left_1 = par_filetype;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );

    if (unlikely( tmp_compare_right_1 == NULL ))
    {
        tmp_compare_right_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );
    }

    if ( tmp_compare_right_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_UNSPECIFIED" );
        exception_tb = NULL;

        exception_lineno = 903;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_assign_source_2 == NULL ))
    {
        tmp_assign_source_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_assign_source_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 904;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    {
        PyObject *old = par_filetype;
        assert( old != NULL );
        par_filetype = tmp_assign_source_2;
        Py_INCREF( par_filetype );
        Py_DECREF( old );
    }

    goto branch_end_1;
    branch_no_1:;
    tmp_isinstance_inst_1 = par_filetype;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 905;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 905;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_1 = const_str_digest_7cf2d06a8643ddce5d0ceedd61c750e1;
    frame_4de9fae261022cc2df5d1800c2c051e5->m_frame.f_lineno = 906;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 906;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    branch_end_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 908;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_use_PrivateKey_file );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 908;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 909;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_keyfile;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = par_filetype;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_4de9fae261022cc2df5d1800c2c051e5->m_frame.f_lineno = 908;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 908;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_use_result == NULL );
    var_use_result = tmp_assign_source_3;

    tmp_cond_value_1 = var_use_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 911;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_4de9fae261022cc2df5d1800c2c051e5->m_frame.f_lineno = 912;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__raise_passphrase_exception );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 912;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4de9fae261022cc2df5d1800c2c051e5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4de9fae261022cc2df5d1800c2c051e5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4de9fae261022cc2df5d1800c2c051e5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4de9fae261022cc2df5d1800c2c051e5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4de9fae261022cc2df5d1800c2c051e5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4de9fae261022cc2df5d1800c2c051e5,
        type_description_1,
        par_self,
        par_keyfile,
        par_filetype,
        var_use_result
    );


    // Release cached frame.
    if ( frame_4de9fae261022cc2df5d1800c2c051e5 == cache_frame_4de9fae261022cc2df5d1800c2c051e5 )
    {
        Py_DECREF( frame_4de9fae261022cc2df5d1800c2c051e5 );
    }
    cache_frame_4de9fae261022cc2df5d1800c2c051e5 = NULL;

    assertFrameObject( frame_4de9fae261022cc2df5d1800c2c051e5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_22_use_privatekey_file );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_keyfile );
    Py_DECREF( par_keyfile );
    par_keyfile = NULL;

    CHECK_OBJECT( (PyObject *)par_filetype );
    Py_DECREF( par_filetype );
    par_filetype = NULL;

    CHECK_OBJECT( (PyObject *)var_use_result );
    Py_DECREF( var_use_result );
    var_use_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_keyfile );
    Py_DECREF( par_keyfile );
    par_keyfile = NULL;

    Py_XDECREF( par_filetype );
    par_filetype = NULL;

    Py_XDECREF( var_use_result );
    var_use_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_22_use_privatekey_file );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_23_use_privatekey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *var_use_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_f14fc0f5a6135692e4f8d5cbdafa1fc5 = NULL;

    struct Nuitka_FrameObject *frame_f14fc0f5a6135692e4f8d5cbdafa1fc5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f14fc0f5a6135692e4f8d5cbdafa1fc5, codeobj_f14fc0f5a6135692e4f8d5cbdafa1fc5, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f14fc0f5a6135692e4f8d5cbdafa1fc5 = cache_frame_f14fc0f5a6135692e4f8d5cbdafa1fc5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f14fc0f5a6135692e4f8d5cbdafa1fc5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f14fc0f5a6135692e4f8d5cbdafa1fc5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_pkey;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_PKey );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
        exception_tb = NULL;

        exception_lineno = 921;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 921;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
    frame_f14fc0f5a6135692e4f8d5cbdafa1fc5->m_frame.f_lineno = 922;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 922;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 924;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_use_PrivateKey );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 924;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 924;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_pkey;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 924;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_f14fc0f5a6135692e4f8d5cbdafa1fc5->m_frame.f_lineno = 924;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 924;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_use_result == NULL );
    var_use_result = tmp_assign_source_1;

    tmp_cond_value_1 = var_use_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 925;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_f14fc0f5a6135692e4f8d5cbdafa1fc5->m_frame.f_lineno = 926;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__raise_passphrase_exception );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 926;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f14fc0f5a6135692e4f8d5cbdafa1fc5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f14fc0f5a6135692e4f8d5cbdafa1fc5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f14fc0f5a6135692e4f8d5cbdafa1fc5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f14fc0f5a6135692e4f8d5cbdafa1fc5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f14fc0f5a6135692e4f8d5cbdafa1fc5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f14fc0f5a6135692e4f8d5cbdafa1fc5,
        type_description_1,
        par_self,
        par_pkey,
        var_use_result
    );


    // Release cached frame.
    if ( frame_f14fc0f5a6135692e4f8d5cbdafa1fc5 == cache_frame_f14fc0f5a6135692e4f8d5cbdafa1fc5 )
    {
        Py_DECREF( frame_f14fc0f5a6135692e4f8d5cbdafa1fc5 );
    }
    cache_frame_f14fc0f5a6135692e4f8d5cbdafa1fc5 = NULL;

    assertFrameObject( frame_f14fc0f5a6135692e4f8d5cbdafa1fc5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_23_use_privatekey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_use_result );
    Py_DECREF( var_use_result );
    var_use_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_use_result );
    var_use_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_23_use_privatekey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_24_check_privatekey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_629eb5b1494882eb95b61538deae4ae8 = NULL;

    struct Nuitka_FrameObject *frame_629eb5b1494882eb95b61538deae4ae8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_629eb5b1494882eb95b61538deae4ae8, codeobj_629eb5b1494882eb95b61538deae4ae8, module_OpenSSL$SSL, sizeof(void *) );
    frame_629eb5b1494882eb95b61538deae4ae8 = cache_frame_629eb5b1494882eb95b61538deae4ae8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_629eb5b1494882eb95b61538deae4ae8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_629eb5b1494882eb95b61538deae4ae8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 935;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_check_private_key );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 935;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 935;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_629eb5b1494882eb95b61538deae4ae8->m_frame.f_lineno = 935;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 935;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 935;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 936;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_629eb5b1494882eb95b61538deae4ae8->m_frame.f_lineno = 936;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 936;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_629eb5b1494882eb95b61538deae4ae8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_629eb5b1494882eb95b61538deae4ae8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_629eb5b1494882eb95b61538deae4ae8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_629eb5b1494882eb95b61538deae4ae8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_629eb5b1494882eb95b61538deae4ae8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_629eb5b1494882eb95b61538deae4ae8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_629eb5b1494882eb95b61538deae4ae8 == cache_frame_629eb5b1494882eb95b61538deae4ae8 )
    {
        Py_DECREF( frame_629eb5b1494882eb95b61538deae4ae8 );
    }
    cache_frame_629eb5b1494882eb95b61538deae4ae8 = NULL;

    assertFrameObject( frame_629eb5b1494882eb95b61538deae4ae8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_24_check_privatekey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_24_check_privatekey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_25_load_client_ca( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cafile = python_pars[ 1 ];
    PyObject *var_ca_list = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_3007ec3d2f42a3dd1be07ca3ae9168a6 = NULL;

    struct Nuitka_FrameObject *frame_3007ec3d2f42a3dd1be07ca3ae9168a6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3007ec3d2f42a3dd1be07ca3ae9168a6, codeobj_3007ec3d2f42a3dd1be07ca3ae9168a6, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3007ec3d2f42a3dd1be07ca3ae9168a6 = cache_frame_3007ec3d2f42a3dd1be07ca3ae9168a6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3007ec3d2f42a3dd1be07ca3ae9168a6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3007ec3d2f42a3dd1be07ca3ae9168a6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 947;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_load_client_CA_file );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 947;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
    }

    if ( tmp_called_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
        exception_tb = NULL;

        exception_lineno = 948;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_str_plain_cafile;
    tmp_args_element_name_3 = par_cafile;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_3007ec3d2f42a3dd1be07ca3ae9168a6->m_frame.f_lineno = 948;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 948;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_3007ec3d2f42a3dd1be07ca3ae9168a6->m_frame.f_lineno = 947;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 947;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_ca_list == NULL );
    var_ca_list = tmp_assign_source_1;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 950;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_ca_list;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 950;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_3007ec3d2f42a3dd1be07ca3ae9168a6->m_frame.f_lineno = 950;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 951;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_set_client_CA_list );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 951;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 951;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_ca_list;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_3007ec3d2f42a3dd1be07ca3ae9168a6->m_frame.f_lineno = 951;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 951;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3007ec3d2f42a3dd1be07ca3ae9168a6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3007ec3d2f42a3dd1be07ca3ae9168a6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3007ec3d2f42a3dd1be07ca3ae9168a6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3007ec3d2f42a3dd1be07ca3ae9168a6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3007ec3d2f42a3dd1be07ca3ae9168a6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3007ec3d2f42a3dd1be07ca3ae9168a6,
        type_description_1,
        par_self,
        par_cafile,
        var_ca_list
    );


    // Release cached frame.
    if ( frame_3007ec3d2f42a3dd1be07ca3ae9168a6 == cache_frame_3007ec3d2f42a3dd1be07ca3ae9168a6 )
    {
        Py_DECREF( frame_3007ec3d2f42a3dd1be07ca3ae9168a6 );
    }
    cache_frame_3007ec3d2f42a3dd1be07ca3ae9168a6 = NULL;

    assertFrameObject( frame_3007ec3d2f42a3dd1be07ca3ae9168a6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_25_load_client_ca );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_ca_list );
    Py_DECREF( var_ca_list );
    var_ca_list = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cafile );
    Py_DECREF( par_cafile );
    par_cafile = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_ca_list );
    var_ca_list = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cafile );
    Py_DECREF( par_cafile );
    par_cafile = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_25_load_client_ca );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_26_set_session_id( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buf = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_f5c821c2b0df1d06e32083d799bd68d5 = NULL;

    struct Nuitka_FrameObject *frame_f5c821c2b0df1d06e32083d799bd68d5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f5c821c2b0df1d06e32083d799bd68d5, codeobj_f5c821c2b0df1d06e32083d799bd68d5, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_f5c821c2b0df1d06e32083d799bd68d5 = cache_frame_f5c821c2b0df1d06e32083d799bd68d5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f5c821c2b0df1d06e32083d799bd68d5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f5c821c2b0df1d06e32083d799bd68d5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
        exception_tb = NULL;

        exception_lineno = 964;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_plain_buf;
    tmp_args_element_name_2 = par_buf;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_f5c821c2b0df1d06e32083d799bd68d5->m_frame.f_lineno = 964;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 964;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_buf;
        assert( old != NULL );
        par_buf = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 965;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 966;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_session_id_context );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 966;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 966;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = par_buf;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_len_arg_1 = par_buf;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_args_element_name_6 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 966;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_f5c821c2b0df1d06e32083d799bd68d5->m_frame.f_lineno = 966;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 966;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_3 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 966;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_f5c821c2b0df1d06e32083d799bd68d5->m_frame.f_lineno = 965;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 965;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f5c821c2b0df1d06e32083d799bd68d5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f5c821c2b0df1d06e32083d799bd68d5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f5c821c2b0df1d06e32083d799bd68d5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f5c821c2b0df1d06e32083d799bd68d5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f5c821c2b0df1d06e32083d799bd68d5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f5c821c2b0df1d06e32083d799bd68d5,
        type_description_1,
        par_self,
        par_buf
    );


    // Release cached frame.
    if ( frame_f5c821c2b0df1d06e32083d799bd68d5 == cache_frame_f5c821c2b0df1d06e32083d799bd68d5 )
    {
        Py_DECREF( frame_f5c821c2b0df1d06e32083d799bd68d5 );
    }
    cache_frame_f5c821c2b0df1d06e32083d799bd68d5 = NULL;

    assertFrameObject( frame_f5c821c2b0df1d06e32083d799bd68d5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_26_set_session_id );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_26_set_session_id );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_27_set_session_cache_mode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_mode = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_dd4d76a4e8e6e30fb69eee67febb6ab6 = NULL;

    struct Nuitka_FrameObject *frame_dd4d76a4e8e6e30fb69eee67febb6ab6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dd4d76a4e8e6e30fb69eee67febb6ab6, codeobj_dd4d76a4e8e6e30fb69eee67febb6ab6, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_dd4d76a4e8e6e30fb69eee67febb6ab6 = cache_frame_dd4d76a4e8e6e30fb69eee67febb6ab6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dd4d76a4e8e6e30fb69eee67febb6ab6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dd4d76a4e8e6e30fb69eee67febb6ab6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_mode;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 982;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 982;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_71f502d97e845c89ec13eb6ef271f294;
    frame_dd4d76a4e8e6e30fb69eee67febb6ab6->m_frame.f_lineno = 983;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 983;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 985;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_session_cache_mode );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 985;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 985;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_mode;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_dd4d76a4e8e6e30fb69eee67febb6ab6->m_frame.f_lineno = 985;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 985;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dd4d76a4e8e6e30fb69eee67febb6ab6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_dd4d76a4e8e6e30fb69eee67febb6ab6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dd4d76a4e8e6e30fb69eee67febb6ab6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dd4d76a4e8e6e30fb69eee67febb6ab6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dd4d76a4e8e6e30fb69eee67febb6ab6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dd4d76a4e8e6e30fb69eee67febb6ab6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dd4d76a4e8e6e30fb69eee67febb6ab6,
        type_description_1,
        par_self,
        par_mode
    );


    // Release cached frame.
    if ( frame_dd4d76a4e8e6e30fb69eee67febb6ab6 == cache_frame_dd4d76a4e8e6e30fb69eee67febb6ab6 )
    {
        Py_DECREF( frame_dd4d76a4e8e6e30fb69eee67febb6ab6 );
    }
    cache_frame_dd4d76a4e8e6e30fb69eee67febb6ab6 = NULL;

    assertFrameObject( frame_dd4d76a4e8e6e30fb69eee67febb6ab6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_27_set_session_cache_mode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mode );
    Py_DECREF( par_mode );
    par_mode = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mode );
    Py_DECREF( par_mode );
    par_mode = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_27_set_session_cache_mode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_28_get_session_cache_mode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_e9f59a45745b46ca2698acf2ac56b799 = NULL;

    struct Nuitka_FrameObject *frame_e9f59a45745b46ca2698acf2ac56b799;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e9f59a45745b46ca2698acf2ac56b799, codeobj_e9f59a45745b46ca2698acf2ac56b799, module_OpenSSL$SSL, sizeof(void *) );
    frame_e9f59a45745b46ca2698acf2ac56b799 = cache_frame_e9f59a45745b46ca2698acf2ac56b799;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e9f59a45745b46ca2698acf2ac56b799 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e9f59a45745b46ca2698acf2ac56b799 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 995;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_get_session_cache_mode );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 995;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 995;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_e9f59a45745b46ca2698acf2ac56b799->m_frame.f_lineno = 995;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 995;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e9f59a45745b46ca2698acf2ac56b799 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e9f59a45745b46ca2698acf2ac56b799 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e9f59a45745b46ca2698acf2ac56b799 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e9f59a45745b46ca2698acf2ac56b799, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e9f59a45745b46ca2698acf2ac56b799->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e9f59a45745b46ca2698acf2ac56b799, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e9f59a45745b46ca2698acf2ac56b799,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_e9f59a45745b46ca2698acf2ac56b799 == cache_frame_e9f59a45745b46ca2698acf2ac56b799 )
    {
        Py_DECREF( frame_e9f59a45745b46ca2698acf2ac56b799 );
    }
    cache_frame_e9f59a45745b46ca2698acf2ac56b799 = NULL;

    assertFrameObject( frame_e9f59a45745b46ca2698acf2ac56b799 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_28_get_session_cache_mode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_28_get_session_cache_mode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_29_set_verify( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_mode = python_pars[ 1 ];
    PyObject *par_callback = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_6fece6983817e1fc2ad98a3d7d149aca = NULL;

    struct Nuitka_FrameObject *frame_6fece6983817e1fc2ad98a3d7d149aca;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6fece6983817e1fc2ad98a3d7d149aca, codeobj_6fece6983817e1fc2ad98a3d7d149aca, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6fece6983817e1fc2ad98a3d7d149aca = cache_frame_6fece6983817e1fc2ad98a3d7d149aca;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6fece6983817e1fc2ad98a3d7d149aca );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6fece6983817e1fc2ad98a3d7d149aca ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_mode;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 1017;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1017;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_71f502d97e845c89ec13eb6ef271f294;
    frame_6fece6983817e1fc2ad98a3d7d149aca->m_frame.f_lineno = 1018;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1018;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_compare_left_1 = par_callback;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assattr_name_1 = Py_None;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__verify_helper, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1021;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = Py_None;
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__verify_callback, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1022;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1023;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_verify );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1023;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1023;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_mode;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1023;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1023;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_6fece6983817e1fc2ad98a3d7d149aca->m_frame.f_lineno = 1023;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1023;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_2;
    branch_no_2:;
    tmp_called_name_2 = LOOKUP_BUILTIN( const_str_plain_callable );
    assert( tmp_called_name_2 != NULL );
    tmp_args_element_name_4 = par_callback;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_6fece6983817e1fc2ad98a3d7d149aca->m_frame.f_lineno = 1025;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1025;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1025;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_make_exception_arg_2 = const_str_digest_3462bf983701fbd7caf2f521f5975fff;
    frame_6fece6983817e1fc2ad98a3d7d149aca->m_frame.f_lineno = 1026;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 1026;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__VerifyHelper );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__VerifyHelper );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_VerifyHelper" );
        exception_tb = NULL;

        exception_lineno = 1028;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = par_callback;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_6fece6983817e1fc2ad98a3d7d149aca->m_frame.f_lineno = 1028;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assattr_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    if ( tmp_assattr_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1028;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__verify_helper, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_3 );

        exception_lineno = 1028;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_3 );
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_source_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__verify_helper );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1029;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_callback );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_assattr_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1029;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_4 = par_self;

    CHECK_OBJECT( tmp_assattr_target_4 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__verify_callback, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_4 );

        exception_lineno = 1029;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_4 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1030;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_SSL_CTX_set_verify );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1030;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__context );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1030;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = par_mode;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_source_name_8 = par_self;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__verify_callback );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_6 );

        exception_lineno = 1030;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_6fece6983817e1fc2ad98a3d7d149aca->m_frame.f_lineno = 1030;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1030;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6fece6983817e1fc2ad98a3d7d149aca );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6fece6983817e1fc2ad98a3d7d149aca );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6fece6983817e1fc2ad98a3d7d149aca, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6fece6983817e1fc2ad98a3d7d149aca->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6fece6983817e1fc2ad98a3d7d149aca, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6fece6983817e1fc2ad98a3d7d149aca,
        type_description_1,
        par_self,
        par_mode,
        par_callback
    );


    // Release cached frame.
    if ( frame_6fece6983817e1fc2ad98a3d7d149aca == cache_frame_6fece6983817e1fc2ad98a3d7d149aca )
    {
        Py_DECREF( frame_6fece6983817e1fc2ad98a3d7d149aca );
    }
    cache_frame_6fece6983817e1fc2ad98a3d7d149aca = NULL;

    assertFrameObject( frame_6fece6983817e1fc2ad98a3d7d149aca );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_29_set_verify );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mode );
    Py_DECREF( par_mode );
    par_mode = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mode );
    Py_DECREF( par_mode );
    par_mode = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_29_set_verify );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_30_set_verify_depth( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_depth = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_8cf45d680dfdb9a914214d7fecc3e983 = NULL;

    struct Nuitka_FrameObject *frame_8cf45d680dfdb9a914214d7fecc3e983;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8cf45d680dfdb9a914214d7fecc3e983, codeobj_8cf45d680dfdb9a914214d7fecc3e983, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_8cf45d680dfdb9a914214d7fecc3e983 = cache_frame_8cf45d680dfdb9a914214d7fecc3e983;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8cf45d680dfdb9a914214d7fecc3e983 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8cf45d680dfdb9a914214d7fecc3e983 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_depth;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 1040;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1040;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_d242bea258df0e7212519aa660c5f53d;
    frame_8cf45d680dfdb9a914214d7fecc3e983->m_frame.f_lineno = 1041;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1041;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1043;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_verify_depth );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1043;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1043;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_depth;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_8cf45d680dfdb9a914214d7fecc3e983->m_frame.f_lineno = 1043;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1043;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8cf45d680dfdb9a914214d7fecc3e983 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8cf45d680dfdb9a914214d7fecc3e983 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8cf45d680dfdb9a914214d7fecc3e983, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8cf45d680dfdb9a914214d7fecc3e983->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8cf45d680dfdb9a914214d7fecc3e983, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8cf45d680dfdb9a914214d7fecc3e983,
        type_description_1,
        par_self,
        par_depth
    );


    // Release cached frame.
    if ( frame_8cf45d680dfdb9a914214d7fecc3e983 == cache_frame_8cf45d680dfdb9a914214d7fecc3e983 )
    {
        Py_DECREF( frame_8cf45d680dfdb9a914214d7fecc3e983 );
    }
    cache_frame_8cf45d680dfdb9a914214d7fecc3e983 = NULL;

    assertFrameObject( frame_8cf45d680dfdb9a914214d7fecc3e983 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_30_set_verify_depth );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_depth );
    Py_DECREF( par_depth );
    par_depth = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_depth );
    Py_DECREF( par_depth );
    par_depth = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_30_set_verify_depth );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_31_get_verify_mode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_1c2bbbdc204d748085502a3e6b781c3d = NULL;

    struct Nuitka_FrameObject *frame_1c2bbbdc204d748085502a3e6b781c3d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1c2bbbdc204d748085502a3e6b781c3d, codeobj_1c2bbbdc204d748085502a3e6b781c3d, module_OpenSSL$SSL, sizeof(void *) );
    frame_1c2bbbdc204d748085502a3e6b781c3d = cache_frame_1c2bbbdc204d748085502a3e6b781c3d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1c2bbbdc204d748085502a3e6b781c3d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1c2bbbdc204d748085502a3e6b781c3d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1052;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_get_verify_mode );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1052;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1052;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_1c2bbbdc204d748085502a3e6b781c3d->m_frame.f_lineno = 1052;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1052;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1c2bbbdc204d748085502a3e6b781c3d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1c2bbbdc204d748085502a3e6b781c3d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1c2bbbdc204d748085502a3e6b781c3d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1c2bbbdc204d748085502a3e6b781c3d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1c2bbbdc204d748085502a3e6b781c3d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1c2bbbdc204d748085502a3e6b781c3d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1c2bbbdc204d748085502a3e6b781c3d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_1c2bbbdc204d748085502a3e6b781c3d == cache_frame_1c2bbbdc204d748085502a3e6b781c3d )
    {
        Py_DECREF( frame_1c2bbbdc204d748085502a3e6b781c3d );
    }
    cache_frame_1c2bbbdc204d748085502a3e6b781c3d = NULL;

    assertFrameObject( frame_1c2bbbdc204d748085502a3e6b781c3d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_31_get_verify_mode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_31_get_verify_mode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_32_get_verify_depth( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_d240f1f9ab03c9ad1d2cb68a1ae386bd = NULL;

    struct Nuitka_FrameObject *frame_d240f1f9ab03c9ad1d2cb68a1ae386bd;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d240f1f9ab03c9ad1d2cb68a1ae386bd, codeobj_d240f1f9ab03c9ad1d2cb68a1ae386bd, module_OpenSSL$SSL, sizeof(void *) );
    frame_d240f1f9ab03c9ad1d2cb68a1ae386bd = cache_frame_d240f1f9ab03c9ad1d2cb68a1ae386bd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d240f1f9ab03c9ad1d2cb68a1ae386bd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d240f1f9ab03c9ad1d2cb68a1ae386bd ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1061;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_get_verify_depth );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1061;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1061;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_d240f1f9ab03c9ad1d2cb68a1ae386bd->m_frame.f_lineno = 1061;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1061;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d240f1f9ab03c9ad1d2cb68a1ae386bd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d240f1f9ab03c9ad1d2cb68a1ae386bd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d240f1f9ab03c9ad1d2cb68a1ae386bd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d240f1f9ab03c9ad1d2cb68a1ae386bd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d240f1f9ab03c9ad1d2cb68a1ae386bd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d240f1f9ab03c9ad1d2cb68a1ae386bd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d240f1f9ab03c9ad1d2cb68a1ae386bd,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d240f1f9ab03c9ad1d2cb68a1ae386bd == cache_frame_d240f1f9ab03c9ad1d2cb68a1ae386bd )
    {
        Py_DECREF( frame_d240f1f9ab03c9ad1d2cb68a1ae386bd );
    }
    cache_frame_d240f1f9ab03c9ad1d2cb68a1ae386bd = NULL;

    assertFrameObject( frame_d240f1f9ab03c9ad1d2cb68a1ae386bd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_32_get_verify_depth );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_32_get_verify_depth );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_33_load_tmp_dh( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_dhfile = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_dh = NULL;
    PyObject *var_res = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_20f3644f0565fa197ebe62d163efece0 = NULL;

    struct Nuitka_FrameObject *frame_20f3644f0565fa197ebe62d163efece0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_20f3644f0565fa197ebe62d163efece0, codeobj_20f3644f0565fa197ebe62d163efece0, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_20f3644f0565fa197ebe62d163efece0 = cache_frame_20f3644f0565fa197ebe62d163efece0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_20f3644f0565fa197ebe62d163efece0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_20f3644f0565fa197ebe62d163efece0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
        exception_tb = NULL;

        exception_lineno = 1072;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_dhfile;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_20f3644f0565fa197ebe62d163efece0->m_frame.f_lineno = 1072;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1072;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_dhfile;
        assert( old != NULL );
        par_dhfile = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1074;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_dhfile;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = const_str_plain_r;
    frame_20f3644f0565fa197ebe62d163efece0->m_frame.f_lineno = 1074;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_BIO_new_file, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1074;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_bio == NULL );
    var_bio = tmp_assign_source_2;

    tmp_compare_left_1 = var_bio;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1075;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1075;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1075;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1076;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_20f3644f0565fa197ebe62d163efece0->m_frame.f_lineno = 1076;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1076;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1077;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_gc );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1077;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1077;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_BIO_free );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1077;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_20f3644f0565fa197ebe62d163efece0->m_frame.f_lineno = 1077;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1077;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_bio;
        assert( old != NULL );
        var_bio = tmp_assign_source_3;
        Py_DECREF( old );
    }

    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1079;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_PEM_read_bio_DHparams );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1079;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_bio;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1079;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1079;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_7 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1079;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_7 );

        exception_lineno = 1079;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_7 );
        Py_DECREF( tmp_args_element_name_8 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1079;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_7 );
        Py_DECREF( tmp_args_element_name_8 );

        exception_lineno = 1079;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_20f3644f0565fa197ebe62d163efece0->m_frame.f_lineno = 1079;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_7 );
    Py_DECREF( tmp_args_element_name_8 );
    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1079;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_dh == NULL );
    var_dh = tmp_assign_source_4;

    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1080;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_gc );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1080;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = var_dh;

    CHECK_OBJECT( tmp_args_element_name_10 );
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1080;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_DH_free );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1080;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_20f3644f0565fa197ebe62d163efece0->m_frame.f_lineno = 1080;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1080;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_dh;
        assert( old != NULL );
        var_dh = tmp_assign_source_5;
        Py_DECREF( old );
    }

    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1081;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_SSL_CTX_set_tmp_dh );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1081;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_11 = par_self;

    CHECK_OBJECT( tmp_source_name_11 );
    tmp_args_element_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__context );
    if ( tmp_args_element_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 1081;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_13 = var_dh;

    CHECK_OBJECT( tmp_args_element_name_13 );
    frame_20f3644f0565fa197ebe62d163efece0->m_frame.f_lineno = 1081;
    {
        PyObject *call_args[] = { tmp_args_element_name_12, tmp_args_element_name_13 };
        tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_12 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1081;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_res == NULL );
    var_res = tmp_assign_source_6;

    tmp_called_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_7 == NULL ))
    {
        tmp_called_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1082;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_res;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_14 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1082;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_20f3644f0565fa197ebe62d163efece0->m_frame.f_lineno = 1082;
    {
        PyObject *call_args[] = { tmp_args_element_name_14 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_args_element_name_14 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1082;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_20f3644f0565fa197ebe62d163efece0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_20f3644f0565fa197ebe62d163efece0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_20f3644f0565fa197ebe62d163efece0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_20f3644f0565fa197ebe62d163efece0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_20f3644f0565fa197ebe62d163efece0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_20f3644f0565fa197ebe62d163efece0,
        type_description_1,
        par_self,
        par_dhfile,
        var_bio,
        var_dh,
        var_res
    );


    // Release cached frame.
    if ( frame_20f3644f0565fa197ebe62d163efece0 == cache_frame_20f3644f0565fa197ebe62d163efece0 )
    {
        Py_DECREF( frame_20f3644f0565fa197ebe62d163efece0 );
    }
    cache_frame_20f3644f0565fa197ebe62d163efece0 = NULL;

    assertFrameObject( frame_20f3644f0565fa197ebe62d163efece0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_33_load_tmp_dh );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dhfile );
    Py_DECREF( par_dhfile );
    par_dhfile = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_dh );
    Py_DECREF( var_dh );
    var_dh = NULL;

    CHECK_OBJECT( (PyObject *)var_res );
    Py_DECREF( var_res );
    var_res = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_dhfile );
    Py_DECREF( par_dhfile );
    par_dhfile = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_dh );
    var_dh = NULL;

    Py_XDECREF( var_res );
    var_res = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_33_load_tmp_dh );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_34_set_tmp_ecdh( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_curve = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_087da86096a9eb38f52586f217604859 = NULL;

    struct Nuitka_FrameObject *frame_087da86096a9eb38f52586f217604859;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_087da86096a9eb38f52586f217604859, codeobj_087da86096a9eb38f52586f217604859, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_087da86096a9eb38f52586f217604859 = cache_frame_087da86096a9eb38f52586f217604859;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_087da86096a9eb38f52586f217604859 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_087da86096a9eb38f52586f217604859 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1094;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_tmp_ecdh );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1094;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1094;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_curve;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_087da86096a9eb38f52586f217604859->m_frame.f_lineno = 1094;
    tmp_args_element_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__to_EC_KEY );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1094;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_087da86096a9eb38f52586f217604859->m_frame.f_lineno = 1094;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1094;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_087da86096a9eb38f52586f217604859 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_087da86096a9eb38f52586f217604859 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_087da86096a9eb38f52586f217604859, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_087da86096a9eb38f52586f217604859->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_087da86096a9eb38f52586f217604859, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_087da86096a9eb38f52586f217604859,
        type_description_1,
        par_self,
        par_curve
    );


    // Release cached frame.
    if ( frame_087da86096a9eb38f52586f217604859 == cache_frame_087da86096a9eb38f52586f217604859 )
    {
        Py_DECREF( frame_087da86096a9eb38f52586f217604859 );
    }
    cache_frame_087da86096a9eb38f52586f217604859 = NULL;

    assertFrameObject( frame_087da86096a9eb38f52586f217604859 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_34_set_tmp_ecdh );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_curve );
    Py_DECREF( par_curve );
    par_curve = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_curve );
    Py_DECREF( par_curve );
    par_curve = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_34_set_tmp_ecdh );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_35_set_cipher_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cipher_list = python_pars[ 1 ];
    PyObject *var_tmpconn = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_call_arg_element_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_e56f5f73584ddfdf176a449c1f1d406c = NULL;

    struct Nuitka_FrameObject *frame_e56f5f73584ddfdf176a449c1f1d406c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e56f5f73584ddfdf176a449c1f1d406c, codeobj_e56f5f73584ddfdf176a449c1f1d406c, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e56f5f73584ddfdf176a449c1f1d406c = cache_frame_e56f5f73584ddfdf176a449c1f1d406c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e56f5f73584ddfdf176a449c1f1d406c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e56f5f73584ddfdf176a449c1f1d406c ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
        exception_tb = NULL;

        exception_lineno = 1106;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_plain_cipher_list;
    tmp_args_element_name_2 = par_cipher_list;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_e56f5f73584ddfdf176a449c1f1d406c->m_frame.f_lineno = 1106;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1106;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_cipher_list;
        assert( old != NULL );
        par_cipher_list = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_isinstance_inst_1 = par_cipher_list;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1108;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_428eff9fedd3b449496fa307af56b948;
    frame_e56f5f73584ddfdf176a449c1f1d406c->m_frame.f_lineno = 1109;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1109;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1111;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1112;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_cipher_list );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1112;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1112;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = par_cipher_list;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_e56f5f73584ddfdf176a449c1f1d406c->m_frame.f_lineno = 1112;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1112;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_3 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1112;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_e56f5f73584ddfdf176a449c1f1d406c->m_frame.f_lineno = 1111;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1111;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
        exception_tb = NULL;

        exception_lineno = 1119;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = par_self;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = Py_None;
    frame_e56f5f73584ddfdf176a449c1f1d406c->m_frame.f_lineno = 1119;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1119;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_tmpconn == NULL );
    var_tmpconn = tmp_assign_source_2;

    tmp_called_instance_1 = var_tmpconn;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_e56f5f73584ddfdf176a449c1f1d406c->m_frame.f_lineno = 1120;
    tmp_compare_left_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_get_cipher_list );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1120;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = LIST_COPY( const_list_6fa8c3d8587ec1659fa28b2f58883e42_list );
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1120;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 1125;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_call_arg_element_1 = LIST_COPY( const_list_tuple_1892b43c5f7e8b28e9bf284d360fe6ef_tuple_list );
    frame_e56f5f73584ddfdf176a449c1f1d406c->m_frame.f_lineno = 1125;
    {
        PyObject *call_args[] = { tmp_call_arg_element_1 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_call_arg_element_1 );
    if ( tmp_raise_type_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1125;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_2;
    exception_lineno = 1125;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e56f5f73584ddfdf176a449c1f1d406c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e56f5f73584ddfdf176a449c1f1d406c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e56f5f73584ddfdf176a449c1f1d406c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e56f5f73584ddfdf176a449c1f1d406c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e56f5f73584ddfdf176a449c1f1d406c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e56f5f73584ddfdf176a449c1f1d406c,
        type_description_1,
        par_self,
        par_cipher_list,
        var_tmpconn
    );


    // Release cached frame.
    if ( frame_e56f5f73584ddfdf176a449c1f1d406c == cache_frame_e56f5f73584ddfdf176a449c1f1d406c )
    {
        Py_DECREF( frame_e56f5f73584ddfdf176a449c1f1d406c );
    }
    cache_frame_e56f5f73584ddfdf176a449c1f1d406c = NULL;

    assertFrameObject( frame_e56f5f73584ddfdf176a449c1f1d406c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_35_set_cipher_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cipher_list );
    Py_DECREF( par_cipher_list );
    par_cipher_list = NULL;

    CHECK_OBJECT( (PyObject *)var_tmpconn );
    Py_DECREF( var_tmpconn );
    var_tmpconn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cipher_list );
    Py_DECREF( par_cipher_list );
    par_cipher_list = NULL;

    Py_XDECREF( var_tmpconn );
    var_tmpconn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_35_set_cipher_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_36_set_client_ca_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_certificate_authorities = python_pars[ 1 ];
    PyObject *var_copy = NULL;
    PyObject *var_name_stack = NULL;
    PyObject *var_ca_name = NULL;
    PyObject *var_push_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_type_arg_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_8d1ca164c82af98e35dc9aa41d641480 = NULL;

    struct Nuitka_FrameObject *frame_8d1ca164c82af98e35dc9aa41d641480;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8d1ca164c82af98e35dc9aa41d641480, codeobj_8d1ca164c82af98e35dc9aa41d641480, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8d1ca164c82af98e35dc9aa41d641480 = cache_frame_8d1ca164c82af98e35dc9aa41d641480;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8d1ca164c82af98e35dc9aa41d641480 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8d1ca164c82af98e35dc9aa41d641480 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1148;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_8d1ca164c82af98e35dc9aa41d641480->m_frame.f_lineno = 1148;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_sk_X509_NAME_new_null );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1148;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_name_stack == NULL );
    var_name_stack = tmp_assign_source_1;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1149;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_name_stack;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1149;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1149;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1149;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_8d1ca164c82af98e35dc9aa41d641480->m_frame.f_lineno = 1149;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1149;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    // Tried code:
    tmp_iter_arg_1 = par_certificate_authorities;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1152;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooo";
        exception_lineno = 1152;
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1152;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_3;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_ca_name;
        var_ca_name = tmp_assign_source_4;
        Py_INCREF( var_ca_name );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_ca_name;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Name );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
        exception_tb = NULL;

        exception_lineno = 1153;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1153;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_left_name_1 = const_str_digest_4387d84e76f6b2a931cf315cb767f6ce;
    tmp_right_name_1 = PyTuple_New( 1 );
    tmp_type_arg_1 = var_ca_name;

    CHECK_OBJECT( tmp_type_arg_1 );
    tmp_source_name_2 = BUILTIN_TYPE1( tmp_type_arg_1 );
    assert( tmp_source_name_2 != NULL );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___name__ );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1156;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1155;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    frame_8d1ca164c82af98e35dc9aa41d641480->m_frame.f_lineno = 1154;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1154;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooooo";
    goto try_except_handler_3;
    branch_no_2:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1158;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_NAME_dup );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1158;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    tmp_source_name_4 = var_ca_name;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__name );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1158;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    frame_8d1ca164c82af98e35dc9aa41d641480->m_frame.f_lineno = 1158;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1158;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_copy;
        var_copy = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1159;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }

    tmp_compexpr_left_2 = var_copy;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1159;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }

    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    tmp_args_element_name_3 = RICH_COMPARE_NE( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    frame_8d1ca164c82af98e35dc9aa41d641480->m_frame.f_lineno = 1159;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1160;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }

    tmp_args_element_name_4 = var_name_stack;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_args_element_name_5 = var_copy;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_8d1ca164c82af98e35dc9aa41d641480->m_frame.f_lineno = 1160;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_sk_X509_NAME_push, call_args );
    }

    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1160;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_push_result;
        var_push_result = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_cond_value_1 = var_push_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1161;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1162;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }

    tmp_args_element_name_6 = var_copy;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_8d1ca164c82af98e35dc9aa41d641480->m_frame.f_lineno = 1162;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_X509_NAME_free, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1162;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1163;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }

    frame_8d1ca164c82af98e35dc9aa41d641480->m_frame.f_lineno = 1163;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1163;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1152;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_8d1ca164c82af98e35dc9aa41d641480 );
    if ( exception_keeper_tb_3 == NULL )
    {
        exception_keeper_tb_3 = MAKE_TRACEBACK( frame_8d1ca164c82af98e35dc9aa41d641480, exception_keeper_lineno_3 );
    }
    else if ( exception_keeper_lineno_3 != 0 )
    {
        exception_keeper_tb_3 = ADD_TRACEBACK( exception_keeper_tb_3, frame_8d1ca164c82af98e35dc9aa41d641480, exception_keeper_lineno_3 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    PUBLISH_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyExc_Exception;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1165;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = var_name_stack;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_8d1ca164c82af98e35dc9aa41d641480->m_frame.f_lineno = 1165;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_sk_X509_NAME_free, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1165;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 1166;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_8d1ca164c82af98e35dc9aa41d641480->m_frame) frame_8d1ca164c82af98e35dc9aa41d641480->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooooo";
    goto frame_exception_exit_1;
    goto branch_end_4;
    branch_no_4:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 1151;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_8d1ca164c82af98e35dc9aa41d641480->m_frame) frame_8d1ca164c82af98e35dc9aa41d641480->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooooo";
    goto frame_exception_exit_1;
    branch_end_4:;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1168;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_SSL_CTX_set_client_CA_list );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1168;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__context );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1168;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_name_stack;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_8d1ca164c82af98e35dc9aa41d641480->m_frame.f_lineno = 1168;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1168;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 1
    RESTORE_FRAME_EXCEPTION( frame_8d1ca164c82af98e35dc9aa41d641480 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_8d1ca164c82af98e35dc9aa41d641480 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8d1ca164c82af98e35dc9aa41d641480, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8d1ca164c82af98e35dc9aa41d641480->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8d1ca164c82af98e35dc9aa41d641480, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8d1ca164c82af98e35dc9aa41d641480,
        type_description_1,
        par_self,
        par_certificate_authorities,
        var_copy,
        var_name_stack,
        var_ca_name,
        var_push_result
    );


    // Release cached frame.
    if ( frame_8d1ca164c82af98e35dc9aa41d641480 == cache_frame_8d1ca164c82af98e35dc9aa41d641480 )
    {
        Py_DECREF( frame_8d1ca164c82af98e35dc9aa41d641480 );
    }
    cache_frame_8d1ca164c82af98e35dc9aa41d641480 = NULL;

    assertFrameObject( frame_8d1ca164c82af98e35dc9aa41d641480 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_36_set_client_ca_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_copy );
    var_copy = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate_authorities );
    Py_DECREF( par_certificate_authorities );
    par_certificate_authorities = NULL;

    CHECK_OBJECT( (PyObject *)var_name_stack );
    Py_DECREF( var_name_stack );
    var_name_stack = NULL;

    Py_XDECREF( var_ca_name );
    var_ca_name = NULL;

    Py_XDECREF( var_push_result );
    var_push_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_copy );
    var_copy = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate_authorities );
    Py_DECREF( par_certificate_authorities );
    par_certificate_authorities = NULL;

    Py_XDECREF( var_name_stack );
    var_name_stack = NULL;

    Py_XDECREF( var_ca_name );
    var_ca_name = NULL;

    Py_XDECREF( var_push_result );
    var_push_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_36_set_client_ca_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_37_add_client_ca( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_certificate_authority = python_pars[ 1 ];
    PyObject *var_add_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_09f851592d260b18b7439a190a4cf649 = NULL;

    struct Nuitka_FrameObject *frame_09f851592d260b18b7439a190a4cf649;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_09f851592d260b18b7439a190a4cf649, codeobj_09f851592d260b18b7439a190a4cf649, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_09f851592d260b18b7439a190a4cf649 = cache_frame_09f851592d260b18b7439a190a4cf649;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_09f851592d260b18b7439a190a4cf649 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_09f851592d260b18b7439a190a4cf649 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_certificate_authority;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 1183;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1183;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_f5111f918158679228186076f422f85e;
    frame_09f851592d260b18b7439a190a4cf649->m_frame.f_lineno = 1184;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1184;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1186;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_add_client_CA );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1186;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1187;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_certificate_authority;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__x509 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1187;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_09f851592d260b18b7439a190a4cf649->m_frame.f_lineno = 1186;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1186;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_add_result == NULL );
    var_add_result = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1189;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_add_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_3 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1189;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_09f851592d260b18b7439a190a4cf649->m_frame.f_lineno = 1189;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1189;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_09f851592d260b18b7439a190a4cf649 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_09f851592d260b18b7439a190a4cf649 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_09f851592d260b18b7439a190a4cf649, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_09f851592d260b18b7439a190a4cf649->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_09f851592d260b18b7439a190a4cf649, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_09f851592d260b18b7439a190a4cf649,
        type_description_1,
        par_self,
        par_certificate_authority,
        var_add_result
    );


    // Release cached frame.
    if ( frame_09f851592d260b18b7439a190a4cf649 == cache_frame_09f851592d260b18b7439a190a4cf649 )
    {
        Py_DECREF( frame_09f851592d260b18b7439a190a4cf649 );
    }
    cache_frame_09f851592d260b18b7439a190a4cf649 = NULL;

    assertFrameObject( frame_09f851592d260b18b7439a190a4cf649 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_37_add_client_ca );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate_authority );
    Py_DECREF( par_certificate_authority );
    par_certificate_authority = NULL;

    CHECK_OBJECT( (PyObject *)var_add_result );
    Py_DECREF( var_add_result );
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate_authority );
    Py_DECREF( par_certificate_authority );
    par_certificate_authority = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_37_add_client_ca );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_38_set_timeout( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_timeout = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_cadc07cf67a4e323687eed3a5255dfa8 = NULL;

    struct Nuitka_FrameObject *frame_cadc07cf67a4e323687eed3a5255dfa8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cadc07cf67a4e323687eed3a5255dfa8, codeobj_cadc07cf67a4e323687eed3a5255dfa8, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_cadc07cf67a4e323687eed3a5255dfa8 = cache_frame_cadc07cf67a4e323687eed3a5255dfa8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cadc07cf67a4e323687eed3a5255dfa8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cadc07cf67a4e323687eed3a5255dfa8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_timeout;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 1200;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1200;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_7ac3fb96e522dea60117802c4a4274df;
    frame_cadc07cf67a4e323687eed3a5255dfa8->m_frame.f_lineno = 1201;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1201;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1203;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_timeout );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1203;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1203;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_timeout;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_cadc07cf67a4e323687eed3a5255dfa8->m_frame.f_lineno = 1203;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1203;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cadc07cf67a4e323687eed3a5255dfa8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cadc07cf67a4e323687eed3a5255dfa8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cadc07cf67a4e323687eed3a5255dfa8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cadc07cf67a4e323687eed3a5255dfa8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cadc07cf67a4e323687eed3a5255dfa8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cadc07cf67a4e323687eed3a5255dfa8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cadc07cf67a4e323687eed3a5255dfa8,
        type_description_1,
        par_self,
        par_timeout
    );


    // Release cached frame.
    if ( frame_cadc07cf67a4e323687eed3a5255dfa8 == cache_frame_cadc07cf67a4e323687eed3a5255dfa8 )
    {
        Py_DECREF( frame_cadc07cf67a4e323687eed3a5255dfa8 );
    }
    cache_frame_cadc07cf67a4e323687eed3a5255dfa8 = NULL;

    assertFrameObject( frame_cadc07cf67a4e323687eed3a5255dfa8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_38_set_timeout );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_timeout );
    Py_DECREF( par_timeout );
    par_timeout = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_timeout );
    Py_DECREF( par_timeout );
    par_timeout = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_38_set_timeout );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_39_get_timeout( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_9c51e814ae59c208eeea05af7ec1d290 = NULL;

    struct Nuitka_FrameObject *frame_9c51e814ae59c208eeea05af7ec1d290;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9c51e814ae59c208eeea05af7ec1d290, codeobj_9c51e814ae59c208eeea05af7ec1d290, module_OpenSSL$SSL, sizeof(void *) );
    frame_9c51e814ae59c208eeea05af7ec1d290 = cache_frame_9c51e814ae59c208eeea05af7ec1d290;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9c51e814ae59c208eeea05af7ec1d290 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9c51e814ae59c208eeea05af7ec1d290 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1212;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_get_timeout );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1212;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_9c51e814ae59c208eeea05af7ec1d290->m_frame.f_lineno = 1212;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c51e814ae59c208eeea05af7ec1d290 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c51e814ae59c208eeea05af7ec1d290 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c51e814ae59c208eeea05af7ec1d290 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9c51e814ae59c208eeea05af7ec1d290, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9c51e814ae59c208eeea05af7ec1d290->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9c51e814ae59c208eeea05af7ec1d290, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9c51e814ae59c208eeea05af7ec1d290,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_9c51e814ae59c208eeea05af7ec1d290 == cache_frame_9c51e814ae59c208eeea05af7ec1d290 )
    {
        Py_DECREF( frame_9c51e814ae59c208eeea05af7ec1d290 );
    }
    cache_frame_9c51e814ae59c208eeea05af7ec1d290 = NULL;

    assertFrameObject( frame_9c51e814ae59c208eeea05af7ec1d290 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_39_get_timeout );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_39_get_timeout );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_40_set_info_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_3ea94e74b8591248d24548abaaf564ff = NULL;

    struct Nuitka_FrameObject *frame_3ea94e74b8591248d24548abaaf564ff;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3ea94e74b8591248d24548abaaf564ff, codeobj_3ea94e74b8591248d24548abaaf564ff, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3ea94e74b8591248d24548abaaf564ff = cache_frame_3ea94e74b8591248d24548abaaf564ff;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3ea94e74b8591248d24548abaaf564ff );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3ea94e74b8591248d24548abaaf564ff ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
        exception_tb = NULL;

        exception_lineno = 1227;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }

    if ( par_callback == NULL )
    {
        tmp_args_element_name_1 = NULL;
    }
    else
    {
        tmp_args_element_name_1 = PyCell_GET( par_callback );
    }

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_3ea94e74b8591248d24548abaaf564ff->m_frame.f_lineno = 1227;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1227;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = MAKE_FUNCTION_OpenSSL$SSL$$$function_40_set_info_callback$$$function_1_wrapper( par_callback );
    frame_3ea94e74b8591248d24548abaaf564ff->m_frame.f_lineno = 1227;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1227;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    assert( var_wrapper == NULL );
    var_wrapper = tmp_assign_source_1;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1231;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = const_str_digest_215c056443df9aa1456b62fe40673d54;
    tmp_args_element_name_4 = var_wrapper;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_3ea94e74b8591248d24548abaaf564ff->m_frame.f_lineno = 1231;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_callback, call_args );
    }

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1231;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__info_callback, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1231;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1234;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_info_callback );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1234;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1234;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__info_callback );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 1234;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    frame_3ea94e74b8591248d24548abaaf564ff->m_frame.f_lineno = 1234;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1234;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ea94e74b8591248d24548abaaf564ff );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ea94e74b8591248d24548abaaf564ff );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3ea94e74b8591248d24548abaaf564ff, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3ea94e74b8591248d24548abaaf564ff->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3ea94e74b8591248d24548abaaf564ff, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3ea94e74b8591248d24548abaaf564ff,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_3ea94e74b8591248d24548abaaf564ff == cache_frame_3ea94e74b8591248d24548abaaf564ff )
    {
        Py_DECREF( frame_3ea94e74b8591248d24548abaaf564ff );
    }
    cache_frame_3ea94e74b8591248d24548abaaf564ff = NULL;

    assertFrameObject( frame_3ea94e74b8591248d24548abaaf564ff );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_40_set_info_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_40_set_info_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_40_set_info_callback$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[ 0 ];
    PyObject *par_where = python_pars[ 1 ];
    PyObject *par_return_code = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_027a1d4675ab6e708189c79b6a91a682 = NULL;

    struct Nuitka_FrameObject *frame_027a1d4675ab6e708189c79b6a91a682;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_027a1d4675ab6e708189c79b6a91a682, codeobj_027a1d4675ab6e708189c79b6a91a682, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_027a1d4675ab6e708189c79b6a91a682 = cache_frame_027a1d4675ab6e708189c79b6a91a682;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_027a1d4675ab6e708189c79b6a91a682 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_027a1d4675ab6e708189c79b6a91a682 ) == 2 ); // Frame stack

    // Framed code:
    if ( self->m_closure[0] == NULL )
    {
        tmp_called_name_1 = NULL;
    }
    else
    {
        tmp_called_name_1 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
        exception_tb = NULL;

        exception_lineno = 1229;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
        exception_tb = NULL;

        exception_lineno = 1229;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1229;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = par_ssl;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1229;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_where;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_return_code;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_027a1d4675ab6e708189c79b6a91a682->m_frame.f_lineno = 1229;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1229;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_027a1d4675ab6e708189c79b6a91a682 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_027a1d4675ab6e708189c79b6a91a682 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_027a1d4675ab6e708189c79b6a91a682, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_027a1d4675ab6e708189c79b6a91a682->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_027a1d4675ab6e708189c79b6a91a682, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_027a1d4675ab6e708189c79b6a91a682,
        type_description_1,
        par_ssl,
        par_where,
        par_return_code,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_027a1d4675ab6e708189c79b6a91a682 == cache_frame_027a1d4675ab6e708189c79b6a91a682 )
    {
        Py_DECREF( frame_027a1d4675ab6e708189c79b6a91a682 );
    }
    cache_frame_027a1d4675ab6e708189c79b6a91a682 = NULL;

    assertFrameObject( frame_027a1d4675ab6e708189c79b6a91a682 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_40_set_info_callback$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_where );
    Py_DECREF( par_where );
    par_where = NULL;

    CHECK_OBJECT( (PyObject *)par_return_code );
    Py_DECREF( par_return_code );
    par_return_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_where );
    Py_DECREF( par_where );
    par_where = NULL;

    CHECK_OBJECT( (PyObject *)par_return_code );
    Py_DECREF( par_return_code );
    par_return_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_40_set_info_callback$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_41_set_keylog_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_eb66fada38d507b21a902b1d1c274f94 = NULL;

    struct Nuitka_FrameObject *frame_eb66fada38d507b21a902b1d1c274f94;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_eb66fada38d507b21a902b1d1c274f94, codeobj_eb66fada38d507b21a902b1d1c274f94, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_eb66fada38d507b21a902b1d1c274f94 = cache_frame_eb66fada38d507b21a902b1d1c274f94;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_eb66fada38d507b21a902b1d1c274f94 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_eb66fada38d507b21a902b1d1c274f94 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
        exception_tb = NULL;

        exception_lineno = 1251;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }

    if ( par_callback == NULL )
    {
        tmp_args_element_name_1 = NULL;
    }
    else
    {
        tmp_args_element_name_1 = PyCell_GET( par_callback );
    }

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_eb66fada38d507b21a902b1d1c274f94->m_frame.f_lineno = 1251;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1251;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = MAKE_FUNCTION_OpenSSL$SSL$$$function_41_set_keylog_callback$$$function_1_wrapper( par_callback );
    frame_eb66fada38d507b21a902b1d1c274f94->m_frame.f_lineno = 1251;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1251;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    assert( var_wrapper == NULL );
    var_wrapper = tmp_assign_source_1;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1256;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = const_str_digest_242762bc0b8f70110beb7fa23160c8c2;
    tmp_args_element_name_4 = var_wrapper;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_eb66fada38d507b21a902b1d1c274f94->m_frame.f_lineno = 1256;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_callback, call_args );
    }

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1256;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__keylog_callback, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1256;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1259;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_keylog_callback );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1259;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1259;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__keylog_callback );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 1259;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    frame_eb66fada38d507b21a902b1d1c274f94->m_frame.f_lineno = 1259;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1259;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eb66fada38d507b21a902b1d1c274f94 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eb66fada38d507b21a902b1d1c274f94 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_eb66fada38d507b21a902b1d1c274f94, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_eb66fada38d507b21a902b1d1c274f94->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_eb66fada38d507b21a902b1d1c274f94, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_eb66fada38d507b21a902b1d1c274f94,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_eb66fada38d507b21a902b1d1c274f94 == cache_frame_eb66fada38d507b21a902b1d1c274f94 )
    {
        Py_DECREF( frame_eb66fada38d507b21a902b1d1c274f94 );
    }
    cache_frame_eb66fada38d507b21a902b1d1c274f94 = NULL;

    assertFrameObject( frame_eb66fada38d507b21a902b1d1c274f94 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_41_set_keylog_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_41_set_keylog_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_41_set_keylog_callback$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[ 0 ];
    PyObject *par_line = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_33618a1a0baec9d4158ab8b5d67b55bb = NULL;

    struct Nuitka_FrameObject *frame_33618a1a0baec9d4158ab8b5d67b55bb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_33618a1a0baec9d4158ab8b5d67b55bb, codeobj_33618a1a0baec9d4158ab8b5d67b55bb, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_33618a1a0baec9d4158ab8b5d67b55bb = cache_frame_33618a1a0baec9d4158ab8b5d67b55bb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_33618a1a0baec9d4158ab8b5d67b55bb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_33618a1a0baec9d4158ab8b5d67b55bb ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1253;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_line;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_33618a1a0baec9d4158ab8b5d67b55bb->m_frame.f_lineno = 1253;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_string, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1253;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_line;
        assert( old != NULL );
        par_line = tmp_assign_source_1;
        Py_DECREF( old );
    }

    if ( self->m_closure[0] == NULL )
    {
        tmp_called_name_1 = NULL;
    }
    else
    {
        tmp_called_name_1 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
        exception_tb = NULL;

        exception_lineno = 1254;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
        exception_tb = NULL;

        exception_lineno = 1254;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1254;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = par_ssl;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1254;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_line;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_33618a1a0baec9d4158ab8b5d67b55bb->m_frame.f_lineno = 1254;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1254;
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_33618a1a0baec9d4158ab8b5d67b55bb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_33618a1a0baec9d4158ab8b5d67b55bb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_33618a1a0baec9d4158ab8b5d67b55bb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_33618a1a0baec9d4158ab8b5d67b55bb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_33618a1a0baec9d4158ab8b5d67b55bb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_33618a1a0baec9d4158ab8b5d67b55bb,
        type_description_1,
        par_ssl,
        par_line,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_33618a1a0baec9d4158ab8b5d67b55bb == cache_frame_33618a1a0baec9d4158ab8b5d67b55bb )
    {
        Py_DECREF( frame_33618a1a0baec9d4158ab8b5d67b55bb );
    }
    cache_frame_33618a1a0baec9d4158ab8b5d67b55bb = NULL;

    assertFrameObject( frame_33618a1a0baec9d4158ab8b5d67b55bb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_41_set_keylog_callback$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_line );
    Py_DECREF( par_line );
    par_line = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_line );
    Py_DECREF( par_line );
    par_line = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_41_set_keylog_callback$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_42_get_app_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_ce76a9677c8d247ae477dbc6379dbbc2 = NULL;

    struct Nuitka_FrameObject *frame_ce76a9677c8d247ae477dbc6379dbbc2;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ce76a9677c8d247ae477dbc6379dbbc2, codeobj_ce76a9677c8d247ae477dbc6379dbbc2, module_OpenSSL$SSL, sizeof(void *) );
    frame_ce76a9677c8d247ae477dbc6379dbbc2 = cache_frame_ce76a9677c8d247ae477dbc6379dbbc2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ce76a9677c8d247ae477dbc6379dbbc2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ce76a9677c8d247ae477dbc6379dbbc2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__app_data );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1267;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce76a9677c8d247ae477dbc6379dbbc2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce76a9677c8d247ae477dbc6379dbbc2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce76a9677c8d247ae477dbc6379dbbc2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ce76a9677c8d247ae477dbc6379dbbc2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ce76a9677c8d247ae477dbc6379dbbc2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ce76a9677c8d247ae477dbc6379dbbc2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ce76a9677c8d247ae477dbc6379dbbc2,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ce76a9677c8d247ae477dbc6379dbbc2 == cache_frame_ce76a9677c8d247ae477dbc6379dbbc2 )
    {
        Py_DECREF( frame_ce76a9677c8d247ae477dbc6379dbbc2 );
    }
    cache_frame_ce76a9677c8d247ae477dbc6379dbbc2 = NULL;

    assertFrameObject( frame_ce76a9677c8d247ae477dbc6379dbbc2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_42_get_app_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_42_get_app_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_43_set_app_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_data = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_56c0d108e11d4f9beec70956f75d378a = NULL;

    struct Nuitka_FrameObject *frame_56c0d108e11d4f9beec70956f75d378a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_56c0d108e11d4f9beec70956f75d378a, codeobj_56c0d108e11d4f9beec70956f75d378a, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_56c0d108e11d4f9beec70956f75d378a = cache_frame_56c0d108e11d4f9beec70956f75d378a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_56c0d108e11d4f9beec70956f75d378a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_56c0d108e11d4f9beec70956f75d378a ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = par_data;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__app_data, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1276;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_56c0d108e11d4f9beec70956f75d378a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_56c0d108e11d4f9beec70956f75d378a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_56c0d108e11d4f9beec70956f75d378a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_56c0d108e11d4f9beec70956f75d378a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_56c0d108e11d4f9beec70956f75d378a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_56c0d108e11d4f9beec70956f75d378a,
        type_description_1,
        par_self,
        par_data
    );


    // Release cached frame.
    if ( frame_56c0d108e11d4f9beec70956f75d378a == cache_frame_56c0d108e11d4f9beec70956f75d378a )
    {
        Py_DECREF( frame_56c0d108e11d4f9beec70956f75d378a );
    }
    cache_frame_56c0d108e11d4f9beec70956f75d378a = NULL;

    assertFrameObject( frame_56c0d108e11d4f9beec70956f75d378a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_43_set_app_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_43_set_app_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_44_get_cert_store( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_pystore = NULL;
    PyObject *var_store = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_15459965e009ac4caaaa8d3428cb3e67 = NULL;

    struct Nuitka_FrameObject *frame_15459965e009ac4caaaa8d3428cb3e67;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_15459965e009ac4caaaa8d3428cb3e67, codeobj_15459965e009ac4caaaa8d3428cb3e67, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_15459965e009ac4caaaa8d3428cb3e67 = cache_frame_15459965e009ac4caaaa8d3428cb3e67;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_15459965e009ac4caaaa8d3428cb3e67 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_15459965e009ac4caaaa8d3428cb3e67 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1286;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_get_cert_store );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1286;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1286;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_15459965e009ac4caaaa8d3428cb3e67->m_frame.f_lineno = 1286;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1286;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_store == NULL );
    var_store = tmp_assign_source_1;

    tmp_compare_left_1 = var_store;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1287;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1287;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1287;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Store );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Store );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Store" );
        exception_tb = NULL;

        exception_lineno = 1291;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain___new__ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1291;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Store );

    if (unlikely( tmp_args_element_name_2 == NULL ))
    {
        tmp_args_element_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Store );
    }

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Store" );
        exception_tb = NULL;

        exception_lineno = 1291;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_15459965e009ac4caaaa8d3428cb3e67->m_frame.f_lineno = 1291;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1291;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_pystore == NULL );
    var_pystore = tmp_assign_source_2;

    tmp_assattr_name_1 = var_store;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = var_pystore;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__store, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1292;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_15459965e009ac4caaaa8d3428cb3e67 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_15459965e009ac4caaaa8d3428cb3e67 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_15459965e009ac4caaaa8d3428cb3e67 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_15459965e009ac4caaaa8d3428cb3e67, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_15459965e009ac4caaaa8d3428cb3e67->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_15459965e009ac4caaaa8d3428cb3e67, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_15459965e009ac4caaaa8d3428cb3e67,
        type_description_1,
        par_self,
        var_pystore,
        var_store
    );


    // Release cached frame.
    if ( frame_15459965e009ac4caaaa8d3428cb3e67 == cache_frame_15459965e009ac4caaaa8d3428cb3e67 )
    {
        Py_DECREF( frame_15459965e009ac4caaaa8d3428cb3e67 );
    }
    cache_frame_15459965e009ac4caaaa8d3428cb3e67 = NULL;

    assertFrameObject( frame_15459965e009ac4caaaa8d3428cb3e67 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_pystore;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_44_get_cert_store );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_pystore );
    var_pystore = NULL;

    CHECK_OBJECT( (PyObject *)var_store );
    Py_DECREF( var_store );
    var_store = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_pystore );
    var_pystore = NULL;

    Py_XDECREF( var_store );
    var_store = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_44_get_cert_store );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_45_set_options( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_options = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_55a7db7b2da21870b1f168c22ed4f7b4 = NULL;

    struct Nuitka_FrameObject *frame_55a7db7b2da21870b1f168c22ed4f7b4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_55a7db7b2da21870b1f168c22ed4f7b4, codeobj_55a7db7b2da21870b1f168c22ed4f7b4, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_55a7db7b2da21870b1f168c22ed4f7b4 = cache_frame_55a7db7b2da21870b1f168c22ed4f7b4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_55a7db7b2da21870b1f168c22ed4f7b4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_55a7db7b2da21870b1f168c22ed4f7b4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_options;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 1303;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1303;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_a068c39f2c9878239ba2a3b47e83e1e0;
    frame_55a7db7b2da21870b1f168c22ed4f7b4->m_frame.f_lineno = 1304;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1304;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1306;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_options );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1306;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1306;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_options;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_55a7db7b2da21870b1f168c22ed4f7b4->m_frame.f_lineno = 1306;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1306;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_55a7db7b2da21870b1f168c22ed4f7b4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_55a7db7b2da21870b1f168c22ed4f7b4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_55a7db7b2da21870b1f168c22ed4f7b4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_55a7db7b2da21870b1f168c22ed4f7b4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_55a7db7b2da21870b1f168c22ed4f7b4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_55a7db7b2da21870b1f168c22ed4f7b4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_55a7db7b2da21870b1f168c22ed4f7b4,
        type_description_1,
        par_self,
        par_options
    );


    // Release cached frame.
    if ( frame_55a7db7b2da21870b1f168c22ed4f7b4 == cache_frame_55a7db7b2da21870b1f168c22ed4f7b4 )
    {
        Py_DECREF( frame_55a7db7b2da21870b1f168c22ed4f7b4 );
    }
    cache_frame_55a7db7b2da21870b1f168c22ed4f7b4 = NULL;

    assertFrameObject( frame_55a7db7b2da21870b1f168c22ed4f7b4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_45_set_options );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_options );
    Py_DECREF( par_options );
    par_options = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_options );
    Py_DECREF( par_options );
    par_options = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_45_set_options );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_46_set_mode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_mode = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_dca08831ab266ef2e54f8c8c25db7b17 = NULL;

    struct Nuitka_FrameObject *frame_dca08831ab266ef2e54f8c8c25db7b17;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dca08831ab266ef2e54f8c8c25db7b17, codeobj_dca08831ab266ef2e54f8c8c25db7b17, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_dca08831ab266ef2e54f8c8c25db7b17 = cache_frame_dca08831ab266ef2e54f8c8c25db7b17;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dca08831ab266ef2e54f8c8c25db7b17 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dca08831ab266ef2e54f8c8c25db7b17 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_mode;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 1316;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1316;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_71f502d97e845c89ec13eb6ef271f294;
    frame_dca08831ab266ef2e54f8c8c25db7b17->m_frame.f_lineno = 1317;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1317;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1319;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_mode );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1319;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1319;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_mode;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_dca08831ab266ef2e54f8c8c25db7b17->m_frame.f_lineno = 1319;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1319;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dca08831ab266ef2e54f8c8c25db7b17 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_dca08831ab266ef2e54f8c8c25db7b17 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dca08831ab266ef2e54f8c8c25db7b17 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dca08831ab266ef2e54f8c8c25db7b17, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dca08831ab266ef2e54f8c8c25db7b17->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dca08831ab266ef2e54f8c8c25db7b17, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dca08831ab266ef2e54f8c8c25db7b17,
        type_description_1,
        par_self,
        par_mode
    );


    // Release cached frame.
    if ( frame_dca08831ab266ef2e54f8c8c25db7b17 == cache_frame_dca08831ab266ef2e54f8c8c25db7b17 )
    {
        Py_DECREF( frame_dca08831ab266ef2e54f8c8c25db7b17 );
    }
    cache_frame_dca08831ab266ef2e54f8c8c25db7b17 = NULL;

    assertFrameObject( frame_dca08831ab266ef2e54f8c8c25db7b17 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_46_set_mode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mode );
    Py_DECREF( par_mode );
    par_mode = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mode );
    Py_DECREF( par_mode );
    par_mode = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_46_set_mode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_47_set_tlsext_servername_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_94c0d4b8cf686c2e34361e7cd48a3052 = NULL;

    struct Nuitka_FrameObject *frame_94c0d4b8cf686c2e34361e7cd48a3052;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_94c0d4b8cf686c2e34361e7cd48a3052, codeobj_94c0d4b8cf686c2e34361e7cd48a3052, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_94c0d4b8cf686c2e34361e7cd48a3052 = cache_frame_94c0d4b8cf686c2e34361e7cd48a3052;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_94c0d4b8cf686c2e34361e7cd48a3052 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_94c0d4b8cf686c2e34361e7cd48a3052 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
        exception_tb = NULL;

        exception_lineno = 1332;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }

    if ( par_callback == NULL )
    {
        tmp_args_element_name_1 = NULL;
    }
    else
    {
        tmp_args_element_name_1 = PyCell_GET( par_callback );
    }

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_94c0d4b8cf686c2e34361e7cd48a3052->m_frame.f_lineno = 1332;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1332;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = MAKE_FUNCTION_OpenSSL$SSL$$$function_47_set_tlsext_servername_callback$$$function_1_wrapper( par_callback );
    frame_94c0d4b8cf686c2e34361e7cd48a3052->m_frame.f_lineno = 1332;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1332;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    assert( var_wrapper == NULL );
    var_wrapper = tmp_assign_source_1;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1337;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = const_str_digest_b02795b9590127f96a3b627129a2fbd2;
    tmp_args_element_name_4 = var_wrapper;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_94c0d4b8cf686c2e34361e7cd48a3052->m_frame.f_lineno = 1337;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_callback, call_args );
    }

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1337;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__tlsext_servername_callback, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1337;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1340;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_tlsext_servername_callback );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1340;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1341;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__tlsext_servername_callback );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 1341;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    frame_94c0d4b8cf686c2e34361e7cd48a3052->m_frame.f_lineno = 1340;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1340;
        type_description_1 = "oco";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_94c0d4b8cf686c2e34361e7cd48a3052 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_94c0d4b8cf686c2e34361e7cd48a3052 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_94c0d4b8cf686c2e34361e7cd48a3052, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_94c0d4b8cf686c2e34361e7cd48a3052->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_94c0d4b8cf686c2e34361e7cd48a3052, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_94c0d4b8cf686c2e34361e7cd48a3052,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_94c0d4b8cf686c2e34361e7cd48a3052 == cache_frame_94c0d4b8cf686c2e34361e7cd48a3052 )
    {
        Py_DECREF( frame_94c0d4b8cf686c2e34361e7cd48a3052 );
    }
    cache_frame_94c0d4b8cf686c2e34361e7cd48a3052 = NULL;

    assertFrameObject( frame_94c0d4b8cf686c2e34361e7cd48a3052 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_47_set_tlsext_servername_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_47_set_tlsext_servername_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_47_set_tlsext_servername_callback$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[ 0 ];
    PyObject *par_alert = python_pars[ 1 ];
    PyObject *par_arg = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_d01eafbb0e285abd4a6f7d94f9e77264 = NULL;

    struct Nuitka_FrameObject *frame_d01eafbb0e285abd4a6f7d94f9e77264;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d01eafbb0e285abd4a6f7d94f9e77264, codeobj_d01eafbb0e285abd4a6f7d94f9e77264, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d01eafbb0e285abd4a6f7d94f9e77264 = cache_frame_d01eafbb0e285abd4a6f7d94f9e77264;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d01eafbb0e285abd4a6f7d94f9e77264 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d01eafbb0e285abd4a6f7d94f9e77264 ) == 2 ); // Frame stack

    // Framed code:
    if ( self->m_closure[0] == NULL )
    {
        tmp_called_name_1 = NULL;
    }
    else
    {
        tmp_called_name_1 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
        exception_tb = NULL;

        exception_lineno = 1334;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
        exception_tb = NULL;

        exception_lineno = 1334;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1334;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = par_ssl;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1334;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    frame_d01eafbb0e285abd4a6f7d94f9e77264->m_frame.f_lineno = 1334;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1334;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d01eafbb0e285abd4a6f7d94f9e77264 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d01eafbb0e285abd4a6f7d94f9e77264 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d01eafbb0e285abd4a6f7d94f9e77264, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d01eafbb0e285abd4a6f7d94f9e77264->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d01eafbb0e285abd4a6f7d94f9e77264, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d01eafbb0e285abd4a6f7d94f9e77264,
        type_description_1,
        par_ssl,
        par_alert,
        par_arg,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_d01eafbb0e285abd4a6f7d94f9e77264 == cache_frame_d01eafbb0e285abd4a6f7d94f9e77264 )
    {
        Py_DECREF( frame_d01eafbb0e285abd4a6f7d94f9e77264 );
    }
    cache_frame_d01eafbb0e285abd4a6f7d94f9e77264 = NULL;

    assertFrameObject( frame_d01eafbb0e285abd4a6f7d94f9e77264 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_47_set_tlsext_servername_callback$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_alert );
    Py_DECREF( par_alert );
    par_alert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_alert );
    Py_DECREF( par_alert );
    par_alert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_47_set_tlsext_servername_callback$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_48_set_tlsext_use_srtp( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_profiles = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_68f89f8855b7fe9638b09d04b6d22f83 = NULL;

    struct Nuitka_FrameObject *frame_68f89f8855b7fe9638b09d04b6d22f83;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_68f89f8855b7fe9638b09d04b6d22f83, codeobj_68f89f8855b7fe9638b09d04b6d22f83, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_68f89f8855b7fe9638b09d04b6d22f83 = cache_frame_68f89f8855b7fe9638b09d04b6d22f83;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_68f89f8855b7fe9638b09d04b6d22f83 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_68f89f8855b7fe9638b09d04b6d22f83 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_profiles;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1352;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_75d74458faf9dee1d9b7a20a034cfad7;
    frame_68f89f8855b7fe9638b09d04b6d22f83->m_frame.f_lineno = 1353;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1353;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1355;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1356;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_tlsext_use_srtp );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1356;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1356;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_profiles;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_68f89f8855b7fe9638b09d04b6d22f83->m_frame.f_lineno = 1356;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1356;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1356;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_68f89f8855b7fe9638b09d04b6d22f83->m_frame.f_lineno = 1355;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1355;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_68f89f8855b7fe9638b09d04b6d22f83 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_68f89f8855b7fe9638b09d04b6d22f83 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_68f89f8855b7fe9638b09d04b6d22f83, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_68f89f8855b7fe9638b09d04b6d22f83->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_68f89f8855b7fe9638b09d04b6d22f83, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_68f89f8855b7fe9638b09d04b6d22f83,
        type_description_1,
        par_self,
        par_profiles
    );


    // Release cached frame.
    if ( frame_68f89f8855b7fe9638b09d04b6d22f83 == cache_frame_68f89f8855b7fe9638b09d04b6d22f83 )
    {
        Py_DECREF( frame_68f89f8855b7fe9638b09d04b6d22f83 );
    }
    cache_frame_68f89f8855b7fe9638b09d04b6d22f83 = NULL;

    assertFrameObject( frame_68f89f8855b7fe9638b09d04b6d22f83 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_48_set_tlsext_use_srtp );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_profiles );
    Py_DECREF( par_profiles );
    par_profiles = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_profiles );
    Py_DECREF( par_profiles );
    par_profiles = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_48_set_tlsext_use_srtp );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_49_set_alpn_protos( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_protos = python_pars[ 1 ];
    PyObject *var_protostr = NULL;
    PyObject *var_input_str = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_8fa949167a3f0e0a7575ae806dd11e0c = NULL;

    struct Nuitka_FrameObject *frame_8fa949167a3f0e0a7575ae806dd11e0c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8fa949167a3f0e0a7575ae806dd11e0c, codeobj_8fa949167a3f0e0a7575ae806dd11e0c, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8fa949167a3f0e0a7575ae806dd11e0c = cache_frame_8fa949167a3f0e0a7575ae806dd11e0c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8fa949167a3f0e0a7575ae806dd11e0c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8fa949167a3f0e0a7575ae806dd11e0c ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_empty;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_join );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_chain );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_chain );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "chain" );
        exception_tb = NULL;

        exception_lineno = 1373;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_from_iterable );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1373;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = par_protos;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1373;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        OpenSSL$SSL$$$function_49_set_alpn_protos$$$genexpr_1_genexpr_context,
        module_OpenSSL$SSL,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_53710dee329bd9462d1d050c80a1709d,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_49_set_alpn_protos );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_49_set_alpn_protos );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_2 = tmp_outline_return_value_1;
    frame_8fa949167a3f0e0a7575ae806dd11e0c->m_frame.f_lineno = 1373;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1373;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_8fa949167a3f0e0a7575ae806dd11e0c->m_frame.f_lineno = 1372;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1372;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_protostr == NULL );
    var_protostr = tmp_assign_source_1;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1378;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
    tmp_args_element_name_4 = var_protostr;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_8fa949167a3f0e0a7575ae806dd11e0c->m_frame.f_lineno = 1378;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_new, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1378;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_input_str == NULL );
    var_input_str = tmp_assign_source_3;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1379;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_set_alpn_protos );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1379;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1379;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_input_str;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_len_arg_1 = var_protostr;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_args_element_name_7 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 1379;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_8fa949167a3f0e0a7575ae806dd11e0c->m_frame.f_lineno = 1379;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1379;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8fa949167a3f0e0a7575ae806dd11e0c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8fa949167a3f0e0a7575ae806dd11e0c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8fa949167a3f0e0a7575ae806dd11e0c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8fa949167a3f0e0a7575ae806dd11e0c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8fa949167a3f0e0a7575ae806dd11e0c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8fa949167a3f0e0a7575ae806dd11e0c,
        type_description_1,
        par_self,
        par_protos,
        var_protostr,
        var_input_str
    );


    // Release cached frame.
    if ( frame_8fa949167a3f0e0a7575ae806dd11e0c == cache_frame_8fa949167a3f0e0a7575ae806dd11e0c )
    {
        Py_DECREF( frame_8fa949167a3f0e0a7575ae806dd11e0c );
    }
    cache_frame_8fa949167a3f0e0a7575ae806dd11e0c = NULL;

    assertFrameObject( frame_8fa949167a3f0e0a7575ae806dd11e0c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_49_set_alpn_protos );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_protos );
    Py_DECREF( par_protos );
    par_protos = NULL;

    CHECK_OBJECT( (PyObject *)var_protostr );
    Py_DECREF( var_protostr );
    var_protostr = NULL;

    CHECK_OBJECT( (PyObject *)var_input_str );
    Py_DECREF( var_input_str );
    var_input_str = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_protos );
    Py_DECREF( par_protos );
    par_protos = NULL;

    Py_XDECREF( var_protostr );
    var_protostr = NULL;

    Py_XDECREF( var_input_str );
    var_input_str = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_49_set_alpn_protos );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct OpenSSL$SSL$$$function_49_set_alpn_protos$$$genexpr_1_genexpr_locals {
    PyObject *var_p
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *OpenSSL$SSL$$$function_49_set_alpn_protos$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void OpenSSL$SSL$$$function_49_set_alpn_protos$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_p = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_53710dee329bd9462d1d050c80a1709d, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 1373;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1373;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_p;
        var_p = tmp_assign_source_2;
        Py_INCREF( var_p );
        Py_XDECREF( old );
    }

    tmp_expression_name_1 = PyTuple_New( 2 );
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_int2byte );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_int2byte );
    }

    if ( tmp_called_name_1 == NULL )
    {
        Py_DECREF( tmp_expression_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "int2byte" );
        exception_tb = NULL;

        exception_lineno = 1373;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_len_arg_1 = var_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_args_element_name_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_1 );

        exception_lineno = 1373;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    generator->m_frame->m_frame.f_lineno = 1373;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_1 );

        exception_lineno = 1373;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_expression_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_p;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_expression_name_1, 1, tmp_tuple_element_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1373;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1373;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_p
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_p );
    var_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_p );
    var_p = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_OpenSSL$SSL$$$function_50_set_alpn_select_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_callback = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_b67de0094492dbb326b6f334ee86c858 = NULL;

    struct Nuitka_FrameObject *frame_b67de0094492dbb326b6f334ee86c858;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b67de0094492dbb326b6f334ee86c858, codeobj_b67de0094492dbb326b6f334ee86c858, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_b67de0094492dbb326b6f334ee86c858 = cache_frame_b67de0094492dbb326b6f334ee86c858;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b67de0094492dbb326b6f334ee86c858 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b67de0094492dbb326b6f334ee86c858 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ALPNSelectHelper );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ALPNSelectHelper );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ALPNSelectHelper" );
        exception_tb = NULL;

        exception_lineno = 1396;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_callback;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_b67de0094492dbb326b6f334ee86c858->m_frame.f_lineno = 1396;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1396;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__alpn_select_helper, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1396;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__alpn_select_helper );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1397;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_callback );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1397;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__alpn_select_callback, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 1397;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1398;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_set_alpn_select_cb );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1398;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1399;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__alpn_select_callback );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1399;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1399;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1399;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_b67de0094492dbb326b6f334ee86c858->m_frame.f_lineno = 1398;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1398;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b67de0094492dbb326b6f334ee86c858 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b67de0094492dbb326b6f334ee86c858 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b67de0094492dbb326b6f334ee86c858, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b67de0094492dbb326b6f334ee86c858->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b67de0094492dbb326b6f334ee86c858, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b67de0094492dbb326b6f334ee86c858,
        type_description_1,
        par_self,
        par_callback
    );


    // Release cached frame.
    if ( frame_b67de0094492dbb326b6f334ee86c858 == cache_frame_b67de0094492dbb326b6f334ee86c858 )
    {
        Py_DECREF( frame_b67de0094492dbb326b6f334ee86c858 );
    }
    cache_frame_b67de0094492dbb326b6f334ee86c858 = NULL;

    assertFrameObject( frame_b67de0094492dbb326b6f334ee86c858 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_50_set_alpn_select_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_50_set_alpn_select_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_51__set_ocsp_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_helper = python_pars[ 1 ];
    PyObject *par_data = python_pars[ 2 ];
    PyObject *var_rc = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    bool tmp_is_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_9d0f44146929f76ab672b2aef6185af0 = NULL;

    struct Nuitka_FrameObject *frame_9d0f44146929f76ab672b2aef6185af0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9d0f44146929f76ab672b2aef6185af0, codeobj_9d0f44146929f76ab672b2aef6185af0, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9d0f44146929f76ab672b2aef6185af0 = cache_frame_9d0f44146929f76ab672b2aef6185af0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9d0f44146929f76ab672b2aef6185af0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9d0f44146929f76ab672b2aef6185af0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = par_helper;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__ocsp_helper, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1408;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = par_helper;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_callback );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1409;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__ocsp_callback, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 1409;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_compare_left_1 = par_data;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1411;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
    if ( tmp_assattr_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1411;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__ocsp_data, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_3 );

        exception_lineno = 1411;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_3 );
    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1413;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_data;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_9d0f44146929f76ab672b2aef6185af0->m_frame.f_lineno = 1413;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assattr_name_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_new_handle, call_args );
    }

    if ( tmp_assattr_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1413;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_4 = par_self;

    CHECK_OBJECT( tmp_assattr_target_4 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__ocsp_data, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_4 );

        exception_lineno = 1413;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_4 );
    branch_end_1:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1415;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_set_tlsext_status_cb );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1415;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1416;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__ocsp_callback );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1416;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_9d0f44146929f76ab672b2aef6185af0->m_frame.f_lineno = 1415;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1415;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_rc == NULL );
    var_rc = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1418;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_rc;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_4 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1418;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_9d0f44146929f76ab672b2aef6185af0->m_frame.f_lineno = 1418;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1418;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1419;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_SSL_CTX_set_tlsext_status_arg );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1419;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__context );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1419;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = par_self;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__ocsp_data );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 1419;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_9d0f44146929f76ab672b2aef6185af0->m_frame.f_lineno = 1419;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1419;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_rc;
        assert( old != NULL );
        var_rc = tmp_assign_source_2;
        Py_DECREF( old );
    }

    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1420;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_2 = var_rc;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = const_int_pos_1;
    tmp_args_element_name_7 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1420;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_9d0f44146929f76ab672b2aef6185af0->m_frame.f_lineno = 1420;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1420;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9d0f44146929f76ab672b2aef6185af0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9d0f44146929f76ab672b2aef6185af0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9d0f44146929f76ab672b2aef6185af0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9d0f44146929f76ab672b2aef6185af0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9d0f44146929f76ab672b2aef6185af0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9d0f44146929f76ab672b2aef6185af0,
        type_description_1,
        par_self,
        par_helper,
        par_data,
        var_rc
    );


    // Release cached frame.
    if ( frame_9d0f44146929f76ab672b2aef6185af0 == cache_frame_9d0f44146929f76ab672b2aef6185af0 )
    {
        Py_DECREF( frame_9d0f44146929f76ab672b2aef6185af0 );
    }
    cache_frame_9d0f44146929f76ab672b2aef6185af0 = NULL;

    assertFrameObject( frame_9d0f44146929f76ab672b2aef6185af0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_51__set_ocsp_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_helper );
    Py_DECREF( par_helper );
    par_helper = NULL;

    CHECK_OBJECT( (PyObject *)var_rc );
    Py_DECREF( var_rc );
    var_rc = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_helper );
    Py_DECREF( par_helper );
    par_helper = NULL;

    Py_XDECREF( var_rc );
    var_rc = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_51__set_ocsp_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_52_set_ocsp_server_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_callback = python_pars[ 1 ];
    PyObject *par_data = python_pars[ 2 ];
    PyObject *var_helper = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_42a5b4bb6bb2aefba79bf25001da3d90 = NULL;

    struct Nuitka_FrameObject *frame_42a5b4bb6bb2aefba79bf25001da3d90;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_42a5b4bb6bb2aefba79bf25001da3d90, codeobj_42a5b4bb6bb2aefba79bf25001da3d90, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_42a5b4bb6bb2aefba79bf25001da3d90 = cache_frame_42a5b4bb6bb2aefba79bf25001da3d90;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_42a5b4bb6bb2aefba79bf25001da3d90 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_42a5b4bb6bb2aefba79bf25001da3d90 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__OCSPServerCallbackHelper );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__OCSPServerCallbackHelper );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_OCSPServerCallbackHelper" );
        exception_tb = NULL;

        exception_lineno = 1437;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_callback;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_42a5b4bb6bb2aefba79bf25001da3d90->m_frame.f_lineno = 1437;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1437;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_helper == NULL );
    var_helper = tmp_assign_source_1;

    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_2 = var_helper;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_data;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_42a5b4bb6bb2aefba79bf25001da3d90->m_frame.f_lineno = 1438;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain__set_ocsp_callback, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1438;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_42a5b4bb6bb2aefba79bf25001da3d90 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_42a5b4bb6bb2aefba79bf25001da3d90 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_42a5b4bb6bb2aefba79bf25001da3d90, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_42a5b4bb6bb2aefba79bf25001da3d90->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_42a5b4bb6bb2aefba79bf25001da3d90, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_42a5b4bb6bb2aefba79bf25001da3d90,
        type_description_1,
        par_self,
        par_callback,
        par_data,
        var_helper
    );


    // Release cached frame.
    if ( frame_42a5b4bb6bb2aefba79bf25001da3d90 == cache_frame_42a5b4bb6bb2aefba79bf25001da3d90 )
    {
        Py_DECREF( frame_42a5b4bb6bb2aefba79bf25001da3d90 );
    }
    cache_frame_42a5b4bb6bb2aefba79bf25001da3d90 = NULL;

    assertFrameObject( frame_42a5b4bb6bb2aefba79bf25001da3d90 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_52_set_ocsp_server_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)var_helper );
    Py_DECREF( var_helper );
    var_helper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    Py_XDECREF( var_helper );
    var_helper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_52_set_ocsp_server_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_53_set_ocsp_client_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_callback = python_pars[ 1 ];
    PyObject *par_data = python_pars[ 2 ];
    PyObject *var_helper = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_c383504c16885b5865730f200cd9d1f8 = NULL;

    struct Nuitka_FrameObject *frame_c383504c16885b5865730f200cd9d1f8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c383504c16885b5865730f200cd9d1f8, codeobj_c383504c16885b5865730f200cd9d1f8, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c383504c16885b5865730f200cd9d1f8 = cache_frame_c383504c16885b5865730f200cd9d1f8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c383504c16885b5865730f200cd9d1f8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c383504c16885b5865730f200cd9d1f8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__OCSPClientCallbackHelper );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__OCSPClientCallbackHelper );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_OCSPClientCallbackHelper" );
        exception_tb = NULL;

        exception_lineno = 1457;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_callback;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_c383504c16885b5865730f200cd9d1f8->m_frame.f_lineno = 1457;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1457;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_helper == NULL );
    var_helper = tmp_assign_source_1;

    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_2 = var_helper;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_data;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_c383504c16885b5865730f200cd9d1f8->m_frame.f_lineno = 1458;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain__set_ocsp_callback, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1458;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c383504c16885b5865730f200cd9d1f8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c383504c16885b5865730f200cd9d1f8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c383504c16885b5865730f200cd9d1f8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c383504c16885b5865730f200cd9d1f8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c383504c16885b5865730f200cd9d1f8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c383504c16885b5865730f200cd9d1f8,
        type_description_1,
        par_self,
        par_callback,
        par_data,
        var_helper
    );


    // Release cached frame.
    if ( frame_c383504c16885b5865730f200cd9d1f8 == cache_frame_c383504c16885b5865730f200cd9d1f8 )
    {
        Py_DECREF( frame_c383504c16885b5865730f200cd9d1f8 );
    }
    cache_frame_c383504c16885b5865730f200cd9d1f8 = NULL;

    assertFrameObject( frame_c383504c16885b5865730f200cd9d1f8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_53_set_ocsp_client_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)var_helper );
    Py_DECREF( var_helper );
    var_helper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    Py_XDECREF( var_helper );
    var_helper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_53_set_ocsp_client_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_54___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_context = python_pars[ 1 ];
    PyObject *par_socket = python_pars[ 2 ];
    PyObject *var_ssl = NULL;
    PyObject *var_set_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_name_5;
    PyObject *tmp_assattr_name_6;
    PyObject *tmp_assattr_name_7;
    PyObject *tmp_assattr_name_8;
    PyObject *tmp_assattr_name_9;
    PyObject *tmp_assattr_name_10;
    PyObject *tmp_assattr_name_11;
    PyObject *tmp_assattr_name_12;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assattr_target_5;
    PyObject *tmp_assattr_target_6;
    PyObject *tmp_assattr_target_7;
    PyObject *tmp_assattr_target_8;
    PyObject *tmp_assattr_target_9;
    PyObject *tmp_assattr_target_10;
    PyObject *tmp_assattr_target_11;
    PyObject *tmp_assattr_target_12;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    PyObject *tmp_source_name_19;
    PyObject *tmp_source_name_20;
    PyObject *tmp_source_name_21;
    PyObject *tmp_source_name_22;
    PyObject *tmp_source_name_23;
    PyObject *tmp_source_name_24;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_5791a020e2944607f45102dc7fe5b8e6 = NULL;

    struct Nuitka_FrameObject *frame_5791a020e2944607f45102dc7fe5b8e6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5791a020e2944607f45102dc7fe5b8e6, codeobj_5791a020e2944607f45102dc7fe5b8e6, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5791a020e2944607f45102dc7fe5b8e6 = cache_frame_5791a020e2944607f45102dc7fe5b8e6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5791a020e2944607f45102dc7fe5b8e6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5791a020e2944607f45102dc7fe5b8e6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_context;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Context );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Context );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Context" );
        exception_tb = NULL;

        exception_lineno = 1472;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1472;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_627e1a07a1a60af86ff9e544428f2f09;
    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1473;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1473;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1475;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_new );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1475;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_context;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1475;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1475;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1475;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_ssl == NULL );
    var_ssl = tmp_assign_source_1;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1476;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_gc );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1476;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_ssl;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1476;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_free );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1476;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1476;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1476;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__ssl, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1476;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1481;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_SSL_set_mode );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1481;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__ssl );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1481;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1481;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_SSL_MODE_AUTO_RETRY );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 1481;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1481;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1481;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_2 = par_context;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__context, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1482;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = Py_None;
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__app_data, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1483;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_4 = Py_None;
    tmp_assattr_target_4 = par_self;

    CHECK_OBJECT( tmp_assattr_target_4 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__alpn_select_callback_args, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1489;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = par_context;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_assattr_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__verify_helper );
    if ( tmp_assattr_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1494;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_5 = par_self;

    CHECK_OBJECT( tmp_assattr_target_5 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain__verify_helper, tmp_assattr_name_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_5 );

        exception_lineno = 1494;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_5 );
    tmp_source_name_9 = par_context;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_assattr_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__verify_callback );
    if ( tmp_assattr_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1495;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_6 = par_self;

    CHECK_OBJECT( tmp_assattr_target_6 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain__verify_callback, tmp_assattr_name_6 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_6 );

        exception_lineno = 1495;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_6 );
    tmp_ass_subvalue_1 = par_self;

    CHECK_OBJECT( tmp_ass_subvalue_1 );
    tmp_source_name_10 = par_self;

    CHECK_OBJECT( tmp_source_name_10 );
    tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain__reverse_mapping );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1497;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_11 = par_self;

    CHECK_OBJECT( tmp_source_name_11 );
    tmp_ass_subscript_1 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__ssl );
    if ( tmp_ass_subscript_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subscribed_1 );

        exception_lineno = 1497;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    Py_DECREF( tmp_ass_subscript_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1497;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_1 = par_socket;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assattr_name_7 = Py_None;
    tmp_assattr_target_7 = par_self;

    CHECK_OBJECT( tmp_assattr_target_7 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain__socket, tmp_assattr_name_7 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1500;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1502;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_BIO_new );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1502;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1502;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1502;
    tmp_args_element_name_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_BIO_s_mem );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1502;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1502;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_assattr_name_8 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assattr_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1502;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_8 = par_self;

    CHECK_OBJECT( tmp_assattr_target_8 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain__into_ssl, tmp_assattr_name_8 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_8 );

        exception_lineno = 1502;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_8 );
    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1503;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_13 = par_self;

    CHECK_OBJECT( tmp_source_name_13 );
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain__into_ssl );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1503;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_14 == NULL ))
    {
        tmp_source_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_14 == NULL )
    {
        Py_DECREF( tmp_compexpr_left_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1503;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_1 );

        exception_lineno = 1503;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1503;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1503;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1503;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_15 == NULL ))
    {
        tmp_source_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1505;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_BIO_new );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1505;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1505;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1505;
    tmp_args_element_name_8 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_BIO_s_mem );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 1505;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1505;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_assattr_name_9 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_assattr_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1505;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_9 = par_self;

    CHECK_OBJECT( tmp_assattr_target_9 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain__from_ssl, tmp_assattr_name_9 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_9 );

        exception_lineno = 1505;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_9 );
    tmp_called_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_7 == NULL ))
    {
        tmp_called_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1506;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_16 = par_self;

    CHECK_OBJECT( tmp_source_name_16 );
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain__from_ssl );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1506;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_17 == NULL ))
    {
        tmp_source_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_17 == NULL )
    {
        Py_DECREF( tmp_compexpr_left_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1506;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_NULL );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 1506;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = RICH_COMPARE_NE( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1506;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1506;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1506;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_18 == NULL ))
    {
        tmp_source_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1508;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_SSL_set_bio );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1508;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_19 = par_self;

    CHECK_OBJECT( tmp_source_name_19 );
    tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain__ssl );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );

        exception_lineno = 1508;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_20 = par_self;

    CHECK_OBJECT( tmp_source_name_20 );
    tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain__into_ssl );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_args_element_name_10 );

        exception_lineno = 1508;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_21 = par_self;

    CHECK_OBJECT( tmp_source_name_21 );
    tmp_args_element_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_21, const_str_plain__from_ssl );
    if ( tmp_args_element_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_args_element_name_10 );
        Py_DECREF( tmp_args_element_name_11 );

        exception_lineno = 1508;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1508;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_called_name_8 );
    Py_DECREF( tmp_args_element_name_10 );
    Py_DECREF( tmp_args_element_name_11 );
    Py_DECREF( tmp_args_element_name_12 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1508;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_2;
    branch_no_2:;
    tmp_assattr_name_10 = Py_None;
    tmp_assattr_target_10 = par_self;

    CHECK_OBJECT( tmp_assattr_target_10 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain__into_ssl, tmp_assattr_name_10 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1510;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_11 = Py_None;
    tmp_assattr_target_11 = par_self;

    CHECK_OBJECT( tmp_assattr_target_11 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_11, const_str_plain__from_ssl, tmp_assattr_name_11 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1511;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_12 = par_socket;

    CHECK_OBJECT( tmp_assattr_name_12 );
    tmp_assattr_target_12 = par_self;

    CHECK_OBJECT( tmp_assattr_target_12 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_12, const_str_plain__socket, tmp_assattr_name_12 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1512;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_22 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_22 == NULL ))
    {
        tmp_source_name_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_22 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1513;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain_SSL_set_fd );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1513;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_23 = par_self;

    CHECK_OBJECT( tmp_source_name_23 );
    tmp_args_element_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain__ssl );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );

        exception_lineno = 1514;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__asFileDescriptor );

    if (unlikely( tmp_called_name_10 == NULL ))
    {
        tmp_called_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__asFileDescriptor );
    }

    if ( tmp_called_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_13 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_asFileDescriptor" );
        exception_tb = NULL;

        exception_lineno = 1514;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_24 = par_self;

    CHECK_OBJECT( tmp_source_name_24 );
    tmp_args_element_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain__socket );
    if ( tmp_args_element_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_13 );

        exception_lineno = 1514;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1514;
    {
        PyObject *call_args[] = { tmp_args_element_name_15 };
        tmp_args_element_name_14 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
    }

    Py_DECREF( tmp_args_element_name_15 );
    if ( tmp_args_element_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_13 );

        exception_lineno = 1514;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1513;
    {
        PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_element_name_13 );
    Py_DECREF( tmp_args_element_name_14 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1513;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_set_result == NULL );
    var_set_result = tmp_assign_source_2;

    tmp_called_name_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_11 == NULL ))
    {
        tmp_called_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1516;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_3 = var_set_result;

    CHECK_OBJECT( tmp_compexpr_left_3 );
    tmp_compexpr_right_3 = const_int_pos_1;
    tmp_args_element_name_16 = RICH_COMPARE_EQ( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    if ( tmp_args_element_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1516;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_5791a020e2944607f45102dc7fe5b8e6->m_frame.f_lineno = 1516;
    {
        PyObject *call_args[] = { tmp_args_element_name_16 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    Py_DECREF( tmp_args_element_name_16 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1516;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5791a020e2944607f45102dc7fe5b8e6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5791a020e2944607f45102dc7fe5b8e6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5791a020e2944607f45102dc7fe5b8e6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5791a020e2944607f45102dc7fe5b8e6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5791a020e2944607f45102dc7fe5b8e6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5791a020e2944607f45102dc7fe5b8e6,
        type_description_1,
        par_self,
        par_context,
        par_socket,
        var_ssl,
        var_set_result
    );


    // Release cached frame.
    if ( frame_5791a020e2944607f45102dc7fe5b8e6 == cache_frame_5791a020e2944607f45102dc7fe5b8e6 )
    {
        Py_DECREF( frame_5791a020e2944607f45102dc7fe5b8e6 );
    }
    cache_frame_5791a020e2944607f45102dc7fe5b8e6 = NULL;

    assertFrameObject( frame_5791a020e2944607f45102dc7fe5b8e6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_54___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_ssl );
    Py_DECREF( var_ssl );
    var_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_socket );
    Py_DECREF( par_socket );
    par_socket = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_ssl );
    var_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_socket );
    Py_DECREF( par_socket );
    par_socket = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_54___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_55___getattr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_getattr_attr_1;
    PyObject *tmp_getattr_target_1;
    bool tmp_is_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_424e405bc16ae3d269c45c550285d49d = NULL;

    struct Nuitka_FrameObject *frame_424e405bc16ae3d269c45c550285d49d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_424e405bc16ae3d269c45c550285d49d, codeobj_424e405bc16ae3d269c45c550285d49d, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_424e405bc16ae3d269c45c550285d49d = cache_frame_424e405bc16ae3d269c45c550285d49d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_424e405bc16ae3d269c45c550285d49d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_424e405bc16ae3d269c45c550285d49d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__socket );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1523;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_left_name_1 = const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e;
    tmp_right_name_1 = PyTuple_New( 2 );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_source_name_2 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_3 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1526;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___name__ );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1526;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_name;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1525;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_424e405bc16ae3d269c45c550285d49d->m_frame.f_lineno = 1524;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AttributeError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1524;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_getattr_target_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__socket );
    if ( tmp_getattr_target_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1529;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_getattr_attr_1 = par_name;

    CHECK_OBJECT( tmp_getattr_attr_1 );
    tmp_return_value = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, NULL );
    Py_DECREF( tmp_getattr_target_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1529;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_424e405bc16ae3d269c45c550285d49d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_424e405bc16ae3d269c45c550285d49d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_424e405bc16ae3d269c45c550285d49d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_424e405bc16ae3d269c45c550285d49d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_424e405bc16ae3d269c45c550285d49d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_424e405bc16ae3d269c45c550285d49d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_424e405bc16ae3d269c45c550285d49d,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if ( frame_424e405bc16ae3d269c45c550285d49d == cache_frame_424e405bc16ae3d269c45c550285d49d )
    {
        Py_DECREF( frame_424e405bc16ae3d269c45c550285d49d );
    }
    cache_frame_424e405bc16ae3d269c45c550285d49d = NULL;

    assertFrameObject( frame_424e405bc16ae3d269c45c550285d49d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_55___getattr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_55___getattr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_56__raise_ssl_error( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_ssl = python_pars[ 1 ];
    PyObject *par_result = python_pars[ 2 ];
    PyObject *var_errno = NULL;
    PyObject *var_error = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    int tmp_cmp_Eq_4;
    int tmp_cmp_Eq_5;
    int tmp_cmp_Eq_6;
    int tmp_cmp_Eq_7;
    int tmp_cmp_Eq_8;
    int tmp_cmp_Lt_1;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_left_9;
    PyObject *tmp_compare_left_10;
    PyObject *tmp_compare_left_11;
    PyObject *tmp_compare_left_12;
    PyObject *tmp_compare_left_13;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_compare_right_9;
    PyObject *tmp_compare_right_10;
    PyObject *tmp_compare_right_11;
    PyObject *tmp_compare_right_12;
    PyObject *tmp_compare_right_13;
    bool tmp_isnot_1;
    bool tmp_isnot_2;
    bool tmp_isnot_3;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_raise_type_4;
    PyObject *tmp_raise_type_5;
    PyObject *tmp_raise_type_6;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    PyObject *tmp_source_name_19;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_f71814b0a3096f278454f1408739a313 = NULL;

    struct Nuitka_FrameObject *frame_f71814b0a3096f278454f1408739a313;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f71814b0a3096f278454f1408739a313, codeobj_f71814b0a3096f278454f1408739a313, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f71814b0a3096f278454f1408739a313 = cache_frame_f71814b0a3096f278454f1408739a313;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f71814b0a3096f278454f1408739a313 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f71814b0a3096f278454f1408739a313 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1532;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__verify_helper );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1532;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1533;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__verify_helper );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1533;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1533;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_raise_if_problem );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1533;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_source_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__context );
    if ( tmp_source_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1534;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__alpn_select_helper );
    Py_DECREF( tmp_source_name_5 );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1534;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = Py_None;
    tmp_isnot_2 = ( tmp_compare_left_2 != tmp_compare_right_2 );
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_isnot_2 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_8 = par_self;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_source_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__context );
    if ( tmp_source_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1535;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__alpn_select_helper );
    Py_DECREF( tmp_source_name_7 );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1535;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1535;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_raise_if_problem );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1535;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;
    tmp_source_name_10 = par_self;

    CHECK_OBJECT( tmp_source_name_10 );
    tmp_source_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain__context );
    if ( tmp_source_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1536;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__ocsp_helper );
    Py_DECREF( tmp_source_name_9 );
    if ( tmp_compare_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1536;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_3 = Py_None;
    tmp_isnot_3 = ( tmp_compare_left_3 != tmp_compare_right_3 );
    Py_DECREF( tmp_compare_left_3 );
    if ( tmp_isnot_3 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_12 = par_self;

    CHECK_OBJECT( tmp_source_name_12 );
    tmp_source_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain__context );
    if ( tmp_source_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1537;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__ocsp_helper );
    Py_DECREF( tmp_source_name_11 );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1537;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1537;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_raise_if_problem );
    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1537;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1539;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_ssl;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = par_result;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1539;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_4, const_str_plain_SSL_get_error, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1539;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_error == NULL );
    var_error = tmp_assign_source_1;

    tmp_compare_left_4 = var_error;

    CHECK_OBJECT( tmp_compare_left_4 );
    tmp_source_name_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_13 == NULL ))
    {
        tmp_source_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_13 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1540;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_SSL_ERROR_WANT_READ );
    if ( tmp_compare_right_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1540;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_4, tmp_compare_right_4 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_4 );

        exception_lineno = 1540;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_4 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantReadError );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_WantReadError );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "WantReadError" );
        exception_tb = NULL;

        exception_lineno = 1541;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1541;
    tmp_raise_type_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_raise_type_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1541;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_1;
    exception_lineno = 1541;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    goto branch_end_4;
    branch_no_4:;
    tmp_compare_left_5 = var_error;

    CHECK_OBJECT( tmp_compare_left_5 );
    tmp_source_name_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_14 == NULL ))
    {
        tmp_source_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1542;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_5 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_SSL_ERROR_WANT_WRITE );
    if ( tmp_compare_right_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1542;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_5, tmp_compare_right_5 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_5 );

        exception_lineno = 1542;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_5 );
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantWriteError );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_WantWriteError );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "WantWriteError" );
        exception_tb = NULL;

        exception_lineno = 1543;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1543;
    tmp_raise_type_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_raise_type_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1543;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_2;
    exception_lineno = 1543;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    goto branch_end_5;
    branch_no_5:;
    tmp_compare_left_6 = var_error;

    CHECK_OBJECT( tmp_compare_left_6 );
    tmp_source_name_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_15 == NULL ))
    {
        tmp_source_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1544;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_6 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_SSL_ERROR_ZERO_RETURN );
    if ( tmp_compare_right_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1544;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_6, tmp_compare_right_6 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_6 );

        exception_lineno = 1544;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_6 );
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_ZeroReturnError );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ZeroReturnError );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ZeroReturnError" );
        exception_tb = NULL;

        exception_lineno = 1545;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1545;
    tmp_raise_type_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_raise_type_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1545;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_3;
    exception_lineno = 1545;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    goto branch_end_6;
    branch_no_6:;
    tmp_compare_left_7 = var_error;

    CHECK_OBJECT( tmp_compare_left_7 );
    tmp_source_name_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_16 == NULL ))
    {
        tmp_source_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1546;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_7 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_SSL_ERROR_WANT_X509_LOOKUP );
    if ( tmp_compare_right_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1546;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_4 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_7, tmp_compare_right_7 );
    if ( tmp_cmp_Eq_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_7 );

        exception_lineno = 1546;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_7 );
    if ( tmp_cmp_Eq_4 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantX509LookupError );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_WantX509LookupError );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "WantX509LookupError" );
        exception_tb = NULL;

        exception_lineno = 1548;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1548;
    tmp_raise_type_4 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_raise_type_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1548;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_4;
    exception_lineno = 1548;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    goto branch_end_7;
    branch_no_7:;
    tmp_compare_left_8 = var_error;

    CHECK_OBJECT( tmp_compare_left_8 );
    tmp_source_name_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_17 == NULL ))
    {
        tmp_source_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1549;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_8 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_SSL_ERROR_SYSCALL );
    if ( tmp_compare_right_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1549;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_5 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_8, tmp_compare_right_8 );
    if ( tmp_cmp_Eq_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_8 );

        exception_lineno = 1549;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_8 );
    if ( tmp_cmp_Eq_5 == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_called_instance_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_5 == NULL ))
    {
        tmp_called_instance_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1550;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1550;
    tmp_compare_left_9 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_ERR_peek_error );
    if ( tmp_compare_left_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1550;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_9 = const_int_0;
    tmp_cmp_Eq_6 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_9, tmp_compare_right_9 );
    if ( tmp_cmp_Eq_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_9 );

        exception_lineno = 1550;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_9 );
    if ( tmp_cmp_Eq_6 == 1 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_compare_left_10 = par_result;

    CHECK_OBJECT( tmp_compare_left_10 );
    tmp_compare_right_10 = const_int_0;
    tmp_cmp_Lt_1 = RICH_COMPARE_BOOL_LT( tmp_compare_left_10, tmp_compare_right_10 );
    if ( tmp_cmp_Lt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1551;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Lt_1 == 1 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    tmp_compare_left_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_platform );

    if (unlikely( tmp_compare_left_11 == NULL ))
    {
        tmp_compare_left_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_platform );
    }

    if ( tmp_compare_left_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "platform" );
        exception_tb = NULL;

        exception_lineno = 1552;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_11 = const_str_plain_win32;
    tmp_cmp_Eq_7 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_11, tmp_compare_right_11 );
    if ( tmp_cmp_Eq_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1552;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_7 == 1 )
    {
        goto branch_yes_11;
    }
    else
    {
        goto branch_no_11;
    }
    branch_yes_11:;
    tmp_called_instance_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_6 == NULL ))
    {
        tmp_called_instance_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1553;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1553;
    tmp_subscribed_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_getwinerror );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1553;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_0;
    tmp_assign_source_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1553;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_errno == NULL );
    var_errno = tmp_assign_source_2;

    goto branch_end_11;
    branch_no_11:;
    tmp_source_name_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_18 == NULL ))
    {
        tmp_source_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1555;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_errno );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1555;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_errno == NULL );
    var_errno = tmp_assign_source_3;

    branch_end_11:;
    tmp_compare_left_12 = var_errno;

    CHECK_OBJECT( tmp_compare_left_12 );
    tmp_compare_right_12 = const_int_0;
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_12, tmp_compare_right_12 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1557;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_12;
    }
    else
    {
        goto branch_no_12;
    }
    branch_yes_12:;
    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SysCallError );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SysCallError );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "SysCallError" );
        exception_tb = NULL;

        exception_lineno = 1558;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_errno;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_called_instance_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_errorcode );

    if (unlikely( tmp_called_instance_7 == NULL ))
    {
        tmp_called_instance_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_errorcode );
    }

    if ( tmp_called_instance_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "errorcode" );
        exception_tb = NULL;

        exception_lineno = 1558;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = var_errno;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1558;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_args_element_name_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_get, call_args );
    }

    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1558;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1558;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_raise_type_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1558;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_5;
    exception_lineno = 1558;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_12:;
    branch_no_10:;
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SysCallError );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SysCallError );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "SysCallError" );
        exception_tb = NULL;

        exception_lineno = 1559;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1559;
    tmp_raise_type_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_int_neg_1_str_digest_fa91b370bf4aa8601b20ad022c04c7f5_tuple, 0 ) );

    if ( tmp_raise_type_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1559;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_6;
    exception_lineno = 1559;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    goto branch_end_9;
    branch_no_9:;
    tmp_called_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_7 == NULL ))
    {
        tmp_called_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1562;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1562;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1562;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_9:;
    goto branch_end_8;
    branch_no_8:;
    tmp_compare_left_13 = var_error;

    CHECK_OBJECT( tmp_compare_left_13 );
    tmp_source_name_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_19 == NULL ))
    {
        tmp_source_name_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_19 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1563;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_13 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_SSL_ERROR_NONE );
    if ( tmp_compare_right_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1563;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_8 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_13, tmp_compare_right_13 );
    if ( tmp_cmp_Eq_8 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_13 );

        exception_lineno = 1563;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_13 );
    if ( tmp_cmp_Eq_8 == 1 )
    {
        goto branch_no_13;
    }
    else
    {
        goto branch_yes_13;
    }
    branch_yes_13:;
    tmp_called_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_8 == NULL ))
    {
        tmp_called_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1566;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_f71814b0a3096f278454f1408739a313->m_frame.f_lineno = 1566;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1566;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_13:;
    branch_end_8:;
    branch_end_7:;
    branch_end_6:;
    branch_end_5:;
    branch_end_4:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f71814b0a3096f278454f1408739a313 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f71814b0a3096f278454f1408739a313 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f71814b0a3096f278454f1408739a313, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f71814b0a3096f278454f1408739a313->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f71814b0a3096f278454f1408739a313, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f71814b0a3096f278454f1408739a313,
        type_description_1,
        par_self,
        par_ssl,
        par_result,
        var_errno,
        var_error
    );


    // Release cached frame.
    if ( frame_f71814b0a3096f278454f1408739a313 == cache_frame_f71814b0a3096f278454f1408739a313 )
    {
        Py_DECREF( frame_f71814b0a3096f278454f1408739a313 );
    }
    cache_frame_f71814b0a3096f278454f1408739a313 = NULL;

    assertFrameObject( frame_f71814b0a3096f278454f1408739a313 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_56__raise_ssl_error );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_result );
    Py_DECREF( par_result );
    par_result = NULL;

    CHECK_OBJECT( (PyObject *)var_error );
    Py_DECREF( var_error );
    var_error = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_errno );
    var_errno = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_result );
    Py_DECREF( par_result );
    par_result = NULL;

    Py_XDECREF( var_error );
    var_error = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_56__raise_ssl_error );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_57_get_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_f05618381c99bf98f904cc9e5458eb7c = NULL;

    struct Nuitka_FrameObject *frame_f05618381c99bf98f904cc9e5458eb7c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f05618381c99bf98f904cc9e5458eb7c, codeobj_f05618381c99bf98f904cc9e5458eb7c, module_OpenSSL$SSL, sizeof(void *) );
    frame_f05618381c99bf98f904cc9e5458eb7c = cache_frame_f05618381c99bf98f904cc9e5458eb7c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f05618381c99bf98f904cc9e5458eb7c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f05618381c99bf98f904cc9e5458eb7c ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__context );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1573;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f05618381c99bf98f904cc9e5458eb7c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f05618381c99bf98f904cc9e5458eb7c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f05618381c99bf98f904cc9e5458eb7c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f05618381c99bf98f904cc9e5458eb7c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f05618381c99bf98f904cc9e5458eb7c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f05618381c99bf98f904cc9e5458eb7c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f05618381c99bf98f904cc9e5458eb7c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f05618381c99bf98f904cc9e5458eb7c == cache_frame_f05618381c99bf98f904cc9e5458eb7c )
    {
        Py_DECREF( frame_f05618381c99bf98f904cc9e5458eb7c );
    }
    cache_frame_f05618381c99bf98f904cc9e5458eb7c = NULL;

    assertFrameObject( frame_f05618381c99bf98f904cc9e5458eb7c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_57_get_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_57_get_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_58_set_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_context = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_645fa587f009c4b0f21236cdaad0381f = NULL;

    struct Nuitka_FrameObject *frame_645fa587f009c4b0f21236cdaad0381f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_645fa587f009c4b0f21236cdaad0381f, codeobj_645fa587f009c4b0f21236cdaad0381f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_645fa587f009c4b0f21236cdaad0381f = cache_frame_645fa587f009c4b0f21236cdaad0381f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_645fa587f009c4b0f21236cdaad0381f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_645fa587f009c4b0f21236cdaad0381f ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_context;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Context );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Context );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Context" );
        exception_tb = NULL;

        exception_lineno = 1582;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1582;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_627e1a07a1a60af86ff9e544428f2f09;
    frame_645fa587f009c4b0f21236cdaad0381f->m_frame.f_lineno = 1583;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1583;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1585;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_SSL_CTX );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1585;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1585;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_context;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__context );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1585;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_645fa587f009c4b0f21236cdaad0381f->m_frame.f_lineno = 1585;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1585;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_1 = par_context;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__context, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1586;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_645fa587f009c4b0f21236cdaad0381f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_645fa587f009c4b0f21236cdaad0381f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_645fa587f009c4b0f21236cdaad0381f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_645fa587f009c4b0f21236cdaad0381f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_645fa587f009c4b0f21236cdaad0381f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_645fa587f009c4b0f21236cdaad0381f,
        type_description_1,
        par_self,
        par_context
    );


    // Release cached frame.
    if ( frame_645fa587f009c4b0f21236cdaad0381f == cache_frame_645fa587f009c4b0f21236cdaad0381f )
    {
        Py_DECREF( frame_645fa587f009c4b0f21236cdaad0381f );
    }
    cache_frame_645fa587f009c4b0f21236cdaad0381f = NULL;

    assertFrameObject( frame_645fa587f009c4b0f21236cdaad0381f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_58_set_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_58_set_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_59_get_servername( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_name = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_40b81d4d05ddb4f44d648a36b01e1399 = NULL;

    struct Nuitka_FrameObject *frame_40b81d4d05ddb4f44d648a36b01e1399;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_40b81d4d05ddb4f44d648a36b01e1399, codeobj_40b81d4d05ddb4f44d648a36b01e1399, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_40b81d4d05ddb4f44d648a36b01e1399 = cache_frame_40b81d4d05ddb4f44d648a36b01e1399;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_40b81d4d05ddb4f44d648a36b01e1399 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_40b81d4d05ddb4f44d648a36b01e1399 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1597;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_servername );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1597;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1598;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1598;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_TLSEXT_NAMETYPE_host_name );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1598;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_40b81d4d05ddb4f44d648a36b01e1399->m_frame.f_lineno = 1597;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1597;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_name == NULL );
    var_name = tmp_assign_source_1;

    tmp_compare_left_1 = var_name;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1600;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1600;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1600;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1603;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_name;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_40b81d4d05ddb4f44d648a36b01e1399->m_frame.f_lineno = 1603;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_string, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1603;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40b81d4d05ddb4f44d648a36b01e1399 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_40b81d4d05ddb4f44d648a36b01e1399 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40b81d4d05ddb4f44d648a36b01e1399 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_40b81d4d05ddb4f44d648a36b01e1399, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_40b81d4d05ddb4f44d648a36b01e1399->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_40b81d4d05ddb4f44d648a36b01e1399, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_40b81d4d05ddb4f44d648a36b01e1399,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if ( frame_40b81d4d05ddb4f44d648a36b01e1399 == cache_frame_40b81d4d05ddb4f44d648a36b01e1399 )
    {
        Py_DECREF( frame_40b81d4d05ddb4f44d648a36b01e1399 );
    }
    cache_frame_40b81d4d05ddb4f44d648a36b01e1399 = NULL;

    assertFrameObject( frame_40b81d4d05ddb4f44d648a36b01e1399 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_59_get_servername );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_name );
    Py_DECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_59_get_servername );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_60_set_tlsext_host_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    int tmp_cmp_In_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_49b91f95fc6102a2bc1d95d7f9f8434b = NULL;

    struct Nuitka_FrameObject *frame_49b91f95fc6102a2bc1d95d7f9f8434b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_49b91f95fc6102a2bc1d95d7f9f8434b, codeobj_49b91f95fc6102a2bc1d95d7f9f8434b, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_49b91f95fc6102a2bc1d95d7f9f8434b = cache_frame_49b91f95fc6102a2bc1d95d7f9f8434b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_49b91f95fc6102a2bc1d95d7f9f8434b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_49b91f95fc6102a2bc1d95d7f9f8434b ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_name;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1613;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_d89a36d0b4664ac4178af2071f30652f;
    frame_49b91f95fc6102a2bc1d95d7f9f8434b->m_frame.f_lineno = 1614;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1614;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_compare_left_1 = const_str_chr_0;
    tmp_compare_right_1 = par_name;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_b965e7ab82e8e0c92ec2736091bc1c12;
    frame_49b91f95fc6102a2bc1d95d7f9f8434b->m_frame.f_lineno = 1616;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 1616;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_2:;
    branch_end_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1619;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_tlsext_host_name );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1619;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1619;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_name;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_49b91f95fc6102a2bc1d95d7f9f8434b->m_frame.f_lineno = 1619;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1619;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_49b91f95fc6102a2bc1d95d7f9f8434b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_49b91f95fc6102a2bc1d95d7f9f8434b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_49b91f95fc6102a2bc1d95d7f9f8434b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_49b91f95fc6102a2bc1d95d7f9f8434b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_49b91f95fc6102a2bc1d95d7f9f8434b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_49b91f95fc6102a2bc1d95d7f9f8434b,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if ( frame_49b91f95fc6102a2bc1d95d7f9f8434b == cache_frame_49b91f95fc6102a2bc1d95d7f9f8434b )
    {
        Py_DECREF( frame_49b91f95fc6102a2bc1d95d7f9f8434b );
    }
    cache_frame_49b91f95fc6102a2bc1d95d7f9f8434b = NULL;

    assertFrameObject( frame_49b91f95fc6102a2bc1d95d7f9f8434b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_60_set_tlsext_host_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_60_set_tlsext_host_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_61_pending( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_f269207fdd9aa826c85b87cc35f9c7ef = NULL;

    struct Nuitka_FrameObject *frame_f269207fdd9aa826c85b87cc35f9c7ef;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f269207fdd9aa826c85b87cc35f9c7ef, codeobj_f269207fdd9aa826c85b87cc35f9c7ef, module_OpenSSL$SSL, sizeof(void *) );
    frame_f269207fdd9aa826c85b87cc35f9c7ef = cache_frame_f269207fdd9aa826c85b87cc35f9c7ef;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f269207fdd9aa826c85b87cc35f9c7ef );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f269207fdd9aa826c85b87cc35f9c7ef ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1628;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_pending );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1628;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1628;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_f269207fdd9aa826c85b87cc35f9c7ef->m_frame.f_lineno = 1628;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1628;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f269207fdd9aa826c85b87cc35f9c7ef );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f269207fdd9aa826c85b87cc35f9c7ef );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f269207fdd9aa826c85b87cc35f9c7ef );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f269207fdd9aa826c85b87cc35f9c7ef, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f269207fdd9aa826c85b87cc35f9c7ef->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f269207fdd9aa826c85b87cc35f9c7ef, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f269207fdd9aa826c85b87cc35f9c7ef,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f269207fdd9aa826c85b87cc35f9c7ef == cache_frame_f269207fdd9aa826c85b87cc35f9c7ef )
    {
        Py_DECREF( frame_f269207fdd9aa826c85b87cc35f9c7ef );
    }
    cache_frame_f269207fdd9aa826c85b87cc35f9c7ef = NULL;

    assertFrameObject( frame_f269207fdd9aa826c85b87cc35f9c7ef );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_61_pending );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_61_pending );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_62_send( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buf = python_pars[ 1 ];
    PyObject *par_flags = python_pars[ 2 ];
    PyObject *var_result = NULL;
    PyObject *var_data = NULL;
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__exit = NULL;
    PyObject *tmp_with_1__indicator = NULL;
    PyObject *tmp_with_1__source = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    bool tmp_is_1;
    bool tmp_is_2;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_959585d8d371bbde9fdf5141fa04539f = NULL;

    struct Nuitka_FrameObject *frame_959585d8d371bbde9fdf5141fa04539f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_959585d8d371bbde9fdf5141fa04539f, codeobj_959585d8d371bbde9fdf5141fa04539f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_959585d8d371bbde9fdf5141fa04539f = cache_frame_959585d8d371bbde9fdf5141fa04539f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_959585d8d371bbde9fdf5141fa04539f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_959585d8d371bbde9fdf5141fa04539f ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
        exception_tb = NULL;

        exception_lineno = 1642;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_plain_buf;
    tmp_args_element_name_2 = par_buf;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_959585d8d371bbde9fdf5141fa04539f->m_frame.f_lineno = 1642;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1642;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_buf;
        assert( old != NULL );
        par_buf = tmp_assign_source_1;
        Py_DECREF( old );
    }

    // Tried code:
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__from_buffer );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__from_buffer );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_from_buffer" );
        exception_tb = NULL;

        exception_lineno = 1644;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_3 = par_buf;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_959585d8d371bbde9fdf5141fa04539f->m_frame.f_lineno = 1644;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1644;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    assert( tmp_with_1__source == NULL );
    tmp_with_1__source = tmp_assign_source_2;

    tmp_source_name_1 = tmp_with_1__source;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_3 = LOOKUP_SPECIAL( tmp_source_name_1, const_str_plain___exit__ );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1644;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    assert( tmp_with_1__exit == NULL );
    tmp_with_1__exit = tmp_assign_source_3;

    tmp_source_name_2 = tmp_with_1__source;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_name_3 = LOOKUP_SPECIAL( tmp_source_name_2, const_str_plain___enter__ );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1644;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    frame_959585d8d371bbde9fdf5141fa04539f->m_frame.f_lineno = 1644;
    tmp_assign_source_4 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    Py_DECREF( tmp_called_name_3 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1644;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    assert( tmp_with_1__enter == NULL );
    tmp_with_1__enter = tmp_assign_source_4;

    tmp_assign_source_5 = Py_True;
    assert( tmp_with_1__indicator == NULL );
    Py_INCREF( tmp_assign_source_5 );
    tmp_with_1__indicator = tmp_assign_source_5;

    tmp_assign_source_6 = tmp_with_1__enter;

    CHECK_OBJECT( tmp_assign_source_6 );
    assert( var_data == NULL );
    Py_INCREF( tmp_assign_source_6 );
    var_data = tmp_assign_source_6;

    // Tried code:
    // Tried code:
    tmp_len_arg_1 = par_buf;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1646;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    tmp_compare_right_1 = const_int_pos_2147483647;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1646;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_8cde8912e8f2207155a1addb0752791f;
    frame_959585d8d371bbde9fdf5141fa04539f->m_frame.f_lineno = 1647;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1647;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto try_except_handler_4;
    branch_no_1:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1651;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_write );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1651;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__ssl );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1651;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    tmp_args_element_name_5 = var_data;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_len_arg_2 = var_data;

    CHECK_OBJECT( tmp_len_arg_2 );
    tmp_args_element_name_6 = BUILTIN_LEN( tmp_len_arg_2 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 1651;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    frame_959585d8d371bbde9fdf5141fa04539f->m_frame.f_lineno = 1651;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1651;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_7;

    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__raise_ssl_error );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1652;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__ssl );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1652;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    tmp_args_element_name_8 = var_result;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_959585d8d371bbde9fdf5141fa04539f->m_frame.f_lineno = 1652;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1652;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    tmp_return_value = var_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_62_send );
    return NULL;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_959585d8d371bbde9fdf5141fa04539f );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_959585d8d371bbde9fdf5141fa04539f, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_959585d8d371bbde9fdf5141fa04539f, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyExc_BaseException;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1644;
        type_description_1 = "ooooo";
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_8 = Py_False;
    {
        PyObject *old = tmp_with_1__indicator;
        assert( old != NULL );
        tmp_with_1__indicator = tmp_assign_source_8;
        Py_INCREF( tmp_with_1__indicator );
        Py_DECREF( old );
    }

    tmp_called_name_6 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_6 );
    tmp_args_element_name_9 = PyThreadState_GET()->exc_type;
    tmp_args_element_name_10 = PyThreadState_GET()->exc_value;
    tmp_args_element_name_11 = PyThreadState_GET()->exc_traceback;
    frame_959585d8d371bbde9fdf5141fa04539f->m_frame.f_lineno = 1644;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1644;
        type_description_1 = "ooooo";
        goto try_except_handler_3;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1644;
        type_description_1 = "ooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 1644;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_959585d8d371bbde9fdf5141fa04539f->m_frame) frame_959585d8d371bbde9fdf5141fa04539f->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "ooooo";
    goto try_except_handler_3;
    branch_no_3:;
    goto branch_end_2;
    branch_no_2:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 1644;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_959585d8d371bbde9fdf5141fa04539f->m_frame) frame_959585d8d371bbde9fdf5141fa04539f->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "ooooo";
    goto try_except_handler_3;
    branch_end_2:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_62_send );
    return NULL;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Return handler code:
    try_return_handler_3:;
    tmp_called_name_7 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_7 );
    frame_959585d8d371bbde9fdf5141fa04539f->m_frame.f_lineno = 1644;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_7, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1644;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto try_return_handler_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_3 = tmp_with_1__indicator;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = Py_True;
    tmp_is_1 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_8 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_8 );
    frame_959585d8d371bbde9fdf5141fa04539f->m_frame.f_lineno = 1644;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 1644;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    tmp_compare_left_4 = tmp_with_1__indicator;

    CHECK_OBJECT( tmp_compare_left_4 );
    tmp_compare_right_4 = Py_True;
    tmp_is_2 = ( tmp_compare_left_4 == tmp_compare_right_4 );
    if ( tmp_is_2 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_9 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_9 );
    frame_959585d8d371bbde9fdf5141fa04539f->m_frame.f_lineno = 1644;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_9, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1644;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    goto try_end_3;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__indicator );
    Py_DECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    Py_XDECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    Py_XDECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_959585d8d371bbde9fdf5141fa04539f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_959585d8d371bbde9fdf5141fa04539f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_959585d8d371bbde9fdf5141fa04539f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_959585d8d371bbde9fdf5141fa04539f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_959585d8d371bbde9fdf5141fa04539f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_959585d8d371bbde9fdf5141fa04539f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_959585d8d371bbde9fdf5141fa04539f,
        type_description_1,
        par_self,
        par_buf,
        par_flags,
        var_result,
        var_data
    );


    // Release cached frame.
    if ( frame_959585d8d371bbde9fdf5141fa04539f == cache_frame_959585d8d371bbde9fdf5141fa04539f )
    {
        Py_DECREF( frame_959585d8d371bbde9fdf5141fa04539f );
    }
    cache_frame_959585d8d371bbde9fdf5141fa04539f = NULL;

    assertFrameObject( frame_959585d8d371bbde9fdf5141fa04539f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_62_send );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)var_data );
    Py_DECREF( var_data );
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_62_send );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_63_sendall( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buf = python_pars[ 1 ];
    PyObject *par_flags = python_pars[ 2 ];
    PyObject *var_left_to_send = NULL;
    PyObject *var_total_sent = NULL;
    PyObject *var_data = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__exit = NULL;
    PyObject *tmp_with_1__indicator = NULL;
    PyObject *tmp_with_1__source = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    int tmp_exc_match_exception_match_1;
    bool tmp_is_1;
    bool tmp_is_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_len_arg_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_09184f4a96c99cec7a5d574311293fc2 = NULL;

    struct Nuitka_FrameObject *frame_09184f4a96c99cec7a5d574311293fc2;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_09184f4a96c99cec7a5d574311293fc2, codeobj_09184f4a96c99cec7a5d574311293fc2, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_09184f4a96c99cec7a5d574311293fc2 = cache_frame_09184f4a96c99cec7a5d574311293fc2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_09184f4a96c99cec7a5d574311293fc2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_09184f4a96c99cec7a5d574311293fc2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
        exception_tb = NULL;

        exception_lineno = 1669;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_plain_buf;
    tmp_args_element_name_2 = par_buf;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_09184f4a96c99cec7a5d574311293fc2->m_frame.f_lineno = 1669;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1669;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_buf;
        assert( old != NULL );
        par_buf = tmp_assign_source_1;
        Py_DECREF( old );
    }

    // Tried code:
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__from_buffer );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__from_buffer );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_from_buffer" );
        exception_tb = NULL;

        exception_lineno = 1671;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_3 = par_buf;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_09184f4a96c99cec7a5d574311293fc2->m_frame.f_lineno = 1671;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1671;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    assert( tmp_with_1__source == NULL );
    tmp_with_1__source = tmp_assign_source_2;

    tmp_source_name_1 = tmp_with_1__source;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_3 = LOOKUP_SPECIAL( tmp_source_name_1, const_str_plain___exit__ );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1671;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    assert( tmp_with_1__exit == NULL );
    tmp_with_1__exit = tmp_assign_source_3;

    tmp_source_name_2 = tmp_with_1__source;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_name_3 = LOOKUP_SPECIAL( tmp_source_name_2, const_str_plain___enter__ );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1671;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    frame_09184f4a96c99cec7a5d574311293fc2->m_frame.f_lineno = 1671;
    tmp_assign_source_4 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    Py_DECREF( tmp_called_name_3 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1671;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    assert( tmp_with_1__enter == NULL );
    tmp_with_1__enter = tmp_assign_source_4;

    tmp_assign_source_5 = Py_True;
    assert( tmp_with_1__indicator == NULL );
    Py_INCREF( tmp_assign_source_5 );
    tmp_with_1__indicator = tmp_assign_source_5;

    tmp_assign_source_6 = tmp_with_1__enter;

    CHECK_OBJECT( tmp_assign_source_6 );
    assert( var_data == NULL );
    Py_INCREF( tmp_assign_source_6 );
    var_data = tmp_assign_source_6;

    // Tried code:
    // Tried code:
    tmp_len_arg_1 = par_buf;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_assign_source_7 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1673;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }
    assert( var_left_to_send == NULL );
    var_left_to_send = tmp_assign_source_7;

    tmp_assign_source_8 = const_int_0;
    assert( var_total_sent == NULL );
    Py_INCREF( tmp_assign_source_8 );
    var_total_sent = tmp_assign_source_8;

    loop_start_1:;
    tmp_cond_value_1 = var_left_to_send;

    if ( tmp_cond_value_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "left_to_send" );
        exception_tb = NULL;

        exception_lineno = 1676;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1676;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    goto loop_end_1;
    branch_no_1:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1679;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_write );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1679;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__ssl );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1680;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }
    tmp_left_name_1 = var_data;

    CHECK_OBJECT( tmp_left_name_1 );
    tmp_right_name_1 = var_total_sent;

    if ( tmp_right_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "total_sent" );
        exception_tb = NULL;

        exception_lineno = 1680;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }

    tmp_args_element_name_5 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 1680;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }
    tmp_called_name_5 = LOOKUP_BUILTIN( const_str_plain_min );
    assert( tmp_called_name_5 != NULL );
    tmp_args_element_name_7 = var_left_to_send;

    if ( tmp_args_element_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "left_to_send" );
        exception_tb = NULL;

        exception_lineno = 1680;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }

    tmp_args_element_name_8 = const_int_pos_2147483647;
    frame_09184f4a96c99cec7a5d574311293fc2->m_frame.f_lineno = 1680;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_args_element_name_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 1680;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }
    frame_09184f4a96c99cec7a5d574311293fc2->m_frame.f_lineno = 1679;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_9 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1679;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }
    {
        PyObject *old = var_result;
        var_result = tmp_assign_source_9;
        Py_XDECREF( old );
    }

    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__raise_ssl_error );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1682;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__ssl );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 1682;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }
    tmp_args_element_name_10 = var_result;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_09184f4a96c99cec7a5d574311293fc2->m_frame.f_lineno = 1682;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1682;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    tmp_left_name_2 = var_total_sent;

    if ( tmp_left_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "total_sent" );
        exception_tb = NULL;

        exception_lineno = 1683;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }

    tmp_right_name_2 = var_result;

    CHECK_OBJECT( tmp_right_name_2 );
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_2, tmp_right_name_2 );
    tmp_assign_source_10 = tmp_left_name_2;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1683;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }
    var_total_sent = tmp_assign_source_10;

    tmp_left_name_3 = var_left_to_send;

    if ( tmp_left_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "left_to_send" );
        exception_tb = NULL;

        exception_lineno = 1684;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }

    tmp_right_name_3 = var_result;

    CHECK_OBJECT( tmp_right_name_3 );
    tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceSubtract, &tmp_left_name_3, tmp_right_name_3 );
    tmp_assign_source_11 = tmp_left_name_3;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1684;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }
    var_left_to_send = tmp_assign_source_11;

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1676;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_return_value = var_total_sent;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "total_sent" );
        exception_tb = NULL;

        exception_lineno = 1686;
        type_description_1 = "ooooooo";
        goto try_except_handler_4;
    }

    Py_INCREF( tmp_return_value );
    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_63_sendall );
    return NULL;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_09184f4a96c99cec7a5d574311293fc2 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_09184f4a96c99cec7a5d574311293fc2, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_09184f4a96c99cec7a5d574311293fc2, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = PyExc_BaseException;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1671;
        type_description_1 = "ooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_12 = Py_False;
    {
        PyObject *old = tmp_with_1__indicator;
        assert( old != NULL );
        tmp_with_1__indicator = tmp_assign_source_12;
        Py_INCREF( tmp_with_1__indicator );
        Py_DECREF( old );
    }

    tmp_called_name_7 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_7 );
    tmp_args_element_name_11 = PyThreadState_GET()->exc_type;
    tmp_args_element_name_12 = PyThreadState_GET()->exc_value;
    tmp_args_element_name_13 = PyThreadState_GET()->exc_traceback;
    frame_09184f4a96c99cec7a5d574311293fc2->m_frame.f_lineno = 1671;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12, tmp_args_element_name_13 };
        tmp_cond_value_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_7, call_args );
    }

    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1671;
        type_description_1 = "ooooooo";
        goto try_except_handler_3;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 1671;
        type_description_1 = "ooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 1671;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_09184f4a96c99cec7a5d574311293fc2->m_frame) frame_09184f4a96c99cec7a5d574311293fc2->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "ooooooo";
    goto try_except_handler_3;
    branch_no_3:;
    goto branch_end_2;
    branch_no_2:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 1671;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_09184f4a96c99cec7a5d574311293fc2->m_frame) frame_09184f4a96c99cec7a5d574311293fc2->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "ooooooo";
    goto try_except_handler_3;
    branch_end_2:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_63_sendall );
    return NULL;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Return handler code:
    try_return_handler_3:;
    tmp_called_name_8 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_8 );
    frame_09184f4a96c99cec7a5d574311293fc2->m_frame.f_lineno = 1671;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1671;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto try_return_handler_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_2 = tmp_with_1__indicator;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = Py_True;
    tmp_is_1 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    if ( tmp_is_1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_9 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_9 );
    frame_09184f4a96c99cec7a5d574311293fc2->m_frame.f_lineno = 1671;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_9, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 1671;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    tmp_compare_left_3 = tmp_with_1__indicator;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = Py_True;
    tmp_is_2 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_2 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_10 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_10 );
    frame_09184f4a96c99cec7a5d574311293fc2->m_frame.f_lineno = 1671;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_10, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1671;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    goto try_end_3;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__indicator );
    Py_DECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    Py_XDECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    Py_XDECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_09184f4a96c99cec7a5d574311293fc2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_09184f4a96c99cec7a5d574311293fc2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_09184f4a96c99cec7a5d574311293fc2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_09184f4a96c99cec7a5d574311293fc2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_09184f4a96c99cec7a5d574311293fc2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_09184f4a96c99cec7a5d574311293fc2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_09184f4a96c99cec7a5d574311293fc2,
        type_description_1,
        par_self,
        par_buf,
        par_flags,
        var_left_to_send,
        var_total_sent,
        var_data,
        var_result
    );


    // Release cached frame.
    if ( frame_09184f4a96c99cec7a5d574311293fc2 == cache_frame_09184f4a96c99cec7a5d574311293fc2 )
    {
        Py_DECREF( frame_09184f4a96c99cec7a5d574311293fc2 );
    }
    cache_frame_09184f4a96c99cec7a5d574311293fc2 = NULL;

    assertFrameObject( frame_09184f4a96c99cec7a5d574311293fc2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_63_sendall );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_left_to_send );
    var_left_to_send = NULL;

    Py_XDECREF( var_total_sent );
    var_total_sent = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_data );
    Py_DECREF( var_data );
    var_data = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_left_to_send );
    var_left_to_send = NULL;

    Py_XDECREF( var_total_sent );
    var_total_sent = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_63_sendall );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_64_recv( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_bufsiz = python_pars[ 1 ];
    PyObject *par_flags = python_pars[ 2 ];
    PyObject *var_buf = NULL;
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_1f33a93420eb4e87671bc14ef5fd1e7f = NULL;

    struct Nuitka_FrameObject *frame_1f33a93420eb4e87671bc14ef5fd1e7f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1f33a93420eb4e87671bc14ef5fd1e7f, codeobj_1f33a93420eb4e87671bc14ef5fd1e7f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1f33a93420eb4e87671bc14ef5fd1e7f = cache_frame_1f33a93420eb4e87671bc14ef5fd1e7f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1f33a93420eb4e87671bc14ef5fd1e7f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1f33a93420eb4e87671bc14ef5fd1e7f ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
        exception_tb = NULL;

        exception_lineno = 1697;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_digest_c561652c58984ec0e9541542aa405594;
    tmp_args_element_name_2 = par_bufsiz;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_1f33a93420eb4e87671bc14ef5fd1e7f->m_frame.f_lineno = 1697;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1697;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_buf == NULL );
    var_buf = tmp_assign_source_1;

    tmp_compexpr_left_1 = par_flags;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = Py_None;
    tmp_and_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 != tmp_compexpr_right_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    assert( !(tmp_and_left_truth_1 == -1) );
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_left_name_1 = par_flags;

    CHECK_OBJECT( tmp_left_name_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_socket );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_socket );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "socket" );
        exception_tb = NULL;

        exception_lineno = 1698;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_MSG_PEEK );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1698;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = BINARY_OPERATION( PyNumber_And, tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1698;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    Py_INCREF( tmp_and_left_value_1 );
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1698;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1699;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_peek );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1699;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ssl );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1699;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = var_buf;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_args_element_name_5 = par_bufsiz;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_1f33a93420eb4e87671bc14ef5fd1e7f->m_frame.f_lineno = 1699;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1699;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_2;

    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1701;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_read );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1701;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__ssl );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1701;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = var_buf;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = par_bufsiz;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_1f33a93420eb4e87671bc14ef5fd1e7f->m_frame.f_lineno = 1701;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1701;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_3;

    branch_end_1:;
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__raise_ssl_error );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1702;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__ssl );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1702;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = var_result;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_1f33a93420eb4e87671bc14ef5fd1e7f->m_frame.f_lineno = 1702;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1702;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1703;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = var_buf;

    CHECK_OBJECT( tmp_args_element_name_11 );
    tmp_args_element_name_12 = var_result;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_1f33a93420eb4e87671bc14ef5fd1e7f->m_frame.f_lineno = 1703;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
    }

    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1703;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1703;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f33a93420eb4e87671bc14ef5fd1e7f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f33a93420eb4e87671bc14ef5fd1e7f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f33a93420eb4e87671bc14ef5fd1e7f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1f33a93420eb4e87671bc14ef5fd1e7f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1f33a93420eb4e87671bc14ef5fd1e7f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1f33a93420eb4e87671bc14ef5fd1e7f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1f33a93420eb4e87671bc14ef5fd1e7f,
        type_description_1,
        par_self,
        par_bufsiz,
        par_flags,
        var_buf,
        var_result
    );


    // Release cached frame.
    if ( frame_1f33a93420eb4e87671bc14ef5fd1e7f == cache_frame_1f33a93420eb4e87671bc14ef5fd1e7f )
    {
        Py_DECREF( frame_1f33a93420eb4e87671bc14ef5fd1e7f );
    }
    cache_frame_1f33a93420eb4e87671bc14ef5fd1e7f = NULL;

    assertFrameObject( frame_1f33a93420eb4e87671bc14ef5fd1e7f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_64_recv );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_buf );
    Py_DECREF( var_buf );
    var_buf = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    CHECK_OBJECT( (PyObject *)par_bufsiz );
    Py_DECREF( par_bufsiz );
    par_bufsiz = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_buf );
    var_buf = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    CHECK_OBJECT( (PyObject *)par_bufsiz );
    Py_DECREF( par_bufsiz );
    par_bufsiz = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_64_recv );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_65_recv_into( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *par_nbytes = python_pars[ 2 ];
    PyObject *par_flags = python_pars[ 3 ];
    PyObject *var_buf = NULL;
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    bool tmp_is_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_sliceass_target_1;
    PyObject *tmp_sliceass_upper_1;
    PyObject *tmp_sliceass_value_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_9de539dd2c4fff7fa74b7cb5d14f8608 = NULL;

    struct Nuitka_FrameObject *frame_9de539dd2c4fff7fa74b7cb5d14f8608;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9de539dd2c4fff7fa74b7cb5d14f8608, codeobj_9de539dd2c4fff7fa74b7cb5d14f8608, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9de539dd2c4fff7fa74b7cb5d14f8608 = cache_frame_9de539dd2c4fff7fa74b7cb5d14f8608;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9de539dd2c4fff7fa74b7cb5d14f8608 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9de539dd2c4fff7fa74b7cb5d14f8608 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_nbytes;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_len_arg_1 = par_buffer;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_assign_source_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1722;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_nbytes;
        assert( old != NULL );
        par_nbytes = tmp_assign_source_1;
        Py_DECREF( old );
    }

    goto branch_end_1;
    branch_no_1:;
    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_min );
    assert( tmp_called_name_1 != NULL );
    tmp_args_element_name_1 = par_nbytes;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_len_arg_2 = par_buffer;

    CHECK_OBJECT( tmp_len_arg_2 );
    tmp_args_element_name_2 = BUILTIN_LEN( tmp_len_arg_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1724;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_9de539dd2c4fff7fa74b7cb5d14f8608->m_frame.f_lineno = 1724;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1724;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_nbytes;
        assert( old != NULL );
        par_nbytes = tmp_assign_source_2;
        Py_DECREF( old );
    }

    branch_end_1:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
        exception_tb = NULL;

        exception_lineno = 1729;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = const_str_digest_c561652c58984ec0e9541542aa405594;
    tmp_args_element_name_4 = par_nbytes;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_9de539dd2c4fff7fa74b7cb5d14f8608->m_frame.f_lineno = 1729;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1729;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_buf == NULL );
    var_buf = tmp_assign_source_3;

    tmp_compexpr_left_1 = par_flags;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = Py_None;
    tmp_and_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 != tmp_compexpr_right_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    assert( !(tmp_and_left_truth_1 == -1) );
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_left_name_1 = par_flags;

    CHECK_OBJECT( tmp_left_name_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_socket );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_socket );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "socket" );
        exception_tb = NULL;

        exception_lineno = 1730;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_MSG_PEEK );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1730;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = BINARY_OPERATION( PyNumber_And, tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1730;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    Py_INCREF( tmp_and_left_value_1 );
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1730;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1731;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_peek );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1731;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ssl );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1731;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_buf;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = par_nbytes;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_9de539dd2c4fff7fa74b7cb5d14f8608->m_frame.f_lineno = 1731;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1731;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_4;

    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1733;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_read );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1733;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__ssl );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1733;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_buf;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_args_element_name_10 = par_nbytes;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_9de539dd2c4fff7fa74b7cb5d14f8608->m_frame.f_lineno = 1733;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1733;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_5;

    branch_end_2:;
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__raise_ssl_error );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1734;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__ssl );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1734;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_12 = var_result;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_9de539dd2c4fff7fa74b7cb5d14f8608->m_frame.f_lineno = 1734;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1734;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_6 = (PyObject *)&PyMemoryView_Type;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1740;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_14 = var_buf;

    CHECK_OBJECT( tmp_args_element_name_14 );
    tmp_args_element_name_15 = var_result;

    CHECK_OBJECT( tmp_args_element_name_15 );
    frame_9de539dd2c4fff7fa74b7cb5d14f8608->m_frame.f_lineno = 1740;
    {
        PyObject *call_args[] = { tmp_args_element_name_14, tmp_args_element_name_15 };
        tmp_args_element_name_13 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
    }

    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1740;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_9de539dd2c4fff7fa74b7cb5d14f8608->m_frame.f_lineno = 1740;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_sliceass_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_args_element_name_13 );
    if ( tmp_sliceass_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1740;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_sliceass_target_1 = par_buffer;

    CHECK_OBJECT( tmp_sliceass_target_1 );
    tmp_sliceass_upper_1 = var_result;

    CHECK_OBJECT( tmp_sliceass_upper_1 );
    tmp_result = SET_SLICE( tmp_sliceass_target_1, Py_None, tmp_sliceass_upper_1, tmp_sliceass_value_1 );
    Py_DECREF( tmp_sliceass_value_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1740;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9de539dd2c4fff7fa74b7cb5d14f8608 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9de539dd2c4fff7fa74b7cb5d14f8608 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9de539dd2c4fff7fa74b7cb5d14f8608, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9de539dd2c4fff7fa74b7cb5d14f8608->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9de539dd2c4fff7fa74b7cb5d14f8608, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9de539dd2c4fff7fa74b7cb5d14f8608,
        type_description_1,
        par_self,
        par_buffer,
        par_nbytes,
        par_flags,
        var_buf,
        var_result
    );


    // Release cached frame.
    if ( frame_9de539dd2c4fff7fa74b7cb5d14f8608 == cache_frame_9de539dd2c4fff7fa74b7cb5d14f8608 )
    {
        Py_DECREF( frame_9de539dd2c4fff7fa74b7cb5d14f8608 );
    }
    cache_frame_9de539dd2c4fff7fa74b7cb5d14f8608 = NULL;

    assertFrameObject( frame_9de539dd2c4fff7fa74b7cb5d14f8608 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_65_recv_into );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    CHECK_OBJECT( (PyObject *)par_nbytes );
    Py_DECREF( par_nbytes );
    par_nbytes = NULL;

    CHECK_OBJECT( (PyObject *)var_buf );
    Py_DECREF( var_buf );
    var_buf = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    Py_XDECREF( par_nbytes );
    par_nbytes = NULL;

    Py_XDECREF( var_buf );
    var_buf = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_65_recv_into );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_66__handle_bio_errors( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_bio = python_pars[ 1 ];
    PyObject *par_result = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_raise_type_4;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_1f497ea15bbb42e7e15142701e11983e = NULL;

    struct Nuitka_FrameObject *frame_1f497ea15bbb42e7e15142701e11983e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1f497ea15bbb42e7e15142701e11983e, codeobj_1f497ea15bbb42e7e15142701e11983e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1f497ea15bbb42e7e15142701e11983e = cache_frame_1f497ea15bbb42e7e15142701e11983e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1f497ea15bbb42e7e15142701e11983e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1f497ea15bbb42e7e15142701e11983e ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1745;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_bio;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_1f497ea15bbb42e7e15142701e11983e->m_frame.f_lineno = 1745;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_BIO_should_retry, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1745;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1745;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1746;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_bio;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_1f497ea15bbb42e7e15142701e11983e->m_frame.f_lineno = 1746;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_cond_value_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_BIO_should_read, call_args );
    }

    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1746;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 1746;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantReadError );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_WantReadError );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "WantReadError" );
        exception_tb = NULL;

        exception_lineno = 1747;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_1f497ea15bbb42e7e15142701e11983e->m_frame.f_lineno = 1747;
    tmp_raise_type_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_raise_type_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1747;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_1;
    exception_lineno = 1747;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    goto branch_end_2;
    branch_no_2:;
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1748;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = par_bio;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_1f497ea15bbb42e7e15142701e11983e->m_frame.f_lineno = 1748;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_cond_value_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_BIO_should_write, call_args );
    }

    if ( tmp_cond_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1748;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 1748;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantWriteError );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_WantWriteError );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "WantWriteError" );
        exception_tb = NULL;

        exception_lineno = 1750;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_1f497ea15bbb42e7e15142701e11983e->m_frame.f_lineno = 1750;
    tmp_raise_type_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_raise_type_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1750;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_2;
    exception_lineno = 1750;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    goto branch_end_3;
    branch_no_3:;
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1751;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = par_bio;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_1f497ea15bbb42e7e15142701e11983e->m_frame.f_lineno = 1751;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_cond_value_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_BIO_should_io_special, call_args );
    }

    if ( tmp_cond_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1751;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_4 );

        exception_lineno = 1751;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_make_exception_arg_1 = const_str_plain_BIO_should_io_special;
    frame_1f497ea15bbb42e7e15142701e11983e->m_frame.f_lineno = 1754;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 1754;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    goto branch_end_4;
    branch_no_4:;
    tmp_make_exception_arg_2 = const_str_digest_1491fa532da0499070a77d607dd12a0d;
    frame_1f497ea15bbb42e7e15142701e11983e->m_frame.f_lineno = 1757;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_4 != NULL );
    exception_type = tmp_raise_type_4;
    exception_lineno = 1757;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_end_4:;
    branch_end_3:;
    branch_end_2:;
    goto branch_end_1;
    branch_no_1:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
        exception_tb = NULL;

        exception_lineno = 1760;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_1f497ea15bbb42e7e15142701e11983e->m_frame.f_lineno = 1760;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1760;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f497ea15bbb42e7e15142701e11983e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f497ea15bbb42e7e15142701e11983e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1f497ea15bbb42e7e15142701e11983e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1f497ea15bbb42e7e15142701e11983e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1f497ea15bbb42e7e15142701e11983e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1f497ea15bbb42e7e15142701e11983e,
        type_description_1,
        par_self,
        par_bio,
        par_result
    );


    // Release cached frame.
    if ( frame_1f497ea15bbb42e7e15142701e11983e == cache_frame_1f497ea15bbb42e7e15142701e11983e )
    {
        Py_DECREF( frame_1f497ea15bbb42e7e15142701e11983e );
    }
    cache_frame_1f497ea15bbb42e7e15142701e11983e = NULL;

    assertFrameObject( frame_1f497ea15bbb42e7e15142701e11983e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_66__handle_bio_errors );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_bio );
    Py_DECREF( par_bio );
    par_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_result );
    Py_DECREF( par_result );
    par_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_bio );
    Py_DECREF( par_bio );
    par_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_result );
    Py_DECREF( par_result );
    par_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_66__handle_bio_errors );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_67_bio_read( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_bufsiz = python_pars[ 1 ];
    PyObject *var_buf = NULL;
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cmp_LtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_76de6ab7acc79e46a01681558ca59a8f = NULL;

    struct Nuitka_FrameObject *frame_76de6ab7acc79e46a01681558ca59a8f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_76de6ab7acc79e46a01681558ca59a8f, codeobj_76de6ab7acc79e46a01681558ca59a8f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_76de6ab7acc79e46a01681558ca59a8f = cache_frame_76de6ab7acc79e46a01681558ca59a8f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_76de6ab7acc79e46a01681558ca59a8f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_76de6ab7acc79e46a01681558ca59a8f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__from_ssl );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1773;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6;
    frame_76de6ab7acc79e46a01681558ca59a8f->m_frame.f_lineno = 1774;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1774;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_isinstance_inst_1 = par_bufsiz;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 1776;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1776;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_2 = const_str_digest_f6ccda911266ccc3bb4cd038d18beb52;
    frame_76de6ab7acc79e46a01681558ca59a8f->m_frame.f_lineno = 1777;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 1777;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
        exception_tb = NULL;

        exception_lineno = 1779;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_digest_c561652c58984ec0e9541542aa405594;
    tmp_args_element_name_2 = par_bufsiz;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_76de6ab7acc79e46a01681558ca59a8f->m_frame.f_lineno = 1779;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1779;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_buf == NULL );
    var_buf = tmp_assign_source_1;

    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1780;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_BIO_read );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1780;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__from_ssl );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1780;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = var_buf;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_args_element_name_5 = par_bufsiz;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_76de6ab7acc79e46a01681558ca59a8f->m_frame.f_lineno = 1780;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1780;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_2;

    tmp_compare_left_2 = var_result;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = const_int_0;
    tmp_cmp_LtE_1 = RICH_COMPARE_BOOL_LE( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_LtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1781;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_LtE_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__handle_bio_errors );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1782;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__from_ssl );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1782;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = var_result;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_76de6ab7acc79e46a01681558ca59a8f->m_frame.f_lineno = 1782;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1782;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1784;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = var_buf;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_args_element_name_9 = var_result;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_76de6ab7acc79e46a01681558ca59a8f->m_frame.f_lineno = 1784;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
    }

    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1784;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1784;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_76de6ab7acc79e46a01681558ca59a8f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_76de6ab7acc79e46a01681558ca59a8f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_76de6ab7acc79e46a01681558ca59a8f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_76de6ab7acc79e46a01681558ca59a8f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_76de6ab7acc79e46a01681558ca59a8f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_76de6ab7acc79e46a01681558ca59a8f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_76de6ab7acc79e46a01681558ca59a8f,
        type_description_1,
        par_self,
        par_bufsiz,
        var_buf,
        var_result
    );


    // Release cached frame.
    if ( frame_76de6ab7acc79e46a01681558ca59a8f == cache_frame_76de6ab7acc79e46a01681558ca59a8f )
    {
        Py_DECREF( frame_76de6ab7acc79e46a01681558ca59a8f );
    }
    cache_frame_76de6ab7acc79e46a01681558ca59a8f = NULL;

    assertFrameObject( frame_76de6ab7acc79e46a01681558ca59a8f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_67_bio_read );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_buf );
    Py_DECREF( var_buf );
    var_buf = NULL;

    CHECK_OBJECT( (PyObject *)par_bufsiz );
    Py_DECREF( par_bufsiz );
    par_bufsiz = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_buf );
    var_buf = NULL;

    CHECK_OBJECT( (PyObject *)par_bufsiz );
    Py_DECREF( par_bufsiz );
    par_bufsiz = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_67_bio_read );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_68_bio_write( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buf = python_pars[ 1 ];
    PyObject *var_data = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__exit = NULL;
    PyObject *tmp_with_1__indicator = NULL;
    PyObject *tmp_with_1__source = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    int tmp_cmp_LtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    bool tmp_is_1;
    bool tmp_is_2;
    bool tmp_is_3;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_46248d2a1416020447a2f1bda814331e = NULL;

    struct Nuitka_FrameObject *frame_46248d2a1416020447a2f1bda814331e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_46248d2a1416020447a2f1bda814331e, codeobj_46248d2a1416020447a2f1bda814331e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_46248d2a1416020447a2f1bda814331e = cache_frame_46248d2a1416020447a2f1bda814331e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_46248d2a1416020447a2f1bda814331e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_46248d2a1416020447a2f1bda814331e ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
        exception_tb = NULL;

        exception_lineno = 1796;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_plain_buf;
    tmp_args_element_name_2 = par_buf;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_46248d2a1416020447a2f1bda814331e->m_frame.f_lineno = 1796;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1796;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_buf;
        assert( old != NULL );
        par_buf = tmp_assign_source_1;
        Py_DECREF( old );
    }

    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__into_ssl );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1798;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6;
    frame_46248d2a1416020447a2f1bda814331e->m_frame.f_lineno = 1799;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1799;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    // Tried code:
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__from_buffer );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__from_buffer );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_from_buffer" );
        exception_tb = NULL;

        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_3 = par_buf;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_46248d2a1416020447a2f1bda814331e->m_frame.f_lineno = 1801;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    assert( tmp_with_1__source == NULL );
    tmp_with_1__source = tmp_assign_source_2;

    tmp_source_name_2 = tmp_with_1__source;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_assign_source_3 = LOOKUP_SPECIAL( tmp_source_name_2, const_str_plain___exit__ );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    assert( tmp_with_1__exit == NULL );
    tmp_with_1__exit = tmp_assign_source_3;

    tmp_source_name_3 = tmp_with_1__source;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_name_3 = LOOKUP_SPECIAL( tmp_source_name_3, const_str_plain___enter__ );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    frame_46248d2a1416020447a2f1bda814331e->m_frame.f_lineno = 1801;
    tmp_assign_source_4 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    Py_DECREF( tmp_called_name_3 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    assert( tmp_with_1__enter == NULL );
    tmp_with_1__enter = tmp_assign_source_4;

    tmp_assign_source_5 = Py_True;
    assert( tmp_with_1__indicator == NULL );
    Py_INCREF( tmp_assign_source_5 );
    tmp_with_1__indicator = tmp_assign_source_5;

    tmp_assign_source_6 = tmp_with_1__enter;

    CHECK_OBJECT( tmp_assign_source_6 );
    assert( var_data == NULL );
    Py_INCREF( tmp_assign_source_6 );
    var_data = tmp_assign_source_6;

    // Tried code:
    // Tried code:
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1802;
        type_description_1 = "oooo";
        goto try_except_handler_4;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_BIO_write );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1802;
        type_description_1 = "oooo";
        goto try_except_handler_4;
    }
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__into_ssl );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1802;
        type_description_1 = "oooo";
        goto try_except_handler_4;
    }
    tmp_args_element_name_5 = var_data;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_len_arg_1 = var_data;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_args_element_name_6 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 1802;
        type_description_1 = "oooo";
        goto try_except_handler_4;
    }
    frame_46248d2a1416020447a2f1bda814331e->m_frame.f_lineno = 1802;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1802;
        type_description_1 = "oooo";
        goto try_except_handler_4;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_7;

    tmp_compare_left_2 = var_result;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = const_int_0;
    tmp_cmp_LtE_1 = RICH_COMPARE_BOOL_LE( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_LtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1803;
        type_description_1 = "oooo";
        goto try_except_handler_4;
    }
    if ( tmp_cmp_LtE_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__handle_bio_errors );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1804;
        type_description_1 = "oooo";
        goto try_except_handler_4;
    }
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__into_ssl );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1804;
        type_description_1 = "oooo";
        goto try_except_handler_4;
    }
    tmp_args_element_name_8 = var_result;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_46248d2a1416020447a2f1bda814331e->m_frame.f_lineno = 1804;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1804;
        type_description_1 = "oooo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;
    tmp_return_value = var_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_68_bio_write );
    return NULL;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_46248d2a1416020447a2f1bda814331e );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_46248d2a1416020447a2f1bda814331e, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_46248d2a1416020447a2f1bda814331e, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_3 = PyThreadState_GET()->exc_type;
    tmp_compare_right_3 = PyExc_BaseException;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_assign_source_8 = Py_False;
    {
        PyObject *old = tmp_with_1__indicator;
        assert( old != NULL );
        tmp_with_1__indicator = tmp_assign_source_8;
        Py_INCREF( tmp_with_1__indicator );
        Py_DECREF( old );
    }

    tmp_called_name_6 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_6 );
    tmp_args_element_name_9 = PyThreadState_GET()->exc_type;
    tmp_args_element_name_10 = PyThreadState_GET()->exc_value;
    tmp_args_element_name_11 = PyThreadState_GET()->exc_traceback;
    frame_46248d2a1416020447a2f1bda814331e->m_frame.f_lineno = 1801;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_3;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 1801;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_46248d2a1416020447a2f1bda814331e->m_frame) frame_46248d2a1416020447a2f1bda814331e->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooo";
    goto try_except_handler_3;
    branch_no_4:;
    goto branch_end_3;
    branch_no_3:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 1801;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_46248d2a1416020447a2f1bda814331e->m_frame) frame_46248d2a1416020447a2f1bda814331e->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooo";
    goto try_except_handler_3;
    branch_end_3:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_68_bio_write );
    return NULL;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Return handler code:
    try_return_handler_3:;
    tmp_called_name_7 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_7 );
    frame_46248d2a1416020447a2f1bda814331e->m_frame.f_lineno = 1801;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_7, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto try_return_handler_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_4 = tmp_with_1__indicator;

    CHECK_OBJECT( tmp_compare_left_4 );
    tmp_compare_right_4 = Py_True;
    tmp_is_2 = ( tmp_compare_left_4 == tmp_compare_right_4 );
    if ( tmp_is_2 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_8 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_8 );
    frame_46248d2a1416020447a2f1bda814331e->m_frame.f_lineno = 1801;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    tmp_compare_left_5 = tmp_with_1__indicator;

    CHECK_OBJECT( tmp_compare_left_5 );
    tmp_compare_right_5 = Py_True;
    tmp_is_3 = ( tmp_compare_left_5 == tmp_compare_right_5 );
    if ( tmp_is_3 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_called_name_9 = tmp_with_1__exit;

    CHECK_OBJECT( tmp_called_name_9 );
    frame_46248d2a1416020447a2f1bda814331e->m_frame.f_lineno = 1801;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_9, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1801;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_6:;
    goto try_end_3;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__indicator );
    Py_DECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    Py_XDECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    Py_XDECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_46248d2a1416020447a2f1bda814331e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_46248d2a1416020447a2f1bda814331e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_46248d2a1416020447a2f1bda814331e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_46248d2a1416020447a2f1bda814331e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_46248d2a1416020447a2f1bda814331e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_46248d2a1416020447a2f1bda814331e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_46248d2a1416020447a2f1bda814331e,
        type_description_1,
        par_self,
        par_buf,
        var_data,
        var_result
    );


    // Release cached frame.
    if ( frame_46248d2a1416020447a2f1bda814331e == cache_frame_46248d2a1416020447a2f1bda814331e )
    {
        Py_DECREF( frame_46248d2a1416020447a2f1bda814331e );
    }
    cache_frame_46248d2a1416020447a2f1bda814331e = NULL;

    assertFrameObject( frame_46248d2a1416020447a2f1bda814331e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_68_bio_write );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_data );
    Py_DECREF( var_data );
    var_data = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_data );
    var_data = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_68_bio_write );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_69_renegotiate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_ef80d1e646870f9f8e6a3599220d1f6c = NULL;

    struct Nuitka_FrameObject *frame_ef80d1e646870f9f8e6a3599220d1f6c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ef80d1e646870f9f8e6a3599220d1f6c, codeobj_ef80d1e646870f9f8e6a3599220d1f6c, module_OpenSSL$SSL, sizeof(void *) );
    frame_ef80d1e646870f9f8e6a3599220d1f6c = cache_frame_ef80d1e646870f9f8e6a3599220d1f6c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ef80d1e646870f9f8e6a3599220d1f6c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ef80d1e646870f9f8e6a3599220d1f6c ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_ef80d1e646870f9f8e6a3599220d1f6c->m_frame.f_lineno = 1814;
    tmp_cond_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_renegotiate_pending );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1814;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1814;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1815;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1815;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_renegotiate );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1815;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1815;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_ef80d1e646870f9f8e6a3599220d1f6c->m_frame.f_lineno = 1815;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1815;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1815;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_ef80d1e646870f9f8e6a3599220d1f6c->m_frame.f_lineno = 1815;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1815;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ef80d1e646870f9f8e6a3599220d1f6c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ef80d1e646870f9f8e6a3599220d1f6c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ef80d1e646870f9f8e6a3599220d1f6c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ef80d1e646870f9f8e6a3599220d1f6c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ef80d1e646870f9f8e6a3599220d1f6c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ef80d1e646870f9f8e6a3599220d1f6c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ef80d1e646870f9f8e6a3599220d1f6c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ef80d1e646870f9f8e6a3599220d1f6c == cache_frame_ef80d1e646870f9f8e6a3599220d1f6c )
    {
        Py_DECREF( frame_ef80d1e646870f9f8e6a3599220d1f6c );
    }
    cache_frame_ef80d1e646870f9f8e6a3599220d1f6c = NULL;

    assertFrameObject( frame_ef80d1e646870f9f8e6a3599220d1f6c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_69_renegotiate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_69_renegotiate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_70_do_handshake( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_f471e6be7d01aa5c66b978c44c21caac = NULL;

    struct Nuitka_FrameObject *frame_f471e6be7d01aa5c66b978c44c21caac;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f471e6be7d01aa5c66b978c44c21caac, codeobj_f471e6be7d01aa5c66b978c44c21caac, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_f471e6be7d01aa5c66b978c44c21caac = cache_frame_f471e6be7d01aa5c66b978c44c21caac;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f471e6be7d01aa5c66b978c44c21caac );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f471e6be7d01aa5c66b978c44c21caac ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1827;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_do_handshake );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1827;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1827;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_f471e6be7d01aa5c66b978c44c21caac->m_frame.f_lineno = 1827;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1827;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__raise_ssl_error );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1828;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__ssl );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1828;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_result;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_f471e6be7d01aa5c66b978c44c21caac->m_frame.f_lineno = 1828;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1828;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f471e6be7d01aa5c66b978c44c21caac );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f471e6be7d01aa5c66b978c44c21caac );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f471e6be7d01aa5c66b978c44c21caac, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f471e6be7d01aa5c66b978c44c21caac->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f471e6be7d01aa5c66b978c44c21caac, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f471e6be7d01aa5c66b978c44c21caac,
        type_description_1,
        par_self,
        var_result
    );


    // Release cached frame.
    if ( frame_f471e6be7d01aa5c66b978c44c21caac == cache_frame_f471e6be7d01aa5c66b978c44c21caac )
    {
        Py_DECREF( frame_f471e6be7d01aa5c66b978c44c21caac );
    }
    cache_frame_f471e6be7d01aa5c66b978c44c21caac = NULL;

    assertFrameObject( frame_f471e6be7d01aa5c66b978c44c21caac );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_70_do_handshake );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_70_do_handshake );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_71_renegotiate_pending( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_cefffc968213c61d10c7867e6cb8570d = NULL;

    struct Nuitka_FrameObject *frame_cefffc968213c61d10c7867e6cb8570d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cefffc968213c61d10c7867e6cb8570d, codeobj_cefffc968213c61d10c7867e6cb8570d, module_OpenSSL$SSL, sizeof(void *) );
    frame_cefffc968213c61d10c7867e6cb8570d = cache_frame_cefffc968213c61d10c7867e6cb8570d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cefffc968213c61d10c7867e6cb8570d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cefffc968213c61d10c7867e6cb8570d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1838;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_renegotiate_pending );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1838;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1838;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_cefffc968213c61d10c7867e6cb8570d->m_frame.f_lineno = 1838;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1838;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1838;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cefffc968213c61d10c7867e6cb8570d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cefffc968213c61d10c7867e6cb8570d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cefffc968213c61d10c7867e6cb8570d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cefffc968213c61d10c7867e6cb8570d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cefffc968213c61d10c7867e6cb8570d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cefffc968213c61d10c7867e6cb8570d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cefffc968213c61d10c7867e6cb8570d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_cefffc968213c61d10c7867e6cb8570d == cache_frame_cefffc968213c61d10c7867e6cb8570d )
    {
        Py_DECREF( frame_cefffc968213c61d10c7867e6cb8570d );
    }
    cache_frame_cefffc968213c61d10c7867e6cb8570d = NULL;

    assertFrameObject( frame_cefffc968213c61d10c7867e6cb8570d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_71_renegotiate_pending );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_71_renegotiate_pending );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_72_total_renegotiations( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_8020a8b1dd8cc3669fc7bd37ad12a2b9 = NULL;

    struct Nuitka_FrameObject *frame_8020a8b1dd8cc3669fc7bd37ad12a2b9;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8020a8b1dd8cc3669fc7bd37ad12a2b9, codeobj_8020a8b1dd8cc3669fc7bd37ad12a2b9, module_OpenSSL$SSL, sizeof(void *) );
    frame_8020a8b1dd8cc3669fc7bd37ad12a2b9 = cache_frame_8020a8b1dd8cc3669fc7bd37ad12a2b9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8020a8b1dd8cc3669fc7bd37ad12a2b9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8020a8b1dd8cc3669fc7bd37ad12a2b9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1847;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_total_renegotiations );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1847;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1847;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_8020a8b1dd8cc3669fc7bd37ad12a2b9->m_frame.f_lineno = 1847;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1847;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8020a8b1dd8cc3669fc7bd37ad12a2b9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8020a8b1dd8cc3669fc7bd37ad12a2b9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8020a8b1dd8cc3669fc7bd37ad12a2b9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8020a8b1dd8cc3669fc7bd37ad12a2b9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8020a8b1dd8cc3669fc7bd37ad12a2b9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8020a8b1dd8cc3669fc7bd37ad12a2b9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8020a8b1dd8cc3669fc7bd37ad12a2b9,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8020a8b1dd8cc3669fc7bd37ad12a2b9 == cache_frame_8020a8b1dd8cc3669fc7bd37ad12a2b9 )
    {
        Py_DECREF( frame_8020a8b1dd8cc3669fc7bd37ad12a2b9 );
    }
    cache_frame_8020a8b1dd8cc3669fc7bd37ad12a2b9 = NULL;

    assertFrameObject( frame_8020a8b1dd8cc3669fc7bd37ad12a2b9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_72_total_renegotiations );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_72_total_renegotiations );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_73_connect( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_addr = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_0b065f9eac3a60d85f6dd231c0feb979 = NULL;

    struct Nuitka_FrameObject *frame_0b065f9eac3a60d85f6dd231c0feb979;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0b065f9eac3a60d85f6dd231c0feb979, codeobj_0b065f9eac3a60d85f6dd231c0feb979, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_0b065f9eac3a60d85f6dd231c0feb979 = cache_frame_0b065f9eac3a60d85f6dd231c0feb979;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0b065f9eac3a60d85f6dd231c0feb979 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0b065f9eac3a60d85f6dd231c0feb979 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1858;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_connect_state );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1858;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1858;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_0b065f9eac3a60d85f6dd231c0feb979->m_frame.f_lineno = 1858;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1858;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__socket );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1859;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_addr;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_0b065f9eac3a60d85f6dd231c0feb979->m_frame.f_lineno = 1859;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_connect, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1859;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b065f9eac3a60d85f6dd231c0feb979 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b065f9eac3a60d85f6dd231c0feb979 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b065f9eac3a60d85f6dd231c0feb979 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0b065f9eac3a60d85f6dd231c0feb979, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0b065f9eac3a60d85f6dd231c0feb979->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0b065f9eac3a60d85f6dd231c0feb979, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0b065f9eac3a60d85f6dd231c0feb979,
        type_description_1,
        par_self,
        par_addr
    );


    // Release cached frame.
    if ( frame_0b065f9eac3a60d85f6dd231c0feb979 == cache_frame_0b065f9eac3a60d85f6dd231c0feb979 )
    {
        Py_DECREF( frame_0b065f9eac3a60d85f6dd231c0feb979 );
    }
    cache_frame_0b065f9eac3a60d85f6dd231c0feb979 = NULL;

    assertFrameObject( frame_0b065f9eac3a60d85f6dd231c0feb979 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_73_connect );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_73_connect );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_74_connect_ex( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_addr = python_pars[ 1 ];
    PyObject *var_connect_ex = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_8ad19aa17d83645d613ebc651e52854c = NULL;

    struct Nuitka_FrameObject *frame_8ad19aa17d83645d613ebc651e52854c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8ad19aa17d83645d613ebc651e52854c, codeobj_8ad19aa17d83645d613ebc651e52854c, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8ad19aa17d83645d613ebc651e52854c = cache_frame_8ad19aa17d83645d613ebc651e52854c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8ad19aa17d83645d613ebc651e52854c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8ad19aa17d83645d613ebc651e52854c ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__socket );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1871;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_connect_ex );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1871;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_connect_ex == NULL );
    var_connect_ex = tmp_assign_source_1;

    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_8ad19aa17d83645d613ebc651e52854c->m_frame.f_lineno = 1872;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_set_connect_state );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1872;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_1 = var_connect_ex;

    CHECK_OBJECT( tmp_called_name_1 );
    tmp_args_element_name_1 = par_addr;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_8ad19aa17d83645d613ebc651e52854c->m_frame.f_lineno = 1873;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1873;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8ad19aa17d83645d613ebc651e52854c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8ad19aa17d83645d613ebc651e52854c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8ad19aa17d83645d613ebc651e52854c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8ad19aa17d83645d613ebc651e52854c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8ad19aa17d83645d613ebc651e52854c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8ad19aa17d83645d613ebc651e52854c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8ad19aa17d83645d613ebc651e52854c,
        type_description_1,
        par_self,
        par_addr,
        var_connect_ex
    );


    // Release cached frame.
    if ( frame_8ad19aa17d83645d613ebc651e52854c == cache_frame_8ad19aa17d83645d613ebc651e52854c )
    {
        Py_DECREF( frame_8ad19aa17d83645d613ebc651e52854c );
    }
    cache_frame_8ad19aa17d83645d613ebc651e52854c = NULL;

    assertFrameObject( frame_8ad19aa17d83645d613ebc651e52854c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_74_connect_ex );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_connect_ex );
    Py_DECREF( var_connect_ex );
    var_connect_ex = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_connect_ex );
    var_connect_ex = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_74_connect_ex );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_75_accept( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_client = NULL;
    PyObject *var_addr = NULL;
    PyObject *var_conn = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc = NULL;

    struct Nuitka_FrameObject *frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc, codeobj_f70ca376b0b1f16d9dd97a3dbf1ac8bc, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc = cache_frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__socket );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1885;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc->m_frame.f_lineno = 1885;
    tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_accept );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1885;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1885;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__source_iter == NULL );
    tmp_tuple_unpack_1__source_iter = tmp_assign_source_1;

    // Tried code:
    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_1 );
    tmp_assign_source_2 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooo";
        exception_lineno = 1885;
        goto try_except_handler_3;
    }
    assert( tmp_tuple_unpack_1__element_1 == NULL );
    tmp_tuple_unpack_1__element_1 = tmp_assign_source_2;

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_2 );
    tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooo";
        exception_lineno = 1885;
        goto try_except_handler_3;
    }
    assert( tmp_tuple_unpack_1__element_2 == NULL );
    tmp_tuple_unpack_1__element_2 = tmp_assign_source_3;

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_1 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "oooo";
                exception_lineno = 1885;
                goto try_except_handler_3;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        type_description_1 = "oooo";
        exception_lineno = 1885;
        goto try_except_handler_3;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    tmp_assign_source_4 = tmp_tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_assign_source_4 );
    assert( var_client == NULL );
    Py_INCREF( tmp_assign_source_4 );
    var_client = tmp_assign_source_4;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    tmp_assign_source_5 = tmp_tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_assign_source_5 );
    assert( var_addr == NULL );
    Py_INCREF( tmp_assign_source_5 );
    var_addr = tmp_assign_source_5;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
        exception_tb = NULL;

        exception_lineno = 1886;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1886;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_client;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc->m_frame.f_lineno = 1886;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1886;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_conn == NULL );
    var_conn = tmp_assign_source_6;

    tmp_called_instance_2 = var_conn;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc->m_frame.f_lineno = 1887;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_set_accept_state );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1887;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc,
        type_description_1,
        par_self,
        var_client,
        var_addr,
        var_conn
    );


    // Release cached frame.
    if ( frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc == cache_frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc )
    {
        Py_DECREF( frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc );
    }
    cache_frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc = NULL;

    assertFrameObject( frame_f70ca376b0b1f16d9dd97a3dbf1ac8bc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = PyTuple_New( 2 );
    tmp_tuple_element_1 = var_conn;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_return_value, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_addr;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_return_value, 1, tmp_tuple_element_1 );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_75_accept );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_client );
    Py_DECREF( var_client );
    var_client = NULL;

    CHECK_OBJECT( (PyObject *)var_addr );
    Py_DECREF( var_addr );
    var_addr = NULL;

    CHECK_OBJECT( (PyObject *)var_conn );
    Py_DECREF( var_conn );
    var_conn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_client );
    var_client = NULL;

    Py_XDECREF( var_addr );
    var_addr = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_75_accept );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_76_bio_shutdown( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_is_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_b2acd45430926a957bca22524535bd30 = NULL;

    struct Nuitka_FrameObject *frame_b2acd45430926a957bca22524535bd30;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b2acd45430926a957bca22524535bd30, codeobj_b2acd45430926a957bca22524535bd30, module_OpenSSL$SSL, sizeof(void *) );
    frame_b2acd45430926a957bca22524535bd30 = cache_frame_b2acd45430926a957bca22524535bd30;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b2acd45430926a957bca22524535bd30 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b2acd45430926a957bca22524535bd30 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__from_ssl );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1898;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6;
    frame_b2acd45430926a957bca22524535bd30->m_frame.f_lineno = 1899;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1899;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "o";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1901;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_BIO_set_mem_eof_return );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1901;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__into_ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1901;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = const_int_0;
    frame_b2acd45430926a957bca22524535bd30->m_frame.f_lineno = 1901;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1901;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b2acd45430926a957bca22524535bd30 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b2acd45430926a957bca22524535bd30 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b2acd45430926a957bca22524535bd30, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b2acd45430926a957bca22524535bd30->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b2acd45430926a957bca22524535bd30, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b2acd45430926a957bca22524535bd30,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b2acd45430926a957bca22524535bd30 == cache_frame_b2acd45430926a957bca22524535bd30 )
    {
        Py_DECREF( frame_b2acd45430926a957bca22524535bd30 );
    }
    cache_frame_b2acd45430926a957bca22524535bd30 = NULL;

    assertFrameObject( frame_b2acd45430926a957bca22524535bd30 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_76_bio_shutdown );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_76_bio_shutdown );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_77_shutdown( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Gt_1;
    int tmp_cmp_Lt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_970d54497ed5d25db8bd7deb24b2b711 = NULL;

    struct Nuitka_FrameObject *frame_970d54497ed5d25db8bd7deb24b2b711;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_970d54497ed5d25db8bd7deb24b2b711, codeobj_970d54497ed5d25db8bd7deb24b2b711, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_970d54497ed5d25db8bd7deb24b2b711 = cache_frame_970d54497ed5d25db8bd7deb24b2b711;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_970d54497ed5d25db8bd7deb24b2b711 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_970d54497ed5d25db8bd7deb24b2b711 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1912;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_shutdown );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1912;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1912;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_970d54497ed5d25db8bd7deb24b2b711->m_frame.f_lineno = 1912;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1912;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_compare_left_1 = var_result;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_Lt_1 = RICH_COMPARE_BOOL_LT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Lt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1913;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Lt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__raise_ssl_error );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1914;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__ssl );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1914;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_result;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_970d54497ed5d25db8bd7deb24b2b711->m_frame.f_lineno = 1914;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1914;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_1;
    branch_no_1:;
    tmp_compare_left_2 = var_result;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = const_int_0;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1915;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_2;
    branch_no_2:;
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_end_2:;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_970d54497ed5d25db8bd7deb24b2b711 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_970d54497ed5d25db8bd7deb24b2b711 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_970d54497ed5d25db8bd7deb24b2b711 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_970d54497ed5d25db8bd7deb24b2b711, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_970d54497ed5d25db8bd7deb24b2b711->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_970d54497ed5d25db8bd7deb24b2b711, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_970d54497ed5d25db8bd7deb24b2b711,
        type_description_1,
        par_self,
        var_result
    );


    // Release cached frame.
    if ( frame_970d54497ed5d25db8bd7deb24b2b711 == cache_frame_970d54497ed5d25db8bd7deb24b2b711 )
    {
        Py_DECREF( frame_970d54497ed5d25db8bd7deb24b2b711 );
    }
    cache_frame_970d54497ed5d25db8bd7deb24b2b711 = NULL;

    assertFrameObject( frame_970d54497ed5d25db8bd7deb24b2b711 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_77_shutdown );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_77_shutdown );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_78_get_cipher_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_i = NULL;
    PyObject *var_ciphers = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_293d554e28a2e0dbefe61787be9b3f54 = NULL;

    struct Nuitka_FrameObject *frame_293d554e28a2e0dbefe61787be9b3f54;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PyList_New( 0 );
    assert( var_ciphers == NULL );
    var_ciphers = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_293d554e28a2e0dbefe61787be9b3f54, codeobj_293d554e28a2e0dbefe61787be9b3f54, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_293d554e28a2e0dbefe61787be9b3f54 = cache_frame_293d554e28a2e0dbefe61787be9b3f54;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_293d554e28a2e0dbefe61787be9b3f54 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_293d554e28a2e0dbefe61787be9b3f54 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_count );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_count );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "count" );
        exception_tb = NULL;

        exception_lineno = 1927;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_293d554e28a2e0dbefe61787be9b3f54->m_frame.f_lineno = 1927;
    tmp_iter_arg_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1927;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1927;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooo";
        exception_lineno = 1927;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1927;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_4;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1928;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_cipher_list );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1928;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1928;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_2 = var_i;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_293d554e28a2e0dbefe61787be9b3f54->m_frame.f_lineno = 1928;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1928;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_result;
        var_result = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_compare_left_2 = var_result;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1929;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_compare_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1929;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 1929;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    goto loop_end_1;
    branch_no_2:;
    tmp_source_name_4 = var_ciphers;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_append );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1931;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__native );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
    }

    if ( tmp_called_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
        exception_tb = NULL;

        exception_lineno = 1931;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1931;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_5 = var_result;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_293d554e28a2e0dbefe61787be9b3f54->m_frame.f_lineno = 1931;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_args_element_name_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_string, call_args );
    }

    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1931;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    frame_293d554e28a2e0dbefe61787be9b3f54->m_frame.f_lineno = 1931;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1931;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    frame_293d554e28a2e0dbefe61787be9b3f54->m_frame.f_lineno = 1931;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1931;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1927;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_293d554e28a2e0dbefe61787be9b3f54 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_293d554e28a2e0dbefe61787be9b3f54 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_293d554e28a2e0dbefe61787be9b3f54, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_293d554e28a2e0dbefe61787be9b3f54->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_293d554e28a2e0dbefe61787be9b3f54, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_293d554e28a2e0dbefe61787be9b3f54,
        type_description_1,
        par_self,
        var_i,
        var_ciphers,
        var_result
    );


    // Release cached frame.
    if ( frame_293d554e28a2e0dbefe61787be9b3f54 == cache_frame_293d554e28a2e0dbefe61787be9b3f54 )
    {
        Py_DECREF( frame_293d554e28a2e0dbefe61787be9b3f54 );
    }
    cache_frame_293d554e28a2e0dbefe61787be9b3f54 = NULL;

    assertFrameObject( frame_293d554e28a2e0dbefe61787be9b3f54 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = var_ciphers;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_78_get_cipher_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ciphers );
    Py_DECREF( var_ciphers );
    var_ciphers = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ciphers );
    Py_DECREF( var_ciphers );
    var_ciphers = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_78_get_cipher_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_79_get_client_ca_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_name = NULL;
    PyObject *var_pyname = NULL;
    PyObject *var_i = NULL;
    PyObject *var_ca_names = NULL;
    PyObject *var_result = NULL;
    PyObject *var_copy = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_range_arg_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_8a41e5553d84f5d5e266ff41226b9c33 = NULL;

    struct Nuitka_FrameObject *frame_8a41e5553d84f5d5e266ff41226b9c33;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8a41e5553d84f5d5e266ff41226b9c33, codeobj_8a41e5553d84f5d5e266ff41226b9c33, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8a41e5553d84f5d5e266ff41226b9c33 = cache_frame_8a41e5553d84f5d5e266ff41226b9c33;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8a41e5553d84f5d5e266ff41226b9c33 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8a41e5553d84f5d5e266ff41226b9c33 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1947;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_client_CA_list );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1947;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1947;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_8a41e5553d84f5d5e266ff41226b9c33->m_frame.f_lineno = 1947;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1947;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_ca_names == NULL );
    var_ca_names = tmp_assign_source_1;

    tmp_compare_left_1 = var_ca_names;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1948;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1948;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1948;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = PyList_New( 0 );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_assign_source_2 = PyList_New( 0 );
    assert( var_result == NULL );
    var_result = tmp_assign_source_2;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1953;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_ca_names;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_8a41e5553d84f5d5e266ff41226b9c33->m_frame.f_lineno = 1953;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_sk_X509_NAME_num, call_args );
    }

    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1953;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1953;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1953;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_3;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_4 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooooo";
        exception_lineno = 1953;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_2 = exception_keeper_type_1;
    tmp_compare_right_2 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1953;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_2;
    branch_no_2:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_2:;
    // End of try:
    try_end_1:;
    tmp_assign_source_5 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_5 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_5;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1954;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_3 = var_ca_names;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = var_i;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_8a41e5553d84f5d5e266ff41226b9c33->m_frame.f_lineno = 1954;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_sk_X509_NAME_value, call_args );
    }

    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1954;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_name;
        var_name = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1955;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_5 = var_name;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_8a41e5553d84f5d5e266ff41226b9c33->m_frame.f_lineno = 1955;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_X509_NAME_dup, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1955;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_copy;
        var_copy = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 1956;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_compexpr_left_1 = var_copy;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1956;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1956;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_6 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1956;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    frame_8a41e5553d84f5d5e266ff41226b9c33->m_frame.f_lineno = 1956;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1956;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Name );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
        exception_tb = NULL;

        exception_lineno = 1958;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain___new__ );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1958;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Name );

    if (unlikely( tmp_args_element_name_7 == NULL ))
    {
        tmp_args_element_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
    }

    if ( tmp_args_element_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
        exception_tb = NULL;

        exception_lineno = 1958;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    frame_8a41e5553d84f5d5e266ff41226b9c33->m_frame.f_lineno = 1958;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1958;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_pyname;
        var_pyname = tmp_assign_source_8;
        Py_XDECREF( old );
    }

    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 1959;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_gc );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1959;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_8 = var_copy;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1959;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_X509_NAME_free );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1959;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    frame_8a41e5553d84f5d5e266ff41226b9c33->m_frame.f_lineno = 1959;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1959;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_assattr_target_1 = var_pyname;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1959;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_called_instance_4 = var_result;

    CHECK_OBJECT( tmp_called_instance_4 );
    tmp_args_element_name_10 = var_pyname;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_8a41e5553d84f5d5e266ff41226b9c33->m_frame.f_lineno = 1960;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1960;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1953;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a41e5553d84f5d5e266ff41226b9c33 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a41e5553d84f5d5e266ff41226b9c33 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a41e5553d84f5d5e266ff41226b9c33 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8a41e5553d84f5d5e266ff41226b9c33, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8a41e5553d84f5d5e266ff41226b9c33->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8a41e5553d84f5d5e266ff41226b9c33, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8a41e5553d84f5d5e266ff41226b9c33,
        type_description_1,
        par_self,
        var_name,
        var_pyname,
        var_i,
        var_ca_names,
        var_result,
        var_copy
    );


    // Release cached frame.
    if ( frame_8a41e5553d84f5d5e266ff41226b9c33 == cache_frame_8a41e5553d84f5d5e266ff41226b9c33 )
    {
        Py_DECREF( frame_8a41e5553d84f5d5e266ff41226b9c33 );
    }
    cache_frame_8a41e5553d84f5d5e266ff41226b9c33 = NULL;

    assertFrameObject( frame_8a41e5553d84f5d5e266ff41226b9c33 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = var_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_79_get_client_ca_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_pyname );
    var_pyname = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ca_names );
    Py_DECREF( var_ca_names );
    var_ca_names = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_copy );
    var_copy = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_pyname );
    var_pyname = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ca_names );
    var_ca_names = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_copy );
    var_copy = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_79_get_client_ca_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_80_makefile( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    static struct Nuitka_FrameObject *cache_frame_7f96db37ca0e6291733c630c66c75747 = NULL;

    struct Nuitka_FrameObject *frame_7f96db37ca0e6291733c630c66c75747;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7f96db37ca0e6291733c630c66c75747, codeobj_7f96db37ca0e6291733c630c66c75747, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7f96db37ca0e6291733c630c66c75747 = cache_frame_7f96db37ca0e6291733c630c66c75747;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7f96db37ca0e6291733c630c66c75747 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7f96db37ca0e6291733c630c66c75747 ) == 2 ); // Frame stack

    // Framed code:
    tmp_make_exception_arg_1 = const_str_digest_7540551bed0e4507c2b90cdbe0aa8fb3;
    frame_7f96db37ca0e6291733c630c66c75747->m_frame.f_lineno = 1970;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1970;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7f96db37ca0e6291733c630c66c75747 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7f96db37ca0e6291733c630c66c75747 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7f96db37ca0e6291733c630c66c75747, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7f96db37ca0e6291733c630c66c75747->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7f96db37ca0e6291733c630c66c75747, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7f96db37ca0e6291733c630c66c75747,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_7f96db37ca0e6291733c630c66c75747 == cache_frame_7f96db37ca0e6291733c630c66c75747 )
    {
        Py_DECREF( frame_7f96db37ca0e6291733c630c66c75747 );
    }
    cache_frame_7f96db37ca0e6291733c630c66c75747 = NULL;

    assertFrameObject( frame_7f96db37ca0e6291733c630c66c75747 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_80_makefile );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_80_makefile );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_OpenSSL$SSL$$$function_81_get_app_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_7ad94f13e041b88ab1ac27807baabbcd = NULL;

    struct Nuitka_FrameObject *frame_7ad94f13e041b88ab1ac27807baabbcd;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7ad94f13e041b88ab1ac27807baabbcd, codeobj_7ad94f13e041b88ab1ac27807baabbcd, module_OpenSSL$SSL, sizeof(void *) );
    frame_7ad94f13e041b88ab1ac27807baabbcd = cache_frame_7ad94f13e041b88ab1ac27807baabbcd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7ad94f13e041b88ab1ac27807baabbcd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7ad94f13e041b88ab1ac27807baabbcd ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__app_data );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1980;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ad94f13e041b88ab1ac27807baabbcd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ad94f13e041b88ab1ac27807baabbcd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ad94f13e041b88ab1ac27807baabbcd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7ad94f13e041b88ab1ac27807baabbcd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7ad94f13e041b88ab1ac27807baabbcd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7ad94f13e041b88ab1ac27807baabbcd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7ad94f13e041b88ab1ac27807baabbcd,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_7ad94f13e041b88ab1ac27807baabbcd == cache_frame_7ad94f13e041b88ab1ac27807baabbcd )
    {
        Py_DECREF( frame_7ad94f13e041b88ab1ac27807baabbcd );
    }
    cache_frame_7ad94f13e041b88ab1ac27807baabbcd = NULL;

    assertFrameObject( frame_7ad94f13e041b88ab1ac27807baabbcd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_81_get_app_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_81_get_app_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_82_set_app_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_data = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_bb8872b94b0002e97eef74e34fbffbe1 = NULL;

    struct Nuitka_FrameObject *frame_bb8872b94b0002e97eef74e34fbffbe1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bb8872b94b0002e97eef74e34fbffbe1, codeobj_bb8872b94b0002e97eef74e34fbffbe1, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_bb8872b94b0002e97eef74e34fbffbe1 = cache_frame_bb8872b94b0002e97eef74e34fbffbe1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bb8872b94b0002e97eef74e34fbffbe1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bb8872b94b0002e97eef74e34fbffbe1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = par_data;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__app_data, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1989;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bb8872b94b0002e97eef74e34fbffbe1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bb8872b94b0002e97eef74e34fbffbe1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bb8872b94b0002e97eef74e34fbffbe1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bb8872b94b0002e97eef74e34fbffbe1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bb8872b94b0002e97eef74e34fbffbe1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bb8872b94b0002e97eef74e34fbffbe1,
        type_description_1,
        par_self,
        par_data
    );


    // Release cached frame.
    if ( frame_bb8872b94b0002e97eef74e34fbffbe1 == cache_frame_bb8872b94b0002e97eef74e34fbffbe1 )
    {
        Py_DECREF( frame_bb8872b94b0002e97eef74e34fbffbe1 );
    }
    cache_frame_bb8872b94b0002e97eef74e34fbffbe1 = NULL;

    assertFrameObject( frame_bb8872b94b0002e97eef74e34fbffbe1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_82_set_app_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_82_set_app_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_83_get_shutdown( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_87f7d3bd0c797a24b2bca9399e1fbbb9 = NULL;

    struct Nuitka_FrameObject *frame_87f7d3bd0c797a24b2bca9399e1fbbb9;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_87f7d3bd0c797a24b2bca9399e1fbbb9, codeobj_87f7d3bd0c797a24b2bca9399e1fbbb9, module_OpenSSL$SSL, sizeof(void *) );
    frame_87f7d3bd0c797a24b2bca9399e1fbbb9 = cache_frame_87f7d3bd0c797a24b2bca9399e1fbbb9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_87f7d3bd0c797a24b2bca9399e1fbbb9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_87f7d3bd0c797a24b2bca9399e1fbbb9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 1998;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_shutdown );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1998;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1998;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_87f7d3bd0c797a24b2bca9399e1fbbb9->m_frame.f_lineno = 1998;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1998;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_87f7d3bd0c797a24b2bca9399e1fbbb9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_87f7d3bd0c797a24b2bca9399e1fbbb9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_87f7d3bd0c797a24b2bca9399e1fbbb9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_87f7d3bd0c797a24b2bca9399e1fbbb9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_87f7d3bd0c797a24b2bca9399e1fbbb9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_87f7d3bd0c797a24b2bca9399e1fbbb9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_87f7d3bd0c797a24b2bca9399e1fbbb9,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_87f7d3bd0c797a24b2bca9399e1fbbb9 == cache_frame_87f7d3bd0c797a24b2bca9399e1fbbb9 )
    {
        Py_DECREF( frame_87f7d3bd0c797a24b2bca9399e1fbbb9 );
    }
    cache_frame_87f7d3bd0c797a24b2bca9399e1fbbb9 = NULL;

    assertFrameObject( frame_87f7d3bd0c797a24b2bca9399e1fbbb9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_83_get_shutdown );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_83_get_shutdown );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_84_set_shutdown( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_state = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_acda319b97db4bd0371702c365a552ee = NULL;

    struct Nuitka_FrameObject *frame_acda319b97db4bd0371702c365a552ee;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_acda319b97db4bd0371702c365a552ee, codeobj_acda319b97db4bd0371702c365a552ee, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_acda319b97db4bd0371702c365a552ee = cache_frame_acda319b97db4bd0371702c365a552ee;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_acda319b97db4bd0371702c365a552ee );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_acda319b97db4bd0371702c365a552ee ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_state;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
        exception_tb = NULL;

        exception_lineno = 2007;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2007;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_8cc305fc9d9a417a96ba57f2c87b94e9;
    frame_acda319b97db4bd0371702c365a552ee->m_frame.f_lineno = 2008;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2008;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2010;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_shutdown );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2010;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2010;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_state;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_acda319b97db4bd0371702c365a552ee->m_frame.f_lineno = 2010;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2010;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_acda319b97db4bd0371702c365a552ee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_acda319b97db4bd0371702c365a552ee );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_acda319b97db4bd0371702c365a552ee, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_acda319b97db4bd0371702c365a552ee->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_acda319b97db4bd0371702c365a552ee, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_acda319b97db4bd0371702c365a552ee,
        type_description_1,
        par_self,
        par_state
    );


    // Release cached frame.
    if ( frame_acda319b97db4bd0371702c365a552ee == cache_frame_acda319b97db4bd0371702c365a552ee )
    {
        Py_DECREF( frame_acda319b97db4bd0371702c365a552ee );
    }
    cache_frame_acda319b97db4bd0371702c365a552ee = NULL;

    assertFrameObject( frame_acda319b97db4bd0371702c365a552ee );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_84_set_shutdown );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_state );
    Py_DECREF( par_state );
    par_state = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_state );
    Py_DECREF( par_state );
    par_state = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_84_set_shutdown );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_85_get_state_string( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_acba1edf54ec8ed7cadead9caaa107de = NULL;

    struct Nuitka_FrameObject *frame_acba1edf54ec8ed7cadead9caaa107de;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_acba1edf54ec8ed7cadead9caaa107de, codeobj_acba1edf54ec8ed7cadead9caaa107de, module_OpenSSL$SSL, sizeof(void *) );
    frame_acba1edf54ec8ed7cadead9caaa107de = cache_frame_acba1edf54ec8ed7cadead9caaa107de;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_acba1edf54ec8ed7cadead9caaa107de );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_acba1edf54ec8ed7cadead9caaa107de ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2019;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_string );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2019;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2019;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_state_string_long );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2019;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ssl );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2019;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_acba1edf54ec8ed7cadead9caaa107de->m_frame.f_lineno = 2019;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2019;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_acba1edf54ec8ed7cadead9caaa107de->m_frame.f_lineno = 2019;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2019;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_acba1edf54ec8ed7cadead9caaa107de );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_acba1edf54ec8ed7cadead9caaa107de );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_acba1edf54ec8ed7cadead9caaa107de );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_acba1edf54ec8ed7cadead9caaa107de, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_acba1edf54ec8ed7cadead9caaa107de->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_acba1edf54ec8ed7cadead9caaa107de, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_acba1edf54ec8ed7cadead9caaa107de,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_acba1edf54ec8ed7cadead9caaa107de == cache_frame_acba1edf54ec8ed7cadead9caaa107de )
    {
        Py_DECREF( frame_acba1edf54ec8ed7cadead9caaa107de );
    }
    cache_frame_acba1edf54ec8ed7cadead9caaa107de = NULL;

    assertFrameObject( frame_acba1edf54ec8ed7cadead9caaa107de );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_85_get_state_string );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_85_get_state_string );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_86_server_random( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_outp = NULL;
    PyObject *var_session = NULL;
    PyObject *var_length = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_787b8e6bfd81d6bd4f675c83610bc416 = NULL;

    struct Nuitka_FrameObject *frame_787b8e6bfd81d6bd4f675c83610bc416;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_787b8e6bfd81d6bd4f675c83610bc416, codeobj_787b8e6bfd81d6bd4f675c83610bc416, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_787b8e6bfd81d6bd4f675c83610bc416 = cache_frame_787b8e6bfd81d6bd4f675c83610bc416;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_787b8e6bfd81d6bd4f675c83610bc416 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_787b8e6bfd81d6bd4f675c83610bc416 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2027;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_session );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2027;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2027;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_787b8e6bfd81d6bd4f675c83610bc416->m_frame.f_lineno = 2027;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2027;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_session == NULL );
    var_session = tmp_assign_source_1;

    tmp_compare_left_1 = var_session;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2028;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2028;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 2028;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2030;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_get_server_random );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2030;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__ssl );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2030;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2030;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 2030;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = const_int_0;
    frame_787b8e6bfd81d6bd4f675c83610bc416->m_frame.f_lineno = 2030;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2030;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_length == NULL );
    var_length = tmp_assign_source_2;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2031;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_length;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_5 = RICH_COMPARE_GT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2031;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_787b8e6bfd81d6bd4f675c83610bc416->m_frame.f_lineno = 2031;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2031;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
        exception_tb = NULL;

        exception_lineno = 2032;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
    tmp_args_element_name_7 = var_length;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_787b8e6bfd81d6bd4f675c83610bc416->m_frame.f_lineno = 2032;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2032;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_outp == NULL );
    var_outp = tmp_assign_source_3;

    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2033;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_SSL_get_server_random );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2033;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = par_self;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__ssl );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 2033;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_outp;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_args_element_name_10 = var_length;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_787b8e6bfd81d6bd4f675c83610bc416->m_frame.f_lineno = 2033;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2033;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2034;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = var_outp;

    CHECK_OBJECT( tmp_args_element_name_11 );
    tmp_args_element_name_12 = var_length;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_787b8e6bfd81d6bd4f675c83610bc416->m_frame.f_lineno = 2034;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
    }

    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2034;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2034;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_787b8e6bfd81d6bd4f675c83610bc416 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_787b8e6bfd81d6bd4f675c83610bc416 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_787b8e6bfd81d6bd4f675c83610bc416 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_787b8e6bfd81d6bd4f675c83610bc416, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_787b8e6bfd81d6bd4f675c83610bc416->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_787b8e6bfd81d6bd4f675c83610bc416, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_787b8e6bfd81d6bd4f675c83610bc416,
        type_description_1,
        par_self,
        var_outp,
        var_session,
        var_length
    );


    // Release cached frame.
    if ( frame_787b8e6bfd81d6bd4f675c83610bc416 == cache_frame_787b8e6bfd81d6bd4f675c83610bc416 )
    {
        Py_DECREF( frame_787b8e6bfd81d6bd4f675c83610bc416 );
    }
    cache_frame_787b8e6bfd81d6bd4f675c83610bc416 = NULL;

    assertFrameObject( frame_787b8e6bfd81d6bd4f675c83610bc416 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_86_server_random );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_session );
    Py_DECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_86_server_random );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_87_client_random( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_outp = NULL;
    PyObject *var_session = NULL;
    PyObject *var_length = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_361c887bcade8cec7b7f7a75e2bc0931 = NULL;

    struct Nuitka_FrameObject *frame_361c887bcade8cec7b7f7a75e2bc0931;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_361c887bcade8cec7b7f7a75e2bc0931, codeobj_361c887bcade8cec7b7f7a75e2bc0931, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_361c887bcade8cec7b7f7a75e2bc0931 = cache_frame_361c887bcade8cec7b7f7a75e2bc0931;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_361c887bcade8cec7b7f7a75e2bc0931 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_361c887bcade8cec7b7f7a75e2bc0931 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2042;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_session );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2042;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2042;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_361c887bcade8cec7b7f7a75e2bc0931->m_frame.f_lineno = 2042;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2042;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_session == NULL );
    var_session = tmp_assign_source_1;

    tmp_compare_left_1 = var_session;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2043;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2043;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 2043;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2046;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_get_client_random );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2046;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__ssl );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2046;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2046;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 2046;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = const_int_0;
    frame_361c887bcade8cec7b7f7a75e2bc0931->m_frame.f_lineno = 2046;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2046;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_length == NULL );
    var_length = tmp_assign_source_2;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2047;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_length;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_5 = RICH_COMPARE_GT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2047;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_361c887bcade8cec7b7f7a75e2bc0931->m_frame.f_lineno = 2047;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2047;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
        exception_tb = NULL;

        exception_lineno = 2048;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
    tmp_args_element_name_7 = var_length;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_361c887bcade8cec7b7f7a75e2bc0931->m_frame.f_lineno = 2048;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2048;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_outp == NULL );
    var_outp = tmp_assign_source_3;

    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2049;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_SSL_get_client_random );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2049;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = par_self;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__ssl );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 2049;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_outp;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_args_element_name_10 = var_length;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_361c887bcade8cec7b7f7a75e2bc0931->m_frame.f_lineno = 2049;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2049;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2050;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = var_outp;

    CHECK_OBJECT( tmp_args_element_name_11 );
    tmp_args_element_name_12 = var_length;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_361c887bcade8cec7b7f7a75e2bc0931->m_frame.f_lineno = 2050;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
    }

    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2050;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2050;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_361c887bcade8cec7b7f7a75e2bc0931 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_361c887bcade8cec7b7f7a75e2bc0931 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_361c887bcade8cec7b7f7a75e2bc0931 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_361c887bcade8cec7b7f7a75e2bc0931, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_361c887bcade8cec7b7f7a75e2bc0931->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_361c887bcade8cec7b7f7a75e2bc0931, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_361c887bcade8cec7b7f7a75e2bc0931,
        type_description_1,
        par_self,
        var_outp,
        var_session,
        var_length
    );


    // Release cached frame.
    if ( frame_361c887bcade8cec7b7f7a75e2bc0931 == cache_frame_361c887bcade8cec7b7f7a75e2bc0931 )
    {
        Py_DECREF( frame_361c887bcade8cec7b7f7a75e2bc0931 );
    }
    cache_frame_361c887bcade8cec7b7f7a75e2bc0931 = NULL;

    assertFrameObject( frame_361c887bcade8cec7b7f7a75e2bc0931 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_87_client_random );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_session );
    Py_DECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_87_client_random );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_88_master_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_outp = NULL;
    PyObject *var_session = NULL;
    PyObject *var_length = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_c5a33d979afcfefdaf074fd78849d7f9 = NULL;

    struct Nuitka_FrameObject *frame_c5a33d979afcfefdaf074fd78849d7f9;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c5a33d979afcfefdaf074fd78849d7f9, codeobj_c5a33d979afcfefdaf074fd78849d7f9, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c5a33d979afcfefdaf074fd78849d7f9 = cache_frame_c5a33d979afcfefdaf074fd78849d7f9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c5a33d979afcfefdaf074fd78849d7f9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c5a33d979afcfefdaf074fd78849d7f9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2058;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_session );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2058;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2058;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_c5a33d979afcfefdaf074fd78849d7f9->m_frame.f_lineno = 2058;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2058;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_session == NULL );
    var_session = tmp_assign_source_1;

    tmp_compare_left_1 = var_session;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2059;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2059;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 2059;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2062;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_SESSION_get_master_key );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2062;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_session;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2062;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2062;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = const_int_0;
    frame_c5a33d979afcfefdaf074fd78849d7f9->m_frame.f_lineno = 2062;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2062;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_length == NULL );
    var_length = tmp_assign_source_2;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2063;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_length;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_0;
    tmp_args_element_name_5 = RICH_COMPARE_GT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2063;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_c5a33d979afcfefdaf074fd78849d7f9->m_frame.f_lineno = 2063;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2063;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
        exception_tb = NULL;

        exception_lineno = 2064;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
    tmp_args_element_name_7 = var_length;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_c5a33d979afcfefdaf074fd78849d7f9->m_frame.f_lineno = 2064;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2064;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_outp == NULL );
    var_outp = tmp_assign_source_3;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2065;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = var_session;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_args_element_name_9 = var_outp;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_args_element_name_10 = var_length;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_c5a33d979afcfefdaf074fd78849d7f9->m_frame.f_lineno = 2065;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_SSL_SESSION_get_master_key, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2065;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2066;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = var_outp;

    CHECK_OBJECT( tmp_args_element_name_11 );
    tmp_args_element_name_12 = var_length;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_c5a33d979afcfefdaf074fd78849d7f9->m_frame.f_lineno = 2066;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_buffer, call_args );
    }

    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2066;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2066;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c5a33d979afcfefdaf074fd78849d7f9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c5a33d979afcfefdaf074fd78849d7f9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c5a33d979afcfefdaf074fd78849d7f9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c5a33d979afcfefdaf074fd78849d7f9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c5a33d979afcfefdaf074fd78849d7f9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c5a33d979afcfefdaf074fd78849d7f9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c5a33d979afcfefdaf074fd78849d7f9,
        type_description_1,
        par_self,
        var_outp,
        var_session,
        var_length
    );


    // Release cached frame.
    if ( frame_c5a33d979afcfefdaf074fd78849d7f9 == cache_frame_c5a33d979afcfefdaf074fd78849d7f9 )
    {
        Py_DECREF( frame_c5a33d979afcfefdaf074fd78849d7f9 );
    }
    cache_frame_c5a33d979afcfefdaf074fd78849d7f9 = NULL;

    assertFrameObject( frame_c5a33d979afcfefdaf074fd78849d7f9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_88_master_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_session );
    Py_DECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_88_master_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_89_export_keying_material( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *par_olen = python_pars[ 2 ];
    PyObject *par_context = python_pars[ 3 ];
    PyObject *var_outp = NULL;
    PyObject *var_use_context = NULL;
    PyObject *var_success = NULL;
    PyObject *var_context_buf = NULL;
    PyObject *var_context_len = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    bool tmp_isnot_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_2fffdc517f229be102aa4e0949e42f3d = NULL;

    struct Nuitka_FrameObject *frame_2fffdc517f229be102aa4e0949e42f3d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2fffdc517f229be102aa4e0949e42f3d, codeobj_2fffdc517f229be102aa4e0949e42f3d, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_2fffdc517f229be102aa4e0949e42f3d = cache_frame_2fffdc517f229be102aa4e0949e42f3d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2fffdc517f229be102aa4e0949e42f3d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2fffdc517f229be102aa4e0949e42f3d ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
        exception_tb = NULL;

        exception_lineno = 2077;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
    tmp_args_element_name_2 = par_olen;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_2fffdc517f229be102aa4e0949e42f3d->m_frame.f_lineno = 2077;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2077;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_outp == NULL );
    var_outp = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2078;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2078;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_context_buf == NULL );
    var_context_buf = tmp_assign_source_2;

    tmp_assign_source_3 = const_int_0;
    assert( var_context_len == NULL );
    Py_INCREF( tmp_assign_source_3 );
    var_context_len = tmp_assign_source_3;

    tmp_assign_source_4 = const_int_0;
    assert( var_use_context == NULL );
    Py_INCREF( tmp_assign_source_4 );
    var_use_context = tmp_assign_source_4;

    tmp_compare_left_1 = par_context;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_5 = par_context;

    CHECK_OBJECT( tmp_assign_source_5 );
    {
        PyObject *old = var_context_buf;
        assert( old != NULL );
        var_context_buf = tmp_assign_source_5;
        Py_INCREF( var_context_buf );
        Py_DECREF( old );
    }

    tmp_len_arg_1 = par_context;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_assign_source_6 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2083;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_context_len;
        assert( old != NULL );
        var_context_len = tmp_assign_source_6;
        Py_DECREF( old );
    }

    tmp_assign_source_7 = const_int_pos_1;
    {
        PyObject *old = var_use_context;
        assert( old != NULL );
        var_use_context = tmp_assign_source_7;
        Py_INCREF( var_use_context );
        Py_DECREF( old );
    }

    branch_no_1:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2085;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_export_keying_material );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2085;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ssl );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2086;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = var_outp;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_args_element_name_5 = par_olen;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = par_label;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_len_arg_2 = par_label;

    CHECK_OBJECT( tmp_len_arg_2 );
    tmp_args_element_name_7 = BUILTIN_LEN( tmp_len_arg_2 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 2090;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = var_context_buf;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_args_element_name_9 = var_context_len;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_args_element_name_10 = var_use_context;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_2fffdc517f229be102aa4e0949e42f3d->m_frame.f_lineno = 2085;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS8( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2085;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_success == NULL );
    var_success = tmp_assign_source_8;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2095;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_success;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_11 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2095;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    frame_2fffdc517f229be102aa4e0949e42f3d->m_frame.f_lineno = 2095;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2095;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2096;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_12 = var_outp;

    CHECK_OBJECT( tmp_args_element_name_12 );
    tmp_args_element_name_13 = par_olen;

    CHECK_OBJECT( tmp_args_element_name_13 );
    frame_2fffdc517f229be102aa4e0949e42f3d->m_frame.f_lineno = 2096;
    {
        PyObject *call_args[] = { tmp_args_element_name_12, tmp_args_element_name_13 };
        tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
    }

    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2096;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2096;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2fffdc517f229be102aa4e0949e42f3d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2fffdc517f229be102aa4e0949e42f3d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2fffdc517f229be102aa4e0949e42f3d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2fffdc517f229be102aa4e0949e42f3d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2fffdc517f229be102aa4e0949e42f3d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2fffdc517f229be102aa4e0949e42f3d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2fffdc517f229be102aa4e0949e42f3d,
        type_description_1,
        par_self,
        par_label,
        par_olen,
        par_context,
        var_outp,
        var_use_context,
        var_success,
        var_context_buf,
        var_context_len
    );


    // Release cached frame.
    if ( frame_2fffdc517f229be102aa4e0949e42f3d == cache_frame_2fffdc517f229be102aa4e0949e42f3d )
    {
        Py_DECREF( frame_2fffdc517f229be102aa4e0949e42f3d );
    }
    cache_frame_2fffdc517f229be102aa4e0949e42f3d = NULL;

    assertFrameObject( frame_2fffdc517f229be102aa4e0949e42f3d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_89_export_keying_material );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_outp );
    Py_DECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)var_use_context );
    Py_DECREF( var_use_context );
    var_use_context = NULL;

    CHECK_OBJECT( (PyObject *)var_success );
    Py_DECREF( var_success );
    var_success = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_label );
    Py_DECREF( par_label );
    par_label = NULL;

    CHECK_OBJECT( (PyObject *)var_context_buf );
    Py_DECREF( var_context_buf );
    var_context_buf = NULL;

    CHECK_OBJECT( (PyObject *)var_context_len );
    Py_DECREF( var_context_len );
    var_context_len = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    CHECK_OBJECT( (PyObject *)par_olen );
    Py_DECREF( par_olen );
    par_olen = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_outp );
    var_outp = NULL;

    Py_XDECREF( var_use_context );
    var_use_context = NULL;

    Py_XDECREF( var_success );
    var_success = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_label );
    Py_DECREF( par_label );
    par_label = NULL;

    Py_XDECREF( var_context_buf );
    var_context_buf = NULL;

    Py_XDECREF( var_context_len );
    var_context_len = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    CHECK_OBJECT( (PyObject *)par_olen );
    Py_DECREF( par_olen );
    par_olen = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_89_export_keying_material );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_90_sock_shutdown( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_9351f991ba8e7d4c0845d79aab6ff700 = NULL;

    struct Nuitka_FrameObject *frame_9351f991ba8e7d4c0845d79aab6ff700;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9351f991ba8e7d4c0845d79aab6ff700, codeobj_9351f991ba8e7d4c0845d79aab6ff700, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9351f991ba8e7d4c0845d79aab6ff700 = cache_frame_9351f991ba8e7d4c0845d79aab6ff700;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9351f991ba8e7d4c0845d79aab6ff700 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9351f991ba8e7d4c0845d79aab6ff700 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__socket );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2105;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_shutdown );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2105;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg2_1 );
    tmp_dircall_arg3_1 = par_kwargs;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg2_1 );
    Py_INCREF( tmp_dircall_arg3_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
        tmp_return_value = impl___internal__$$$function_1_complex_call_helper_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2105;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9351f991ba8e7d4c0845d79aab6ff700 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9351f991ba8e7d4c0845d79aab6ff700 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9351f991ba8e7d4c0845d79aab6ff700 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9351f991ba8e7d4c0845d79aab6ff700, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9351f991ba8e7d4c0845d79aab6ff700->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9351f991ba8e7d4c0845d79aab6ff700, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9351f991ba8e7d4c0845d79aab6ff700,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_9351f991ba8e7d4c0845d79aab6ff700 == cache_frame_9351f991ba8e7d4c0845d79aab6ff700 )
    {
        Py_DECREF( frame_9351f991ba8e7d4c0845d79aab6ff700 );
    }
    cache_frame_9351f991ba8e7d4c0845d79aab6ff700 = NULL;

    assertFrameObject( frame_9351f991ba8e7d4c0845d79aab6ff700 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_90_sock_shutdown );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_90_sock_shutdown );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_91_get_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_cert = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_86508d4dd364cb660af852a87adf893f = NULL;

    struct Nuitka_FrameObject *frame_86508d4dd364cb660af852a87adf893f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_86508d4dd364cb660af852a87adf893f, codeobj_86508d4dd364cb660af852a87adf893f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_86508d4dd364cb660af852a87adf893f = cache_frame_86508d4dd364cb660af852a87adf893f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_86508d4dd364cb660af852a87adf893f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_86508d4dd364cb660af852a87adf893f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2113;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_certificate );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2113;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2113;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_86508d4dd364cb660af852a87adf893f->m_frame.f_lineno = 2113;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2113;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_cert == NULL );
    var_cert = tmp_assign_source_1;

    tmp_compare_left_1 = var_cert;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2114;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2114;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 2114;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2115;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_cert;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_86508d4dd364cb660af852a87adf893f->m_frame.f_lineno = 2115;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_up_ref, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2115;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 2116;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_cert;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_86508d4dd364cb660af852a87adf893f->m_frame.f_lineno = 2116;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__from_raw_x509_ptr, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2116;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_86508d4dd364cb660af852a87adf893f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_86508d4dd364cb660af852a87adf893f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_86508d4dd364cb660af852a87adf893f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_86508d4dd364cb660af852a87adf893f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_86508d4dd364cb660af852a87adf893f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_86508d4dd364cb660af852a87adf893f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_86508d4dd364cb660af852a87adf893f,
        type_description_1,
        par_self,
        var_cert
    );


    // Release cached frame.
    if ( frame_86508d4dd364cb660af852a87adf893f == cache_frame_86508d4dd364cb660af852a87adf893f )
    {
        Py_DECREF( frame_86508d4dd364cb660af852a87adf893f );
    }
    cache_frame_86508d4dd364cb660af852a87adf893f = NULL;

    assertFrameObject( frame_86508d4dd364cb660af852a87adf893f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_91_get_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_91_get_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_92_get_peer_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_cert = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_59e17a52f108ec0be7939e85e90ca5b0 = NULL;

    struct Nuitka_FrameObject *frame_59e17a52f108ec0be7939e85e90ca5b0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_59e17a52f108ec0be7939e85e90ca5b0, codeobj_59e17a52f108ec0be7939e85e90ca5b0, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_59e17a52f108ec0be7939e85e90ca5b0 = cache_frame_59e17a52f108ec0be7939e85e90ca5b0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_59e17a52f108ec0be7939e85e90ca5b0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_59e17a52f108ec0be7939e85e90ca5b0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2125;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_peer_certificate );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2125;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2125;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_59e17a52f108ec0be7939e85e90ca5b0->m_frame.f_lineno = 2125;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2125;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_cert == NULL );
    var_cert = tmp_assign_source_1;

    tmp_compare_left_1 = var_cert;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2126;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2126;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 2126;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 2127;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = var_cert;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_59e17a52f108ec0be7939e85e90ca5b0->m_frame.f_lineno = 2127;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__from_raw_x509_ptr, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2127;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_59e17a52f108ec0be7939e85e90ca5b0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_59e17a52f108ec0be7939e85e90ca5b0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_59e17a52f108ec0be7939e85e90ca5b0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_59e17a52f108ec0be7939e85e90ca5b0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_59e17a52f108ec0be7939e85e90ca5b0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_59e17a52f108ec0be7939e85e90ca5b0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_59e17a52f108ec0be7939e85e90ca5b0,
        type_description_1,
        par_self,
        var_cert
    );


    // Release cached frame.
    if ( frame_59e17a52f108ec0be7939e85e90ca5b0 == cache_frame_59e17a52f108ec0be7939e85e90ca5b0 )
    {
        Py_DECREF( frame_59e17a52f108ec0be7939e85e90ca5b0 );
    }
    cache_frame_59e17a52f108ec0be7939e85e90ca5b0 = NULL;

    assertFrameObject( frame_59e17a52f108ec0be7939e85e90ca5b0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_92_get_peer_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_92_get_peer_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_93__cert_stack_to_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cert_stack = python_pars[ 0 ];
    PyObject *var_i = NULL;
    PyObject *var_pycert = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_result = NULL;
    PyObject *var_res = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_range_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_188b168a82dba9bb38a8643a6f371a55 = NULL;

    struct Nuitka_FrameObject *frame_188b168a82dba9bb38a8643a6f371a55;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PyList_New( 0 );
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_188b168a82dba9bb38a8643a6f371a55, codeobj_188b168a82dba9bb38a8643a6f371a55, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_188b168a82dba9bb38a8643a6f371a55 = cache_frame_188b168a82dba9bb38a8643a6f371a55;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_188b168a82dba9bb38a8643a6f371a55 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_188b168a82dba9bb38a8643a6f371a55 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2137;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_cert_stack;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_188b168a82dba9bb38a8643a6f371a55->m_frame.f_lineno = 2137;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_sk_X509_num, call_args );
    }

    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2137;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2137;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2137;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooo";
        exception_lineno = 2137;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 2137;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_4;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2138;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_2 = par_cert_stack;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = var_i;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_188b168a82dba9bb38a8643a6f371a55->m_frame.f_lineno = 2138;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_sk_X509_value, call_args );
    }

    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2138;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_cert;
        var_cert = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2139;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_compexpr_left_1 = var_cert;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2139;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2139;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_4 = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2139;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    frame_188b168a82dba9bb38a8643a6f371a55->m_frame.f_lineno = 2139;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2139;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2140;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_5 = var_cert;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_188b168a82dba9bb38a8643a6f371a55->m_frame.f_lineno = 2140;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_X509_up_ref, call_args );
    }

    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2140;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_res;
        var_res = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2141;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_compexpr_left_2 = var_res;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = const_int_pos_1;
    tmp_args_element_name_6 = RICH_COMPARE_GE( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2141;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    frame_188b168a82dba9bb38a8643a6f371a55->m_frame.f_lineno = 2141;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2141;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
        exception_tb = NULL;

        exception_lineno = 2142;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_7 = var_cert;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_188b168a82dba9bb38a8643a6f371a55->m_frame.f_lineno = 2142;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain__from_raw_x509_ptr, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2142;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_pycert;
        var_pycert = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_called_instance_5 = var_result;

    CHECK_OBJECT( tmp_called_instance_5 );
    tmp_args_element_name_8 = var_pycert;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_188b168a82dba9bb38a8643a6f371a55->m_frame.f_lineno = 2143;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_append, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2143;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2137;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_188b168a82dba9bb38a8643a6f371a55 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_188b168a82dba9bb38a8643a6f371a55 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_188b168a82dba9bb38a8643a6f371a55, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_188b168a82dba9bb38a8643a6f371a55->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_188b168a82dba9bb38a8643a6f371a55, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_188b168a82dba9bb38a8643a6f371a55,
        type_description_1,
        par_cert_stack,
        var_i,
        var_pycert,
        var_cert,
        var_result,
        var_res
    );


    // Release cached frame.
    if ( frame_188b168a82dba9bb38a8643a6f371a55 == cache_frame_188b168a82dba9bb38a8643a6f371a55 )
    {
        Py_DECREF( frame_188b168a82dba9bb38a8643a6f371a55 );
    }
    cache_frame_188b168a82dba9bb38a8643a6f371a55 = NULL;

    assertFrameObject( frame_188b168a82dba9bb38a8643a6f371a55 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = var_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_93__cert_stack_to_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_cert_stack );
    Py_DECREF( par_cert_stack );
    par_cert_stack = NULL;

    Py_XDECREF( var_pycert );
    var_pycert = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_res );
    var_res = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_cert_stack );
    Py_DECREF( par_cert_stack );
    par_cert_stack = NULL;

    Py_XDECREF( var_pycert );
    var_pycert = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_res );
    var_res = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_93__cert_stack_to_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_94_get_peer_cert_chain( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_cert_stack = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_f5481765c0dd14c9fd2dc2cbccca5828 = NULL;

    struct Nuitka_FrameObject *frame_f5481765c0dd14c9fd2dc2cbccca5828;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f5481765c0dd14c9fd2dc2cbccca5828, codeobj_f5481765c0dd14c9fd2dc2cbccca5828, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_f5481765c0dd14c9fd2dc2cbccca5828 = cache_frame_f5481765c0dd14c9fd2dc2cbccca5828;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f5481765c0dd14c9fd2dc2cbccca5828 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f5481765c0dd14c9fd2dc2cbccca5828 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2153;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_peer_cert_chain );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2153;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2153;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_f5481765c0dd14c9fd2dc2cbccca5828->m_frame.f_lineno = 2153;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2153;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_cert_stack == NULL );
    var_cert_stack = tmp_assign_source_1;

    tmp_compare_left_1 = var_cert_stack;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2154;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2154;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 2154;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_2 = var_cert_stack;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_f5481765c0dd14c9fd2dc2cbccca5828->m_frame.f_lineno = 2157;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__cert_stack_to_list, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2157;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f5481765c0dd14c9fd2dc2cbccca5828 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f5481765c0dd14c9fd2dc2cbccca5828 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f5481765c0dd14c9fd2dc2cbccca5828 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f5481765c0dd14c9fd2dc2cbccca5828, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f5481765c0dd14c9fd2dc2cbccca5828->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f5481765c0dd14c9fd2dc2cbccca5828, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f5481765c0dd14c9fd2dc2cbccca5828,
        type_description_1,
        par_self,
        var_cert_stack
    );


    // Release cached frame.
    if ( frame_f5481765c0dd14c9fd2dc2cbccca5828 == cache_frame_f5481765c0dd14c9fd2dc2cbccca5828 )
    {
        Py_DECREF( frame_f5481765c0dd14c9fd2dc2cbccca5828 );
    }
    cache_frame_f5481765c0dd14c9fd2dc2cbccca5828 = NULL;

    assertFrameObject( frame_f5481765c0dd14c9fd2dc2cbccca5828 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_94_get_peer_cert_chain );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_cert_stack );
    Py_DECREF( var_cert_stack );
    var_cert_stack = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_cert_stack );
    var_cert_stack = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_94_get_peer_cert_chain );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_95_get_verified_chain( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_cert_stack = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_e0473f6709515182770f72050d887758 = NULL;

    struct Nuitka_FrameObject *frame_e0473f6709515182770f72050d887758;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e0473f6709515182770f72050d887758, codeobj_e0473f6709515182770f72050d887758, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_e0473f6709515182770f72050d887758 = cache_frame_e0473f6709515182770f72050d887758;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e0473f6709515182770f72050d887758 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e0473f6709515182770f72050d887758 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2172;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get0_verified_chain );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2172;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2172;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_e0473f6709515182770f72050d887758->m_frame.f_lineno = 2172;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2172;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_cert_stack == NULL );
    var_cert_stack = tmp_assign_source_1;

    tmp_compare_left_1 = var_cert_stack;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2173;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2173;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 2173;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_2 = var_cert_stack;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_e0473f6709515182770f72050d887758->m_frame.f_lineno = 2176;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__cert_stack_to_list, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2176;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e0473f6709515182770f72050d887758 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e0473f6709515182770f72050d887758 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e0473f6709515182770f72050d887758 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e0473f6709515182770f72050d887758, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e0473f6709515182770f72050d887758->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e0473f6709515182770f72050d887758, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e0473f6709515182770f72050d887758,
        type_description_1,
        par_self,
        var_cert_stack
    );


    // Release cached frame.
    if ( frame_e0473f6709515182770f72050d887758 == cache_frame_e0473f6709515182770f72050d887758 )
    {
        Py_DECREF( frame_e0473f6709515182770f72050d887758 );
    }
    cache_frame_e0473f6709515182770f72050d887758 = NULL;

    assertFrameObject( frame_e0473f6709515182770f72050d887758 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_95_get_verified_chain );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_cert_stack );
    Py_DECREF( var_cert_stack );
    var_cert_stack = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_cert_stack );
    var_cert_stack = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_95_get_verified_chain );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_96_want_read( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_d14e5f7a612d4badaf324988c48b88af = NULL;

    struct Nuitka_FrameObject *frame_d14e5f7a612d4badaf324988c48b88af;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d14e5f7a612d4badaf324988c48b88af, codeobj_d14e5f7a612d4badaf324988c48b88af, module_OpenSSL$SSL, sizeof(void *) );
    frame_d14e5f7a612d4badaf324988c48b88af = cache_frame_d14e5f7a612d4badaf324988c48b88af;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d14e5f7a612d4badaf324988c48b88af );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d14e5f7a612d4badaf324988c48b88af ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2185;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_want_read );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2185;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2185;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_d14e5f7a612d4badaf324988c48b88af->m_frame.f_lineno = 2185;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2185;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d14e5f7a612d4badaf324988c48b88af );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d14e5f7a612d4badaf324988c48b88af );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d14e5f7a612d4badaf324988c48b88af );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d14e5f7a612d4badaf324988c48b88af, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d14e5f7a612d4badaf324988c48b88af->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d14e5f7a612d4badaf324988c48b88af, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d14e5f7a612d4badaf324988c48b88af,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d14e5f7a612d4badaf324988c48b88af == cache_frame_d14e5f7a612d4badaf324988c48b88af )
    {
        Py_DECREF( frame_d14e5f7a612d4badaf324988c48b88af );
    }
    cache_frame_d14e5f7a612d4badaf324988c48b88af = NULL;

    assertFrameObject( frame_d14e5f7a612d4badaf324988c48b88af );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_96_want_read );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_96_want_read );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_97_want_write( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_66106d74879c849f5649f3f764b1f958 = NULL;

    struct Nuitka_FrameObject *frame_66106d74879c849f5649f3f764b1f958;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_66106d74879c849f5649f3f764b1f958, codeobj_66106d74879c849f5649f3f764b1f958, module_OpenSSL$SSL, sizeof(void *) );
    frame_66106d74879c849f5649f3f764b1f958 = cache_frame_66106d74879c849f5649f3f764b1f958;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_66106d74879c849f5649f3f764b1f958 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_66106d74879c849f5649f3f764b1f958 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2194;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_want_write );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2194;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2194;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_66106d74879c849f5649f3f764b1f958->m_frame.f_lineno = 2194;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2194;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_66106d74879c849f5649f3f764b1f958 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_66106d74879c849f5649f3f764b1f958 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_66106d74879c849f5649f3f764b1f958 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_66106d74879c849f5649f3f764b1f958, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_66106d74879c849f5649f3f764b1f958->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_66106d74879c849f5649f3f764b1f958, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_66106d74879c849f5649f3f764b1f958,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_66106d74879c849f5649f3f764b1f958 == cache_frame_66106d74879c849f5649f3f764b1f958 )
    {
        Py_DECREF( frame_66106d74879c849f5649f3f764b1f958 );
    }
    cache_frame_66106d74879c849f5649f3f764b1f958 = NULL;

    assertFrameObject( frame_66106d74879c849f5649f3f764b1f958 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_97_want_write );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_97_want_write );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_98_set_accept_state( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_b36eb1a77f0339db15b9fbd63165b3ab = NULL;

    struct Nuitka_FrameObject *frame_b36eb1a77f0339db15b9fbd63165b3ab;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b36eb1a77f0339db15b9fbd63165b3ab, codeobj_b36eb1a77f0339db15b9fbd63165b3ab, module_OpenSSL$SSL, sizeof(void *) );
    frame_b36eb1a77f0339db15b9fbd63165b3ab = cache_frame_b36eb1a77f0339db15b9fbd63165b3ab;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b36eb1a77f0339db15b9fbd63165b3ab );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b36eb1a77f0339db15b9fbd63165b3ab ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2203;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_accept_state );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2203;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2203;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_b36eb1a77f0339db15b9fbd63165b3ab->m_frame.f_lineno = 2203;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2203;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b36eb1a77f0339db15b9fbd63165b3ab );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b36eb1a77f0339db15b9fbd63165b3ab );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b36eb1a77f0339db15b9fbd63165b3ab, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b36eb1a77f0339db15b9fbd63165b3ab->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b36eb1a77f0339db15b9fbd63165b3ab, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b36eb1a77f0339db15b9fbd63165b3ab,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b36eb1a77f0339db15b9fbd63165b3ab == cache_frame_b36eb1a77f0339db15b9fbd63165b3ab )
    {
        Py_DECREF( frame_b36eb1a77f0339db15b9fbd63165b3ab );
    }
    cache_frame_b36eb1a77f0339db15b9fbd63165b3ab = NULL;

    assertFrameObject( frame_b36eb1a77f0339db15b9fbd63165b3ab );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_98_set_accept_state );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_98_set_accept_state );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_99_set_connect_state( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_6e69ef82635c437b7d2bbe57e645669d = NULL;

    struct Nuitka_FrameObject *frame_6e69ef82635c437b7d2bbe57e645669d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6e69ef82635c437b7d2bbe57e645669d, codeobj_6e69ef82635c437b7d2bbe57e645669d, module_OpenSSL$SSL, sizeof(void *) );
    frame_6e69ef82635c437b7d2bbe57e645669d = cache_frame_6e69ef82635c437b7d2bbe57e645669d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6e69ef82635c437b7d2bbe57e645669d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6e69ef82635c437b7d2bbe57e645669d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2212;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_connect_state );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2212;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2212;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_6e69ef82635c437b7d2bbe57e645669d->m_frame.f_lineno = 2212;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2212;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6e69ef82635c437b7d2bbe57e645669d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6e69ef82635c437b7d2bbe57e645669d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6e69ef82635c437b7d2bbe57e645669d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6e69ef82635c437b7d2bbe57e645669d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6e69ef82635c437b7d2bbe57e645669d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6e69ef82635c437b7d2bbe57e645669d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6e69ef82635c437b7d2bbe57e645669d == cache_frame_6e69ef82635c437b7d2bbe57e645669d )
    {
        Py_DECREF( frame_6e69ef82635c437b7d2bbe57e645669d );
    }
    cache_frame_6e69ef82635c437b7d2bbe57e645669d = NULL;

    assertFrameObject( frame_6e69ef82635c437b7d2bbe57e645669d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_99_set_connect_state );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_99_set_connect_state );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_100_get_session( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_session = NULL;
    PyObject *var_pysession = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    static struct Nuitka_FrameObject *cache_frame_6287cec24f2f783aa4294293d15dff9f = NULL;

    struct Nuitka_FrameObject *frame_6287cec24f2f783aa4294293d15dff9f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6287cec24f2f783aa4294293d15dff9f, codeobj_6287cec24f2f783aa4294293d15dff9f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6287cec24f2f783aa4294293d15dff9f = cache_frame_6287cec24f2f783aa4294293d15dff9f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6287cec24f2f783aa4294293d15dff9f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6287cec24f2f783aa4294293d15dff9f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2223;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get1_session );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2223;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2223;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_6287cec24f2f783aa4294293d15dff9f->m_frame.f_lineno = 2223;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2223;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_session == NULL );
    var_session = tmp_assign_source_1;

    tmp_compare_left_1 = var_session;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2224;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2224;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 2224;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Session );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Session );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Session" );
        exception_tb = NULL;

        exception_lineno = 2227;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain___new__ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2227;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Session );

    if (unlikely( tmp_args_element_name_2 == NULL ))
    {
        tmp_args_element_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Session );
    }

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Session" );
        exception_tb = NULL;

        exception_lineno = 2227;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_6287cec24f2f783aa4294293d15dff9f->m_frame.f_lineno = 2227;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2227;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_pysession == NULL );
    var_pysession = tmp_assign_source_2;

    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2228;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_gc );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2228;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_session;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2228;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_SSL_SESSION_free );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 2228;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_6287cec24f2f783aa4294293d15dff9f->m_frame.f_lineno = 2228;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2228;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_pysession;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__session, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 2228;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6287cec24f2f783aa4294293d15dff9f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6287cec24f2f783aa4294293d15dff9f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6287cec24f2f783aa4294293d15dff9f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6287cec24f2f783aa4294293d15dff9f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6287cec24f2f783aa4294293d15dff9f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6287cec24f2f783aa4294293d15dff9f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6287cec24f2f783aa4294293d15dff9f,
        type_description_1,
        par_self,
        var_session,
        var_pysession
    );


    // Release cached frame.
    if ( frame_6287cec24f2f783aa4294293d15dff9f == cache_frame_6287cec24f2f783aa4294293d15dff9f )
    {
        Py_DECREF( frame_6287cec24f2f783aa4294293d15dff9f );
    }
    cache_frame_6287cec24f2f783aa4294293d15dff9f = NULL;

    assertFrameObject( frame_6287cec24f2f783aa4294293d15dff9f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_pysession;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_100_get_session );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_session );
    Py_DECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_pysession );
    var_pysession = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_pysession );
    var_pysession = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_100_get_session );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_101_set_session( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_session = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_0061a6af4bcd40a38fc7710d502b3b9f = NULL;

    struct Nuitka_FrameObject *frame_0061a6af4bcd40a38fc7710d502b3b9f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0061a6af4bcd40a38fc7710d502b3b9f, codeobj_0061a6af4bcd40a38fc7710d502b3b9f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0061a6af4bcd40a38fc7710d502b3b9f = cache_frame_0061a6af4bcd40a38fc7710d502b3b9f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0061a6af4bcd40a38fc7710d502b3b9f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0061a6af4bcd40a38fc7710d502b3b9f ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_session;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Session );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Session );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Session" );
        exception_tb = NULL;

        exception_lineno = 2240;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2240;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_d5ded94dafea47ce6f2b4fa579755177;
    frame_0061a6af4bcd40a38fc7710d502b3b9f->m_frame.f_lineno = 2241;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 2241;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2243;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_session );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2243;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2243;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_session;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__session );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 2243;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_0061a6af4bcd40a38fc7710d502b3b9f->m_frame.f_lineno = 2243;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2243;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2244;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_result;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_3 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2244;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_0061a6af4bcd40a38fc7710d502b3b9f->m_frame.f_lineno = 2244;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2244;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0061a6af4bcd40a38fc7710d502b3b9f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0061a6af4bcd40a38fc7710d502b3b9f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0061a6af4bcd40a38fc7710d502b3b9f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0061a6af4bcd40a38fc7710d502b3b9f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0061a6af4bcd40a38fc7710d502b3b9f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0061a6af4bcd40a38fc7710d502b3b9f,
        type_description_1,
        par_self,
        par_session,
        var_result
    );


    // Release cached frame.
    if ( frame_0061a6af4bcd40a38fc7710d502b3b9f == cache_frame_0061a6af4bcd40a38fc7710d502b3b9f )
    {
        Py_DECREF( frame_0061a6af4bcd40a38fc7710d502b3b9f );
    }
    cache_frame_0061a6af4bcd40a38fc7710d502b3b9f = NULL;

    assertFrameObject( frame_0061a6af4bcd40a38fc7710d502b3b9f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_101_set_session );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_101_set_session );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_102__get_finished_message( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_function = python_pars[ 1 ];
    PyObject *var_buf = NULL;
    PyObject *var_empty = NULL;
    PyObject *var_size = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_d03524879f755099a288faa08445dd35 = NULL;

    struct Nuitka_FrameObject *frame_d03524879f755099a288faa08445dd35;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d03524879f755099a288faa08445dd35, codeobj_d03524879f755099a288faa08445dd35, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d03524879f755099a288faa08445dd35 = cache_frame_d03524879f755099a288faa08445dd35;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d03524879f755099a288faa08445dd35 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d03524879f755099a288faa08445dd35 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2270;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_d03524879f755099a288faa08445dd35->m_frame.f_lineno = 2270;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2270;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_empty == NULL );
    var_empty = tmp_assign_source_1;

    tmp_called_name_1 = par_function;

    CHECK_OBJECT( tmp_called_name_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2271;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_empty;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = const_int_0;
    frame_d03524879f755099a288faa08445dd35->m_frame.f_lineno = 2271;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2271;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_size == NULL );
    var_size = tmp_assign_source_2;

    tmp_compare_left_1 = var_size;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2272;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
        exception_tb = NULL;

        exception_lineno = 2276;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_str_digest_c561652c58984ec0e9541542aa405594;
    tmp_args_element_name_5 = var_size;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_d03524879f755099a288faa08445dd35->m_frame.f_lineno = 2276;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2276;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_buf == NULL );
    var_buf = tmp_assign_source_3;

    tmp_called_name_3 = par_function;

    CHECK_OBJECT( tmp_called_name_3 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2277;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = var_buf;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = var_size;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_d03524879f755099a288faa08445dd35->m_frame.f_lineno = 2277;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2277;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2278;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_9 = var_buf;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_args_element_name_10 = var_size;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_d03524879f755099a288faa08445dd35->m_frame.f_lineno = 2278;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_buffer, call_args );
    }

    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2278;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2278;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d03524879f755099a288faa08445dd35 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d03524879f755099a288faa08445dd35 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d03524879f755099a288faa08445dd35 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d03524879f755099a288faa08445dd35, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d03524879f755099a288faa08445dd35->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d03524879f755099a288faa08445dd35, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d03524879f755099a288faa08445dd35,
        type_description_1,
        par_self,
        par_function,
        var_buf,
        var_empty,
        var_size
    );


    // Release cached frame.
    if ( frame_d03524879f755099a288faa08445dd35 == cache_frame_d03524879f755099a288faa08445dd35 )
    {
        Py_DECREF( frame_d03524879f755099a288faa08445dd35 );
    }
    cache_frame_d03524879f755099a288faa08445dd35 = NULL;

    assertFrameObject( frame_d03524879f755099a288faa08445dd35 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_102__get_finished_message );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_function );
    Py_DECREF( par_function );
    par_function = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_buf );
    var_buf = NULL;

    CHECK_OBJECT( (PyObject *)var_empty );
    Py_DECREF( var_empty );
    var_empty = NULL;

    CHECK_OBJECT( (PyObject *)var_size );
    Py_DECREF( var_size );
    var_size = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_function );
    Py_DECREF( par_function );
    par_function = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_buf );
    var_buf = NULL;

    Py_XDECREF( var_empty );
    var_empty = NULL;

    Py_XDECREF( var_size );
    var_size = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_102__get_finished_message );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_103_get_finished( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_d70f4c3855ac84dfd6756f48541c0461 = NULL;

    struct Nuitka_FrameObject *frame_d70f4c3855ac84dfd6756f48541c0461;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d70f4c3855ac84dfd6756f48541c0461, codeobj_d70f4c3855ac84dfd6756f48541c0461, module_OpenSSL$SSL, sizeof(void *) );
    frame_d70f4c3855ac84dfd6756f48541c0461 = cache_frame_d70f4c3855ac84dfd6756f48541c0461;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d70f4c3855ac84dfd6756f48541c0461 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d70f4c3855ac84dfd6756f48541c0461 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_finished_message );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2290;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2290;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_get_finished );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2290;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_d70f4c3855ac84dfd6756f48541c0461->m_frame.f_lineno = 2290;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2290;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d70f4c3855ac84dfd6756f48541c0461 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d70f4c3855ac84dfd6756f48541c0461 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d70f4c3855ac84dfd6756f48541c0461 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d70f4c3855ac84dfd6756f48541c0461, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d70f4c3855ac84dfd6756f48541c0461->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d70f4c3855ac84dfd6756f48541c0461, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d70f4c3855ac84dfd6756f48541c0461,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d70f4c3855ac84dfd6756f48541c0461 == cache_frame_d70f4c3855ac84dfd6756f48541c0461 )
    {
        Py_DECREF( frame_d70f4c3855ac84dfd6756f48541c0461 );
    }
    cache_frame_d70f4c3855ac84dfd6756f48541c0461 = NULL;

    assertFrameObject( frame_d70f4c3855ac84dfd6756f48541c0461 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_103_get_finished );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_103_get_finished );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_104_get_peer_finished( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_d62fea0d70dd931f7aac134f15bc6f9d = NULL;

    struct Nuitka_FrameObject *frame_d62fea0d70dd931f7aac134f15bc6f9d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d62fea0d70dd931f7aac134f15bc6f9d, codeobj_d62fea0d70dd931f7aac134f15bc6f9d, module_OpenSSL$SSL, sizeof(void *) );
    frame_d62fea0d70dd931f7aac134f15bc6f9d = cache_frame_d62fea0d70dd931f7aac134f15bc6f9d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d62fea0d70dd931f7aac134f15bc6f9d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d62fea0d70dd931f7aac134f15bc6f9d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_finished_message );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2302;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2302;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_get_peer_finished );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2302;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_d62fea0d70dd931f7aac134f15bc6f9d->m_frame.f_lineno = 2302;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2302;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d62fea0d70dd931f7aac134f15bc6f9d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d62fea0d70dd931f7aac134f15bc6f9d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d62fea0d70dd931f7aac134f15bc6f9d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d62fea0d70dd931f7aac134f15bc6f9d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d62fea0d70dd931f7aac134f15bc6f9d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d62fea0d70dd931f7aac134f15bc6f9d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d62fea0d70dd931f7aac134f15bc6f9d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d62fea0d70dd931f7aac134f15bc6f9d == cache_frame_d62fea0d70dd931f7aac134f15bc6f9d )
    {
        Py_DECREF( frame_d62fea0d70dd931f7aac134f15bc6f9d );
    }
    cache_frame_d62fea0d70dd931f7aac134f15bc6f9d = NULL;

    assertFrameObject( frame_d62fea0d70dd931f7aac134f15bc6f9d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_104_get_peer_finished );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_104_get_peer_finished );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_105_get_cipher_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_cipher = NULL;
    PyObject *var_name = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_df8436592d8dd8945dc232488aaff7d5 = NULL;

    struct Nuitka_FrameObject *frame_df8436592d8dd8945dc232488aaff7d5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_df8436592d8dd8945dc232488aaff7d5, codeobj_df8436592d8dd8945dc232488aaff7d5, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_df8436592d8dd8945dc232488aaff7d5 = cache_frame_df8436592d8dd8945dc232488aaff7d5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_df8436592d8dd8945dc232488aaff7d5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_df8436592d8dd8945dc232488aaff7d5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2314;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_current_cipher );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2314;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2314;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_df8436592d8dd8945dc232488aaff7d5->m_frame.f_lineno = 2314;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2314;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_cipher == NULL );
    var_cipher = tmp_assign_source_1;

    tmp_compare_left_1 = var_cipher;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2315;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2315;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 2315;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2318;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_string );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2318;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2318;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_cipher;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_df8436592d8dd8945dc232488aaff7d5->m_frame.f_lineno = 2318;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_args_element_name_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_SSL_CIPHER_get_name, call_args );
    }

    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2318;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_df8436592d8dd8945dc232488aaff7d5->m_frame.f_lineno = 2318;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2318;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_name == NULL );
    var_name = tmp_assign_source_2;

    tmp_called_instance_2 = var_name;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_df8436592d8dd8945dc232488aaff7d5->m_frame.f_lineno = 2319;
    tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0 ) );

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2319;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df8436592d8dd8945dc232488aaff7d5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_df8436592d8dd8945dc232488aaff7d5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df8436592d8dd8945dc232488aaff7d5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_df8436592d8dd8945dc232488aaff7d5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_df8436592d8dd8945dc232488aaff7d5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_df8436592d8dd8945dc232488aaff7d5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_df8436592d8dd8945dc232488aaff7d5,
        type_description_1,
        par_self,
        var_cipher,
        var_name
    );


    // Release cached frame.
    if ( frame_df8436592d8dd8945dc232488aaff7d5 == cache_frame_df8436592d8dd8945dc232488aaff7d5 )
    {
        Py_DECREF( frame_df8436592d8dd8945dc232488aaff7d5 );
    }
    cache_frame_df8436592d8dd8945dc232488aaff7d5 = NULL;

    assertFrameObject( frame_df8436592d8dd8945dc232488aaff7d5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_105_get_cipher_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_cipher );
    Py_DECREF( var_cipher );
    var_cipher = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cipher );
    var_cipher = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_105_get_cipher_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_106_get_cipher_bits( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_cipher = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    static struct Nuitka_FrameObject *cache_frame_601cda9f3a43b06b800b2285b0e8144e = NULL;

    struct Nuitka_FrameObject *frame_601cda9f3a43b06b800b2285b0e8144e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_601cda9f3a43b06b800b2285b0e8144e, codeobj_601cda9f3a43b06b800b2285b0e8144e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_601cda9f3a43b06b800b2285b0e8144e = cache_frame_601cda9f3a43b06b800b2285b0e8144e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_601cda9f3a43b06b800b2285b0e8144e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_601cda9f3a43b06b800b2285b0e8144e ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2331;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_current_cipher );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2331;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2331;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_601cda9f3a43b06b800b2285b0e8144e->m_frame.f_lineno = 2331;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2331;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_cipher == NULL );
    var_cipher = tmp_assign_source_1;

    tmp_compare_left_1 = var_cipher;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2332;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2332;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 2332;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2335;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_CIPHER_get_bits );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2335;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_cipher;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2335;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2335;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_601cda9f3a43b06b800b2285b0e8144e->m_frame.f_lineno = 2335;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2335;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_601cda9f3a43b06b800b2285b0e8144e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_601cda9f3a43b06b800b2285b0e8144e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_601cda9f3a43b06b800b2285b0e8144e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_601cda9f3a43b06b800b2285b0e8144e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_601cda9f3a43b06b800b2285b0e8144e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_601cda9f3a43b06b800b2285b0e8144e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_601cda9f3a43b06b800b2285b0e8144e,
        type_description_1,
        par_self,
        var_cipher
    );


    // Release cached frame.
    if ( frame_601cda9f3a43b06b800b2285b0e8144e == cache_frame_601cda9f3a43b06b800b2285b0e8144e )
    {
        Py_DECREF( frame_601cda9f3a43b06b800b2285b0e8144e );
    }
    cache_frame_601cda9f3a43b06b800b2285b0e8144e = NULL;

    assertFrameObject( frame_601cda9f3a43b06b800b2285b0e8144e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_106_get_cipher_bits );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_cipher );
    Py_DECREF( var_cipher );
    var_cipher = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cipher );
    var_cipher = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_106_get_cipher_bits );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_107_get_cipher_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_cipher = NULL;
    PyObject *var_version = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_d494fa4cd1e36945df2bf5baf361dabb = NULL;

    struct Nuitka_FrameObject *frame_d494fa4cd1e36945df2bf5baf361dabb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d494fa4cd1e36945df2bf5baf361dabb, codeobj_d494fa4cd1e36945df2bf5baf361dabb, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d494fa4cd1e36945df2bf5baf361dabb = cache_frame_d494fa4cd1e36945df2bf5baf361dabb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d494fa4cd1e36945df2bf5baf361dabb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d494fa4cd1e36945df2bf5baf361dabb ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2347;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_current_cipher );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2347;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2347;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_d494fa4cd1e36945df2bf5baf361dabb->m_frame.f_lineno = 2347;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2347;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_cipher == NULL );
    var_cipher = tmp_assign_source_1;

    tmp_compare_left_1 = var_cipher;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2348;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2348;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 2348;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2351;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_string );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2351;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2351;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = var_cipher;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_d494fa4cd1e36945df2bf5baf361dabb->m_frame.f_lineno = 2351;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_args_element_name_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_SSL_CIPHER_get_version, call_args );
    }

    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2351;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_d494fa4cd1e36945df2bf5baf361dabb->m_frame.f_lineno = 2351;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2351;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_version == NULL );
    var_version = tmp_assign_source_2;

    tmp_called_instance_2 = var_version;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_d494fa4cd1e36945df2bf5baf361dabb->m_frame.f_lineno = 2352;
    tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0 ) );

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2352;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d494fa4cd1e36945df2bf5baf361dabb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d494fa4cd1e36945df2bf5baf361dabb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d494fa4cd1e36945df2bf5baf361dabb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d494fa4cd1e36945df2bf5baf361dabb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d494fa4cd1e36945df2bf5baf361dabb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d494fa4cd1e36945df2bf5baf361dabb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d494fa4cd1e36945df2bf5baf361dabb,
        type_description_1,
        par_self,
        var_cipher,
        var_version
    );


    // Release cached frame.
    if ( frame_d494fa4cd1e36945df2bf5baf361dabb == cache_frame_d494fa4cd1e36945df2bf5baf361dabb )
    {
        Py_DECREF( frame_d494fa4cd1e36945df2bf5baf361dabb );
    }
    cache_frame_d494fa4cd1e36945df2bf5baf361dabb = NULL;

    assertFrameObject( frame_d494fa4cd1e36945df2bf5baf361dabb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_107_get_cipher_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_cipher );
    Py_DECREF( var_cipher );
    var_cipher = NULL;

    Py_XDECREF( var_version );
    var_version = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cipher );
    var_cipher = NULL;

    Py_XDECREF( var_version );
    var_version = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_107_get_cipher_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_108_get_protocol_version_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_version = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_6f6b8001279fb5a11951fb3d88c5d2e2 = NULL;

    struct Nuitka_FrameObject *frame_6f6b8001279fb5a11951fb3d88c5d2e2;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6f6b8001279fb5a11951fb3d88c5d2e2, codeobj_6f6b8001279fb5a11951fb3d88c5d2e2, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_6f6b8001279fb5a11951fb3d88c5d2e2 = cache_frame_6f6b8001279fb5a11951fb3d88c5d2e2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6f6b8001279fb5a11951fb3d88c5d2e2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6f6b8001279fb5a11951fb3d88c5d2e2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2363;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_string );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2363;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2363;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_get_version );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2363;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ssl );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2363;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_6f6b8001279fb5a11951fb3d88c5d2e2->m_frame.f_lineno = 2363;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2363;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_6f6b8001279fb5a11951fb3d88c5d2e2->m_frame.f_lineno = 2363;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2363;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_version == NULL );
    var_version = tmp_assign_source_1;

    tmp_called_instance_1 = var_version;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_6f6b8001279fb5a11951fb3d88c5d2e2->m_frame.f_lineno = 2364;
    tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0 ) );

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2364;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f6b8001279fb5a11951fb3d88c5d2e2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f6b8001279fb5a11951fb3d88c5d2e2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f6b8001279fb5a11951fb3d88c5d2e2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6f6b8001279fb5a11951fb3d88c5d2e2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6f6b8001279fb5a11951fb3d88c5d2e2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6f6b8001279fb5a11951fb3d88c5d2e2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6f6b8001279fb5a11951fb3d88c5d2e2,
        type_description_1,
        par_self,
        var_version
    );


    // Release cached frame.
    if ( frame_6f6b8001279fb5a11951fb3d88c5d2e2 == cache_frame_6f6b8001279fb5a11951fb3d88c5d2e2 )
    {
        Py_DECREF( frame_6f6b8001279fb5a11951fb3d88c5d2e2 );
    }
    cache_frame_6f6b8001279fb5a11951fb3d88c5d2e2 = NULL;

    assertFrameObject( frame_6f6b8001279fb5a11951fb3d88c5d2e2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_108_get_protocol_version_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_version );
    Py_DECREF( var_version );
    var_version = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_version );
    var_version = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_108_get_protocol_version_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_109_get_protocol_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_version = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_38389ef2c7d34bba1ceac4f4e9271d9b = NULL;

    struct Nuitka_FrameObject *frame_38389ef2c7d34bba1ceac4f4e9271d9b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_38389ef2c7d34bba1ceac4f4e9271d9b, codeobj_38389ef2c7d34bba1ceac4f4e9271d9b, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_38389ef2c7d34bba1ceac4f4e9271d9b = cache_frame_38389ef2c7d34bba1ceac4f4e9271d9b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_38389ef2c7d34bba1ceac4f4e9271d9b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_38389ef2c7d34bba1ceac4f4e9271d9b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2374;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_version );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2374;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2374;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_38389ef2c7d34bba1ceac4f4e9271d9b->m_frame.f_lineno = 2374;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2374;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_version == NULL );
    var_version = tmp_assign_source_1;


#if 0
    RESTORE_FRAME_EXCEPTION( frame_38389ef2c7d34bba1ceac4f4e9271d9b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_38389ef2c7d34bba1ceac4f4e9271d9b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_38389ef2c7d34bba1ceac4f4e9271d9b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_38389ef2c7d34bba1ceac4f4e9271d9b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_38389ef2c7d34bba1ceac4f4e9271d9b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_38389ef2c7d34bba1ceac4f4e9271d9b,
        type_description_1,
        par_self,
        var_version
    );


    // Release cached frame.
    if ( frame_38389ef2c7d34bba1ceac4f4e9271d9b == cache_frame_38389ef2c7d34bba1ceac4f4e9271d9b )
    {
        Py_DECREF( frame_38389ef2c7d34bba1ceac4f4e9271d9b );
    }
    cache_frame_38389ef2c7d34bba1ceac4f4e9271d9b = NULL;

    assertFrameObject( frame_38389ef2c7d34bba1ceac4f4e9271d9b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_version;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_109_get_protocol_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_version );
    Py_DECREF( var_version );
    var_version = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_109_get_protocol_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_110_set_alpn_protos( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_protos = python_pars[ 1 ];
    PyObject *var_protostr = NULL;
    PyObject *var_input_str = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_8aa9ecd9db1af193441ce35c222c7d1a = NULL;

    struct Nuitka_FrameObject *frame_8aa9ecd9db1af193441ce35c222c7d1a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8aa9ecd9db1af193441ce35c222c7d1a, codeobj_8aa9ecd9db1af193441ce35c222c7d1a, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8aa9ecd9db1af193441ce35c222c7d1a = cache_frame_8aa9ecd9db1af193441ce35c222c7d1a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8aa9ecd9db1af193441ce35c222c7d1a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8aa9ecd9db1af193441ce35c222c7d1a ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_empty;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_join );
    assert( tmp_called_name_1 != NULL );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_chain );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_chain );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "chain" );
        exception_tb = NULL;

        exception_lineno = 2391;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_from_iterable );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2391;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = par_protos;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2391;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        OpenSSL$SSL$$$function_110_set_alpn_protos$$$genexpr_1_genexpr_context,
        module_OpenSSL$SSL,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_44bd407237c2a443c2a210cba0d6c284,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 1 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_110_set_alpn_protos );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_110_set_alpn_protos );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_2 = tmp_outline_return_value_1;
    frame_8aa9ecd9db1af193441ce35c222c7d1a->m_frame.f_lineno = 2391;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2391;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_8aa9ecd9db1af193441ce35c222c7d1a->m_frame.f_lineno = 2390;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2390;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_protostr == NULL );
    var_protostr = tmp_assign_source_1;

    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2396;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
    tmp_args_element_name_4 = var_protostr;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_8aa9ecd9db1af193441ce35c222c7d1a->m_frame.f_lineno = 2396;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_new, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2396;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_input_str == NULL );
    var_input_str = tmp_assign_source_3;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2397;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_set_alpn_protos );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2397;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__ssl );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 2397;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_input_str;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_len_arg_1 = var_protostr;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_args_element_name_7 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 2397;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    frame_8aa9ecd9db1af193441ce35c222c7d1a->m_frame.f_lineno = 2397;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2397;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8aa9ecd9db1af193441ce35c222c7d1a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8aa9ecd9db1af193441ce35c222c7d1a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8aa9ecd9db1af193441ce35c222c7d1a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8aa9ecd9db1af193441ce35c222c7d1a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8aa9ecd9db1af193441ce35c222c7d1a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8aa9ecd9db1af193441ce35c222c7d1a,
        type_description_1,
        par_self,
        par_protos,
        var_protostr,
        var_input_str
    );


    // Release cached frame.
    if ( frame_8aa9ecd9db1af193441ce35c222c7d1a == cache_frame_8aa9ecd9db1af193441ce35c222c7d1a )
    {
        Py_DECREF( frame_8aa9ecd9db1af193441ce35c222c7d1a );
    }
    cache_frame_8aa9ecd9db1af193441ce35c222c7d1a = NULL;

    assertFrameObject( frame_8aa9ecd9db1af193441ce35c222c7d1a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_110_set_alpn_protos );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_protos );
    Py_DECREF( par_protos );
    par_protos = NULL;

    CHECK_OBJECT( (PyObject *)var_protostr );
    Py_DECREF( var_protostr );
    var_protostr = NULL;

    CHECK_OBJECT( (PyObject *)var_input_str );
    Py_DECREF( var_input_str );
    var_input_str = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_protos );
    Py_DECREF( par_protos );
    par_protos = NULL;

    Py_XDECREF( var_protostr );
    var_protostr = NULL;

    Py_XDECREF( var_input_str );
    var_input_str = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_110_set_alpn_protos );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct OpenSSL$SSL$$$function_110_set_alpn_protos$$$genexpr_1_genexpr_locals {
    PyObject *var_p
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *OpenSSL$SSL$$$function_110_set_alpn_protos$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void OpenSSL$SSL$$$function_110_set_alpn_protos$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_p = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_44bd407237c2a443c2a210cba0d6c284, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->m_frame.f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "No";
        exception_lineno = 2391;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 2391;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_p;
        var_p = tmp_assign_source_2;
        Py_INCREF( var_p );
        Py_XDECREF( old );
    }

    tmp_expression_name_1 = PyTuple_New( 2 );
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_int2byte );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_int2byte );
    }

    if ( tmp_called_name_1 == NULL )
    {
        Py_DECREF( tmp_expression_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "int2byte" );
        exception_tb = NULL;

        exception_lineno = 2391;
        type_description_1 = "No";
        goto try_except_handler_2;
    }

    tmp_len_arg_1 = var_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_args_element_name_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_1 );

        exception_lineno = 2391;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    generator->m_frame->m_frame.f_lineno = 2391;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_1 );

        exception_lineno = 2391;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_expression_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_p;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_expression_name_1, 1, tmp_tuple_element_1 );
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2391;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2391;
        type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_p
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_p );
    var_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_p );
    var_p = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_OpenSSL$SSL$$$function_111_get_alpn_proto_negotiated( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_data_len = NULL;
    PyObject *var_data = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_return_value;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_68cb302ba2f275b9a0b37a8bc2f49774 = NULL;

    struct Nuitka_FrameObject *frame_68cb302ba2f275b9a0b37a8bc2f49774;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_68cb302ba2f275b9a0b37a8bc2f49774, codeobj_68cb302ba2f275b9a0b37a8bc2f49774, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_68cb302ba2f275b9a0b37a8bc2f49774 = cache_frame_68cb302ba2f275b9a0b37a8bc2f49774;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_68cb302ba2f275b9a0b37a8bc2f49774 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_68cb302ba2f275b9a0b37a8bc2f49774 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2407;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_68cb302ba2f275b9a0b37a8bc2f49774->m_frame.f_lineno = 2407;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_52773e1185116024389d12c91a4ccf3d_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2407;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_data == NULL );
    var_data = tmp_assign_source_1;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2408;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_68cb302ba2f275b9a0b37a8bc2f49774->m_frame.f_lineno = 2408;
    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple, 0 ) );

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2408;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_data_len == NULL );
    var_data_len = tmp_assign_source_2;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2410;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get0_alpn_selected );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2410;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2410;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_data;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = var_data_len;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_68cb302ba2f275b9a0b37a8bc2f49774->m_frame.f_lineno = 2410;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2410;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_cond_value_1 = var_data_len;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2412;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = const_str_empty;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
        exception_tb = NULL;

        exception_lineno = 2415;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_buffer );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2415;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = var_data;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_args_element_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 2415;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = var_data_len;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_0;
    tmp_args_element_name_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 2415;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_68cb302ba2f275b9a0b37a8bc2f49774->m_frame.f_lineno = 2415;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2415;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2415;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_68cb302ba2f275b9a0b37a8bc2f49774 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_68cb302ba2f275b9a0b37a8bc2f49774 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_68cb302ba2f275b9a0b37a8bc2f49774 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_68cb302ba2f275b9a0b37a8bc2f49774, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_68cb302ba2f275b9a0b37a8bc2f49774->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_68cb302ba2f275b9a0b37a8bc2f49774, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_68cb302ba2f275b9a0b37a8bc2f49774,
        type_description_1,
        par_self,
        var_data_len,
        var_data
    );


    // Release cached frame.
    if ( frame_68cb302ba2f275b9a0b37a8bc2f49774 == cache_frame_68cb302ba2f275b9a0b37a8bc2f49774 )
    {
        Py_DECREF( frame_68cb302ba2f275b9a0b37a8bc2f49774 );
    }
    cache_frame_68cb302ba2f275b9a0b37a8bc2f49774 = NULL;

    assertFrameObject( frame_68cb302ba2f275b9a0b37a8bc2f49774 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_111_get_alpn_proto_negotiated );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_data_len );
    Py_DECREF( var_data_len );
    var_data_len = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_data );
    Py_DECREF( var_data );
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_data_len );
    var_data_len = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_111_get_alpn_proto_negotiated );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_OpenSSL$SSL$$$function_112_request_ocsp( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_rc = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_644e8a19fb20958d76ff8d32a6edd3e6 = NULL;

    struct Nuitka_FrameObject *frame_644e8a19fb20958d76ff8d32a6edd3e6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_644e8a19fb20958d76ff8d32a6edd3e6, codeobj_644e8a19fb20958d76ff8d32a6edd3e6, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_644e8a19fb20958d76ff8d32a6edd3e6 = cache_frame_644e8a19fb20958d76ff8d32a6edd3e6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_644e8a19fb20958d76ff8d32a6edd3e6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_644e8a19fb20958d76ff8d32a6edd3e6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2424;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_tlsext_status_type );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2424;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 2425;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2425;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_TLSEXT_STATUSTYPE_ocsp );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 2425;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_644e8a19fb20958d76ff8d32a6edd3e6->m_frame.f_lineno = 2424;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2424;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_rc == NULL );
    var_rc = tmp_assign_source_1;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
        exception_tb = NULL;

        exception_lineno = 2427;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = var_rc;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_args_element_name_3 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2427;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_644e8a19fb20958d76ff8d32a6edd3e6->m_frame.f_lineno = 2427;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2427;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_644e8a19fb20958d76ff8d32a6edd3e6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_644e8a19fb20958d76ff8d32a6edd3e6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_644e8a19fb20958d76ff8d32a6edd3e6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_644e8a19fb20958d76ff8d32a6edd3e6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_644e8a19fb20958d76ff8d32a6edd3e6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_644e8a19fb20958d76ff8d32a6edd3e6,
        type_description_1,
        par_self,
        var_rc
    );


    // Release cached frame.
    if ( frame_644e8a19fb20958d76ff8d32a6edd3e6 == cache_frame_644e8a19fb20958d76ff8d32a6edd3e6 )
    {
        Py_DECREF( frame_644e8a19fb20958d76ff8d32a6edd3e6 );
    }
    cache_frame_644e8a19fb20958d76ff8d32a6edd3e6 = NULL;

    assertFrameObject( frame_644e8a19fb20958d76ff8d32a6edd3e6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_112_request_ocsp );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_rc );
    Py_DECREF( var_rc );
    var_rc = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_rc );
    var_rc = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_112_request_ocsp );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_100_get_session(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_100_get_session,
        const_str_plain_get_session,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6287cec24f2f783aa4294293d15dff9f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ef6e6485863cf611499d4e66d7c8cb32,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_101_set_session(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_101_set_session,
        const_str_plain_set_session,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0061a6af4bcd40a38fc7710d502b3b9f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_099382aff2f4e6520a621b385fae4992,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_102__get_finished_message(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_102__get_finished_message,
        const_str_plain__get_finished_message,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d03524879f755099a288faa08445dd35,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_38eb25c1dd31f1c93831bc586a51d94a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_103_get_finished(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_103_get_finished,
        const_str_plain_get_finished,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d70f4c3855ac84dfd6756f48541c0461,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_a824ae6766bf79c53a58510064186c32,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_104_get_peer_finished(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_104_get_peer_finished,
        const_str_plain_get_peer_finished,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d62fea0d70dd931f7aac134f15bc6f9d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6a85cdfe995e144af7c992d7adff36a9,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_105_get_cipher_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_105_get_cipher_name,
        const_str_plain_get_cipher_name,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_df8436592d8dd8945dc232488aaff7d5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_09af89b9aab79bc5666da647371af25d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_106_get_cipher_bits(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_106_get_cipher_bits,
        const_str_plain_get_cipher_bits,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_601cda9f3a43b06b800b2285b0e8144e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b8ccf81a020f16490de1c8527ea9e4d6,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_107_get_cipher_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_107_get_cipher_version,
        const_str_plain_get_cipher_version,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d494fa4cd1e36945df2bf5baf361dabb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0e87e25b0ab76d44ec1e50f187ee33bd,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_108_get_protocol_version_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_108_get_protocol_version_name,
        const_str_plain_get_protocol_version_name,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6f6b8001279fb5a11951fb3d88c5d2e2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_39e6e3efbf37d872dab9cfbddc398ebf,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_109_get_protocol_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_109_get_protocol_version,
        const_str_plain_get_protocol_version,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_38389ef2c7d34bba1ceac4f4e9271d9b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_776556dd9343f57c1cd72ff937153f0f,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_10___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_10___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5973516a5de55b67ec5f148e8c29eb73,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_110_set_alpn_protos(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_110_set_alpn_protos,
        const_str_plain_set_alpn_protos,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8aa9ecd9db1af193441ce35c222c7d1a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_a971aca8bab65513da2005120ca529f5,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_111_get_alpn_proto_negotiated(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_111_get_alpn_proto_negotiated,
        const_str_plain_get_alpn_proto_negotiated,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_68cb302ba2f275b9a0b37a8bc2f49774,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_aa803484dcfcfaec3d1d830a5ef1f026,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_112_request_ocsp(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_112_request_ocsp,
        const_str_plain_request_ocsp,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_644e8a19fb20958d76ff8d32a6edd3e6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1c1aa9b3fa80807ae10c68cfa1a0b8e6,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11_load_verify_locations( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_11_load_verify_locations,
        const_str_plain_load_verify_locations,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d9c6f022e88d1a70d6925713b6a4247b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_85e95361903fe71cece52bb01216866e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_12__wrap_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_12__wrap_callback,
        const_str_plain__wrap_callback,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_367ddb5676f8f9ebb625b6c3a765d683,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_12__wrap_callback$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback, struct Nuitka_CellObject *closure_self )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_12__wrap_callback$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ea8cd308a788cb7a890b205884b79311,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        2
    );

result->m_closure[0] = closure_callback;
Py_INCREF( result->m_closure[0] );
result->m_closure[1] = closure_self;
Py_INCREF( result->m_closure[1] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_13_set_passwd_cb( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_13_set_passwd_cb,
        const_str_plain_set_passwd_cb,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3b53e64ae4d15799dfacfe9ba165e79a,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_83abd167711a9d69f6fb1ba8bbb40fdb,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_14_set_default_verify_paths(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_14_set_default_verify_paths,
        const_str_plain_set_default_verify_paths,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b4423fe8f1ca9b3a46b290e554de7290,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_7f19e81c824604e95ebb1f01b7f5d7a1,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_15__check_env_vars_set(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_15__check_env_vars_set,
        const_str_plain__check_env_vars_set,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2f089a1360ec6540a7885d667632b8af,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0f682ae315fc37e97d14dcc920e8b91d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_16__fallback_default_verify_paths(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_16__fallback_default_verify_paths,
        const_str_plain__fallback_default_verify_paths,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0d5bd775cfaaf931ada177403f26906f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_c9c6fa40ef38c8d28b115afb17db4e50,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_17_use_certificate_chain_file(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_17_use_certificate_chain_file,
        const_str_plain_use_certificate_chain_file,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a3496fb28d148bcd6c9a9c8044088e8a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6e6e0d8d93df9702d9c8795dc2391090,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_18_use_certificate_file( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_18_use_certificate_file,
        const_str_plain_use_certificate_file,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a8c1083e5a0e9d5d314d2ea77db9921f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_e5bdbccc007b5187d287f36f3c9f8130,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_19_use_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_19_use_certificate,
        const_str_plain_use_certificate,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b23113cd07b644554a3131a5d950cae1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_eda9ad2d7932cfc1d1f52f27a3ed06a8,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_1___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_1___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4ca3f63ef305b6138693815b24777b10,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_20_add_extra_chain_cert(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_20_add_extra_chain_cert,
        const_str_plain_add_extra_chain_cert,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c79a0c40ab56e09c1dbb541ab527a740,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3d1ad7b2c9fa025afe944eacf471d909,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_21__raise_passphrase_exception(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_21__raise_passphrase_exception,
        const_str_plain__raise_passphrase_exception,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_bb672ed8d8171604b1f6c1b3ebba963b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_22_use_privatekey_file( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_22_use_privatekey_file,
        const_str_plain_use_privatekey_file,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4de9fae261022cc2df5d1800c2c051e5,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_794f687944b90121fa261238090835e1,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_23_use_privatekey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_23_use_privatekey,
        const_str_plain_use_privatekey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f14fc0f5a6135692e4f8d5cbdafa1fc5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1f9e090d5f76db9e818dd53fef9b8465,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_24_check_privatekey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_24_check_privatekey,
        const_str_plain_check_privatekey,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_629eb5b1494882eb95b61538deae4ae8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ceaeeee7f342339744c9535ada3c62e3,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_25_load_client_ca(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_25_load_client_ca,
        const_str_plain_load_client_ca,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3007ec3d2f42a3dd1be07ca3ae9168a6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_68d768407778bc3b4c8ffc953440b717,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_26_set_session_id(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_26_set_session_id,
        const_str_plain_set_session_id,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f5c821c2b0df1d06e32083d799bd68d5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_df17ae6c88635e3960d7bf94f5e880a4,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_27_set_session_cache_mode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_27_set_session_cache_mode,
        const_str_plain_set_session_cache_mode,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_dd4d76a4e8e6e30fb69eee67febb6ab6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b65860d01f08f87c7391d19b5cfd9850,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_28_get_session_cache_mode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_28_get_session_cache_mode,
        const_str_plain_get_session_cache_mode,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e9f59a45745b46ca2698acf2ac56b799,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_73851dbd1821d646fbb8ad48e937548f,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_29_set_verify( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_29_set_verify,
        const_str_plain_set_verify,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6fece6983817e1fc2ad98a3d7d149aca,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_25ee1ab59a31b6b65728138ca859d41c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_2_raise_if_problem(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_2_raise_if_problem,
        const_str_plain_raise_if_problem,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2174564c9980af7eed2d6441dc38c5e4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0438f8885bf87c226201350e81ca4f79,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_30_set_verify_depth(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_30_set_verify_depth,
        const_str_plain_set_verify_depth,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8cf45d680dfdb9a914214d7fecc3e983,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_c5585513b25f5127855be671a08a1332,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_31_get_verify_mode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_31_get_verify_mode,
        const_str_plain_get_verify_mode,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1c2bbbdc204d748085502a3e6b781c3d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6d088f969ab84bf3d60ab75faa431e51,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_32_get_verify_depth(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_32_get_verify_depth,
        const_str_plain_get_verify_depth,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d240f1f9ab03c9ad1d2cb68a1ae386bd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_723fb164f3e133051d00542dd747fe2d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_33_load_tmp_dh(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_33_load_tmp_dh,
        const_str_plain_load_tmp_dh,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_20f3644f0565fa197ebe62d163efece0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_8e472bc9049677fa90a9da1a818ea22f,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_34_set_tmp_ecdh(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_34_set_tmp_ecdh,
        const_str_plain_set_tmp_ecdh,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_087da86096a9eb38f52586f217604859,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_62f84685dfb1efe6a65f54b5d84154ad,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_35_set_cipher_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_35_set_cipher_list,
        const_str_plain_set_cipher_list,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e56f5f73584ddfdf176a449c1f1d406c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0b1af5d020260df564f1f58f9f88daaa,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_36_set_client_ca_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_36_set_client_ca_list,
        const_str_plain_set_client_ca_list,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8d1ca164c82af98e35dc9aa41d641480,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f7bf61568f9564a7aee5354f80d84343,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_37_add_client_ca(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_37_add_client_ca,
        const_str_plain_add_client_ca,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_09f851592d260b18b7439a190a4cf649,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f5da7ec1228a5c8d32fa9b786affa014,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_38_set_timeout(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_38_set_timeout,
        const_str_plain_set_timeout,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cadc07cf67a4e323687eed3a5255dfa8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_39dd8800b3995a2e161e8739b1bebc01,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_39_get_timeout(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_39_get_timeout,
        const_str_plain_get_timeout,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9c51e814ae59c208eeea05af7ec1d290,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0bb5eb9f5b32c979fadc3e4b702de2f7,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_3___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f8a3170870e2ea9cb12ee1d6ba8dcc7c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback, struct Nuitka_CellObject *closure_self )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e08bdb6ef7d176edd569f0ebe97e06fe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        2
    );

result->m_closure[0] = closure_callback;
Py_INCREF( result->m_closure[0] );
result->m_closure[1] = closure_self;
Py_INCREF( result->m_closure[1] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_40_set_info_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_40_set_info_callback,
        const_str_plain_set_info_callback,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3ea94e74b8591248d24548abaaf564ff,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_e04d236da419e1b15c5c13532be67a91,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_40_set_info_callback$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_40_set_info_callback$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_027a1d4675ab6e708189c79b6a91a682,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        1
    );

result->m_closure[0] = closure_callback;
Py_INCREF( result->m_closure[0] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_41_set_keylog_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_41_set_keylog_callback,
        const_str_plain_set_keylog_callback,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_eb66fada38d507b21a902b1d1c274f94,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_62d4d7edcf7c24573f6c449cbee3cf23,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_41_set_keylog_callback$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_41_set_keylog_callback$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_33618a1a0baec9d4158ab8b5d67b55bb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        1
    );

result->m_closure[0] = closure_callback;
Py_INCREF( result->m_closure[0] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_42_get_app_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_42_get_app_data,
        const_str_plain_get_app_data,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ce76a9677c8d247ae477dbc6379dbbc2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0d994cfb9823ffc5647bea3454d1e646,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_43_set_app_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_43_set_app_data,
        const_str_plain_set_app_data,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_56c0d108e11d4f9beec70956f75d378a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_bae02e8783abd2cb1ef184c4ddb0f45d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_44_get_cert_store(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_44_get_cert_store,
        const_str_plain_get_cert_store,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_15459965e009ac4caaaa8d3428cb3e67,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b55bbb0df6959d47693f7145ead6828a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_45_set_options(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_45_set_options,
        const_str_plain_set_options,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_55a7db7b2da21870b1f168c22ed4f7b4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3957b1b23f06761ef1844caf450dffd3,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_46_set_mode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_46_set_mode,
        const_str_plain_set_mode,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_dca08831ab266ef2e54f8c8c25db7b17,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_8d1f7ec402c1b452808eeb662977982b,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_47_set_tlsext_servername_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_47_set_tlsext_servername_callback,
        const_str_plain_set_tlsext_servername_callback,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_94c0d4b8cf686c2e34361e7cd48a3052,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_d84d6f514b61e2d13913a11459387aca,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_47_set_tlsext_servername_callback$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_47_set_tlsext_servername_callback$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d01eafbb0e285abd4a6f7d94f9e77264,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        1
    );

result->m_closure[0] = closure_callback;
Py_INCREF( result->m_closure[0] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_use_srtp(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_48_set_tlsext_use_srtp,
        const_str_plain_set_tlsext_use_srtp,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_68f89f8855b7fe9638b09d04b6d22f83,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_447836721d7454a13033957e012d7688,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_49_set_alpn_protos(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_49_set_alpn_protos,
        const_str_plain_set_alpn_protos,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8fa949167a3f0e0a7575ae806dd11e0c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_cf5a529c83a60eab9bc87caa3430bc5c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_4___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9af82c9b2f08b52e9e1a6e31b73ec652,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback, struct Nuitka_CellObject *closure_self )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_45214eee286f8b09ba13e2d070abb952,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        2
    );

result->m_closure[0] = closure_callback;
Py_INCREF( result->m_closure[0] );
result->m_closure[1] = closure_self;
Py_INCREF( result->m_closure[1] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_50_set_alpn_select_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_50_set_alpn_select_callback,
        const_str_plain_set_alpn_select_callback,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b67de0094492dbb326b6f334ee86c858,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_c16991ba946fb91cede508bddb6a3d8d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_51__set_ocsp_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_51__set_ocsp_callback,
        const_str_plain__set_ocsp_callback,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9d0f44146929f76ab672b2aef6185af0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_e7ed1590d11cbaaaf17420c6bdc13490,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_52_set_ocsp_server_callback( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_52_set_ocsp_server_callback,
        const_str_plain_set_ocsp_server_callback,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_42a5b4bb6bb2aefba79bf25001da3d90,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_77c1b668370aaac8571fd41e2e807543,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_53_set_ocsp_client_callback( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_53_set_ocsp_client_callback,
        const_str_plain_set_ocsp_client_callback,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c383504c16885b5865730f200cd9d1f8,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_7cc8f764b42656b144d56bfbd9df2b48,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_54___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_54___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5791a020e2944607f45102dc7fe5b8e6,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_149b7c0937a6a666f182d0520ebdf631,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_55___getattr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_55___getattr__,
        const_str_plain___getattr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_424e405bc16ae3d269c45c550285d49d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_eb75de26d3d89a0b83fc536ac20042b0,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_56__raise_ssl_error(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_56__raise_ssl_error,
        const_str_plain__raise_ssl_error,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f71814b0a3096f278454f1408739a313,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_57_get_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_57_get_context,
        const_str_plain_get_context,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f05618381c99bf98f904cc9e5458eb7c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_d71143a9aaaa613b59e0c4c3015a7c4a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_58_set_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_58_set_context,
        const_str_plain_set_context,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_645fa587f009c4b0f21236cdaad0381f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_fe9d923dffe7ca07e210d76d45bba668,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_59_get_servername(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_59_get_servername,
        const_str_plain_get_servername,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_40b81d4d05ddb4f44d648a36b01e1399,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_94e7111e03f9422114930bb75dfc492c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_5___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ab00c4dfc87ce556418936a5e1f26e78,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback, struct Nuitka_CellObject *closure_self )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0ad17b909e53698f39728a57b64a8076,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        2
    );

result->m_closure[0] = closure_callback;
Py_INCREF( result->m_closure[0] );
result->m_closure[1] = closure_self;
Py_INCREF( result->m_closure[1] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_60_set_tlsext_host_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_60_set_tlsext_host_name,
        const_str_plain_set_tlsext_host_name,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_49b91f95fc6102a2bc1d95d7f9f8434b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b2b544e0252baa92681eeaf8ffa03130,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_61_pending(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_61_pending,
        const_str_plain_pending,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f269207fdd9aa826c85b87cc35f9c7ef,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1ba1651f4266e42e9b568d28fa131281,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_62_send( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_62_send,
        const_str_plain_send,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_959585d8d371bbde9fdf5141fa04539f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_2c98e45dae0eb590d01836d5f4b5f54f,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_63_sendall( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_63_sendall,
        const_str_plain_sendall,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_09184f4a96c99cec7a5d574311293fc2,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_2eac950a8b26412274fa98ea596054c5,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_64_recv( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_64_recv,
        const_str_plain_recv,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1f33a93420eb4e87671bc14ef5fd1e7f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ebaec5436a48442094f25464a6eec24c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_65_recv_into( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_65_recv_into,
        const_str_plain_recv_into,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9de539dd2c4fff7fa74b7cb5d14f8608,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6f72f23667e4f49591ed4cf6d6205ca5,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_66__handle_bio_errors(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_66__handle_bio_errors,
        const_str_plain__handle_bio_errors,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1f497ea15bbb42e7e15142701e11983e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_67_bio_read(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_67_bio_read,
        const_str_plain_bio_read,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_76de6ab7acc79e46a01681558ca59a8f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f68d1733f2e29d0ad83b903b8f287e14,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_68_bio_write(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_68_bio_write,
        const_str_plain_bio_write,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_46248d2a1416020447a2f1bda814331e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3c214455d63d6846892932f043ae8dab,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_69_renegotiate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_69_renegotiate,
        const_str_plain_renegotiate,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ef80d1e646870f9f8e6a3599220d1f6c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_91c07271f44b73503e7c77deea91aef1,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_6___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_dade4f6f27b248c7011ea5b59e49e882,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper( struct Nuitka_CellObject *closure_callback, struct Nuitka_CellObject *closure_self )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_43b1c0b0ce1eda30c8482da409dfed18,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        2
    );

result->m_closure[0] = closure_callback;
Py_INCREF( result->m_closure[0] );
result->m_closure[1] = closure_self;
Py_INCREF( result->m_closure[1] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_70_do_handshake(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_70_do_handshake,
        const_str_plain_do_handshake,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f471e6be7d01aa5c66b978c44c21caac,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_48d61bd61390dfd5cd1a721d2881edd7,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_71_renegotiate_pending(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_71_renegotiate_pending,
        const_str_plain_renegotiate_pending,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cefffc968213c61d10c7867e6cb8570d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_bd36e8cd21056831af843bc4658cec96,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_72_total_renegotiations(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_72_total_renegotiations,
        const_str_plain_total_renegotiations,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8020a8b1dd8cc3669fc7bd37ad12a2b9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_61df355efe52f096d5251268bee9ada3,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_73_connect(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_73_connect,
        const_str_plain_connect,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0b065f9eac3a60d85f6dd231c0feb979,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_060a092ce142509580b5fc6c56b149a1,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_74_connect_ex(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_74_connect_ex,
        const_str_plain_connect_ex,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8ad19aa17d83645d613ebc651e52854c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_60759f97a8e448eec2208bd0c353d705,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_75_accept(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_75_accept,
        const_str_plain_accept,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f70ca376b0b1f16d9dd97a3dbf1ac8bc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_592776beca582822ed747da68adba670,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_76_bio_shutdown(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_76_bio_shutdown,
        const_str_plain_bio_shutdown,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b2acd45430926a957bca22524535bd30,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_5ecd8d00ee49c82aecc9b4312a6eab51,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_77_shutdown(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_77_shutdown,
        const_str_plain_shutdown,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_970d54497ed5d25db8bd7deb24b2b711,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_9071118ef0006cb5d28d9100761be8e9,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_78_get_cipher_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_78_get_cipher_list,
        const_str_plain_get_cipher_list,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_293d554e28a2e0dbefe61787be9b3f54,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_92d0e5bbbb594d3595c30b16879df5a0,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_79_get_client_ca_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_79_get_client_ca_list,
        const_str_plain_get_client_ca_list,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8a41e5553d84f5d5e266ff41226b9c33,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_92dae1d5c0e993b1b8bd25bfbbae5039,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_7__asFileDescriptor(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_7__asFileDescriptor,
        const_str_plain__asFileDescriptor,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ee325f32577779b2b6a08490839df69e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_80_makefile(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_80_makefile,
        const_str_plain_makefile,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7f96db37ca0e6291733c630c66c75747,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f45f13437cfffca595693525af90acd6,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_81_get_app_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_81_get_app_data,
        const_str_plain_get_app_data,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7ad94f13e041b88ab1ac27807baabbcd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_8d7c284f25a4b19db8bcbef7a9895745,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_82_set_app_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_82_set_app_data,
        const_str_plain_set_app_data,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_bb8872b94b0002e97eef74e34fbffbe1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_240fed82a102b949d0d53c00df42e330,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_83_get_shutdown(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_83_get_shutdown,
        const_str_plain_get_shutdown,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_87f7d3bd0c797a24b2bca9399e1fbbb9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0bdfe95b50c341a06f9727afb1a762dc,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_84_set_shutdown(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_84_set_shutdown,
        const_str_plain_set_shutdown,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_acda319b97db4bd0371702c365a552ee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_655ba65e888ba33199198c92a8e95d70,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_85_get_state_string(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_85_get_state_string,
        const_str_plain_get_state_string,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_acba1edf54ec8ed7cadead9caaa107de,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6e6304d3afc4a993b41c01e5af499f6b,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_86_server_random(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_86_server_random,
        const_str_plain_server_random,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_787b8e6bfd81d6bd4f675c83610bc416,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ad463a4d3fa3baff68f13aea2d205572,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_87_client_random(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_87_client_random,
        const_str_plain_client_random,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_361c887bcade8cec7b7f7a75e2bc0931,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ce6e46c47189c65d4c33b9ca8d5ba2ad,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_88_master_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_88_master_key,
        const_str_plain_master_key,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c5a33d979afcfefdaf074fd78849d7f9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_a94ef27b6600318cb26f98532a46ec7d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_89_export_keying_material( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_89_export_keying_material,
        const_str_plain_export_keying_material,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2fffdc517f229be102aa4e0949e42f3d,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_cbc74855fdd069af46a5197a85921eab,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_8_SSLeay_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_8_SSLeay_version,
        const_str_plain_SSLeay_version,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e398f1d99b089b4d7b9c44b332686f32,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1c06dc4166e08805f38a8dca82ce4339,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_90_sock_shutdown(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_90_sock_shutdown,
        const_str_plain_sock_shutdown,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9351f991ba8e7d4c0845d79aab6ff700,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_159b478f00ae4e4ff337b75b4ff4b73e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_91_get_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_91_get_certificate,
        const_str_plain_get_certificate,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_86508d4dd364cb660af852a87adf893f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_770cbd653c9b65a44061ec243e0b5fd3,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_92_get_peer_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_92_get_peer_certificate,
        const_str_plain_get_peer_certificate,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_59e17a52f108ec0be7939e85e90ca5b0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_5f09856be161f8b617a90e11db2ed735,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_93__cert_stack_to_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_93__cert_stack_to_list,
        const_str_plain__cert_stack_to_list,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_188b168a82dba9bb38a8643a6f371a55,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_59969d93e4432efc7c61f6e9fd945ba6,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_94_get_peer_cert_chain(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_94_get_peer_cert_chain,
        const_str_plain_get_peer_cert_chain,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f5481765c0dd14c9fd2dc2cbccca5828,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b6ee2740f619fbeb4f2040d74693ca57,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_95_get_verified_chain(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_95_get_verified_chain,
        const_str_plain_get_verified_chain,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e0473f6709515182770f72050d887758,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_fc4eb7967b0e83bc3a3b7fec0ef46cce,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_96_want_read(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_96_want_read,
        const_str_plain_want_read,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d14e5f7a612d4badaf324988c48b88af,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_bcb5a3a78e430302038d88f5e5d88cc5,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_97_want_write(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_97_want_write,
        const_str_plain_want_write,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_66106d74879c849f5649f3f764b1f958,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1f723e76cd26cf3162ae94f693472dd5,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_98_set_accept_state(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_98_set_accept_state,
        const_str_plain_set_accept_state,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b36eb1a77f0339db15b9fbd63165b3ab,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3319904791e7df62e14d88cc362facc1,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_99_set_connect_state(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_99_set_connect_state,
        const_str_plain_set_connect_state,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6e69ef82635c437b7d2bbe57e645669d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3f54294273e4f6390044ae027b11e5ae,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_9__make_requires(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_9__make_requires,
        const_str_plain__make_requires,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cc10cda9431f221c058f51f43369d877,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b8ec26ebdab81fb3d5f36275b48d4beb,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator( struct Nuitka_CellObject *closure_error, struct Nuitka_CellObject *closure_flag )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator,
        const_str_plain__requires_decorator,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_08887bdadd93093833a6269bac10532c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        2
    );

result->m_closure[0] = closure_error;
Py_INCREF( result->m_closure[0] );
result->m_closure[1] = closure_flag;
Py_INCREF( result->m_closure[1] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator$$$function_1_explode( struct Nuitka_CellObject *closure_error )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_9__make_requires$$$function_1__requires_decorator$$$function_1_explode,
        const_str_plain_explode,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_063bd03355e78d04c83a3ed99d0f9b6f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_OpenSSL$SSL,
        Py_None,
        1
    );

result->m_closure[0] = closure_error;
Py_INCREF( result->m_closure[0] );

    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_OpenSSL$SSL =
{
    PyModuleDef_HEAD_INIT,
    "OpenSSL.SSL",   /* m_name */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___package__;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;
#endif
#if PYTHON_VERSION >= 330
extern PyObject *const_str_plain___loader__;
extern PyObject *metapath_based_loader;
#endif
#if PYTHON_VERSION >= 330
extern PyObject *const_str_plain___spec__;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( OpenSSL$SSL )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_OpenSSL$SSL );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    puts("OpenSSL.SSL: Calling setupMetaPathBasedLoader().");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("OpenSSL.SSL: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("OpenSSL.SSL: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initOpenSSL$SSL" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_OpenSSL$SSL = Py_InitModule4(
        "OpenSSL.SSL",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else

    module_OpenSSL$SSL = PyModule_Create( &mdef_OpenSSL$SSL );
#endif

    moduledict_OpenSSL$SSL = MODULE_DICT( module_OpenSSL$SSL );

    // Update "__package__" value to what it ought to be.
    {
#if 0
#if PYTHON_VERSION < 300 || PYTHON_VERSION >= 330
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___name__ );

        UPDATE_STRING_DICT1(
            moduledict_OpenSSL$SSL,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#endif

#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___name__ );
        char const *module_name_cstr = PyString_AS_STRING( module_name );

        char const *last_dot = strrchr( module_name_cstr, '.' );

        if ( last_dot != NULL )
        {
            UPDATE_STRING_DICT1(
                moduledict_OpenSSL$SSL,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize( module_name_cstr, last_dot - module_name_cstr )
            );
        }
#elif PYTHON_VERSION < 330
        UPDATE_STRING_DICT1(
            moduledict_OpenSSL$SSL,
            (Nuitka_StringObject *)const_str_plain___package__,
            Py_None
        );
#else
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___name__ );
        Py_ssize_t dot_index = PyUnicode_Find( module_name, const_str_dot, 0, PyUnicode_GetLength( module_name ), -1 );

        if ( dot_index != -1 )
        {
            UPDATE_STRING_DICT1(
                moduledict_OpenSSL$SSL,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring( module_name, 0, dot_index )
            );
        }
#endif
#endif
    }

    CHECK_OBJECT( module_OpenSSL$SSL );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PySys_GetObject( (char *)"modules" ), const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9, module_OpenSSL$SSL );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if ( GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___builtins__, value );
    }

#if PYTHON_VERSION >= 330
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___loader__, metapath_based_loader );
#endif

#if PYTHON_VERSION >= 340
#if 0
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___spec__, Py_None );
#else
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT( bootstrap_module );
        PyObject *module_spec_class = PyObject_GetAttrString( bootstrap_module, "ModuleSpec" );
        Py_DECREF( bootstrap_module );

        PyObject *args[] = {
            GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___name__ ),
            metapath_based_loader
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );

        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___spec__, spec_value );

        Py_DECREF( module_spec_class );
    }
#endif
#endif


    // Temp variables if any
    PyObject *tmp_Context$genexpr_1__$0 = NULL;
    PyObject *tmp_class_creation_10__bases = NULL;
    PyObject *tmp_class_creation_10__class = NULL;
    PyObject *tmp_class_creation_10__class_dict = NULL;
    PyObject *tmp_class_creation_10__metaclass = NULL;
    PyObject *tmp_class_creation_11__bases = NULL;
    PyObject *tmp_class_creation_11__class = NULL;
    PyObject *tmp_class_creation_11__class_dict = NULL;
    PyObject *tmp_class_creation_11__metaclass = NULL;
    PyObject *tmp_class_creation_12__bases = NULL;
    PyObject *tmp_class_creation_12__class = NULL;
    PyObject *tmp_class_creation_12__class_dict = NULL;
    PyObject *tmp_class_creation_12__metaclass = NULL;
    PyObject *tmp_class_creation_13__class = NULL;
    PyObject *tmp_class_creation_13__class_dict = NULL;
    PyObject *tmp_class_creation_13__metaclass = NULL;
    PyObject *tmp_class_creation_14__class = NULL;
    PyObject *tmp_class_creation_14__class_dict = NULL;
    PyObject *tmp_class_creation_14__metaclass = NULL;
    PyObject *tmp_class_creation_15__class = NULL;
    PyObject *tmp_class_creation_15__class_dict = NULL;
    PyObject *tmp_class_creation_15__metaclass = NULL;
    PyObject *tmp_class_creation_2__bases = NULL;
    PyObject *tmp_class_creation_2__class = NULL;
    PyObject *tmp_class_creation_2__class_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_3__bases = NULL;
    PyObject *tmp_class_creation_3__class = NULL;
    PyObject *tmp_class_creation_3__class_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_4__bases = NULL;
    PyObject *tmp_class_creation_4__class = NULL;
    PyObject *tmp_class_creation_4__class_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_5__bases = NULL;
    PyObject *tmp_class_creation_5__class = NULL;
    PyObject *tmp_class_creation_5__class_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_6__bases = NULL;
    PyObject *tmp_class_creation_6__class = NULL;
    PyObject *tmp_class_creation_6__class_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_7__bases = NULL;
    PyObject *tmp_class_creation_7__class = NULL;
    PyObject *tmp_class_creation_7__class_dict = NULL;
    PyObject *tmp_class_creation_7__metaclass = NULL;
    PyObject *tmp_class_creation_8__class = NULL;
    PyObject *tmp_class_creation_8__class_dict = NULL;
    PyObject *tmp_class_creation_8__metaclass = NULL;
    PyObject *tmp_class_creation_9__bases = NULL;
    PyObject *tmp_class_creation_9__class = NULL;
    PyObject *tmp_class_creation_9__class_dict = NULL;
    PyObject *tmp_class_creation_9__metaclass = NULL;
    PyObject *tmp_import_from_1__module = NULL;
    PyObject *tmp_import_from_2__module = NULL;
    PyObject *tmp_import_from_3__module = NULL;
    PyObject *tmp_import_from_4__module = NULL;
    PyObject *tmp_import_from_5__module = NULL;
    PyObject *tmp_select_metaclass_10__base = NULL;
    PyObject *tmp_select_metaclass_11__base = NULL;
    PyObject *tmp_select_metaclass_12__base = NULL;
    PyObject *tmp_select_metaclass_2__base = NULL;
    PyObject *tmp_select_metaclass_3__base = NULL;
    PyObject *tmp_select_metaclass_4__base = NULL;
    PyObject *tmp_select_metaclass_5__base = NULL;
    PyObject *tmp_select_metaclass_6__base = NULL;
    PyObject *tmp_select_metaclass_7__base = NULL;
    PyObject *tmp_select_metaclass_9__base = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;
    PyObject *exception_keeper_type_28;
    PyObject *exception_keeper_value_28;
    PyTracebackObject *exception_keeper_tb_28;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_28;
    PyObject *exception_keeper_type_29;
    PyObject *exception_keeper_value_29;
    PyTracebackObject *exception_keeper_tb_29;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_29;
    PyObject *exception_keeper_type_30;
    PyObject *exception_keeper_value_30;
    PyTracebackObject *exception_keeper_tb_30;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_30;
    PyObject *exception_keeper_type_31;
    PyObject *exception_keeper_value_31;
    PyTracebackObject *exception_keeper_tb_31;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_31;
    PyObject *exception_keeper_type_32;
    PyObject *exception_keeper_value_32;
    PyTracebackObject *exception_keeper_tb_32;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_32;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_element_name_22;
    PyObject *tmp_args_element_name_23;
    PyObject *tmp_args_element_name_24;
    PyObject *tmp_args_element_name_25;
    PyObject *tmp_args_element_name_26;
    PyObject *tmp_args_element_name_27;
    PyObject *tmp_args_element_name_28;
    PyObject *tmp_args_element_name_29;
    PyObject *tmp_args_element_name_30;
    PyObject *tmp_args_element_name_31;
    PyObject *tmp_args_element_name_32;
    PyObject *tmp_args_element_name_33;
    PyObject *tmp_args_element_name_34;
    PyObject *tmp_args_element_name_35;
    PyObject *tmp_args_element_name_36;
    PyObject *tmp_args_element_name_37;
    PyObject *tmp_args_element_name_38;
    PyObject *tmp_args_element_name_39;
    PyObject *tmp_args_element_name_40;
    PyObject *tmp_args_element_name_41;
    PyObject *tmp_args_element_name_42;
    PyObject *tmp_args_element_name_43;
    PyObject *tmp_args_element_name_44;
    PyObject *tmp_args_element_name_45;
    PyObject *tmp_args_element_name_46;
    PyObject *tmp_args_element_name_47;
    PyObject *tmp_args_element_name_48;
    PyObject *tmp_args_element_name_49;
    PyObject *tmp_args_element_name_50;
    PyObject *tmp_args_element_name_51;
    PyObject *tmp_args_element_name_52;
    PyObject *tmp_args_element_name_53;
    PyObject *tmp_args_element_name_54;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_assign_source_30;
    PyObject *tmp_assign_source_31;
    PyObject *tmp_assign_source_32;
    PyObject *tmp_assign_source_33;
    PyObject *tmp_assign_source_34;
    PyObject *tmp_assign_source_35;
    PyObject *tmp_assign_source_36;
    PyObject *tmp_assign_source_37;
    PyObject *tmp_assign_source_38;
    PyObject *tmp_assign_source_39;
    PyObject *tmp_assign_source_40;
    PyObject *tmp_assign_source_41;
    PyObject *tmp_assign_source_42;
    PyObject *tmp_assign_source_43;
    PyObject *tmp_assign_source_44;
    PyObject *tmp_assign_source_45;
    PyObject *tmp_assign_source_46;
    PyObject *tmp_assign_source_47;
    PyObject *tmp_assign_source_48;
    PyObject *tmp_assign_source_49;
    PyObject *tmp_assign_source_50;
    PyObject *tmp_assign_source_51;
    PyObject *tmp_assign_source_52;
    PyObject *tmp_assign_source_53;
    PyObject *tmp_assign_source_54;
    PyObject *tmp_assign_source_55;
    PyObject *tmp_assign_source_56;
    PyObject *tmp_assign_source_57;
    PyObject *tmp_assign_source_58;
    PyObject *tmp_assign_source_59;
    PyObject *tmp_assign_source_60;
    PyObject *tmp_assign_source_61;
    PyObject *tmp_assign_source_62;
    PyObject *tmp_assign_source_63;
    PyObject *tmp_assign_source_64;
    PyObject *tmp_assign_source_65;
    PyObject *tmp_assign_source_66;
    PyObject *tmp_assign_source_67;
    PyObject *tmp_assign_source_68;
    PyObject *tmp_assign_source_69;
    PyObject *tmp_assign_source_70;
    PyObject *tmp_assign_source_71;
    PyObject *tmp_assign_source_72;
    PyObject *tmp_assign_source_73;
    PyObject *tmp_assign_source_74;
    PyObject *tmp_assign_source_75;
    PyObject *tmp_assign_source_76;
    PyObject *tmp_assign_source_77;
    PyObject *tmp_assign_source_78;
    PyObject *tmp_assign_source_79;
    PyObject *tmp_assign_source_80;
    PyObject *tmp_assign_source_81;
    PyObject *tmp_assign_source_82;
    PyObject *tmp_assign_source_83;
    PyObject *tmp_assign_source_84;
    PyObject *tmp_assign_source_85;
    PyObject *tmp_assign_source_86;
    PyObject *tmp_assign_source_87;
    PyObject *tmp_assign_source_88;
    PyObject *tmp_assign_source_89;
    PyObject *tmp_assign_source_90;
    PyObject *tmp_assign_source_91;
    PyObject *tmp_assign_source_92;
    PyObject *tmp_assign_source_93;
    PyObject *tmp_assign_source_94;
    PyObject *tmp_assign_source_95;
    PyObject *tmp_assign_source_96;
    PyObject *tmp_assign_source_97;
    PyObject *tmp_assign_source_98;
    PyObject *tmp_assign_source_99;
    PyObject *tmp_assign_source_100;
    PyObject *tmp_assign_source_101;
    PyObject *tmp_assign_source_102;
    PyObject *tmp_assign_source_103;
    PyObject *tmp_assign_source_104;
    PyObject *tmp_assign_source_105;
    PyObject *tmp_assign_source_106;
    PyObject *tmp_assign_source_107;
    PyObject *tmp_assign_source_108;
    PyObject *tmp_assign_source_109;
    PyObject *tmp_assign_source_110;
    PyObject *tmp_assign_source_111;
    PyObject *tmp_assign_source_112;
    PyObject *tmp_assign_source_113;
    PyObject *tmp_assign_source_114;
    PyObject *tmp_assign_source_115;
    PyObject *tmp_assign_source_116;
    PyObject *tmp_assign_source_117;
    PyObject *tmp_assign_source_118;
    PyObject *tmp_assign_source_119;
    PyObject *tmp_assign_source_120;
    PyObject *tmp_assign_source_121;
    PyObject *tmp_assign_source_122;
    PyObject *tmp_assign_source_123;
    PyObject *tmp_assign_source_124;
    PyObject *tmp_assign_source_125;
    PyObject *tmp_assign_source_126;
    PyObject *tmp_assign_source_127;
    PyObject *tmp_assign_source_128;
    PyObject *tmp_assign_source_129;
    PyObject *tmp_assign_source_130;
    PyObject *tmp_assign_source_131;
    PyObject *tmp_assign_source_132;
    PyObject *tmp_assign_source_133;
    PyObject *tmp_assign_source_134;
    PyObject *tmp_assign_source_135;
    PyObject *tmp_assign_source_136;
    PyObject *tmp_assign_source_137;
    PyObject *tmp_assign_source_138;
    PyObject *tmp_assign_source_139;
    PyObject *tmp_assign_source_140;
    PyObject *tmp_assign_source_141;
    PyObject *tmp_assign_source_142;
    PyObject *tmp_assign_source_143;
    PyObject *tmp_assign_source_144;
    PyObject *tmp_assign_source_145;
    PyObject *tmp_assign_source_146;
    PyObject *tmp_assign_source_147;
    PyObject *tmp_assign_source_148;
    PyObject *tmp_assign_source_149;
    PyObject *tmp_assign_source_150;
    PyObject *tmp_assign_source_151;
    PyObject *tmp_assign_source_152;
    PyObject *tmp_assign_source_153;
    PyObject *tmp_assign_source_154;
    PyObject *tmp_assign_source_155;
    PyObject *tmp_assign_source_156;
    PyObject *tmp_assign_source_157;
    PyObject *tmp_assign_source_158;
    PyObject *tmp_assign_source_159;
    PyObject *tmp_assign_source_160;
    PyObject *tmp_assign_source_161;
    PyObject *tmp_assign_source_162;
    PyObject *tmp_assign_source_163;
    PyObject *tmp_assign_source_164;
    PyObject *tmp_assign_source_165;
    PyObject *tmp_assign_source_166;
    PyObject *tmp_assign_source_167;
    PyObject *tmp_assign_source_168;
    PyObject *tmp_assign_source_169;
    PyObject *tmp_assign_source_170;
    PyObject *tmp_assign_source_171;
    PyObject *tmp_assign_source_172;
    PyObject *tmp_assign_source_173;
    PyObject *tmp_assign_source_174;
    PyObject *tmp_assign_source_175;
    PyObject *tmp_assign_source_176;
    PyObject *tmp_assign_source_177;
    PyObject *tmp_assign_source_178;
    PyObject *tmp_assign_source_179;
    PyObject *tmp_assign_source_180;
    PyObject *tmp_assign_source_181;
    PyObject *tmp_assign_source_182;
    PyObject *tmp_assign_source_183;
    PyObject *tmp_assign_source_184;
    PyObject *tmp_assign_source_185;
    PyObject *tmp_assign_source_186;
    PyObject *tmp_assign_source_187;
    PyObject *tmp_assign_source_188;
    PyObject *tmp_assign_source_189;
    PyObject *tmp_assign_source_190;
    PyObject *tmp_assign_source_191;
    PyObject *tmp_assign_source_192;
    PyObject *tmp_assign_source_193;
    PyObject *tmp_assign_source_194;
    PyObject *tmp_assign_source_195;
    PyObject *tmp_assign_source_196;
    PyObject *tmp_assign_source_197;
    PyObject *tmp_assign_source_198;
    PyObject *tmp_assign_source_199;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    PyObject *tmp_called_name_21;
    PyObject *tmp_called_name_22;
    PyObject *tmp_called_name_23;
    PyObject *tmp_called_name_24;
    PyObject *tmp_called_name_25;
    int tmp_cmp_In_1;
    int tmp_cmp_In_2;
    int tmp_cmp_In_3;
    int tmp_cmp_In_4;
    int tmp_cmp_In_5;
    int tmp_cmp_In_6;
    int tmp_cmp_In_7;
    int tmp_cmp_In_8;
    int tmp_cmp_In_9;
    int tmp_cmp_In_10;
    int tmp_cmp_In_11;
    int tmp_cmp_In_12;
    int tmp_cmp_In_13;
    int tmp_cmp_In_14;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_left_9;
    PyObject *tmp_compare_left_10;
    PyObject *tmp_compare_left_11;
    PyObject *tmp_compare_left_12;
    PyObject *tmp_compare_left_13;
    PyObject *tmp_compare_left_14;
    PyObject *tmp_compare_left_15;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_compare_right_9;
    PyObject *tmp_compare_right_10;
    PyObject *tmp_compare_right_11;
    PyObject *tmp_compare_right_12;
    PyObject *tmp_compare_right_13;
    PyObject *tmp_compare_right_14;
    PyObject *tmp_compare_right_15;
    PyObject *tmp_defaults_1;
    PyObject *tmp_defaults_2;
    PyObject *tmp_defaults_3;
    PyObject *tmp_defaults_4;
    PyObject *tmp_defaults_5;
    PyObject *tmp_defaults_6;
    PyObject *tmp_defaults_7;
    PyObject *tmp_defaults_8;
    PyObject *tmp_defaults_9;
    PyObject *tmp_defaults_10;
    PyObject *tmp_defaults_11;
    PyObject *tmp_defaults_12;
    PyObject *tmp_defaults_13;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_name_1;
    PyObject *tmp_dict_name_2;
    PyObject *tmp_dict_name_3;
    PyObject *tmp_dict_name_4;
    PyObject *tmp_dict_name_5;
    PyObject *tmp_dict_name_6;
    PyObject *tmp_dict_name_7;
    PyObject *tmp_dict_name_8;
    PyObject *tmp_dict_name_9;
    PyObject *tmp_dict_name_10;
    PyObject *tmp_dict_name_11;
    PyObject *tmp_dict_name_12;
    PyObject *tmp_dict_name_13;
    PyObject *tmp_dict_name_14;
    PyObject *tmp_dict_seq_1;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_dictset_value;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_fromlist_name_2;
    PyObject *tmp_fromlist_name_3;
    PyObject *tmp_fromlist_name_4;
    PyObject *tmp_fromlist_name_5;
    PyObject *tmp_fromlist_name_6;
    PyObject *tmp_fromlist_name_7;
    PyObject *tmp_fromlist_name_8;
    PyObject *tmp_fromlist_name_9;
    PyObject *tmp_fromlist_name_10;
    PyObject *tmp_getattr_attr_1;
    PyObject *tmp_getattr_default_1;
    PyObject *tmp_getattr_target_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_globals_name_2;
    PyObject *tmp_globals_name_3;
    PyObject *tmp_globals_name_4;
    PyObject *tmp_globals_name_5;
    PyObject *tmp_globals_name_6;
    PyObject *tmp_globals_name_7;
    PyObject *tmp_globals_name_8;
    PyObject *tmp_globals_name_9;
    PyObject *tmp_globals_name_10;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_import_name_from_3;
    PyObject *tmp_import_name_from_4;
    PyObject *tmp_import_name_from_5;
    PyObject *tmp_import_name_from_6;
    PyObject *tmp_import_name_from_7;
    PyObject *tmp_import_name_from_8;
    PyObject *tmp_import_name_from_9;
    PyObject *tmp_import_name_from_10;
    PyObject *tmp_import_name_from_11;
    PyObject *tmp_import_name_from_12;
    PyObject *tmp_import_name_from_13;
    PyObject *tmp_import_name_from_14;
    PyObject *tmp_import_name_from_15;
    PyObject *tmp_import_name_from_16;
    PyObject *tmp_import_name_from_17;
    PyObject *tmp_import_name_from_18;
    PyObject *tmp_import_name_from_19;
    PyObject *tmp_import_name_from_20;
    PyObject *tmp_import_name_from_21;
    PyObject *tmp_import_name_from_22;
    PyObject *tmp_import_name_from_23;
    PyObject *tmp_import_name_from_24;
    PyObject *tmp_import_name_from_25;
    PyObject *tmp_import_name_from_26;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_key_name_1;
    PyObject *tmp_key_name_2;
    PyObject *tmp_key_name_3;
    PyObject *tmp_key_name_4;
    PyObject *tmp_key_name_5;
    PyObject *tmp_key_name_6;
    PyObject *tmp_key_name_7;
    PyObject *tmp_key_name_8;
    PyObject *tmp_key_name_9;
    PyObject *tmp_key_name_10;
    PyObject *tmp_key_name_11;
    PyObject *tmp_key_name_12;
    PyObject *tmp_key_name_13;
    PyObject *tmp_key_name_14;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_locals_name_2;
    PyObject *tmp_locals_name_3;
    PyObject *tmp_locals_name_4;
    PyObject *tmp_locals_name_5;
    PyObject *tmp_locals_name_6;
    PyObject *tmp_locals_name_7;
    PyObject *tmp_locals_name_8;
    PyObject *tmp_locals_name_9;
    PyObject *tmp_locals_name_10;
    PyObject *tmp_name_name_1;
    PyObject *tmp_name_name_2;
    PyObject *tmp_name_name_3;
    PyObject *tmp_name_name_4;
    PyObject *tmp_name_name_5;
    PyObject *tmp_name_name_6;
    PyObject *tmp_name_name_7;
    PyObject *tmp_name_name_8;
    PyObject *tmp_name_name_9;
    PyObject *tmp_name_name_10;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_outline_return_value_2;
    PyObject *tmp_outline_return_value_3;
    PyObject *tmp_outline_return_value_4;
    PyObject *tmp_outline_return_value_5;
    PyObject *tmp_outline_return_value_6;
    PyObject *tmp_outline_return_value_7;
    PyObject *tmp_outline_return_value_8;
    PyObject *tmp_outline_return_value_9;
    PyObject *tmp_outline_return_value_10;
    PyObject *tmp_outline_return_value_11;
    PyObject *tmp_outline_return_value_12;
    PyObject *tmp_outline_return_value_13;
    PyObject *tmp_outline_return_value_14;
    PyObject *tmp_outline_return_value_15;
    PyObject *tmp_outline_return_value_16;
    PyObject *tmp_outline_return_value_17;
    PyObject *tmp_outline_return_value_18;
    PyObject *tmp_outline_return_value_19;
    PyObject *tmp_outline_return_value_20;
    PyObject *tmp_outline_return_value_21;
    PyObject *tmp_outline_return_value_22;
    PyObject *tmp_outline_return_value_23;
    PyObject *tmp_outline_return_value_24;
    PyObject *tmp_outline_return_value_25;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_set_locals;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    PyObject *tmp_source_name_19;
    PyObject *tmp_source_name_20;
    PyObject *tmp_source_name_21;
    PyObject *tmp_source_name_22;
    PyObject *tmp_source_name_23;
    PyObject *tmp_source_name_24;
    PyObject *tmp_source_name_25;
    PyObject *tmp_source_name_26;
    PyObject *tmp_source_name_27;
    PyObject *tmp_source_name_28;
    PyObject *tmp_source_name_29;
    PyObject *tmp_source_name_30;
    PyObject *tmp_source_name_31;
    PyObject *tmp_source_name_32;
    PyObject *tmp_source_name_33;
    PyObject *tmp_source_name_34;
    PyObject *tmp_source_name_35;
    PyObject *tmp_source_name_36;
    PyObject *tmp_source_name_37;
    PyObject *tmp_source_name_38;
    PyObject *tmp_source_name_39;
    PyObject *tmp_source_name_40;
    PyObject *tmp_source_name_41;
    PyObject *tmp_source_name_42;
    PyObject *tmp_source_name_43;
    PyObject *tmp_source_name_44;
    PyObject *tmp_source_name_45;
    PyObject *tmp_source_name_46;
    PyObject *tmp_source_name_47;
    PyObject *tmp_source_name_48;
    PyObject *tmp_source_name_49;
    PyObject *tmp_source_name_50;
    PyObject *tmp_source_name_51;
    PyObject *tmp_source_name_52;
    PyObject *tmp_source_name_53;
    PyObject *tmp_source_name_54;
    PyObject *tmp_source_name_55;
    PyObject *tmp_source_name_56;
    PyObject *tmp_source_name_57;
    PyObject *tmp_source_name_58;
    PyObject *tmp_source_name_59;
    PyObject *tmp_source_name_60;
    PyObject *tmp_source_name_61;
    PyObject *tmp_source_name_62;
    PyObject *tmp_source_name_63;
    PyObject *tmp_source_name_64;
    PyObject *tmp_source_name_65;
    PyObject *tmp_source_name_66;
    PyObject *tmp_source_name_67;
    PyObject *tmp_source_name_68;
    PyObject *tmp_source_name_69;
    PyObject *tmp_source_name_70;
    PyObject *tmp_source_name_71;
    PyObject *tmp_source_name_72;
    PyObject *tmp_source_name_73;
    PyObject *tmp_source_name_74;
    PyObject *tmp_source_name_75;
    PyObject *tmp_source_name_76;
    PyObject *tmp_source_name_77;
    PyObject *tmp_source_name_78;
    PyObject *tmp_staticmethod_arg_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscribed_name_8;
    PyObject *tmp_subscribed_name_9;
    PyObject *tmp_subscribed_name_10;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    PyObject *tmp_subscript_name_8;
    PyObject *tmp_subscript_name_9;
    PyObject *tmp_subscript_name_10;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_tuple_element_4;
    PyObject *tmp_tuple_element_5;
    PyObject *tmp_tuple_element_6;
    PyObject *tmp_tuple_element_7;
    PyObject *tmp_tuple_element_8;
    PyObject *tmp_tuple_element_9;
    PyObject *tmp_tuple_element_10;
    PyObject *tmp_tuple_element_11;
    PyObject *tmp_tuple_element_12;
    PyObject *tmp_type_arg_1;
    PyObject *tmp_type_arg_2;
    PyObject *tmp_type_arg_3;
    PyObject *tmp_type_arg_4;
    PyObject *tmp_type_arg_5;
    PyObject *tmp_type_arg_6;
    PyObject *tmp_type_arg_7;
    PyObject *tmp_type_arg_8;
    PyObject *tmp_type_arg_9;
    PyObject *tmp_type_arg_10;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2 = NULL;

    struct Nuitka_FrameObject *frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2;

    static struct Nuitka_FrameObject *cache_frame_e4910e1ff9226b6796184f2658fa4bf8_3 = NULL;

    struct Nuitka_FrameObject *frame_e4910e1ff9226b6796184f2658fa4bf8_3;

    struct Nuitka_FrameObject *frame_88603af527c83dda944c7ddf4d45b354;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    tmp_outline_return_value_1 = NULL;
    tmp_outline_return_value_2 = NULL;
    tmp_outline_return_value_3 = NULL;
    tmp_outline_return_value_4 = NULL;
    tmp_outline_return_value_5 = NULL;
    tmp_outline_return_value_6 = NULL;
    tmp_outline_return_value_7 = NULL;
    tmp_outline_return_value_8 = NULL;
    tmp_outline_return_value_9 = NULL;
    tmp_outline_return_value_10 = NULL;
    tmp_outline_return_value_11 = NULL;
    tmp_outline_return_value_12 = NULL;
    tmp_outline_return_value_13 = NULL;
    tmp_outline_return_value_14 = NULL;
    tmp_outline_return_value_15 = NULL;
    tmp_outline_return_value_16 = NULL;
    tmp_outline_return_value_17 = NULL;
    tmp_outline_return_value_18 = NULL;
    tmp_outline_return_value_19 = NULL;
    tmp_outline_return_value_20 = NULL;
    tmp_outline_return_value_21 = NULL;
    tmp_outline_return_value_22 = NULL;
    tmp_outline_return_value_23 = NULL;
    tmp_outline_return_value_24 = NULL;
    tmp_outline_return_value_25 = NULL;
    PyObject *locals_SysCallError_264 = NULL;
    PyObject *locals__ALPNSelectHelper_339 = NULL;
    PyObject *locals_WantReadError_248 = NULL;
    PyObject *locals_Context_602 = NULL;
    PyObject *locals_ZeroReturnError_260 = NULL;
    PyObject *locals_WantX509LookupError_256 = NULL;
    PyObject *locals__OCSPClientCallbackHelper_467 = NULL;
    PyObject *locals_Connection_1461 = NULL;
    PyObject *locals__VerifyHelper_296 = NULL;
    PyObject *locals__OCSPServerCallbackHelper_400 = NULL;
    PyObject *locals_Error_238 = NULL;
    PyObject *locals_WantWriteError_252 = NULL;
    PyObject *locals__CallbackExceptionHelper_268 = NULL;
    PyObject *locals_Session_590 = NULL;

    // Module code.
    tmp_assign_source_1 = Py_None;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    tmp_assign_source_2 = module_filename_obj;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    // Frame without reuse.
    frame_88603af527c83dda944c7ddf4d45b354 = MAKE_MODULE_FRAME( codeobj_88603af527c83dda944c7ddf4d45b354, module_OpenSSL$SSL );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_88603af527c83dda944c7ddf4d45b354 );
    assert( Py_REFCNT( frame_88603af527c83dda944c7ddf4d45b354 ) == 2 );

    // Framed code:
    tmp_name_name_1 = const_str_plain_os;
    tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$SSL;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = Py_None;
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 1;
    tmp_assign_source_3 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os, tmp_assign_source_3 );
    tmp_name_name_2 = const_str_plain_socket;
    tmp_globals_name_2 = (PyObject *)moduledict_OpenSSL$SSL;
    tmp_locals_name_2 = Py_None;
    tmp_fromlist_name_2 = Py_None;
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 2;
    tmp_assign_source_4 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_socket, tmp_assign_source_4 );
    tmp_name_name_3 = const_str_plain_sys;
    tmp_globals_name_3 = (PyObject *)moduledict_OpenSSL$SSL;
    tmp_locals_name_3 = Py_None;
    tmp_fromlist_name_3 = const_tuple_str_plain_platform_tuple;
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 3;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3 );
    assert( tmp_import_name_from_1 != NULL );
    tmp_assign_source_5 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_platform );
    Py_DECREF( tmp_import_name_from_1 );
    assert( tmp_assign_source_5 != NULL );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_platform, tmp_assign_source_5 );
    tmp_name_name_4 = const_str_plain_functools;
    tmp_globals_name_4 = (PyObject *)moduledict_OpenSSL$SSL;
    tmp_locals_name_4 = Py_None;
    tmp_fromlist_name_4 = const_tuple_str_plain_wraps_str_plain_partial_tuple;
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 4;
    tmp_assign_source_6 = IMPORT_MODULE4( tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 4;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_1__module == NULL );
    tmp_import_from_1__module = tmp_assign_source_6;

    // Tried code:
    tmp_import_name_from_2 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_2 );
    tmp_assign_source_7 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_wraps );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 4;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps, tmp_assign_source_7 );
    tmp_import_name_from_3 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_3 );
    tmp_assign_source_8 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_partial );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 4;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_partial, tmp_assign_source_8 );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    tmp_name_name_5 = const_str_plain_itertools;
    tmp_globals_name_5 = (PyObject *)moduledict_OpenSSL$SSL;
    tmp_locals_name_5 = Py_None;
    tmp_fromlist_name_5 = const_tuple_str_plain_count_str_plain_chain_tuple;
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 5;
    tmp_assign_source_9 = IMPORT_MODULE4( tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 5;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_2__module == NULL );
    tmp_import_from_2__module = tmp_assign_source_9;

    // Tried code:
    tmp_import_name_from_4 = tmp_import_from_2__module;

    CHECK_OBJECT( tmp_import_name_from_4 );
    tmp_assign_source_10 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain_count );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 5;

        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_count, tmp_assign_source_10 );
    tmp_import_name_from_5 = tmp_import_from_2__module;

    CHECK_OBJECT( tmp_import_name_from_5 );
    tmp_assign_source_11 = IMPORT_NAME( tmp_import_name_from_5, const_str_plain_chain );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 5;

        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_chain, tmp_assign_source_11 );
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_2__module );
    Py_DECREF( tmp_import_from_2__module );
    tmp_import_from_2__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_2__module );
    Py_DECREF( tmp_import_from_2__module );
    tmp_import_from_2__module = NULL;

    tmp_name_name_6 = const_str_plain_weakref;
    tmp_globals_name_6 = (PyObject *)moduledict_OpenSSL$SSL;
    tmp_locals_name_6 = Py_None;
    tmp_fromlist_name_6 = const_tuple_str_plain_WeakValueDictionary_tuple;
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 6;
    tmp_import_name_from_6 = IMPORT_MODULE4( tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6 );
    if ( tmp_import_name_from_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 6;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_12 = IMPORT_NAME( tmp_import_name_from_6, const_str_plain_WeakValueDictionary );
    Py_DECREF( tmp_import_name_from_6 );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 6;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WeakValueDictionary, tmp_assign_source_12 );
    tmp_name_name_7 = const_str_plain_errno;
    tmp_globals_name_7 = (PyObject *)moduledict_OpenSSL$SSL;
    tmp_locals_name_7 = Py_None;
    tmp_fromlist_name_7 = const_tuple_str_plain_errorcode_tuple;
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 7;
    tmp_import_name_from_7 = IMPORT_MODULE4( tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7 );
    assert( tmp_import_name_from_7 != NULL );
    tmp_assign_source_13 = IMPORT_NAME( tmp_import_name_from_7, const_str_plain_errorcode );
    Py_DECREF( tmp_import_name_from_7 );
    assert( tmp_assign_source_13 != NULL );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_errorcode, tmp_assign_source_13 );
    tmp_name_name_8 = const_str_plain_six;
    tmp_globals_name_8 = (PyObject *)moduledict_OpenSSL$SSL;
    tmp_locals_name_8 = Py_None;
    tmp_fromlist_name_8 = const_tuple_d443d2554e6119150f8264e2746dcaf3_tuple;
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 9;
    tmp_assign_source_14 = IMPORT_MODULE4( tmp_name_name_8, tmp_globals_name_8, tmp_locals_name_8, tmp_fromlist_name_8 );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 9;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_3__module == NULL );
    tmp_import_from_3__module = tmp_assign_source_14;

    // Tried code:
    tmp_import_name_from_8 = tmp_import_from_3__module;

    CHECK_OBJECT( tmp_import_name_from_8 );
    tmp_assign_source_15 = IMPORT_NAME( tmp_import_name_from_8, const_str_plain_integer_types );
    if ( tmp_assign_source_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 9;

        goto try_except_handler_3;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types, tmp_assign_source_15 );
    tmp_import_name_from_9 = tmp_import_from_3__module;

    CHECK_OBJECT( tmp_import_name_from_9 );
    tmp_assign_source_16 = IMPORT_NAME( tmp_import_name_from_9, const_str_plain_int2byte );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 9;

        goto try_except_handler_3;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_int2byte, tmp_assign_source_16 );
    tmp_import_name_from_10 = tmp_import_from_3__module;

    CHECK_OBJECT( tmp_import_name_from_10 );
    tmp_assign_source_17 = IMPORT_NAME( tmp_import_name_from_10, const_str_plain_indexbytes );
    if ( tmp_assign_source_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 9;

        goto try_except_handler_3;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_indexbytes, tmp_assign_source_17 );
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    tmp_name_name_9 = const_str_digest_2c0accc407028fbaba46fefdee9c6c06;
    tmp_globals_name_9 = (PyObject *)moduledict_OpenSSL$SSL;
    tmp_locals_name_9 = Py_None;
    tmp_fromlist_name_9 = const_tuple_bf8c920f4f7b4caeaec53a43edb49d5c_tuple;
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 11;
    tmp_assign_source_18 = IMPORT_MODULE4( tmp_name_name_9, tmp_globals_name_9, tmp_locals_name_9, tmp_fromlist_name_9 );
    if ( tmp_assign_source_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_4__module == NULL );
    tmp_import_from_4__module = tmp_assign_source_18;

    // Tried code:
    tmp_import_name_from_11 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_11 );
    tmp_assign_source_19 = IMPORT_NAME( tmp_import_name_from_11, const_str_plain_UNSPECIFIED );
    if ( tmp_assign_source_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED, tmp_assign_source_19 );
    tmp_import_name_from_12 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_12 );
    tmp_assign_source_20 = IMPORT_NAME( tmp_import_name_from_12, const_str_plain_exception_from_error_queue );
    if ( tmp_assign_source_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue, tmp_assign_source_20 );
    tmp_import_name_from_13 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_13 );
    tmp_assign_source_21 = IMPORT_NAME( tmp_import_name_from_13, const_str_plain_ffi );
    if ( tmp_assign_source_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi, tmp_assign_source_21 );
    tmp_import_name_from_14 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_14 );
    tmp_assign_source_22 = IMPORT_NAME( tmp_import_name_from_14, const_str_plain_from_buffer );
    if ( tmp_assign_source_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__from_buffer, tmp_assign_source_22 );
    tmp_import_name_from_15 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_15 );
    tmp_assign_source_23 = IMPORT_NAME( tmp_import_name_from_15, const_str_plain_lib );
    if ( tmp_assign_source_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib, tmp_assign_source_23 );
    tmp_import_name_from_16 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_16 );
    tmp_assign_source_24 = IMPORT_NAME( tmp_import_name_from_16, const_str_plain_make_assert );
    if ( tmp_assign_source_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_assert, tmp_assign_source_24 );
    tmp_import_name_from_17 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_17 );
    tmp_assign_source_25 = IMPORT_NAME( tmp_import_name_from_17, const_str_plain_native );
    if ( tmp_assign_source_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__native, tmp_assign_source_25 );
    tmp_import_name_from_18 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_18 );
    tmp_assign_source_26 = IMPORT_NAME( tmp_import_name_from_18, const_str_plain_path_string );
    if ( tmp_assign_source_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string, tmp_assign_source_26 );
    tmp_import_name_from_19 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_19 );
    tmp_assign_source_27 = IMPORT_NAME( tmp_import_name_from_19, const_str_plain_text_to_bytes_and_warn );
    if ( tmp_assign_source_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn, tmp_assign_source_27 );
    tmp_import_name_from_20 = tmp_import_from_4__module;

    CHECK_OBJECT( tmp_import_name_from_20 );
    tmp_assign_source_28 = IMPORT_NAME( tmp_import_name_from_20, const_str_plain_no_zero_allocator );
    if ( tmp_assign_source_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto try_except_handler_4;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator, tmp_assign_source_28 );
    goto try_end_4;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_4__module );
    Py_DECREF( tmp_import_from_4__module );
    tmp_import_from_4__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_4__module );
    Py_DECREF( tmp_import_from_4__module );
    tmp_import_from_4__module = NULL;

    tmp_name_name_10 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
    tmp_globals_name_10 = (PyObject *)moduledict_OpenSSL$SSL;
    tmp_locals_name_10 = Py_None;
    tmp_fromlist_name_10 = const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple;
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 24;
    tmp_assign_source_29 = IMPORT_MODULE4( tmp_name_name_10, tmp_globals_name_10, tmp_locals_name_10, tmp_fromlist_name_10 );
    if ( tmp_assign_source_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 24;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_5__module == NULL );
    tmp_import_from_5__module = tmp_assign_source_29;

    // Tried code:
    tmp_import_name_from_21 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_21 );
    tmp_assign_source_30 = IMPORT_NAME( tmp_import_name_from_21, const_str_plain_FILETYPE_PEM );
    if ( tmp_assign_source_30 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 24;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM, tmp_assign_source_30 );
    tmp_import_name_from_22 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_22 );
    tmp_assign_source_31 = IMPORT_NAME( tmp_import_name_from_22, const_str_plain__PassphraseHelper );
    if ( tmp_assign_source_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 24;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__PassphraseHelper, tmp_assign_source_31 );
    tmp_import_name_from_23 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_23 );
    tmp_assign_source_32 = IMPORT_NAME( tmp_import_name_from_23, const_str_plain_PKey );
    if ( tmp_assign_source_32 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 24;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_PKey, tmp_assign_source_32 );
    tmp_import_name_from_24 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_24 );
    tmp_assign_source_33 = IMPORT_NAME( tmp_import_name_from_24, const_str_plain_X509Name );
    if ( tmp_assign_source_33 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 24;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Name, tmp_assign_source_33 );
    tmp_import_name_from_25 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_25 );
    tmp_assign_source_34 = IMPORT_NAME( tmp_import_name_from_25, const_str_plain_X509 );
    if ( tmp_assign_source_34 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 24;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509, tmp_assign_source_34 );
    tmp_import_name_from_26 = tmp_import_from_5__module;

    CHECK_OBJECT( tmp_import_name_from_26 );
    tmp_assign_source_35 = IMPORT_NAME( tmp_import_name_from_26, const_str_plain_X509Store );
    if ( tmp_assign_source_35 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 24;

        goto try_except_handler_5;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Store, tmp_assign_source_35 );
    goto try_end_5;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_5__module );
    Py_DECREF( tmp_import_from_5__module );
    tmp_import_from_5__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_5__module );
    Py_DECREF( tmp_import_from_5__module );
    tmp_import_from_5__module = NULL;

    tmp_assign_source_36 = LIST_COPY( const_list_394c4be2fcfa967175404c799b8030c7_list );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___all__, tmp_assign_source_36 );
    tmp_assign_source_37 = (PyObject *)&PyBuffer_Type;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__buffer, tmp_assign_source_37 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 127;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_38 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_OPENSSL_VERSION_NUMBER );
    if ( tmp_assign_source_38 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 127;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OPENSSL_VERSION_NUMBER, tmp_assign_source_38 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 128;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_39 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSLEAY_VERSION );
    if ( tmp_assign_source_39 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 128;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_VERSION, tmp_assign_source_39 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 129;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_40 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSLEAY_CFLAGS );
    if ( tmp_assign_source_40 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 129;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_CFLAGS, tmp_assign_source_40 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 130;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_41 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSLEAY_PLATFORM );
    if ( tmp_assign_source_41 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 130;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_PLATFORM, tmp_assign_source_41 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 131;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_42 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_SSLEAY_DIR );
    if ( tmp_assign_source_42 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 131;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_DIR, tmp_assign_source_42 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 132;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_43 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_SSLEAY_BUILT_ON );
    if ( tmp_assign_source_43 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 132;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_BUILT_ON, tmp_assign_source_43 );
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 134;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_44 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_SSL_SENT_SHUTDOWN );
    if ( tmp_assign_source_44 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 134;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SENT_SHUTDOWN, tmp_assign_source_44 );
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 135;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_45 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_SSL_RECEIVED_SHUTDOWN );
    if ( tmp_assign_source_45 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 135;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_RECEIVED_SHUTDOWN, tmp_assign_source_45 );
    tmp_assign_source_46 = const_int_pos_1;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv2_METHOD, tmp_assign_source_46 );
    tmp_assign_source_47 = const_int_pos_2;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv3_METHOD, tmp_assign_source_47 );
    tmp_assign_source_48 = const_int_pos_3;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv23_METHOD, tmp_assign_source_48 );
    tmp_assign_source_49 = const_int_pos_4;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_METHOD, tmp_assign_source_49 );
    tmp_assign_source_50 = const_int_pos_5;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_1_METHOD, tmp_assign_source_50 );
    tmp_assign_source_51 = const_int_pos_6;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_2_METHOD, tmp_assign_source_51 );
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 144;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_52 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_SSL_OP_NO_SSLv2 );
    if ( tmp_assign_source_52 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 144;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_SSLv2, tmp_assign_source_52 );
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 145;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_53 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_SSL_OP_NO_SSLv3 );
    if ( tmp_assign_source_53 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 145;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_SSLv3, tmp_assign_source_53 );
    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 146;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_54 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_SSL_OP_NO_TLSv1 );
    if ( tmp_assign_source_54 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 146;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_TLSv1, tmp_assign_source_54 );
    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 147;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_55 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_SSL_OP_NO_TLSv1_1 );
    if ( tmp_assign_source_55 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 147;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_TLSv1_1, tmp_assign_source_55 );
    tmp_source_name_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_13 == NULL ))
    {
        tmp_source_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_13 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 148;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_56 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_SSL_OP_NO_TLSv1_2 );
    if ( tmp_assign_source_56 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 148;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_TLSv1_2, tmp_assign_source_56 );
    // Tried code:
    tmp_source_name_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_14 == NULL ))
    {
        tmp_source_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 150;

        goto try_except_handler_6;
    }

    tmp_assign_source_57 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_SSL_OP_NO_TLSv1_3 );
    if ( tmp_assign_source_57 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 150;

        goto try_except_handler_6;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_TLSv1_3, tmp_assign_source_57 );
    goto try_end_6;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_88603af527c83dda944c7ddf4d45b354 );
    if ( exception_keeper_tb_6 == NULL )
    {
        exception_keeper_tb_6 = MAKE_TRACEBACK( frame_88603af527c83dda944c7ddf4d45b354, exception_keeper_lineno_6 );
    }
    else if ( exception_keeper_lineno_6 != 0 )
    {
        exception_keeper_tb_6 = ADD_TRACEBACK( exception_keeper_tb_6, frame_88603af527c83dda944c7ddf4d45b354, exception_keeper_lineno_6 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_6, &exception_keeper_value_6, &exception_keeper_tb_6 );
    PUBLISH_EXCEPTION( &exception_keeper_type_6, &exception_keeper_value_6, &exception_keeper_tb_6 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = PyExc_AttributeError;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 151;

        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 149;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_88603af527c83dda944c7ddf4d45b354->m_frame) frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = exception_tb->tb_lineno;

    goto frame_exception_exit_1;
    branch_no_1:;
    goto try_end_6;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // End of try:
    try_end_6:;
    tmp_source_name_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_15 == NULL ))
    {
        tmp_source_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 154;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_58 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_SSL_MODE_RELEASE_BUFFERS );
    if ( tmp_assign_source_58 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 154;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_MODE_RELEASE_BUFFERS, tmp_assign_source_58 );
    tmp_source_name_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_16 == NULL ))
    {
        tmp_source_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 156;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_59 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_SSL_OP_SINGLE_DH_USE );
    if ( tmp_assign_source_59 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 156;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_SINGLE_DH_USE, tmp_assign_source_59 );
    tmp_source_name_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_17 == NULL ))
    {
        tmp_source_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 157;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_60 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_SSL_OP_SINGLE_ECDH_USE );
    if ( tmp_assign_source_60 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 157;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_SINGLE_ECDH_USE, tmp_assign_source_60 );
    tmp_source_name_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_18 == NULL ))
    {
        tmp_source_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 158;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_61 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_SSL_OP_EPHEMERAL_RSA );
    if ( tmp_assign_source_61 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 158;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_EPHEMERAL_RSA, tmp_assign_source_61 );
    tmp_source_name_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_19 == NULL ))
    {
        tmp_source_name_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_19 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 159;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_62 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_SSL_OP_MICROSOFT_SESS_ID_BUG );
    if ( tmp_assign_source_62 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 159;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_MICROSOFT_SESS_ID_BUG, tmp_assign_source_62 );
    tmp_source_name_20 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_20 == NULL ))
    {
        tmp_source_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_20 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 160;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_63 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_SSL_OP_NETSCAPE_CHALLENGE_BUG );
    if ( tmp_assign_source_63 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 160;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NETSCAPE_CHALLENGE_BUG, tmp_assign_source_63 );
    tmp_source_name_21 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_21 == NULL ))
    {
        tmp_source_name_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_21 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 162;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_64 = LOOKUP_ATTRIBUTE( tmp_source_name_21, const_str_plain_SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG );
    if ( tmp_assign_source_64 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 162;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG, tmp_assign_source_64 );
    tmp_source_name_22 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_22 == NULL ))
    {
        tmp_source_name_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_22 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 164;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_65 = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain_SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG );
    if ( tmp_assign_source_65 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 164;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_SSLREF2_REUSE_CERT_TYPE_BUG, tmp_assign_source_65 );
    tmp_source_name_23 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_23 == NULL ))
    {
        tmp_source_name_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_23 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 165;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_66 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain_SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER );
    if ( tmp_assign_source_66 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 165;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_MICROSOFT_BIG_SSLV3_BUFFER, tmp_assign_source_66 );
    tmp_source_name_24 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_24 == NULL ))
    {
        tmp_source_name_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_24 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 166;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_67 = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain_SSL_OP_MSIE_SSLV2_RSA_PADDING );
    if ( tmp_assign_source_67 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 166;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_MSIE_SSLV2_RSA_PADDING, tmp_assign_source_67 );
    tmp_source_name_25 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_25 == NULL ))
    {
        tmp_source_name_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_25 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 167;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_68 = LOOKUP_ATTRIBUTE( tmp_source_name_25, const_str_plain_SSL_OP_SSLEAY_080_CLIENT_DH_BUG );
    if ( tmp_assign_source_68 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 167;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_SSLEAY_080_CLIENT_DH_BUG, tmp_assign_source_68 );
    tmp_source_name_26 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_26 == NULL ))
    {
        tmp_source_name_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_26 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 168;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_69 = LOOKUP_ATTRIBUTE( tmp_source_name_26, const_str_plain_SSL_OP_TLS_D5_BUG );
    if ( tmp_assign_source_69 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 168;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_TLS_D5_BUG, tmp_assign_source_69 );
    tmp_source_name_27 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_27 == NULL ))
    {
        tmp_source_name_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_27 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 169;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_70 = LOOKUP_ATTRIBUTE( tmp_source_name_27, const_str_plain_SSL_OP_TLS_BLOCK_PADDING_BUG );
    if ( tmp_assign_source_70 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 169;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_TLS_BLOCK_PADDING_BUG, tmp_assign_source_70 );
    tmp_source_name_28 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_28 == NULL ))
    {
        tmp_source_name_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_28 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 170;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_71 = LOOKUP_ATTRIBUTE( tmp_source_name_28, const_str_plain_SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS );
    if ( tmp_assign_source_71 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 170;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_DONT_INSERT_EMPTY_FRAGMENTS, tmp_assign_source_71 );
    tmp_source_name_29 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_29 == NULL ))
    {
        tmp_source_name_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_29 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 171;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_72 = LOOKUP_ATTRIBUTE( tmp_source_name_29, const_str_plain_SSL_OP_CIPHER_SERVER_PREFERENCE );
    if ( tmp_assign_source_72 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 171;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_CIPHER_SERVER_PREFERENCE, tmp_assign_source_72 );
    tmp_source_name_30 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_30 == NULL ))
    {
        tmp_source_name_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_30 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 172;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_73 = LOOKUP_ATTRIBUTE( tmp_source_name_30, const_str_plain_SSL_OP_TLS_ROLLBACK_BUG );
    if ( tmp_assign_source_73 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 172;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_TLS_ROLLBACK_BUG, tmp_assign_source_73 );
    tmp_source_name_31 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_31 == NULL ))
    {
        tmp_source_name_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_31 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 173;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_74 = LOOKUP_ATTRIBUTE( tmp_source_name_31, const_str_plain_SSL_OP_PKCS1_CHECK_1 );
    if ( tmp_assign_source_74 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 173;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_PKCS1_CHECK_1, tmp_assign_source_74 );
    tmp_source_name_32 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_32 == NULL ))
    {
        tmp_source_name_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_32 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 174;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_75 = LOOKUP_ATTRIBUTE( tmp_source_name_32, const_str_plain_SSL_OP_PKCS1_CHECK_2 );
    if ( tmp_assign_source_75 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 174;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_PKCS1_CHECK_2, tmp_assign_source_75 );
    tmp_source_name_33 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_33 == NULL ))
    {
        tmp_source_name_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_33 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 175;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_76 = LOOKUP_ATTRIBUTE( tmp_source_name_33, const_str_plain_SSL_OP_NETSCAPE_CA_DN_BUG );
    if ( tmp_assign_source_76 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 175;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NETSCAPE_CA_DN_BUG, tmp_assign_source_76 );
    tmp_source_name_34 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_34 == NULL ))
    {
        tmp_source_name_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_34 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 177;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_77 = LOOKUP_ATTRIBUTE( tmp_source_name_34, const_str_plain_SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG );
    if ( tmp_assign_source_77 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 177;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG, tmp_assign_source_77 );
    tmp_source_name_35 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_35 == NULL ))
    {
        tmp_source_name_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_35 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 179;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_78 = LOOKUP_ATTRIBUTE( tmp_source_name_35, const_str_plain_SSL_OP_NO_COMPRESSION );
    if ( tmp_assign_source_78 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 179;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_COMPRESSION, tmp_assign_source_78 );
    tmp_source_name_36 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_36 == NULL ))
    {
        tmp_source_name_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_36 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 181;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_79 = LOOKUP_ATTRIBUTE( tmp_source_name_36, const_str_plain_SSL_OP_NO_QUERY_MTU );
    if ( tmp_assign_source_79 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 181;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_QUERY_MTU, tmp_assign_source_79 );
    tmp_source_name_37 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_37 == NULL ))
    {
        tmp_source_name_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_37 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 182;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_80 = LOOKUP_ATTRIBUTE( tmp_source_name_37, const_str_plain_SSL_OP_COOKIE_EXCHANGE );
    if ( tmp_assign_source_80 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 182;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_COOKIE_EXCHANGE, tmp_assign_source_80 );
    tmp_source_name_38 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_38 == NULL ))
    {
        tmp_source_name_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_38 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 183;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_81 = LOOKUP_ATTRIBUTE( tmp_source_name_38, const_str_plain_SSL_OP_NO_TICKET );
    if ( tmp_assign_source_81 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 183;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_TICKET, tmp_assign_source_81 );
    tmp_source_name_39 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_39 == NULL ))
    {
        tmp_source_name_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_39 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 185;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_82 = LOOKUP_ATTRIBUTE( tmp_source_name_39, const_str_plain_SSL_OP_ALL );
    if ( tmp_assign_source_82 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 185;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_ALL, tmp_assign_source_82 );
    tmp_source_name_40 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_40 == NULL ))
    {
        tmp_source_name_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_40 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 187;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_83 = LOOKUP_ATTRIBUTE( tmp_source_name_40, const_str_plain_SSL_VERIFY_PEER );
    if ( tmp_assign_source_83 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 187;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_VERIFY_PEER, tmp_assign_source_83 );
    tmp_source_name_41 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_41 == NULL ))
    {
        tmp_source_name_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_41 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 188;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_84 = LOOKUP_ATTRIBUTE( tmp_source_name_41, const_str_plain_SSL_VERIFY_FAIL_IF_NO_PEER_CERT );
    if ( tmp_assign_source_84 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 188;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_VERIFY_FAIL_IF_NO_PEER_CERT, tmp_assign_source_84 );
    tmp_source_name_42 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_42 == NULL ))
    {
        tmp_source_name_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_42 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 189;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_85 = LOOKUP_ATTRIBUTE( tmp_source_name_42, const_str_plain_SSL_VERIFY_CLIENT_ONCE );
    if ( tmp_assign_source_85 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 189;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_VERIFY_CLIENT_ONCE, tmp_assign_source_85 );
    tmp_source_name_43 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_43 == NULL ))
    {
        tmp_source_name_43 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_43 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 190;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_86 = LOOKUP_ATTRIBUTE( tmp_source_name_43, const_str_plain_SSL_VERIFY_NONE );
    if ( tmp_assign_source_86 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 190;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_VERIFY_NONE, tmp_assign_source_86 );
    tmp_source_name_44 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_44 == NULL ))
    {
        tmp_source_name_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_44 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 192;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_87 = LOOKUP_ATTRIBUTE( tmp_source_name_44, const_str_plain_SSL_SESS_CACHE_OFF );
    if ( tmp_assign_source_87 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 192;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_OFF, tmp_assign_source_87 );
    tmp_source_name_45 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_45 == NULL ))
    {
        tmp_source_name_45 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_45 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 193;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_88 = LOOKUP_ATTRIBUTE( tmp_source_name_45, const_str_plain_SSL_SESS_CACHE_CLIENT );
    if ( tmp_assign_source_88 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 193;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_CLIENT, tmp_assign_source_88 );
    tmp_source_name_46 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_46 == NULL ))
    {
        tmp_source_name_46 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_46 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 194;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_89 = LOOKUP_ATTRIBUTE( tmp_source_name_46, const_str_plain_SSL_SESS_CACHE_SERVER );
    if ( tmp_assign_source_89 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 194;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_SERVER, tmp_assign_source_89 );
    tmp_source_name_47 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_47 == NULL ))
    {
        tmp_source_name_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_47 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 195;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_90 = LOOKUP_ATTRIBUTE( tmp_source_name_47, const_str_plain_SSL_SESS_CACHE_BOTH );
    if ( tmp_assign_source_90 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 195;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_BOTH, tmp_assign_source_90 );
    tmp_source_name_48 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_48 == NULL ))
    {
        tmp_source_name_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_48 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 196;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_91 = LOOKUP_ATTRIBUTE( tmp_source_name_48, const_str_plain_SSL_SESS_CACHE_NO_AUTO_CLEAR );
    if ( tmp_assign_source_91 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 196;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_NO_AUTO_CLEAR, tmp_assign_source_91 );
    tmp_source_name_49 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_49 == NULL ))
    {
        tmp_source_name_49 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_49 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 197;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_92 = LOOKUP_ATTRIBUTE( tmp_source_name_49, const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_LOOKUP );
    if ( tmp_assign_source_92 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 197;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_NO_INTERNAL_LOOKUP, tmp_assign_source_92 );
    tmp_source_name_50 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_50 == NULL ))
    {
        tmp_source_name_50 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_50 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 198;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_93 = LOOKUP_ATTRIBUTE( tmp_source_name_50, const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_STORE );
    if ( tmp_assign_source_93 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 198;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_NO_INTERNAL_STORE, tmp_assign_source_93 );
    tmp_source_name_51 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_51 == NULL ))
    {
        tmp_source_name_51 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_51 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 199;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_94 = LOOKUP_ATTRIBUTE( tmp_source_name_51, const_str_plain_SSL_SESS_CACHE_NO_INTERNAL );
    if ( tmp_assign_source_94 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 199;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_NO_INTERNAL, tmp_assign_source_94 );
    tmp_source_name_52 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_52 == NULL ))
    {
        tmp_source_name_52 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_52 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 201;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_95 = LOOKUP_ATTRIBUTE( tmp_source_name_52, const_str_plain_SSL_ST_CONNECT );
    if ( tmp_assign_source_95 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 201;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_CONNECT, tmp_assign_source_95 );
    tmp_source_name_53 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_53 == NULL ))
    {
        tmp_source_name_53 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_53 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 202;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_96 = LOOKUP_ATTRIBUTE( tmp_source_name_53, const_str_plain_SSL_ST_ACCEPT );
    if ( tmp_assign_source_96 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 202;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_ACCEPT, tmp_assign_source_96 );
    tmp_source_name_54 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_54 == NULL ))
    {
        tmp_source_name_54 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_54 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 203;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_97 = LOOKUP_ATTRIBUTE( tmp_source_name_54, const_str_plain_SSL_ST_MASK );
    if ( tmp_assign_source_97 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 203;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_MASK, tmp_assign_source_97 );
    tmp_source_name_55 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_55 == NULL ))
    {
        tmp_source_name_55 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_55 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 205;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_98 = LOOKUP_ATTRIBUTE( tmp_source_name_55, const_str_plain_SSL_CB_LOOP );
    if ( tmp_assign_source_98 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 205;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_LOOP, tmp_assign_source_98 );
    tmp_source_name_56 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_56 == NULL ))
    {
        tmp_source_name_56 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_56 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 206;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_99 = LOOKUP_ATTRIBUTE( tmp_source_name_56, const_str_plain_SSL_CB_EXIT );
    if ( tmp_assign_source_99 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 206;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_EXIT, tmp_assign_source_99 );
    tmp_source_name_57 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_57 == NULL ))
    {
        tmp_source_name_57 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_57 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 207;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_100 = LOOKUP_ATTRIBUTE( tmp_source_name_57, const_str_plain_SSL_CB_READ );
    if ( tmp_assign_source_100 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 207;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_READ, tmp_assign_source_100 );
    tmp_source_name_58 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_58 == NULL ))
    {
        tmp_source_name_58 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_58 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 208;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_101 = LOOKUP_ATTRIBUTE( tmp_source_name_58, const_str_plain_SSL_CB_WRITE );
    if ( tmp_assign_source_101 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 208;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_WRITE, tmp_assign_source_101 );
    tmp_source_name_59 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_59 == NULL ))
    {
        tmp_source_name_59 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_59 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 209;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_102 = LOOKUP_ATTRIBUTE( tmp_source_name_59, const_str_plain_SSL_CB_ALERT );
    if ( tmp_assign_source_102 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 209;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_ALERT, tmp_assign_source_102 );
    tmp_source_name_60 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_60 == NULL ))
    {
        tmp_source_name_60 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_60 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 210;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_103 = LOOKUP_ATTRIBUTE( tmp_source_name_60, const_str_plain_SSL_CB_READ_ALERT );
    if ( tmp_assign_source_103 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 210;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_READ_ALERT, tmp_assign_source_103 );
    tmp_source_name_61 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_61 == NULL ))
    {
        tmp_source_name_61 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_61 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 211;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_104 = LOOKUP_ATTRIBUTE( tmp_source_name_61, const_str_plain_SSL_CB_WRITE_ALERT );
    if ( tmp_assign_source_104 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 211;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_WRITE_ALERT, tmp_assign_source_104 );
    tmp_source_name_62 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_62 == NULL ))
    {
        tmp_source_name_62 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_62 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 212;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_105 = LOOKUP_ATTRIBUTE( tmp_source_name_62, const_str_plain_SSL_CB_ACCEPT_LOOP );
    if ( tmp_assign_source_105 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 212;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_ACCEPT_LOOP, tmp_assign_source_105 );
    tmp_source_name_63 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_63 == NULL ))
    {
        tmp_source_name_63 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_63 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 213;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_106 = LOOKUP_ATTRIBUTE( tmp_source_name_63, const_str_plain_SSL_CB_ACCEPT_EXIT );
    if ( tmp_assign_source_106 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 213;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_ACCEPT_EXIT, tmp_assign_source_106 );
    tmp_source_name_64 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_64 == NULL ))
    {
        tmp_source_name_64 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_64 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 214;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_107 = LOOKUP_ATTRIBUTE( tmp_source_name_64, const_str_plain_SSL_CB_CONNECT_LOOP );
    if ( tmp_assign_source_107 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 214;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_CONNECT_LOOP, tmp_assign_source_107 );
    tmp_source_name_65 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_65 == NULL ))
    {
        tmp_source_name_65 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_65 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 215;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_108 = LOOKUP_ATTRIBUTE( tmp_source_name_65, const_str_plain_SSL_CB_CONNECT_EXIT );
    if ( tmp_assign_source_108 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 215;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_CONNECT_EXIT, tmp_assign_source_108 );
    tmp_source_name_66 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_66 == NULL ))
    {
        tmp_source_name_66 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_66 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 216;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_109 = LOOKUP_ATTRIBUTE( tmp_source_name_66, const_str_plain_SSL_CB_HANDSHAKE_START );
    if ( tmp_assign_source_109 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 216;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_HANDSHAKE_START, tmp_assign_source_109 );
    tmp_source_name_67 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_67 == NULL ))
    {
        tmp_source_name_67 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_67 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 217;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_110 = LOOKUP_ATTRIBUTE( tmp_source_name_67, const_str_plain_SSL_CB_HANDSHAKE_DONE );
    if ( tmp_assign_source_110 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 217;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_HANDSHAKE_DONE, tmp_assign_source_110 );
    tmp_assign_source_111 = LIST_COPY( const_list_b44af29ad37821285e6b89a520342cf5_list );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_FILE_LOCATIONS, tmp_assign_source_111 );
    tmp_assign_source_112 = LIST_COPY( const_list_str_digest_746ae0014bb266cffee8b7b1473626af_list );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_PATH_LOCATIONS, tmp_assign_source_112 );
    tmp_assign_source_113 = const_str_digest_3b38b9684d0a691f727a5c25b49127cb;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR, tmp_assign_source_113 );
    tmp_assign_source_114 = const_str_digest_04211c3d50cdc4f69d9c36018d92c12f;
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE, tmp_assign_source_114 );
    tmp_assign_source_115 = PyTuple_New( 1 );
    tmp_tuple_element_1 = PyExc_Exception;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_assign_source_115, 0, tmp_tuple_element_1 );
    assert( tmp_class_creation_2__bases == NULL );
    tmp_class_creation_2__bases = tmp_assign_source_115;

    tmp_set_locals = PyDict_New();
    locals_Error_238 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals_Error_238, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_971aa32305ac0845a4048d72c4cd63c5;
    tmp_res = PyDict_SetItem( locals_Error_238, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_1 = locals_Error_238;
    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_7;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_7:;
    Py_DECREF( locals_Error_238 );
    locals_Error_238 = NULL;
    goto outline_result_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_1:;
    tmp_assign_source_116 = tmp_outline_return_value_1;
    assert( tmp_class_creation_2__class_dict == NULL );
    tmp_class_creation_2__class_dict = tmp_assign_source_116;

    // Tried code:
    tmp_compare_left_2 = const_str_plain___metaclass__;
    tmp_compare_right_2 = tmp_class_creation_2__class_dict;

    CHECK_OBJECT( tmp_compare_right_2 );
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_2, tmp_compare_left_2 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_dict_name_1 = tmp_class_creation_2__class_dict;

    CHECK_OBJECT( tmp_dict_name_1 );
    tmp_key_name_1 = const_str_plain___metaclass__;
    tmp_assign_source_117 = DICT_GET_ITEM( tmp_dict_name_1, tmp_key_name_1 );
    if ( tmp_assign_source_117 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 238;

        goto try_except_handler_8;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_subscribed_name_1 = tmp_class_creation_2__bases;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_assign_source_118 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_assign_source_118 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 238;

        goto try_except_handler_8;
    }
    assert( tmp_select_metaclass_2__base == NULL );
    tmp_select_metaclass_2__base = tmp_assign_source_118;

    // Tried code:
    // Tried code:
    tmp_source_name_68 = tmp_select_metaclass_2__base;

    CHECK_OBJECT( tmp_source_name_68 );
    tmp_outline_return_value_2 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_68 );
    if ( tmp_outline_return_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 238;

        goto try_except_handler_10;
    }
    goto try_return_handler_9;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_10:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_7 );
    Py_XDECREF( exception_keeper_value_7 );
    Py_XDECREF( exception_keeper_tb_7 );
    tmp_type_arg_1 = tmp_select_metaclass_2__base;

    CHECK_OBJECT( tmp_type_arg_1 );
    tmp_outline_return_value_2 = BUILTIN_TYPE1( tmp_type_arg_1 );
    assert( tmp_outline_return_value_2 != NULL );
    goto try_return_handler_9;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_9:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_2__base );
    Py_DECREF( tmp_select_metaclass_2__base );
    tmp_select_metaclass_2__base = NULL;

    goto outline_result_2;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_2__base );
    Py_DECREF( tmp_select_metaclass_2__base );
    tmp_select_metaclass_2__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_2:;
    tmp_assign_source_117 = tmp_outline_return_value_2;
    condexpr_end_1:;
    assert( tmp_class_creation_2__metaclass == NULL );
    tmp_class_creation_2__metaclass = tmp_assign_source_117;

    tmp_called_name_1 = tmp_class_creation_2__metaclass;

    CHECK_OBJECT( tmp_called_name_1 );
    tmp_args_element_name_1 = const_str_plain_Error;
    tmp_args_element_name_2 = tmp_class_creation_2__bases;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = tmp_class_creation_2__class_dict;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 238;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_119 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_119 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 238;

        goto try_except_handler_8;
    }
    assert( tmp_class_creation_2__class == NULL );
    tmp_class_creation_2__class = tmp_assign_source_119;

    goto try_end_7;
    // Exception handler code:
    try_except_handler_8:;
    exception_keeper_type_8 = exception_type;
    exception_keeper_value_8 = exception_value;
    exception_keeper_tb_8 = exception_tb;
    exception_keeper_lineno_8 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__bases );
    Py_DECREF( tmp_class_creation_2__bases );
    tmp_class_creation_2__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_8;
    exception_value = exception_keeper_value_8;
    exception_tb = exception_keeper_tb_8;
    exception_lineno = exception_keeper_lineno_8;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    tmp_assign_source_120 = tmp_class_creation_2__class;

    CHECK_OBJECT( tmp_assign_source_120 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error, tmp_assign_source_120 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class );
    Py_DECREF( tmp_class_creation_2__class );
    tmp_class_creation_2__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__bases );
    Py_DECREF( tmp_class_creation_2__bases );
    tmp_class_creation_2__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__metaclass );
    Py_DECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_partial );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_partial );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "partial" );
        exception_tb = NULL;

        exception_lineno = 244;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue );

    if (unlikely( tmp_args_element_name_4 == NULL ))
    {
        tmp_args_element_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue );
    }

    if ( tmp_args_element_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_exception_from_error_queue" );
        exception_tb = NULL;

        exception_lineno = 244;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_args_element_name_5 == NULL ))
    {
        tmp_args_element_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_args_element_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 244;

        goto frame_exception_exit_1;
    }

    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 244;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_121 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_121 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 244;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error, tmp_assign_source_121 );
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_assert );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_assert );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_assert" );
        exception_tb = NULL;

        exception_lineno = 245;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_args_element_name_6 == NULL ))
    {
        tmp_args_element_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_args_element_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 245;

        goto frame_exception_exit_1;
    }

    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 245;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_assign_source_122 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    if ( tmp_assign_source_122 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 245;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert, tmp_assign_source_122 );
    // Tried code:
    tmp_assign_source_123 = PyTuple_New( 1 );
    tmp_tuple_element_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_tuple_element_2 == NULL ))
    {
        tmp_tuple_element_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_tuple_element_2 == NULL )
    {
        Py_DECREF( tmp_assign_source_123 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 248;

        goto try_except_handler_11;
    }

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_assign_source_123, 0, tmp_tuple_element_2 );
    assert( tmp_class_creation_3__bases == NULL );
    tmp_class_creation_3__bases = tmp_assign_source_123;

    tmp_set_locals = PyDict_New();
    locals_WantReadError_248 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals_WantReadError_248, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_3 = locals_WantReadError_248;
    Py_INCREF( tmp_outline_return_value_3 );
    goto try_return_handler_12;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_12:;
    Py_DECREF( locals_WantReadError_248 );
    locals_WantReadError_248 = NULL;
    goto outline_result_3;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_3:;
    tmp_assign_source_124 = tmp_outline_return_value_3;
    assert( tmp_class_creation_3__class_dict == NULL );
    tmp_class_creation_3__class_dict = tmp_assign_source_124;

    tmp_compare_left_3 = const_str_plain___metaclass__;
    tmp_compare_right_3 = tmp_class_creation_3__class_dict;

    CHECK_OBJECT( tmp_compare_right_3 );
    tmp_cmp_In_2 = PySequence_Contains( tmp_compare_right_3, tmp_compare_left_3 );
    assert( !(tmp_cmp_In_2 == -1) );
    if ( tmp_cmp_In_2 == 1 )
    {
        goto condexpr_true_2;
    }
    else
    {
        goto condexpr_false_2;
    }
    condexpr_true_2:;
    tmp_dict_name_2 = tmp_class_creation_3__class_dict;

    CHECK_OBJECT( tmp_dict_name_2 );
    tmp_key_name_2 = const_str_plain___metaclass__;
    tmp_assign_source_125 = DICT_GET_ITEM( tmp_dict_name_2, tmp_key_name_2 );
    if ( tmp_assign_source_125 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 248;

        goto try_except_handler_11;
    }
    goto condexpr_end_2;
    condexpr_false_2:;
    tmp_subscribed_name_2 = tmp_class_creation_3__bases;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_0;
    tmp_assign_source_126 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_assign_source_126 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 248;

        goto try_except_handler_11;
    }
    assert( tmp_select_metaclass_3__base == NULL );
    tmp_select_metaclass_3__base = tmp_assign_source_126;

    // Tried code:
    // Tried code:
    tmp_source_name_69 = tmp_select_metaclass_3__base;

    CHECK_OBJECT( tmp_source_name_69 );
    tmp_outline_return_value_4 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_69 );
    if ( tmp_outline_return_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 248;

        goto try_except_handler_14;
    }
    goto try_return_handler_13;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_14:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_9 );
    Py_XDECREF( exception_keeper_value_9 );
    Py_XDECREF( exception_keeper_tb_9 );
    tmp_type_arg_2 = tmp_select_metaclass_3__base;

    CHECK_OBJECT( tmp_type_arg_2 );
    tmp_outline_return_value_4 = BUILTIN_TYPE1( tmp_type_arg_2 );
    assert( tmp_outline_return_value_4 != NULL );
    goto try_return_handler_13;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_13:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_3__base );
    Py_DECREF( tmp_select_metaclass_3__base );
    tmp_select_metaclass_3__base = NULL;

    goto outline_result_4;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_3__base );
    Py_DECREF( tmp_select_metaclass_3__base );
    tmp_select_metaclass_3__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_4:;
    tmp_assign_source_125 = tmp_outline_return_value_4;
    condexpr_end_2:;
    assert( tmp_class_creation_3__metaclass == NULL );
    tmp_class_creation_3__metaclass = tmp_assign_source_125;

    tmp_called_name_4 = tmp_class_creation_3__metaclass;

    CHECK_OBJECT( tmp_called_name_4 );
    tmp_args_element_name_7 = const_str_plain_WantReadError;
    tmp_args_element_name_8 = tmp_class_creation_3__bases;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_args_element_name_9 = tmp_class_creation_3__class_dict;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 248;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_assign_source_127 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    if ( tmp_assign_source_127 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 248;

        goto try_except_handler_11;
    }
    assert( tmp_class_creation_3__class == NULL );
    tmp_class_creation_3__class = tmp_assign_source_127;

    goto try_end_8;
    // Exception handler code:
    try_except_handler_11:;
    exception_keeper_type_10 = exception_type;
    exception_keeper_value_10 = exception_value;
    exception_keeper_tb_10 = exception_tb;
    exception_keeper_lineno_10 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_3__bases );
    tmp_class_creation_3__bases = NULL;

    Py_XDECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_10;
    exception_value = exception_keeper_value_10;
    exception_tb = exception_keeper_tb_10;
    exception_lineno = exception_keeper_lineno_10;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    tmp_assign_source_128 = tmp_class_creation_3__class;

    CHECK_OBJECT( tmp_assign_source_128 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantReadError, tmp_assign_source_128 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class );
    Py_DECREF( tmp_class_creation_3__class );
    tmp_class_creation_3__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__bases );
    Py_DECREF( tmp_class_creation_3__bases );
    tmp_class_creation_3__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_dict );
    Py_DECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__metaclass );
    Py_DECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    // Tried code:
    tmp_assign_source_129 = PyTuple_New( 1 );
    tmp_tuple_element_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_tuple_element_3 == NULL ))
    {
        tmp_tuple_element_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_tuple_element_3 == NULL )
    {
        Py_DECREF( tmp_assign_source_129 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 252;

        goto try_except_handler_15;
    }

    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_assign_source_129, 0, tmp_tuple_element_3 );
    assert( tmp_class_creation_4__bases == NULL );
    tmp_class_creation_4__bases = tmp_assign_source_129;

    tmp_set_locals = PyDict_New();
    locals_WantWriteError_252 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals_WantWriteError_252, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_5 = locals_WantWriteError_252;
    Py_INCREF( tmp_outline_return_value_5 );
    goto try_return_handler_16;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_16:;
    Py_DECREF( locals_WantWriteError_252 );
    locals_WantWriteError_252 = NULL;
    goto outline_result_5;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_5:;
    tmp_assign_source_130 = tmp_outline_return_value_5;
    assert( tmp_class_creation_4__class_dict == NULL );
    tmp_class_creation_4__class_dict = tmp_assign_source_130;

    tmp_compare_left_4 = const_str_plain___metaclass__;
    tmp_compare_right_4 = tmp_class_creation_4__class_dict;

    CHECK_OBJECT( tmp_compare_right_4 );
    tmp_cmp_In_3 = PySequence_Contains( tmp_compare_right_4, tmp_compare_left_4 );
    assert( !(tmp_cmp_In_3 == -1) );
    if ( tmp_cmp_In_3 == 1 )
    {
        goto condexpr_true_3;
    }
    else
    {
        goto condexpr_false_3;
    }
    condexpr_true_3:;
    tmp_dict_name_3 = tmp_class_creation_4__class_dict;

    CHECK_OBJECT( tmp_dict_name_3 );
    tmp_key_name_3 = const_str_plain___metaclass__;
    tmp_assign_source_131 = DICT_GET_ITEM( tmp_dict_name_3, tmp_key_name_3 );
    if ( tmp_assign_source_131 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 252;

        goto try_except_handler_15;
    }
    goto condexpr_end_3;
    condexpr_false_3:;
    tmp_subscribed_name_3 = tmp_class_creation_4__bases;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_0;
    tmp_assign_source_132 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_assign_source_132 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 252;

        goto try_except_handler_15;
    }
    assert( tmp_select_metaclass_4__base == NULL );
    tmp_select_metaclass_4__base = tmp_assign_source_132;

    // Tried code:
    // Tried code:
    tmp_source_name_70 = tmp_select_metaclass_4__base;

    CHECK_OBJECT( tmp_source_name_70 );
    tmp_outline_return_value_6 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_70 );
    if ( tmp_outline_return_value_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 252;

        goto try_except_handler_18;
    }
    goto try_return_handler_17;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_18:;
    exception_keeper_type_11 = exception_type;
    exception_keeper_value_11 = exception_value;
    exception_keeper_tb_11 = exception_tb;
    exception_keeper_lineno_11 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_11 );
    Py_XDECREF( exception_keeper_value_11 );
    Py_XDECREF( exception_keeper_tb_11 );
    tmp_type_arg_3 = tmp_select_metaclass_4__base;

    CHECK_OBJECT( tmp_type_arg_3 );
    tmp_outline_return_value_6 = BUILTIN_TYPE1( tmp_type_arg_3 );
    assert( tmp_outline_return_value_6 != NULL );
    goto try_return_handler_17;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_17:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_4__base );
    Py_DECREF( tmp_select_metaclass_4__base );
    tmp_select_metaclass_4__base = NULL;

    goto outline_result_6;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_4__base );
    Py_DECREF( tmp_select_metaclass_4__base );
    tmp_select_metaclass_4__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_6:;
    tmp_assign_source_131 = tmp_outline_return_value_6;
    condexpr_end_3:;
    assert( tmp_class_creation_4__metaclass == NULL );
    tmp_class_creation_4__metaclass = tmp_assign_source_131;

    tmp_called_name_5 = tmp_class_creation_4__metaclass;

    CHECK_OBJECT( tmp_called_name_5 );
    tmp_args_element_name_10 = const_str_plain_WantWriteError;
    tmp_args_element_name_11 = tmp_class_creation_4__bases;

    CHECK_OBJECT( tmp_args_element_name_11 );
    tmp_args_element_name_12 = tmp_class_creation_4__class_dict;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 252;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_assign_source_133 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
    }

    if ( tmp_assign_source_133 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 252;

        goto try_except_handler_15;
    }
    assert( tmp_class_creation_4__class == NULL );
    tmp_class_creation_4__class = tmp_assign_source_133;

    goto try_end_9;
    // Exception handler code:
    try_except_handler_15:;
    exception_keeper_type_12 = exception_type;
    exception_keeper_value_12 = exception_value;
    exception_keeper_tb_12 = exception_tb;
    exception_keeper_lineno_12 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    Py_XDECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_12;
    exception_value = exception_keeper_value_12;
    exception_tb = exception_keeper_tb_12;
    exception_lineno = exception_keeper_lineno_12;

    goto frame_exception_exit_1;
    // End of try:
    try_end_9:;
    tmp_assign_source_134 = tmp_class_creation_4__class;

    CHECK_OBJECT( tmp_assign_source_134 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantWriteError, tmp_assign_source_134 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class );
    Py_DECREF( tmp_class_creation_4__class );
    tmp_class_creation_4__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__bases );
    Py_DECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class_dict );
    Py_DECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__metaclass );
    Py_DECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    // Tried code:
    tmp_assign_source_135 = PyTuple_New( 1 );
    tmp_tuple_element_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_tuple_element_4 == NULL ))
    {
        tmp_tuple_element_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_tuple_element_4 == NULL )
    {
        Py_DECREF( tmp_assign_source_135 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 256;

        goto try_except_handler_19;
    }

    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_assign_source_135, 0, tmp_tuple_element_4 );
    assert( tmp_class_creation_5__bases == NULL );
    tmp_class_creation_5__bases = tmp_assign_source_135;

    tmp_set_locals = PyDict_New();
    locals_WantX509LookupError_256 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals_WantX509LookupError_256, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_7 = locals_WantX509LookupError_256;
    Py_INCREF( tmp_outline_return_value_7 );
    goto try_return_handler_20;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_20:;
    Py_DECREF( locals_WantX509LookupError_256 );
    locals_WantX509LookupError_256 = NULL;
    goto outline_result_7;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_7:;
    tmp_assign_source_136 = tmp_outline_return_value_7;
    assert( tmp_class_creation_5__class_dict == NULL );
    tmp_class_creation_5__class_dict = tmp_assign_source_136;

    tmp_compare_left_5 = const_str_plain___metaclass__;
    tmp_compare_right_5 = tmp_class_creation_5__class_dict;

    CHECK_OBJECT( tmp_compare_right_5 );
    tmp_cmp_In_4 = PySequence_Contains( tmp_compare_right_5, tmp_compare_left_5 );
    assert( !(tmp_cmp_In_4 == -1) );
    if ( tmp_cmp_In_4 == 1 )
    {
        goto condexpr_true_4;
    }
    else
    {
        goto condexpr_false_4;
    }
    condexpr_true_4:;
    tmp_dict_name_4 = tmp_class_creation_5__class_dict;

    CHECK_OBJECT( tmp_dict_name_4 );
    tmp_key_name_4 = const_str_plain___metaclass__;
    tmp_assign_source_137 = DICT_GET_ITEM( tmp_dict_name_4, tmp_key_name_4 );
    if ( tmp_assign_source_137 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 256;

        goto try_except_handler_19;
    }
    goto condexpr_end_4;
    condexpr_false_4:;
    tmp_subscribed_name_4 = tmp_class_creation_5__bases;

    CHECK_OBJECT( tmp_subscribed_name_4 );
    tmp_subscript_name_4 = const_int_0;
    tmp_assign_source_138 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_assign_source_138 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 256;

        goto try_except_handler_19;
    }
    assert( tmp_select_metaclass_5__base == NULL );
    tmp_select_metaclass_5__base = tmp_assign_source_138;

    // Tried code:
    // Tried code:
    tmp_source_name_71 = tmp_select_metaclass_5__base;

    CHECK_OBJECT( tmp_source_name_71 );
    tmp_outline_return_value_8 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_71 );
    if ( tmp_outline_return_value_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 256;

        goto try_except_handler_22;
    }
    goto try_return_handler_21;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_22:;
    exception_keeper_type_13 = exception_type;
    exception_keeper_value_13 = exception_value;
    exception_keeper_tb_13 = exception_tb;
    exception_keeper_lineno_13 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_13 );
    Py_XDECREF( exception_keeper_value_13 );
    Py_XDECREF( exception_keeper_tb_13 );
    tmp_type_arg_4 = tmp_select_metaclass_5__base;

    CHECK_OBJECT( tmp_type_arg_4 );
    tmp_outline_return_value_8 = BUILTIN_TYPE1( tmp_type_arg_4 );
    assert( tmp_outline_return_value_8 != NULL );
    goto try_return_handler_21;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_21:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_5__base );
    Py_DECREF( tmp_select_metaclass_5__base );
    tmp_select_metaclass_5__base = NULL;

    goto outline_result_8;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_5__base );
    Py_DECREF( tmp_select_metaclass_5__base );
    tmp_select_metaclass_5__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_8:;
    tmp_assign_source_137 = tmp_outline_return_value_8;
    condexpr_end_4:;
    assert( tmp_class_creation_5__metaclass == NULL );
    tmp_class_creation_5__metaclass = tmp_assign_source_137;

    tmp_called_name_6 = tmp_class_creation_5__metaclass;

    CHECK_OBJECT( tmp_called_name_6 );
    tmp_args_element_name_13 = const_str_plain_WantX509LookupError;
    tmp_args_element_name_14 = tmp_class_creation_5__bases;

    CHECK_OBJECT( tmp_args_element_name_14 );
    tmp_args_element_name_15 = tmp_class_creation_5__class_dict;

    CHECK_OBJECT( tmp_args_element_name_15 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 256;
    {
        PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15 };
        tmp_assign_source_139 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, call_args );
    }

    if ( tmp_assign_source_139 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 256;

        goto try_except_handler_19;
    }
    assert( tmp_class_creation_5__class == NULL );
    tmp_class_creation_5__class = tmp_assign_source_139;

    goto try_end_10;
    // Exception handler code:
    try_except_handler_19:;
    exception_keeper_type_14 = exception_type;
    exception_keeper_value_14 = exception_value;
    exception_keeper_tb_14 = exception_tb;
    exception_keeper_lineno_14 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_5__bases );
    tmp_class_creation_5__bases = NULL;

    Py_XDECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_14;
    exception_value = exception_keeper_value_14;
    exception_tb = exception_keeper_tb_14;
    exception_lineno = exception_keeper_lineno_14;

    goto frame_exception_exit_1;
    // End of try:
    try_end_10:;
    tmp_assign_source_140 = tmp_class_creation_5__class;

    CHECK_OBJECT( tmp_assign_source_140 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantX509LookupError, tmp_assign_source_140 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class );
    Py_DECREF( tmp_class_creation_5__class );
    tmp_class_creation_5__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__bases );
    Py_DECREF( tmp_class_creation_5__bases );
    tmp_class_creation_5__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class_dict );
    Py_DECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__metaclass );
    Py_DECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    // Tried code:
    tmp_assign_source_141 = PyTuple_New( 1 );
    tmp_tuple_element_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_tuple_element_5 == NULL ))
    {
        tmp_tuple_element_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_tuple_element_5 == NULL )
    {
        Py_DECREF( tmp_assign_source_141 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 260;

        goto try_except_handler_23;
    }

    Py_INCREF( tmp_tuple_element_5 );
    PyTuple_SET_ITEM( tmp_assign_source_141, 0, tmp_tuple_element_5 );
    assert( tmp_class_creation_6__bases == NULL );
    tmp_class_creation_6__bases = tmp_assign_source_141;

    tmp_set_locals = PyDict_New();
    locals_ZeroReturnError_260 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals_ZeroReturnError_260, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_9 = locals_ZeroReturnError_260;
    Py_INCREF( tmp_outline_return_value_9 );
    goto try_return_handler_24;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_24:;
    Py_DECREF( locals_ZeroReturnError_260 );
    locals_ZeroReturnError_260 = NULL;
    goto outline_result_9;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_9:;
    tmp_assign_source_142 = tmp_outline_return_value_9;
    assert( tmp_class_creation_6__class_dict == NULL );
    tmp_class_creation_6__class_dict = tmp_assign_source_142;

    tmp_compare_left_6 = const_str_plain___metaclass__;
    tmp_compare_right_6 = tmp_class_creation_6__class_dict;

    CHECK_OBJECT( tmp_compare_right_6 );
    tmp_cmp_In_5 = PySequence_Contains( tmp_compare_right_6, tmp_compare_left_6 );
    assert( !(tmp_cmp_In_5 == -1) );
    if ( tmp_cmp_In_5 == 1 )
    {
        goto condexpr_true_5;
    }
    else
    {
        goto condexpr_false_5;
    }
    condexpr_true_5:;
    tmp_dict_name_5 = tmp_class_creation_6__class_dict;

    CHECK_OBJECT( tmp_dict_name_5 );
    tmp_key_name_5 = const_str_plain___metaclass__;
    tmp_assign_source_143 = DICT_GET_ITEM( tmp_dict_name_5, tmp_key_name_5 );
    if ( tmp_assign_source_143 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 260;

        goto try_except_handler_23;
    }
    goto condexpr_end_5;
    condexpr_false_5:;
    tmp_subscribed_name_5 = tmp_class_creation_6__bases;

    CHECK_OBJECT( tmp_subscribed_name_5 );
    tmp_subscript_name_5 = const_int_0;
    tmp_assign_source_144 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_assign_source_144 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 260;

        goto try_except_handler_23;
    }
    assert( tmp_select_metaclass_6__base == NULL );
    tmp_select_metaclass_6__base = tmp_assign_source_144;

    // Tried code:
    // Tried code:
    tmp_source_name_72 = tmp_select_metaclass_6__base;

    CHECK_OBJECT( tmp_source_name_72 );
    tmp_outline_return_value_10 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_72 );
    if ( tmp_outline_return_value_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 260;

        goto try_except_handler_26;
    }
    goto try_return_handler_25;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_26:;
    exception_keeper_type_15 = exception_type;
    exception_keeper_value_15 = exception_value;
    exception_keeper_tb_15 = exception_tb;
    exception_keeper_lineno_15 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_15 );
    Py_XDECREF( exception_keeper_value_15 );
    Py_XDECREF( exception_keeper_tb_15 );
    tmp_type_arg_5 = tmp_select_metaclass_6__base;

    CHECK_OBJECT( tmp_type_arg_5 );
    tmp_outline_return_value_10 = BUILTIN_TYPE1( tmp_type_arg_5 );
    assert( tmp_outline_return_value_10 != NULL );
    goto try_return_handler_25;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_25:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_6__base );
    Py_DECREF( tmp_select_metaclass_6__base );
    tmp_select_metaclass_6__base = NULL;

    goto outline_result_10;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_6__base );
    Py_DECREF( tmp_select_metaclass_6__base );
    tmp_select_metaclass_6__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_10:;
    tmp_assign_source_143 = tmp_outline_return_value_10;
    condexpr_end_5:;
    assert( tmp_class_creation_6__metaclass == NULL );
    tmp_class_creation_6__metaclass = tmp_assign_source_143;

    tmp_called_name_7 = tmp_class_creation_6__metaclass;

    CHECK_OBJECT( tmp_called_name_7 );
    tmp_args_element_name_16 = const_str_plain_ZeroReturnError;
    tmp_args_element_name_17 = tmp_class_creation_6__bases;

    CHECK_OBJECT( tmp_args_element_name_17 );
    tmp_args_element_name_18 = tmp_class_creation_6__class_dict;

    CHECK_OBJECT( tmp_args_element_name_18 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 260;
    {
        PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18 };
        tmp_assign_source_145 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_7, call_args );
    }

    if ( tmp_assign_source_145 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 260;

        goto try_except_handler_23;
    }
    assert( tmp_class_creation_6__class == NULL );
    tmp_class_creation_6__class = tmp_assign_source_145;

    goto try_end_11;
    // Exception handler code:
    try_except_handler_23:;
    exception_keeper_type_16 = exception_type;
    exception_keeper_value_16 = exception_value;
    exception_keeper_tb_16 = exception_tb;
    exception_keeper_lineno_16 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_6__bases );
    tmp_class_creation_6__bases = NULL;

    Py_XDECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_16;
    exception_value = exception_keeper_value_16;
    exception_tb = exception_keeper_tb_16;
    exception_lineno = exception_keeper_lineno_16;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    tmp_assign_source_146 = tmp_class_creation_6__class;

    CHECK_OBJECT( tmp_assign_source_146 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_ZeroReturnError, tmp_assign_source_146 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class );
    Py_DECREF( tmp_class_creation_6__class );
    tmp_class_creation_6__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__bases );
    Py_DECREF( tmp_class_creation_6__bases );
    tmp_class_creation_6__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class_dict );
    Py_DECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__metaclass );
    Py_DECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    // Tried code:
    tmp_assign_source_147 = PyTuple_New( 1 );
    tmp_tuple_element_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

    if (unlikely( tmp_tuple_element_6 == NULL ))
    {
        tmp_tuple_element_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
    }

    if ( tmp_tuple_element_6 == NULL )
    {
        Py_DECREF( tmp_assign_source_147 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
        exception_tb = NULL;

        exception_lineno = 264;

        goto try_except_handler_27;
    }

    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_assign_source_147, 0, tmp_tuple_element_6 );
    assert( tmp_class_creation_7__bases == NULL );
    tmp_class_creation_7__bases = tmp_assign_source_147;

    tmp_set_locals = PyDict_New();
    locals_SysCallError_264 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals_SysCallError_264, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_11 = locals_SysCallError_264;
    Py_INCREF( tmp_outline_return_value_11 );
    goto try_return_handler_28;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_28:;
    Py_DECREF( locals_SysCallError_264 );
    locals_SysCallError_264 = NULL;
    goto outline_result_11;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_11:;
    tmp_assign_source_148 = tmp_outline_return_value_11;
    assert( tmp_class_creation_7__class_dict == NULL );
    tmp_class_creation_7__class_dict = tmp_assign_source_148;

    tmp_compare_left_7 = const_str_plain___metaclass__;
    tmp_compare_right_7 = tmp_class_creation_7__class_dict;

    CHECK_OBJECT( tmp_compare_right_7 );
    tmp_cmp_In_6 = PySequence_Contains( tmp_compare_right_7, tmp_compare_left_7 );
    assert( !(tmp_cmp_In_6 == -1) );
    if ( tmp_cmp_In_6 == 1 )
    {
        goto condexpr_true_6;
    }
    else
    {
        goto condexpr_false_6;
    }
    condexpr_true_6:;
    tmp_dict_name_6 = tmp_class_creation_7__class_dict;

    CHECK_OBJECT( tmp_dict_name_6 );
    tmp_key_name_6 = const_str_plain___metaclass__;
    tmp_assign_source_149 = DICT_GET_ITEM( tmp_dict_name_6, tmp_key_name_6 );
    if ( tmp_assign_source_149 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 264;

        goto try_except_handler_27;
    }
    goto condexpr_end_6;
    condexpr_false_6:;
    tmp_subscribed_name_6 = tmp_class_creation_7__bases;

    CHECK_OBJECT( tmp_subscribed_name_6 );
    tmp_subscript_name_6 = const_int_0;
    tmp_assign_source_150 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_assign_source_150 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 264;

        goto try_except_handler_27;
    }
    assert( tmp_select_metaclass_7__base == NULL );
    tmp_select_metaclass_7__base = tmp_assign_source_150;

    // Tried code:
    // Tried code:
    tmp_source_name_73 = tmp_select_metaclass_7__base;

    CHECK_OBJECT( tmp_source_name_73 );
    tmp_outline_return_value_12 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_73 );
    if ( tmp_outline_return_value_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 264;

        goto try_except_handler_30;
    }
    goto try_return_handler_29;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_30:;
    exception_keeper_type_17 = exception_type;
    exception_keeper_value_17 = exception_value;
    exception_keeper_tb_17 = exception_tb;
    exception_keeper_lineno_17 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_17 );
    Py_XDECREF( exception_keeper_value_17 );
    Py_XDECREF( exception_keeper_tb_17 );
    tmp_type_arg_6 = tmp_select_metaclass_7__base;

    CHECK_OBJECT( tmp_type_arg_6 );
    tmp_outline_return_value_12 = BUILTIN_TYPE1( tmp_type_arg_6 );
    assert( tmp_outline_return_value_12 != NULL );
    goto try_return_handler_29;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_29:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_7__base );
    Py_DECREF( tmp_select_metaclass_7__base );
    tmp_select_metaclass_7__base = NULL;

    goto outline_result_12;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_7__base );
    Py_DECREF( tmp_select_metaclass_7__base );
    tmp_select_metaclass_7__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_12:;
    tmp_assign_source_149 = tmp_outline_return_value_12;
    condexpr_end_6:;
    assert( tmp_class_creation_7__metaclass == NULL );
    tmp_class_creation_7__metaclass = tmp_assign_source_149;

    tmp_called_name_8 = tmp_class_creation_7__metaclass;

    CHECK_OBJECT( tmp_called_name_8 );
    tmp_args_element_name_19 = const_str_plain_SysCallError;
    tmp_args_element_name_20 = tmp_class_creation_7__bases;

    CHECK_OBJECT( tmp_args_element_name_20 );
    tmp_args_element_name_21 = tmp_class_creation_7__class_dict;

    CHECK_OBJECT( tmp_args_element_name_21 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 264;
    {
        PyObject *call_args[] = { tmp_args_element_name_19, tmp_args_element_name_20, tmp_args_element_name_21 };
        tmp_assign_source_151 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, call_args );
    }

    if ( tmp_assign_source_151 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 264;

        goto try_except_handler_27;
    }
    assert( tmp_class_creation_7__class == NULL );
    tmp_class_creation_7__class = tmp_assign_source_151;

    goto try_end_12;
    // Exception handler code:
    try_except_handler_27:;
    exception_keeper_type_18 = exception_type;
    exception_keeper_value_18 = exception_value;
    exception_keeper_tb_18 = exception_tb;
    exception_keeper_lineno_18 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_7__bases );
    tmp_class_creation_7__bases = NULL;

    Py_XDECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_18;
    exception_value = exception_keeper_value_18;
    exception_tb = exception_keeper_tb_18;
    exception_lineno = exception_keeper_lineno_18;

    goto frame_exception_exit_1;
    // End of try:
    try_end_12:;
    tmp_assign_source_152 = tmp_class_creation_7__class;

    CHECK_OBJECT( tmp_assign_source_152 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SysCallError, tmp_assign_source_152 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class );
    Py_DECREF( tmp_class_creation_7__class );
    tmp_class_creation_7__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__bases );
    Py_DECREF( tmp_class_creation_7__bases );
    tmp_class_creation_7__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class_dict );
    Py_DECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__metaclass );
    Py_DECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    tmp_set_locals = PyDict_New();
    locals__CallbackExceptionHelper_268 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals__CallbackExceptionHelper_268, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_03a9c0f25246f86801453ac49af67056;
    tmp_res = PyDict_SetItem( locals__CallbackExceptionHelper_268, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_1___init__(  );
    tmp_res = PyDict_SetItem( locals__CallbackExceptionHelper_268, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_2_raise_if_problem(  );
    tmp_res = PyDict_SetItem( locals__CallbackExceptionHelper_268, const_str_plain_raise_if_problem, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_13 = locals__CallbackExceptionHelper_268;
    Py_INCREF( tmp_outline_return_value_13 );
    goto try_return_handler_31;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_31:;
    Py_DECREF( locals__CallbackExceptionHelper_268 );
    locals__CallbackExceptionHelper_268 = NULL;
    goto outline_result_13;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_13:;
    tmp_assign_source_153 = tmp_outline_return_value_13;
    assert( tmp_class_creation_8__class_dict == NULL );
    tmp_class_creation_8__class_dict = tmp_assign_source_153;

    // Tried code:
    tmp_compare_left_8 = const_str_plain___metaclass__;
    tmp_compare_right_8 = tmp_class_creation_8__class_dict;

    CHECK_OBJECT( tmp_compare_right_8 );
    tmp_cmp_In_7 = PySequence_Contains( tmp_compare_right_8, tmp_compare_left_8 );
    assert( !(tmp_cmp_In_7 == -1) );
    if ( tmp_cmp_In_7 == 1 )
    {
        goto condexpr_true_7;
    }
    else
    {
        goto condexpr_false_7;
    }
    condexpr_true_7:;
    tmp_dict_name_7 = tmp_class_creation_8__class_dict;

    CHECK_OBJECT( tmp_dict_name_7 );
    tmp_key_name_7 = const_str_plain___metaclass__;
    tmp_assign_source_154 = DICT_GET_ITEM( tmp_dict_name_7, tmp_key_name_7 );
    if ( tmp_assign_source_154 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 268;

        goto try_except_handler_32;
    }
    goto condexpr_end_7;
    condexpr_false_7:;
    tmp_assign_source_154 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_154 );
    condexpr_end_7:;
    assert( tmp_class_creation_8__metaclass == NULL );
    tmp_class_creation_8__metaclass = tmp_assign_source_154;

    tmp_called_name_9 = tmp_class_creation_8__metaclass;

    CHECK_OBJECT( tmp_called_name_9 );
    tmp_args_element_name_22 = const_str_plain__CallbackExceptionHelper;
    tmp_args_element_name_23 = const_tuple_type_object_tuple;
    tmp_args_element_name_24 = tmp_class_creation_8__class_dict;

    CHECK_OBJECT( tmp_args_element_name_24 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 268;
    {
        PyObject *call_args[] = { tmp_args_element_name_22, tmp_args_element_name_23, tmp_args_element_name_24 };
        tmp_assign_source_155 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_9, call_args );
    }

    if ( tmp_assign_source_155 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 268;

        goto try_except_handler_32;
    }
    assert( tmp_class_creation_8__class == NULL );
    tmp_class_creation_8__class = tmp_assign_source_155;

    goto try_end_13;
    // Exception handler code:
    try_except_handler_32:;
    exception_keeper_type_19 = exception_type;
    exception_keeper_value_19 = exception_value;
    exception_keeper_tb_19 = exception_tb;
    exception_keeper_lineno_19 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class_dict );
    Py_DECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_19;
    exception_value = exception_keeper_value_19;
    exception_tb = exception_keeper_tb_19;
    exception_lineno = exception_keeper_lineno_19;

    goto frame_exception_exit_1;
    // End of try:
    try_end_13:;
    tmp_assign_source_156 = tmp_class_creation_8__class;

    CHECK_OBJECT( tmp_assign_source_156 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper, tmp_assign_source_156 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class );
    Py_DECREF( tmp_class_creation_8__class );
    tmp_class_creation_8__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class_dict );
    Py_DECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__metaclass );
    Py_DECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    // Tried code:
    tmp_assign_source_157 = PyTuple_New( 1 );
    tmp_tuple_element_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

    if (unlikely( tmp_tuple_element_7 == NULL ))
    {
        tmp_tuple_element_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
    }

    if ( tmp_tuple_element_7 == NULL )
    {
        Py_DECREF( tmp_assign_source_157 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_CallbackExceptionHelper" );
        exception_tb = NULL;

        exception_lineno = 296;

        goto try_except_handler_33;
    }

    Py_INCREF( tmp_tuple_element_7 );
    PyTuple_SET_ITEM( tmp_assign_source_157, 0, tmp_tuple_element_7 );
    assert( tmp_class_creation_9__bases == NULL );
    tmp_class_creation_9__bases = tmp_assign_source_157;

    tmp_set_locals = PyDict_New();
    locals__VerifyHelper_296 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals__VerifyHelper_296, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_1494ae1301cb98a828389add570df55f;
    tmp_res = PyDict_SetItem( locals__VerifyHelper_296, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__(  );
    tmp_res = PyDict_SetItem( locals__VerifyHelper_296, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_14 = locals__VerifyHelper_296;
    Py_INCREF( tmp_outline_return_value_14 );
    goto try_return_handler_34;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_34:;
    Py_DECREF( locals__VerifyHelper_296 );
    locals__VerifyHelper_296 = NULL;
    goto outline_result_14;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_14:;
    tmp_assign_source_158 = tmp_outline_return_value_14;
    assert( tmp_class_creation_9__class_dict == NULL );
    tmp_class_creation_9__class_dict = tmp_assign_source_158;

    tmp_compare_left_9 = const_str_plain___metaclass__;
    tmp_compare_right_9 = tmp_class_creation_9__class_dict;

    CHECK_OBJECT( tmp_compare_right_9 );
    tmp_cmp_In_8 = PySequence_Contains( tmp_compare_right_9, tmp_compare_left_9 );
    assert( !(tmp_cmp_In_8 == -1) );
    if ( tmp_cmp_In_8 == 1 )
    {
        goto condexpr_true_8;
    }
    else
    {
        goto condexpr_false_8;
    }
    condexpr_true_8:;
    tmp_dict_name_8 = tmp_class_creation_9__class_dict;

    CHECK_OBJECT( tmp_dict_name_8 );
    tmp_key_name_8 = const_str_plain___metaclass__;
    tmp_assign_source_159 = DICT_GET_ITEM( tmp_dict_name_8, tmp_key_name_8 );
    if ( tmp_assign_source_159 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 296;

        goto try_except_handler_33;
    }
    goto condexpr_end_8;
    condexpr_false_8:;
    tmp_subscribed_name_7 = tmp_class_creation_9__bases;

    CHECK_OBJECT( tmp_subscribed_name_7 );
    tmp_subscript_name_7 = const_int_0;
    tmp_assign_source_160 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    if ( tmp_assign_source_160 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 296;

        goto try_except_handler_33;
    }
    assert( tmp_select_metaclass_9__base == NULL );
    tmp_select_metaclass_9__base = tmp_assign_source_160;

    // Tried code:
    // Tried code:
    tmp_source_name_74 = tmp_select_metaclass_9__base;

    CHECK_OBJECT( tmp_source_name_74 );
    tmp_outline_return_value_15 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_74 );
    if ( tmp_outline_return_value_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 296;

        goto try_except_handler_36;
    }
    goto try_return_handler_35;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_36:;
    exception_keeper_type_20 = exception_type;
    exception_keeper_value_20 = exception_value;
    exception_keeper_tb_20 = exception_tb;
    exception_keeper_lineno_20 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_20 );
    Py_XDECREF( exception_keeper_value_20 );
    Py_XDECREF( exception_keeper_tb_20 );
    tmp_type_arg_7 = tmp_select_metaclass_9__base;

    CHECK_OBJECT( tmp_type_arg_7 );
    tmp_outline_return_value_15 = BUILTIN_TYPE1( tmp_type_arg_7 );
    assert( tmp_outline_return_value_15 != NULL );
    goto try_return_handler_35;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_35:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_9__base );
    Py_DECREF( tmp_select_metaclass_9__base );
    tmp_select_metaclass_9__base = NULL;

    goto outline_result_15;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_9__base );
    Py_DECREF( tmp_select_metaclass_9__base );
    tmp_select_metaclass_9__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_15:;
    tmp_assign_source_159 = tmp_outline_return_value_15;
    condexpr_end_8:;
    assert( tmp_class_creation_9__metaclass == NULL );
    tmp_class_creation_9__metaclass = tmp_assign_source_159;

    tmp_called_name_10 = tmp_class_creation_9__metaclass;

    CHECK_OBJECT( tmp_called_name_10 );
    tmp_args_element_name_25 = const_str_plain__VerifyHelper;
    tmp_args_element_name_26 = tmp_class_creation_9__bases;

    CHECK_OBJECT( tmp_args_element_name_26 );
    tmp_args_element_name_27 = tmp_class_creation_9__class_dict;

    CHECK_OBJECT( tmp_args_element_name_27 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 296;
    {
        PyObject *call_args[] = { tmp_args_element_name_25, tmp_args_element_name_26, tmp_args_element_name_27 };
        tmp_assign_source_161 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_10, call_args );
    }

    if ( tmp_assign_source_161 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 296;

        goto try_except_handler_33;
    }
    assert( tmp_class_creation_9__class == NULL );
    tmp_class_creation_9__class = tmp_assign_source_161;

    goto try_end_14;
    // Exception handler code:
    try_except_handler_33:;
    exception_keeper_type_21 = exception_type;
    exception_keeper_value_21 = exception_value;
    exception_keeper_tb_21 = exception_tb;
    exception_keeper_lineno_21 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_9__bases );
    tmp_class_creation_9__bases = NULL;

    Py_XDECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_21;
    exception_value = exception_keeper_value_21;
    exception_tb = exception_keeper_tb_21;
    exception_lineno = exception_keeper_lineno_21;

    goto frame_exception_exit_1;
    // End of try:
    try_end_14:;
    tmp_assign_source_162 = tmp_class_creation_9__class;

    CHECK_OBJECT( tmp_assign_source_162 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__VerifyHelper, tmp_assign_source_162 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class );
    Py_DECREF( tmp_class_creation_9__class );
    tmp_class_creation_9__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__bases );
    Py_DECREF( tmp_class_creation_9__bases );
    tmp_class_creation_9__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class_dict );
    Py_DECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__metaclass );
    Py_DECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    tmp_called_name_11 = (PyObject *)&PyBaseObject_Type;
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 336;
    tmp_assign_source_163 = CALL_FUNCTION_NO_ARGS( tmp_called_name_11 );
    if ( tmp_assign_source_163 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 336;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_NO_OVERLAPPING_PROTOCOLS, tmp_assign_source_163 );
    // Tried code:
    tmp_assign_source_164 = PyTuple_New( 1 );
    tmp_tuple_element_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

    if (unlikely( tmp_tuple_element_8 == NULL ))
    {
        tmp_tuple_element_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
    }

    if ( tmp_tuple_element_8 == NULL )
    {
        Py_DECREF( tmp_assign_source_164 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_CallbackExceptionHelper" );
        exception_tb = NULL;

        exception_lineno = 339;

        goto try_except_handler_37;
    }

    Py_INCREF( tmp_tuple_element_8 );
    PyTuple_SET_ITEM( tmp_assign_source_164, 0, tmp_tuple_element_8 );
    assert( tmp_class_creation_10__bases == NULL );
    tmp_class_creation_10__bases = tmp_assign_source_164;

    tmp_set_locals = PyDict_New();
    locals__ALPNSelectHelper_339 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals__ALPNSelectHelper_339, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_a9a754c6f4c1dd488de35af4ae59537f;
    tmp_res = PyDict_SetItem( locals__ALPNSelectHelper_339, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__(  );
    tmp_res = PyDict_SetItem( locals__ALPNSelectHelper_339, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_16 = locals__ALPNSelectHelper_339;
    Py_INCREF( tmp_outline_return_value_16 );
    goto try_return_handler_38;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_38:;
    Py_DECREF( locals__ALPNSelectHelper_339 );
    locals__ALPNSelectHelper_339 = NULL;
    goto outline_result_16;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_16:;
    tmp_assign_source_165 = tmp_outline_return_value_16;
    assert( tmp_class_creation_10__class_dict == NULL );
    tmp_class_creation_10__class_dict = tmp_assign_source_165;

    tmp_compare_left_10 = const_str_plain___metaclass__;
    tmp_compare_right_10 = tmp_class_creation_10__class_dict;

    CHECK_OBJECT( tmp_compare_right_10 );
    tmp_cmp_In_9 = PySequence_Contains( tmp_compare_right_10, tmp_compare_left_10 );
    assert( !(tmp_cmp_In_9 == -1) );
    if ( tmp_cmp_In_9 == 1 )
    {
        goto condexpr_true_9;
    }
    else
    {
        goto condexpr_false_9;
    }
    condexpr_true_9:;
    tmp_dict_name_9 = tmp_class_creation_10__class_dict;

    CHECK_OBJECT( tmp_dict_name_9 );
    tmp_key_name_9 = const_str_plain___metaclass__;
    tmp_assign_source_166 = DICT_GET_ITEM( tmp_dict_name_9, tmp_key_name_9 );
    if ( tmp_assign_source_166 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 339;

        goto try_except_handler_37;
    }
    goto condexpr_end_9;
    condexpr_false_9:;
    tmp_subscribed_name_8 = tmp_class_creation_10__bases;

    CHECK_OBJECT( tmp_subscribed_name_8 );
    tmp_subscript_name_8 = const_int_0;
    tmp_assign_source_167 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_8, tmp_subscript_name_8 );
    if ( tmp_assign_source_167 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 339;

        goto try_except_handler_37;
    }
    assert( tmp_select_metaclass_10__base == NULL );
    tmp_select_metaclass_10__base = tmp_assign_source_167;

    // Tried code:
    // Tried code:
    tmp_source_name_75 = tmp_select_metaclass_10__base;

    CHECK_OBJECT( tmp_source_name_75 );
    tmp_outline_return_value_17 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_75 );
    if ( tmp_outline_return_value_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 339;

        goto try_except_handler_40;
    }
    goto try_return_handler_39;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_40:;
    exception_keeper_type_22 = exception_type;
    exception_keeper_value_22 = exception_value;
    exception_keeper_tb_22 = exception_tb;
    exception_keeper_lineno_22 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_22 );
    Py_XDECREF( exception_keeper_value_22 );
    Py_XDECREF( exception_keeper_tb_22 );
    tmp_type_arg_8 = tmp_select_metaclass_10__base;

    CHECK_OBJECT( tmp_type_arg_8 );
    tmp_outline_return_value_17 = BUILTIN_TYPE1( tmp_type_arg_8 );
    assert( tmp_outline_return_value_17 != NULL );
    goto try_return_handler_39;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_39:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_10__base );
    Py_DECREF( tmp_select_metaclass_10__base );
    tmp_select_metaclass_10__base = NULL;

    goto outline_result_17;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_10__base );
    Py_DECREF( tmp_select_metaclass_10__base );
    tmp_select_metaclass_10__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_17:;
    tmp_assign_source_166 = tmp_outline_return_value_17;
    condexpr_end_9:;
    assert( tmp_class_creation_10__metaclass == NULL );
    tmp_class_creation_10__metaclass = tmp_assign_source_166;

    tmp_called_name_12 = tmp_class_creation_10__metaclass;

    CHECK_OBJECT( tmp_called_name_12 );
    tmp_args_element_name_28 = const_str_plain__ALPNSelectHelper;
    tmp_args_element_name_29 = tmp_class_creation_10__bases;

    CHECK_OBJECT( tmp_args_element_name_29 );
    tmp_args_element_name_30 = tmp_class_creation_10__class_dict;

    CHECK_OBJECT( tmp_args_element_name_30 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 339;
    {
        PyObject *call_args[] = { tmp_args_element_name_28, tmp_args_element_name_29, tmp_args_element_name_30 };
        tmp_assign_source_168 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_12, call_args );
    }

    if ( tmp_assign_source_168 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 339;

        goto try_except_handler_37;
    }
    assert( tmp_class_creation_10__class == NULL );
    tmp_class_creation_10__class = tmp_assign_source_168;

    goto try_end_15;
    // Exception handler code:
    try_except_handler_37:;
    exception_keeper_type_23 = exception_type;
    exception_keeper_value_23 = exception_value;
    exception_keeper_tb_23 = exception_tb;
    exception_keeper_lineno_23 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_10__bases );
    tmp_class_creation_10__bases = NULL;

    Py_XDECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_23;
    exception_value = exception_keeper_value_23;
    exception_tb = exception_keeper_tb_23;
    exception_lineno = exception_keeper_lineno_23;

    goto frame_exception_exit_1;
    // End of try:
    try_end_15:;
    tmp_assign_source_169 = tmp_class_creation_10__class;

    CHECK_OBJECT( tmp_assign_source_169 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ALPNSelectHelper, tmp_assign_source_169 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class );
    Py_DECREF( tmp_class_creation_10__class );
    tmp_class_creation_10__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__bases );
    Py_DECREF( tmp_class_creation_10__bases );
    tmp_class_creation_10__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class_dict );
    Py_DECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__metaclass );
    Py_DECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    // Tried code:
    tmp_assign_source_170 = PyTuple_New( 1 );
    tmp_tuple_element_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

    if (unlikely( tmp_tuple_element_9 == NULL ))
    {
        tmp_tuple_element_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
    }

    if ( tmp_tuple_element_9 == NULL )
    {
        Py_DECREF( tmp_assign_source_170 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_CallbackExceptionHelper" );
        exception_tb = NULL;

        exception_lineno = 400;

        goto try_except_handler_41;
    }

    Py_INCREF( tmp_tuple_element_9 );
    PyTuple_SET_ITEM( tmp_assign_source_170, 0, tmp_tuple_element_9 );
    assert( tmp_class_creation_11__bases == NULL );
    tmp_class_creation_11__bases = tmp_assign_source_170;

    tmp_set_locals = PyDict_New();
    locals__OCSPServerCallbackHelper_400 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals__OCSPServerCallbackHelper_400, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_ebc06328e68f0dbdd2e23e3f1f581b13;
    tmp_res = PyDict_SetItem( locals__OCSPServerCallbackHelper_400, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__(  );
    tmp_res = PyDict_SetItem( locals__OCSPServerCallbackHelper_400, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_18 = locals__OCSPServerCallbackHelper_400;
    Py_INCREF( tmp_outline_return_value_18 );
    goto try_return_handler_42;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_42:;
    Py_DECREF( locals__OCSPServerCallbackHelper_400 );
    locals__OCSPServerCallbackHelper_400 = NULL;
    goto outline_result_18;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_18:;
    tmp_assign_source_171 = tmp_outline_return_value_18;
    assert( tmp_class_creation_11__class_dict == NULL );
    tmp_class_creation_11__class_dict = tmp_assign_source_171;

    tmp_compare_left_11 = const_str_plain___metaclass__;
    tmp_compare_right_11 = tmp_class_creation_11__class_dict;

    CHECK_OBJECT( tmp_compare_right_11 );
    tmp_cmp_In_10 = PySequence_Contains( tmp_compare_right_11, tmp_compare_left_11 );
    assert( !(tmp_cmp_In_10 == -1) );
    if ( tmp_cmp_In_10 == 1 )
    {
        goto condexpr_true_10;
    }
    else
    {
        goto condexpr_false_10;
    }
    condexpr_true_10:;
    tmp_dict_name_10 = tmp_class_creation_11__class_dict;

    CHECK_OBJECT( tmp_dict_name_10 );
    tmp_key_name_10 = const_str_plain___metaclass__;
    tmp_assign_source_172 = DICT_GET_ITEM( tmp_dict_name_10, tmp_key_name_10 );
    if ( tmp_assign_source_172 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 400;

        goto try_except_handler_41;
    }
    goto condexpr_end_10;
    condexpr_false_10:;
    tmp_subscribed_name_9 = tmp_class_creation_11__bases;

    CHECK_OBJECT( tmp_subscribed_name_9 );
    tmp_subscript_name_9 = const_int_0;
    tmp_assign_source_173 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_9, tmp_subscript_name_9 );
    if ( tmp_assign_source_173 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 400;

        goto try_except_handler_41;
    }
    assert( tmp_select_metaclass_11__base == NULL );
    tmp_select_metaclass_11__base = tmp_assign_source_173;

    // Tried code:
    // Tried code:
    tmp_source_name_76 = tmp_select_metaclass_11__base;

    CHECK_OBJECT( tmp_source_name_76 );
    tmp_outline_return_value_19 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_76 );
    if ( tmp_outline_return_value_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 400;

        goto try_except_handler_44;
    }
    goto try_return_handler_43;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_44:;
    exception_keeper_type_24 = exception_type;
    exception_keeper_value_24 = exception_value;
    exception_keeper_tb_24 = exception_tb;
    exception_keeper_lineno_24 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_24 );
    Py_XDECREF( exception_keeper_value_24 );
    Py_XDECREF( exception_keeper_tb_24 );
    tmp_type_arg_9 = tmp_select_metaclass_11__base;

    CHECK_OBJECT( tmp_type_arg_9 );
    tmp_outline_return_value_19 = BUILTIN_TYPE1( tmp_type_arg_9 );
    assert( tmp_outline_return_value_19 != NULL );
    goto try_return_handler_43;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_43:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_11__base );
    Py_DECREF( tmp_select_metaclass_11__base );
    tmp_select_metaclass_11__base = NULL;

    goto outline_result_19;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_11__base );
    Py_DECREF( tmp_select_metaclass_11__base );
    tmp_select_metaclass_11__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_19:;
    tmp_assign_source_172 = tmp_outline_return_value_19;
    condexpr_end_10:;
    assert( tmp_class_creation_11__metaclass == NULL );
    tmp_class_creation_11__metaclass = tmp_assign_source_172;

    tmp_called_name_13 = tmp_class_creation_11__metaclass;

    CHECK_OBJECT( tmp_called_name_13 );
    tmp_args_element_name_31 = const_str_plain__OCSPServerCallbackHelper;
    tmp_args_element_name_32 = tmp_class_creation_11__bases;

    CHECK_OBJECT( tmp_args_element_name_32 );
    tmp_args_element_name_33 = tmp_class_creation_11__class_dict;

    CHECK_OBJECT( tmp_args_element_name_33 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 400;
    {
        PyObject *call_args[] = { tmp_args_element_name_31, tmp_args_element_name_32, tmp_args_element_name_33 };
        tmp_assign_source_174 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_13, call_args );
    }

    if ( tmp_assign_source_174 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 400;

        goto try_except_handler_41;
    }
    assert( tmp_class_creation_11__class == NULL );
    tmp_class_creation_11__class = tmp_assign_source_174;

    goto try_end_16;
    // Exception handler code:
    try_except_handler_41:;
    exception_keeper_type_25 = exception_type;
    exception_keeper_value_25 = exception_value;
    exception_keeper_tb_25 = exception_tb;
    exception_keeper_lineno_25 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_11__bases );
    tmp_class_creation_11__bases = NULL;

    Py_XDECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_25;
    exception_value = exception_keeper_value_25;
    exception_tb = exception_keeper_tb_25;
    exception_lineno = exception_keeper_lineno_25;

    goto frame_exception_exit_1;
    // End of try:
    try_end_16:;
    tmp_assign_source_175 = tmp_class_creation_11__class;

    CHECK_OBJECT( tmp_assign_source_175 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__OCSPServerCallbackHelper, tmp_assign_source_175 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class );
    Py_DECREF( tmp_class_creation_11__class );
    tmp_class_creation_11__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__bases );
    Py_DECREF( tmp_class_creation_11__bases );
    tmp_class_creation_11__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class_dict );
    Py_DECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__metaclass );
    Py_DECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    // Tried code:
    tmp_assign_source_176 = PyTuple_New( 1 );
    tmp_tuple_element_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

    if (unlikely( tmp_tuple_element_10 == NULL ))
    {
        tmp_tuple_element_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
    }

    if ( tmp_tuple_element_10 == NULL )
    {
        Py_DECREF( tmp_assign_source_176 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_CallbackExceptionHelper" );
        exception_tb = NULL;

        exception_lineno = 467;

        goto try_except_handler_45;
    }

    Py_INCREF( tmp_tuple_element_10 );
    PyTuple_SET_ITEM( tmp_assign_source_176, 0, tmp_tuple_element_10 );
    assert( tmp_class_creation_12__bases == NULL );
    tmp_class_creation_12__bases = tmp_assign_source_176;

    tmp_set_locals = PyDict_New();
    locals__OCSPClientCallbackHelper_467 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals__OCSPClientCallbackHelper_467, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_fd8757ca246c476601094123086e9a80;
    tmp_res = PyDict_SetItem( locals__OCSPClientCallbackHelper_467, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__(  );
    tmp_res = PyDict_SetItem( locals__OCSPClientCallbackHelper_467, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_20 = locals__OCSPClientCallbackHelper_467;
    Py_INCREF( tmp_outline_return_value_20 );
    goto try_return_handler_46;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_46:;
    Py_DECREF( locals__OCSPClientCallbackHelper_467 );
    locals__OCSPClientCallbackHelper_467 = NULL;
    goto outline_result_20;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_20:;
    tmp_assign_source_177 = tmp_outline_return_value_20;
    assert( tmp_class_creation_12__class_dict == NULL );
    tmp_class_creation_12__class_dict = tmp_assign_source_177;

    tmp_compare_left_12 = const_str_plain___metaclass__;
    tmp_compare_right_12 = tmp_class_creation_12__class_dict;

    CHECK_OBJECT( tmp_compare_right_12 );
    tmp_cmp_In_11 = PySequence_Contains( tmp_compare_right_12, tmp_compare_left_12 );
    assert( !(tmp_cmp_In_11 == -1) );
    if ( tmp_cmp_In_11 == 1 )
    {
        goto condexpr_true_11;
    }
    else
    {
        goto condexpr_false_11;
    }
    condexpr_true_11:;
    tmp_dict_name_11 = tmp_class_creation_12__class_dict;

    CHECK_OBJECT( tmp_dict_name_11 );
    tmp_key_name_11 = const_str_plain___metaclass__;
    tmp_assign_source_178 = DICT_GET_ITEM( tmp_dict_name_11, tmp_key_name_11 );
    if ( tmp_assign_source_178 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;

        goto try_except_handler_45;
    }
    goto condexpr_end_11;
    condexpr_false_11:;
    tmp_subscribed_name_10 = tmp_class_creation_12__bases;

    CHECK_OBJECT( tmp_subscribed_name_10 );
    tmp_subscript_name_10 = const_int_0;
    tmp_assign_source_179 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_10, tmp_subscript_name_10 );
    if ( tmp_assign_source_179 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;

        goto try_except_handler_45;
    }
    assert( tmp_select_metaclass_12__base == NULL );
    tmp_select_metaclass_12__base = tmp_assign_source_179;

    // Tried code:
    // Tried code:
    tmp_source_name_77 = tmp_select_metaclass_12__base;

    CHECK_OBJECT( tmp_source_name_77 );
    tmp_outline_return_value_21 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_77 );
    if ( tmp_outline_return_value_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;

        goto try_except_handler_48;
    }
    goto try_return_handler_47;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_48:;
    exception_keeper_type_26 = exception_type;
    exception_keeper_value_26 = exception_value;
    exception_keeper_tb_26 = exception_tb;
    exception_keeper_lineno_26 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( exception_keeper_type_26 );
    Py_XDECREF( exception_keeper_value_26 );
    Py_XDECREF( exception_keeper_tb_26 );
    tmp_type_arg_10 = tmp_select_metaclass_12__base;

    CHECK_OBJECT( tmp_type_arg_10 );
    tmp_outline_return_value_21 = BUILTIN_TYPE1( tmp_type_arg_10 );
    assert( tmp_outline_return_value_21 != NULL );
    goto try_return_handler_47;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_47:;
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_12__base );
    Py_DECREF( tmp_select_metaclass_12__base );
    tmp_select_metaclass_12__base = NULL;

    goto outline_result_21;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_select_metaclass_12__base );
    Py_DECREF( tmp_select_metaclass_12__base );
    tmp_select_metaclass_12__base = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_21:;
    tmp_assign_source_178 = tmp_outline_return_value_21;
    condexpr_end_11:;
    assert( tmp_class_creation_12__metaclass == NULL );
    tmp_class_creation_12__metaclass = tmp_assign_source_178;

    tmp_called_name_14 = tmp_class_creation_12__metaclass;

    CHECK_OBJECT( tmp_called_name_14 );
    tmp_args_element_name_34 = const_str_plain__OCSPClientCallbackHelper;
    tmp_args_element_name_35 = tmp_class_creation_12__bases;

    CHECK_OBJECT( tmp_args_element_name_35 );
    tmp_args_element_name_36 = tmp_class_creation_12__class_dict;

    CHECK_OBJECT( tmp_args_element_name_36 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 467;
    {
        PyObject *call_args[] = { tmp_args_element_name_34, tmp_args_element_name_35, tmp_args_element_name_36 };
        tmp_assign_source_180 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_14, call_args );
    }

    if ( tmp_assign_source_180 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;

        goto try_except_handler_45;
    }
    assert( tmp_class_creation_12__class == NULL );
    tmp_class_creation_12__class = tmp_assign_source_180;

    goto try_end_17;
    // Exception handler code:
    try_except_handler_45:;
    exception_keeper_type_27 = exception_type;
    exception_keeper_value_27 = exception_value;
    exception_keeper_tb_27 = exception_tb;
    exception_keeper_lineno_27 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_12__bases );
    tmp_class_creation_12__bases = NULL;

    Py_XDECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_27;
    exception_value = exception_keeper_value_27;
    exception_tb = exception_keeper_tb_27;
    exception_lineno = exception_keeper_lineno_27;

    goto frame_exception_exit_1;
    // End of try:
    try_end_17:;
    tmp_assign_source_181 = tmp_class_creation_12__class;

    CHECK_OBJECT( tmp_assign_source_181 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__OCSPClientCallbackHelper, tmp_assign_source_181 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class );
    Py_DECREF( tmp_class_creation_12__class );
    tmp_class_creation_12__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__bases );
    Py_DECREF( tmp_class_creation_12__bases );
    tmp_class_creation_12__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class_dict );
    Py_DECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__metaclass );
    Py_DECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    tmp_assign_source_182 = MAKE_FUNCTION_OpenSSL$SSL$$$function_7__asFileDescriptor(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__asFileDescriptor, tmp_assign_source_182 );
    tmp_assign_source_183 = MAKE_FUNCTION_OpenSSL$SSL$$$function_8_SSLeay_version(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLeay_version, tmp_assign_source_183 );
    tmp_assign_source_184 = MAKE_FUNCTION_OpenSSL$SSL$$$function_9__make_requires(  );
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_requires, tmp_assign_source_184 );
    tmp_called_name_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_requires );

    if (unlikely( tmp_called_name_15 == NULL ))
    {
        tmp_called_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_requires );
    }

    CHECK_OBJECT( tmp_called_name_15 );
    tmp_source_name_78 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_source_name_78 == NULL ))
    {
        tmp_source_name_78 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_source_name_78 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 581;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_37 = LOOKUP_ATTRIBUTE( tmp_source_name_78, const_str_plain_Cryptography_HAS_ALPN );
    if ( tmp_args_element_name_37 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 581;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_38 = const_str_digest_616719c4a0cde3344203a07484a7fb54;
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 580;
    {
        PyObject *call_args[] = { tmp_args_element_name_37, tmp_args_element_name_38 };
        tmp_assign_source_185 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_15, call_args );
    }

    Py_DECREF( tmp_args_element_name_37 );
    if ( tmp_assign_source_185 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 580;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn, tmp_assign_source_185 );
    tmp_called_name_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_requires );

    if (unlikely( tmp_called_name_16 == NULL ))
    {
        tmp_called_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_requires );
    }

    if ( tmp_called_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_requires" );
        exception_tb = NULL;

        exception_lineno = 585;

        goto frame_exception_exit_1;
    }

    tmp_getattr_target_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_getattr_target_1 == NULL ))
    {
        tmp_getattr_target_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_getattr_target_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 586;

        goto frame_exception_exit_1;
    }

    tmp_getattr_attr_1 = const_str_plain_Cryptography_HAS_KEYLOG;
    tmp_getattr_default_1 = Py_None;
    tmp_args_element_name_39 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1 );
    if ( tmp_args_element_name_39 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 586;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_40 = const_str_digest_0db98f8a8931566efc9f7dd135830a12;
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 585;
    {
        PyObject *call_args[] = { tmp_args_element_name_39, tmp_args_element_name_40 };
        tmp_assign_source_186 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_16, call_args );
    }

    Py_DECREF( tmp_args_element_name_39 );
    if ( tmp_assign_source_186 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 585;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_keylog, tmp_assign_source_186 );
    tmp_set_locals = PyDict_New();
    locals_Session_590 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals_Session_590, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_720dcf8e2be0afcf53b482e84751fd16;
    tmp_res = PyDict_SetItem( locals_Session_590, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    tmp_outline_return_value_22 = locals_Session_590;
    Py_INCREF( tmp_outline_return_value_22 );
    goto try_return_handler_49;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_49:;
    Py_DECREF( locals_Session_590 );
    locals_Session_590 = NULL;
    goto outline_result_22;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_22:;
    tmp_assign_source_187 = tmp_outline_return_value_22;
    assert( tmp_class_creation_13__class_dict == NULL );
    tmp_class_creation_13__class_dict = tmp_assign_source_187;

    // Tried code:
    tmp_compare_left_13 = const_str_plain___metaclass__;
    tmp_compare_right_13 = tmp_class_creation_13__class_dict;

    CHECK_OBJECT( tmp_compare_right_13 );
    tmp_cmp_In_12 = PySequence_Contains( tmp_compare_right_13, tmp_compare_left_13 );
    assert( !(tmp_cmp_In_12 == -1) );
    if ( tmp_cmp_In_12 == 1 )
    {
        goto condexpr_true_12;
    }
    else
    {
        goto condexpr_false_12;
    }
    condexpr_true_12:;
    tmp_dict_name_12 = tmp_class_creation_13__class_dict;

    CHECK_OBJECT( tmp_dict_name_12 );
    tmp_key_name_12 = const_str_plain___metaclass__;
    tmp_assign_source_188 = DICT_GET_ITEM( tmp_dict_name_12, tmp_key_name_12 );
    if ( tmp_assign_source_188 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 590;

        goto try_except_handler_50;
    }
    goto condexpr_end_12;
    condexpr_false_12:;
    tmp_assign_source_188 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_188 );
    condexpr_end_12:;
    assert( tmp_class_creation_13__metaclass == NULL );
    tmp_class_creation_13__metaclass = tmp_assign_source_188;

    tmp_called_name_17 = tmp_class_creation_13__metaclass;

    CHECK_OBJECT( tmp_called_name_17 );
    tmp_args_element_name_41 = const_str_plain_Session;
    tmp_args_element_name_42 = const_tuple_type_object_tuple;
    tmp_args_element_name_43 = tmp_class_creation_13__class_dict;

    CHECK_OBJECT( tmp_args_element_name_43 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 590;
    {
        PyObject *call_args[] = { tmp_args_element_name_41, tmp_args_element_name_42, tmp_args_element_name_43 };
        tmp_assign_source_189 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_17, call_args );
    }

    if ( tmp_assign_source_189 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 590;

        goto try_except_handler_50;
    }
    assert( tmp_class_creation_13__class == NULL );
    tmp_class_creation_13__class = tmp_assign_source_189;

    goto try_end_18;
    // Exception handler code:
    try_except_handler_50:;
    exception_keeper_type_28 = exception_type;
    exception_keeper_value_28 = exception_value;
    exception_keeper_tb_28 = exception_tb;
    exception_keeper_lineno_28 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class_dict );
    Py_DECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_28;
    exception_value = exception_keeper_value_28;
    exception_tb = exception_keeper_tb_28;
    exception_lineno = exception_keeper_lineno_28;

    goto frame_exception_exit_1;
    // End of try:
    try_end_18:;
    tmp_assign_source_190 = tmp_class_creation_13__class;

    CHECK_OBJECT( tmp_assign_source_190 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Session, tmp_assign_source_190 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class );
    Py_DECREF( tmp_class_creation_13__class );
    tmp_class_creation_13__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class_dict );
    Py_DECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__metaclass );
    Py_DECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_Context_602 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = const_str_digest_91220ffd97efb14a503e0ecf9d7ff0d1;
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain___doc__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2, codeobj_ebb4019f10ac1dbcdaadd42bfd017b9d, module_OpenSSL$SSL, 0 );
    frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2 = cache_frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = _PyDict_NewPresized( 6 );
    tmp_dict_value_1 = const_str_plain_SSLv2_method;
    tmp_dict_key_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv2_METHOD );

    if (unlikely( tmp_dict_key_1 == NULL ))
    {
        tmp_dict_key_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLv2_METHOD );
    }

    if ( tmp_dict_key_1 == NULL )
    {
        Py_DECREF( tmp_dictset_value );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "SSLv2_METHOD" );
        exception_tb = NULL;

        exception_lineno = 612;

        goto frame_exception_exit_2;
    }

    tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_1, tmp_dict_value_1 );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_dictset_value );

        exception_lineno = 611;

        goto frame_exception_exit_2;
    }
    tmp_dict_value_2 = const_str_plain_SSLv3_method;
    tmp_dict_key_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv3_METHOD );

    if (unlikely( tmp_dict_key_2 == NULL ))
    {
        tmp_dict_key_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLv3_METHOD );
    }

    if ( tmp_dict_key_2 == NULL )
    {
        Py_DECREF( tmp_dictset_value );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "SSLv3_METHOD" );
        exception_tb = NULL;

        exception_lineno = 613;

        goto frame_exception_exit_2;
    }

    tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_2, tmp_dict_value_2 );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_dictset_value );

        exception_lineno = 611;

        goto frame_exception_exit_2;
    }
    tmp_dict_value_3 = const_str_plain_SSLv23_method;
    tmp_dict_key_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv23_METHOD );

    if (unlikely( tmp_dict_key_3 == NULL ))
    {
        tmp_dict_key_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLv23_METHOD );
    }

    if ( tmp_dict_key_3 == NULL )
    {
        Py_DECREF( tmp_dictset_value );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "SSLv23_METHOD" );
        exception_tb = NULL;

        exception_lineno = 614;

        goto frame_exception_exit_2;
    }

    tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_3, tmp_dict_value_3 );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_dictset_value );

        exception_lineno = 611;

        goto frame_exception_exit_2;
    }
    tmp_dict_value_4 = const_str_plain_TLSv1_method;
    tmp_dict_key_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_METHOD );

    if (unlikely( tmp_dict_key_4 == NULL ))
    {
        tmp_dict_key_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSv1_METHOD );
    }

    if ( tmp_dict_key_4 == NULL )
    {
        Py_DECREF( tmp_dictset_value );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "TLSv1_METHOD" );
        exception_tb = NULL;

        exception_lineno = 615;

        goto frame_exception_exit_2;
    }

    tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_4, tmp_dict_value_4 );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_dictset_value );

        exception_lineno = 611;

        goto frame_exception_exit_2;
    }
    tmp_dict_value_5 = const_str_plain_TLSv1_1_method;
    tmp_dict_key_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_1_METHOD );

    if (unlikely( tmp_dict_key_5 == NULL ))
    {
        tmp_dict_key_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSv1_1_METHOD );
    }

    if ( tmp_dict_key_5 == NULL )
    {
        Py_DECREF( tmp_dictset_value );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "TLSv1_1_METHOD" );
        exception_tb = NULL;

        exception_lineno = 616;

        goto frame_exception_exit_2;
    }

    tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_5, tmp_dict_value_5 );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_dictset_value );

        exception_lineno = 611;

        goto frame_exception_exit_2;
    }
    tmp_dict_value_6 = const_str_plain_TLSv1_2_method;
    tmp_dict_key_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_2_METHOD );

    if (unlikely( tmp_dict_key_6 == NULL ))
    {
        tmp_dict_key_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSv1_2_METHOD );
    }

    if ( tmp_dict_key_6 == NULL )
    {
        Py_DECREF( tmp_dictset_value );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "TLSv1_2_METHOD" );
        exception_tb = NULL;

        exception_lineno = 617;

        goto frame_exception_exit_2;
    }

    tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_6, tmp_dict_value_6 );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_dictset_value );

        exception_lineno = 611;

        goto frame_exception_exit_2;
    }
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain__methods, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;

        goto frame_exception_exit_2;
    }
    tmp_called_instance_1 = PyDict_GetItem( locals_Context_602, const_str_plain__methods );

    if ( tmp_called_instance_1 == NULL )
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__methods );

        if (unlikely( tmp_called_instance_1 == NULL ))
        {
            tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__methods );
        }

        if ( tmp_called_instance_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_methods" );
            exception_tb = NULL;

            exception_lineno = 621;

            goto frame_exception_exit_2;
        }

    }

    frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2->m_frame.f_lineno = 621;
    tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_items );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 621;

        goto frame_exception_exit_2;
    }
    tmp_assign_source_192 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_192 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 620;

        goto frame_exception_exit_2;
    }
    assert( tmp_Context$genexpr_1__$0 == NULL );
    tmp_Context$genexpr_1__$0 = tmp_assign_source_192;

    // Tried code:
    tmp_outline_return_value_24 = Nuitka_Generator_New(
        OpenSSL$SSL$$$genexpr_1_genexpr_context,
        module_OpenSSL$SSL,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_666efd733c0235abde1396b39c7b9f90,
        1
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_24)->m_closure[0] = PyCell_NEW0( tmp_Context$genexpr_1__$0 );
    assert( Py_SIZE( tmp_outline_return_value_24 ) >= 1 ); 


    goto try_return_handler_53;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_53:;
    CHECK_OBJECT( (PyObject *)tmp_Context$genexpr_1__$0 );
    Py_DECREF( tmp_Context$genexpr_1__$0 );
    tmp_Context$genexpr_1__$0 = NULL;

    goto outline_result_24;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_Context$genexpr_1__$0 );
    Py_DECREF( tmp_Context$genexpr_1__$0 );
    tmp_Context$genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_result_24:;
    tmp_dict_seq_1 = tmp_outline_return_value_24;
    tmp_dictset_value = TO_DICT( tmp_dict_seq_1, NULL );
    Py_DECREF( tmp_dict_seq_1 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 619;

        goto frame_exception_exit_2;
    }
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain__methods, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 619;

        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_10___init__(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_1 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_1 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_11_load_verify_locations( tmp_defaults_1 );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_load_verify_locations, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_12__wrap_callback(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain__wrap_callback, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_2 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_2 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_13_set_passwd_cb( tmp_defaults_2 );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_passwd_cb, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_14_set_default_verify_paths(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_default_verify_paths, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_15__check_env_vars_set(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain__check_env_vars_set, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_16__fallback_default_verify_paths(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain__fallback_default_verify_paths, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_17_use_certificate_chain_file(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_use_certificate_chain_file, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_3 = PyTuple_New( 1 );
    tmp_tuple_element_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

    if (unlikely( tmp_tuple_element_11 == NULL ))
    {
        tmp_tuple_element_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
    }

    if ( tmp_tuple_element_11 == NULL )
    {
        Py_DECREF( tmp_defaults_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "FILETYPE_PEM" );
        exception_tb = NULL;

        exception_lineno = 831;

        goto frame_exception_exit_2;
    }

    Py_INCREF( tmp_tuple_element_11 );
    PyTuple_SET_ITEM( tmp_defaults_3, 0, tmp_tuple_element_11 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_18_use_certificate_file( tmp_defaults_3 );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_use_certificate_file, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 831;

        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_19_use_certificate(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_use_certificate, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_20_add_extra_chain_cert(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_add_extra_chain_cert, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_21__raise_passphrase_exception(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain__raise_passphrase_exception, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_4 = PyTuple_New( 1 );
    tmp_tuple_element_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );

    if (unlikely( tmp_tuple_element_12 == NULL ))
    {
        tmp_tuple_element_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );
    }

    if ( tmp_tuple_element_12 == NULL )
    {
        Py_DECREF( tmp_defaults_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_UNSPECIFIED" );
        exception_tb = NULL;

        exception_lineno = 890;

        goto frame_exception_exit_2;
    }

    Py_INCREF( tmp_tuple_element_12 );
    PyTuple_SET_ITEM( tmp_defaults_4, 0, tmp_tuple_element_12 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_22_use_privatekey_file( tmp_defaults_4 );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_use_privatekey_file, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 890;

        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_23_use_privatekey(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_use_privatekey, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_24_check_privatekey(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_check_privatekey, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_25_load_client_ca(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_load_client_ca, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_26_set_session_id(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_session_id, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_27_set_session_cache_mode(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_session_cache_mode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_28_get_session_cache_mode(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_get_session_cache_mode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_5 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_5 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_29_set_verify( tmp_defaults_5 );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_verify, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_30_set_verify_depth(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_verify_depth, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_31_get_verify_mode(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_get_verify_mode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_32_get_verify_depth(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_get_verify_depth, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_33_load_tmp_dh(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_load_tmp_dh, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_34_set_tmp_ecdh(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_tmp_ecdh, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_35_set_cipher_list(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_cipher_list, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_36_set_client_ca_list(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_client_ca_list, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_37_add_client_ca(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_add_client_ca, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_38_set_timeout(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_timeout, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_39_get_timeout(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_get_timeout, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_40_set_info_callback(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_info_callback, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_name_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_keylog );

    if (unlikely( tmp_called_name_18 == NULL ))
    {
        tmp_called_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_keylog );
    }

    if ( tmp_called_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_keylog" );
        exception_tb = NULL;

        exception_lineno = 1236;

        goto frame_exception_exit_2;
    }

    tmp_args_element_name_44 = MAKE_FUNCTION_OpenSSL$SSL$$$function_41_set_keylog_callback(  );
    frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2->m_frame.f_lineno = 1236;
    {
        PyObject *call_args[] = { tmp_args_element_name_44 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_18, call_args );
    }

    Py_DECREF( tmp_args_element_name_44 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1236;

        goto frame_exception_exit_2;
    }
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_keylog_callback, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1236;

        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_42_get_app_data(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_get_app_data, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_43_set_app_data(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_app_data, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_44_get_cert_store(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_get_cert_store, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_45_set_options(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_options, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_46_set_mode(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_mode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_47_set_tlsext_servername_callback(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_tlsext_servername_callback, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_use_srtp(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_tlsext_use_srtp, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_name_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn );

    if (unlikely( tmp_called_name_19 == NULL ))
    {
        tmp_called_name_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_alpn );
    }

    if ( tmp_called_name_19 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_alpn" );
        exception_tb = NULL;

        exception_lineno = 1359;

        goto frame_exception_exit_2;
    }

    tmp_args_element_name_45 = MAKE_FUNCTION_OpenSSL$SSL$$$function_49_set_alpn_protos(  );
    frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2->m_frame.f_lineno = 1359;
    {
        PyObject *call_args[] = { tmp_args_element_name_45 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_19, call_args );
    }

    Py_DECREF( tmp_args_element_name_45 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1359;

        goto frame_exception_exit_2;
    }
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_alpn_protos, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1359;

        goto frame_exception_exit_2;
    }
    tmp_called_name_20 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn );

    if (unlikely( tmp_called_name_20 == NULL ))
    {
        tmp_called_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_alpn );
    }

    if ( tmp_called_name_20 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_alpn" );
        exception_tb = NULL;

        exception_lineno = 1381;

        goto frame_exception_exit_2;
    }

    tmp_args_element_name_46 = MAKE_FUNCTION_OpenSSL$SSL$$$function_50_set_alpn_select_callback(  );
    frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2->m_frame.f_lineno = 1381;
    {
        PyObject *call_args[] = { tmp_args_element_name_46 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_20, call_args );
    }

    Py_DECREF( tmp_args_element_name_46 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1381;

        goto frame_exception_exit_2;
    }
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_alpn_select_callback, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1381;

        goto frame_exception_exit_2;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2,
        type_description_2
    );


    // Release cached frame.
    if ( frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2 == cache_frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2 )
    {
        Py_DECREF( frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2 );
    }
    cache_frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2 = NULL;

    assertFrameObject( frame_ebb4019f10ac1dbcdaadd42bfd017b9d_2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_1;

    frame_no_exception_1:;

    goto skip_nested_handling_1;
    nested_frame_exit_1:;

    goto try_except_handler_52;
    skip_nested_handling_1:;
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_51__set_ocsp_callback(  );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain__set_ocsp_callback, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_6 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_6 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_52_set_ocsp_server_callback( tmp_defaults_6 );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_ocsp_server_callback, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_7 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_7 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_53_set_ocsp_client_callback( tmp_defaults_7 );
    tmp_res = PyDict_SetItem( locals_Context_602, const_str_plain_set_ocsp_client_callback, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_23 = locals_Context_602;
    Py_INCREF( tmp_outline_return_value_23 );
    goto try_return_handler_52;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_52:;
    Py_DECREF( locals_Context_602 );
    locals_Context_602 = NULL;
    goto outline_result_23;
    // Exception handler code:
    try_except_handler_52:;
    exception_keeper_type_29 = exception_type;
    exception_keeper_value_29 = exception_value;
    exception_keeper_tb_29 = exception_tb;
    exception_keeper_lineno_29 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_Context_602 );
    locals_Context_602 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_29;
    exception_value = exception_keeper_value_29;
    exception_tb = exception_keeper_tb_29;
    exception_lineno = exception_keeper_lineno_29;

    goto outline_exception_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_1:;
    exception_lineno = 602;
    goto try_except_handler_51;
    outline_result_23:;
    tmp_assign_source_191 = tmp_outline_return_value_23;
    assert( tmp_class_creation_14__class_dict == NULL );
    tmp_class_creation_14__class_dict = tmp_assign_source_191;

    tmp_compare_left_14 = const_str_plain___metaclass__;
    tmp_compare_right_14 = tmp_class_creation_14__class_dict;

    CHECK_OBJECT( tmp_compare_right_14 );
    tmp_cmp_In_13 = PySequence_Contains( tmp_compare_right_14, tmp_compare_left_14 );
    assert( !(tmp_cmp_In_13 == -1) );
    if ( tmp_cmp_In_13 == 1 )
    {
        goto condexpr_true_13;
    }
    else
    {
        goto condexpr_false_13;
    }
    condexpr_true_13:;
    tmp_dict_name_13 = tmp_class_creation_14__class_dict;

    CHECK_OBJECT( tmp_dict_name_13 );
    tmp_key_name_13 = const_str_plain___metaclass__;
    tmp_assign_source_193 = DICT_GET_ITEM( tmp_dict_name_13, tmp_key_name_13 );
    if ( tmp_assign_source_193 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 602;

        goto try_except_handler_51;
    }
    goto condexpr_end_13;
    condexpr_false_13:;
    tmp_assign_source_193 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_193 );
    condexpr_end_13:;
    assert( tmp_class_creation_14__metaclass == NULL );
    tmp_class_creation_14__metaclass = tmp_assign_source_193;

    tmp_called_name_21 = tmp_class_creation_14__metaclass;

    CHECK_OBJECT( tmp_called_name_21 );
    tmp_args_element_name_47 = const_str_plain_Context;
    tmp_args_element_name_48 = const_tuple_type_object_tuple;
    tmp_args_element_name_49 = tmp_class_creation_14__class_dict;

    CHECK_OBJECT( tmp_args_element_name_49 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 602;
    {
        PyObject *call_args[] = { tmp_args_element_name_47, tmp_args_element_name_48, tmp_args_element_name_49 };
        tmp_assign_source_194 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_21, call_args );
    }

    if ( tmp_assign_source_194 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 602;

        goto try_except_handler_51;
    }
    assert( tmp_class_creation_14__class == NULL );
    tmp_class_creation_14__class = tmp_assign_source_194;

    goto try_end_19;
    // Exception handler code:
    try_except_handler_51:;
    exception_keeper_type_30 = exception_type;
    exception_keeper_value_30 = exception_value;
    exception_keeper_tb_30 = exception_tb;
    exception_keeper_lineno_30 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_30;
    exception_value = exception_keeper_value_30;
    exception_tb = exception_keeper_tb_30;
    exception_lineno = exception_keeper_lineno_30;

    goto frame_exception_exit_1;
    // End of try:
    try_end_19:;
    tmp_assign_source_195 = tmp_class_creation_14__class;

    CHECK_OBJECT( tmp_assign_source_195 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Context, tmp_assign_source_195 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class );
    Py_DECREF( tmp_class_creation_14__class );
    tmp_class_creation_14__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class_dict );
    Py_DECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__metaclass );
    Py_DECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    // Tried code:
    tmp_set_locals = PyDict_New();
    locals_Connection_1461 = tmp_set_locals;
    tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain___module__, tmp_dictset_value );
    assert( !(tmp_res != 0) );
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e4910e1ff9226b6796184f2658fa4bf8_3, codeobj_e4910e1ff9226b6796184f2658fa4bf8, module_OpenSSL$SSL, 0 );
    frame_e4910e1ff9226b6796184f2658fa4bf8_3 = cache_frame_e4910e1ff9226b6796184f2658fa4bf8_3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e4910e1ff9226b6796184f2658fa4bf8_3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e4910e1ff9226b6796184f2658fa4bf8_3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_22 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WeakValueDictionary );

    if (unlikely( tmp_called_name_22 == NULL ))
    {
        tmp_called_name_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_WeakValueDictionary );
    }

    if ( tmp_called_name_22 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "WeakValueDictionary" );
        exception_tb = NULL;

        exception_lineno = 1462;

        goto frame_exception_exit_3;
    }

    frame_e4910e1ff9226b6796184f2658fa4bf8_3->m_frame.f_lineno = 1462;
    tmp_dictset_value = CALL_FUNCTION_NO_ARGS( tmp_called_name_22 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1462;

        goto frame_exception_exit_3;
    }
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain__reverse_mapping, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1462;

        goto frame_exception_exit_3;
    }
    tmp_defaults_8 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_8 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_54___init__( tmp_defaults_8 );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_55___getattr__(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain___getattr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_56__raise_ssl_error(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain__raise_ssl_error, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_57_get_context(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_context, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_58_set_context(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_set_context, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_59_get_servername(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_servername, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_60_set_tlsext_host_name(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_set_tlsext_host_name, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_61_pending(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_pending, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_9 = const_tuple_int_0_tuple;
    Py_INCREF( tmp_defaults_9 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_62_send( tmp_defaults_9 );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_send, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = PyDict_GetItem( locals_Connection_1461, const_str_plain_send );

    if ( tmp_dictset_value == NULL )
    {
        tmp_dictset_value = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_send );

        if (unlikely( tmp_dictset_value == NULL ))
        {
            tmp_dictset_value = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_send );
        }

        if ( tmp_dictset_value == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "send" );
            exception_tb = NULL;

            exception_lineno = 1656;

            goto frame_exception_exit_3;
        }

    }

    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_write, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1656;

        goto frame_exception_exit_3;
    }
    tmp_defaults_10 = const_tuple_int_0_tuple;
    Py_INCREF( tmp_defaults_10 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_63_sendall( tmp_defaults_10 );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_sendall, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_11 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_11 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_64_recv( tmp_defaults_11 );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_recv, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = PyDict_GetItem( locals_Connection_1461, const_str_plain_recv );

    if ( tmp_dictset_value == NULL )
    {
        tmp_dictset_value = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_recv );

        if (unlikely( tmp_dictset_value == NULL ))
        {
            tmp_dictset_value = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_recv );
        }

        if ( tmp_dictset_value == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "recv" );
            exception_tb = NULL;

            exception_lineno = 1705;

            goto frame_exception_exit_3;
        }

    }

    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_read, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1705;

        goto frame_exception_exit_3;
    }
    tmp_defaults_12 = const_tuple_none_none_tuple;
    Py_INCREF( tmp_defaults_12 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_65_recv_into( tmp_defaults_12 );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_recv_into, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_66__handle_bio_errors(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain__handle_bio_errors, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_67_bio_read(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_bio_read, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_68_bio_write(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_bio_write, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_69_renegotiate(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_renegotiate, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_70_do_handshake(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_do_handshake, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_71_renegotiate_pending(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_renegotiate_pending, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_72_total_renegotiations(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_total_renegotiations, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_73_connect(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_connect, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_74_connect_ex(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_connect_ex, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_75_accept(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_accept, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_76_bio_shutdown(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_bio_shutdown, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_77_shutdown(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_shutdown, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_78_get_cipher_list(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_cipher_list, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_79_get_client_ca_list(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_client_ca_list, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_80_makefile(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_makefile, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_81_get_app_data(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_app_data, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_82_set_app_data(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_set_app_data, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_83_get_shutdown(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_shutdown, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_84_set_shutdown(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_set_shutdown, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_85_get_state_string(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_state_string, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_86_server_random(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_server_random, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_87_client_random(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_client_random, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_88_master_key(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_master_key, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_defaults_13 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_13 );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_89_export_keying_material( tmp_defaults_13 );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_export_keying_material, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_90_sock_shutdown(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_sock_shutdown, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_91_get_certificate(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_certificate, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_92_get_peer_certificate(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_peer_certificate, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_staticmethod_arg_1 = MAKE_FUNCTION_OpenSSL$SSL$$$function_93__cert_stack_to_list(  );
    tmp_dictset_value = BUILTIN_STATICMETHOD( tmp_staticmethod_arg_1 );
    Py_DECREF( tmp_staticmethod_arg_1 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2130;

        goto frame_exception_exit_3;
    }
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain__cert_stack_to_list, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2130;

        goto frame_exception_exit_3;
    }
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_94_get_peer_cert_chain(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_peer_cert_chain, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_95_get_verified_chain(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_verified_chain, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_96_want_read(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_want_read, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_97_want_write(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_want_write, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_98_set_accept_state(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_set_accept_state, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_99_set_connect_state(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_set_connect_state, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_100_get_session(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_session, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_101_set_session(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_set_session, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_102__get_finished_message(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain__get_finished_message, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_103_get_finished(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_finished, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_104_get_peer_finished(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_peer_finished, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_105_get_cipher_name(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_cipher_name, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_106_get_cipher_bits(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_cipher_bits, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_107_get_cipher_version(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_cipher_version, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_108_get_protocol_version_name(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_protocol_version_name, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_109_get_protocol_version(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_protocol_version, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_called_name_23 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn );

    if (unlikely( tmp_called_name_23 == NULL ))
    {
        tmp_called_name_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_alpn );
    }

    if ( tmp_called_name_23 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_alpn" );
        exception_tb = NULL;

        exception_lineno = 2377;

        goto frame_exception_exit_3;
    }

    tmp_args_element_name_50 = MAKE_FUNCTION_OpenSSL$SSL$$$function_110_set_alpn_protos(  );
    frame_e4910e1ff9226b6796184f2658fa4bf8_3->m_frame.f_lineno = 2377;
    {
        PyObject *call_args[] = { tmp_args_element_name_50 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_23, call_args );
    }

    Py_DECREF( tmp_args_element_name_50 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2377;

        goto frame_exception_exit_3;
    }
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_set_alpn_protos, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2377;

        goto frame_exception_exit_3;
    }
    tmp_called_name_24 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn );

    if (unlikely( tmp_called_name_24 == NULL ))
    {
        tmp_called_name_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_alpn );
    }

    if ( tmp_called_name_24 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_alpn" );
        exception_tb = NULL;

        exception_lineno = 2399;

        goto frame_exception_exit_3;
    }

    tmp_args_element_name_51 = MAKE_FUNCTION_OpenSSL$SSL$$$function_111_get_alpn_proto_negotiated(  );
    frame_e4910e1ff9226b6796184f2658fa4bf8_3->m_frame.f_lineno = 2399;
    {
        PyObject *call_args[] = { tmp_args_element_name_51 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_24, call_args );
    }

    Py_DECREF( tmp_args_element_name_51 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2399;

        goto frame_exception_exit_3;
    }
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_get_alpn_proto_negotiated, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2399;

        goto frame_exception_exit_3;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e4910e1ff9226b6796184f2658fa4bf8_3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_exception_exit_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e4910e1ff9226b6796184f2658fa4bf8_3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e4910e1ff9226b6796184f2658fa4bf8_3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e4910e1ff9226b6796184f2658fa4bf8_3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e4910e1ff9226b6796184f2658fa4bf8_3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e4910e1ff9226b6796184f2658fa4bf8_3,
        type_description_2
    );


    // Release cached frame.
    if ( frame_e4910e1ff9226b6796184f2658fa4bf8_3 == cache_frame_e4910e1ff9226b6796184f2658fa4bf8_3 )
    {
        Py_DECREF( frame_e4910e1ff9226b6796184f2658fa4bf8_3 );
    }
    cache_frame_e4910e1ff9226b6796184f2658fa4bf8_3 = NULL;

    assertFrameObject( frame_e4910e1ff9226b6796184f2658fa4bf8_3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_2;

    frame_no_exception_2:;

    goto skip_nested_handling_2;
    nested_frame_exit_2:;

    goto try_except_handler_55;
    skip_nested_handling_2:;
    tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_112_request_ocsp(  );
    tmp_res = PyDict_SetItem( locals_Connection_1461, const_str_plain_request_ocsp, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    assert( !(tmp_res != 0) );
    tmp_outline_return_value_25 = locals_Connection_1461;
    Py_INCREF( tmp_outline_return_value_25 );
    goto try_return_handler_55;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_55:;
    Py_DECREF( locals_Connection_1461 );
    locals_Connection_1461 = NULL;
    goto outline_result_25;
    // Exception handler code:
    try_except_handler_55:;
    exception_keeper_type_31 = exception_type;
    exception_keeper_value_31 = exception_value;
    exception_keeper_tb_31 = exception_tb;
    exception_keeper_lineno_31 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_Connection_1461 );
    locals_Connection_1461 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_31;
    exception_value = exception_keeper_value_31;
    exception_tb = exception_keeper_tb_31;
    exception_lineno = exception_keeper_lineno_31;

    goto outline_exception_2;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_2:;
    exception_lineno = 1461;
    goto try_except_handler_54;
    outline_result_25:;
    tmp_assign_source_196 = tmp_outline_return_value_25;
    assert( tmp_class_creation_15__class_dict == NULL );
    tmp_class_creation_15__class_dict = tmp_assign_source_196;

    tmp_compare_left_15 = const_str_plain___metaclass__;
    tmp_compare_right_15 = tmp_class_creation_15__class_dict;

    CHECK_OBJECT( tmp_compare_right_15 );
    tmp_cmp_In_14 = PySequence_Contains( tmp_compare_right_15, tmp_compare_left_15 );
    assert( !(tmp_cmp_In_14 == -1) );
    if ( tmp_cmp_In_14 == 1 )
    {
        goto condexpr_true_14;
    }
    else
    {
        goto condexpr_false_14;
    }
    condexpr_true_14:;
    tmp_dict_name_14 = tmp_class_creation_15__class_dict;

    CHECK_OBJECT( tmp_dict_name_14 );
    tmp_key_name_14 = const_str_plain___metaclass__;
    tmp_assign_source_197 = DICT_GET_ITEM( tmp_dict_name_14, tmp_key_name_14 );
    if ( tmp_assign_source_197 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1461;

        goto try_except_handler_54;
    }
    goto condexpr_end_14;
    condexpr_false_14:;
    tmp_assign_source_197 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_assign_source_197 );
    condexpr_end_14:;
    assert( tmp_class_creation_15__metaclass == NULL );
    tmp_class_creation_15__metaclass = tmp_assign_source_197;

    tmp_called_name_25 = tmp_class_creation_15__metaclass;

    CHECK_OBJECT( tmp_called_name_25 );
    tmp_args_element_name_52 = const_str_plain_Connection;
    tmp_args_element_name_53 = const_tuple_type_object_tuple;
    tmp_args_element_name_54 = tmp_class_creation_15__class_dict;

    CHECK_OBJECT( tmp_args_element_name_54 );
    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 1461;
    {
        PyObject *call_args[] = { tmp_args_element_name_52, tmp_args_element_name_53, tmp_args_element_name_54 };
        tmp_assign_source_198 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_25, call_args );
    }

    if ( tmp_assign_source_198 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1461;

        goto try_except_handler_54;
    }
    assert( tmp_class_creation_15__class == NULL );
    tmp_class_creation_15__class = tmp_assign_source_198;

    goto try_end_20;
    // Exception handler code:
    try_except_handler_54:;
    exception_keeper_type_32 = exception_type;
    exception_keeper_value_32 = exception_value;
    exception_keeper_tb_32 = exception_tb;
    exception_keeper_lineno_32 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_32;
    exception_value = exception_keeper_value_32;
    exception_tb = exception_keeper_tb_32;
    exception_lineno = exception_keeper_lineno_32;

    goto frame_exception_exit_1;
    // End of try:
    try_end_20:;
    tmp_assign_source_199 = tmp_class_creation_15__class;

    CHECK_OBJECT( tmp_assign_source_199 );
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection, tmp_assign_source_199 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class );
    Py_DECREF( tmp_class_creation_15__class );
    tmp_class_creation_15__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class_dict );
    Py_DECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__metaclass );
    Py_DECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
        exception_tb = NULL;

        exception_lineno = 2432;

        goto frame_exception_exit_1;
    }

    frame_88603af527c83dda944c7ddf4d45b354->m_frame.f_lineno = 2432;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_SSL_library_init );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2432;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

    // Restore frame exception if necessary.
#if 1
    RESTORE_FRAME_EXCEPTION( frame_88603af527c83dda944c7ddf4d45b354 );
#endif
    popFrameStack();

    assertFrameObject( frame_88603af527c83dda944c7ddf4d45b354 );

    goto frame_no_exception_3;
    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_88603af527c83dda944c7ddf4d45b354 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_88603af527c83dda944c7ddf4d45b354, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_88603af527c83dda944c7ddf4d45b354->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_88603af527c83dda944c7ddf4d45b354, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;
    frame_no_exception_3:;

    return MOD_RETURN_VALUE( module_OpenSSL$SSL );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
